diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/Makefile modules/gdi/Makefile
--- origmodules/gdi/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/Makefile	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1,52 @@
+# Makefile for the CLISP module gdi
+
+# Programs used by "make":
+CC = gcc
+
+CFLAGS =  -W -Wswitch -Wcomment -Wpointer-arith -Wimplicit -Wreturn-type  -Wno-sign-compare -g -DSAFETY=1 -DUNICODE -DDYNAMIC_FFI -DNO_SIGSEGV -I. -I.. -falign-functions=4
+
+INCLUDES=-I. -I..
+CPP = gcc -O -E -w -DUNICODE -DDYNAMIC_FFI
+CLFLAGS = 
+
+MODPREP = ../modprep.fas
+
+CLISP = ../clisp -q -norc -E 1:1
+
+LN = ln
+
+MAKE = make
+
+SHELL = /bin/sh
+
+DISTRIBFILES = *
+distribdir =
+
+all : gdi.o gdi.fas
+
+gdi.fas : gdi.lisp
+	$(CLISP) -c gdi.lisp
+
+gdi.c : gdi.m local.c funcs-ok.c funcs-rest.c funcs-prob.c funcs-count.c funcs-out.c
+	cat gdi.m local.c funcs-ok.c funcs-rest.c funcs-prob.c  funcs-count.c funcs-out.c >gdi.mm
+	$(CLISP) $(MODPREP) gdi.mm gdi.mmm
+	grep -v "\#line" gdi.mmm > gdi.c
+	rm gdi.mmm
+
+gdi.o : gdi.c
+	$(CC) $(CFLAGS) $(INCLUDES) -I.. -c gdi.c
+
+# Make a module
+clisp-module : all
+
+clean :
+	rm gdi.o gdi.c gdi.mm gdi.fas gdi.lib
+# Make a module distribution into $(distribdir)
+clisp-module-distrib : clisp-module force
+	$(LN) $(DISTRIBFILES) $(distribdir)
+
+tgz:
+	rm -f gdi.o gdi.c gdi.mm gdi.lib gdi.fas
+	cd ..;tar -zcvf gdi.tar.gz gdi p1.lisp p2.lisp
+force :
+
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/README modules/gdi/README
--- origmodules/gdi/README	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/README	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1,81 @@
+This module is a interface to gdi, the lowest level
+ms windows graphics api.  It is a work in progress,
+and is copyright Dan Stanger 2002.
+It is licensed under the lgpl and all rights assigned
+to the Free Software Foundation.
+There are many places to learn about the gdi.  The wine
+web site has some links to web sites about it.
+This was the first gdi program I ever wrote.
+
+WARNING: DONT regenerate any code without
+thinking very carefully.  All the c files were hand edited,
+and you dont want to redo that.
+END WARNING
+
+All the C files were hand edited to use with_string_0
+instead of TheAsciz.
+
+At the current time, I am not interested in doing any more work on this
+project.  If you want to, have it installed in the clisp cvs, and
+get write permissions for it.
+
+Todo:
+
+Fix warnings.
+Test existing code.
+Add more message handling code.
+Finish the process*, output* routines.
+Write more examples, and documentation.
+
+To install:
+move the gdi directory below your cygwin build directory
+for example
+/cygdrive/e/clisp-2.28/cygwin/gdi
+in gdi
+compile gdi.lisp with:
+clisp -q -c gdi.lisp
+make the object gdi.o
+make
+cd ..
+echo rm -rf gdi+base;./clisp-link add-module-set gdi . gdi+base
+cd gdi+base
+cp * /usr/local/lib/clisp/base
+
+now clisp should execute with the gdi module, and *features* should
+have gdi in it.
+
+Notes:
+Some functions which in c would return a struct return multiple values
+if it was more convenient to do so.  For example GetTextExtentPoint32
+would return a SIZE, but most of the time, the size will be used
+directly.  If this proves not to be the case, change it.
+
+Files:
+Makefile
+func.awk program to convert output of c preprocesser to clisp module code
+funcs-count.c functions <= 5 args
+funcs-count.h header file of functions <= 5 args
+funcs-ok.c functions that probably translated ok
+funcs-ok.h header file of functions that probably translated ok
+funcs-out.c functions that return data
+funcs-out.h header file of functions that return data
+funcs-prob.c functions that have been hand edited
+funcs-prob.h header file of functions that will require hand editing
+funcs-rest.c functions that have more than 5 parameters, has been hand edited
+funcs-rest.c-prev a previous version of the previous file
+funcs-rest.h header file of functions that have more than 5 parameters
+funcs-rest.sh script to create the funcs-rest.c
+gdi-preload.lisp used by module process
+gdi.lisp lisp code for module
+gdi.m c code that was written by hand
+input.awk code to help generate process* routines in local.c
+link.sh used by module process
+local.c mostly process and output routines.
+struct1.awk code to help generate process* routines in local.c
+struct2.awk code to help generate lisp structures
+struct3.awk code to help generate output* routines in local.c
+todo obsolete ??? todo list
+
+Maintainer note:
+Dan Stanger stopped writing at this code at end of 2003, and 
+Reini Urban took it over 2006.
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/TODO modules/gdi/TODO
--- origmodules/gdi/TODO	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/TODO	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1,4 @@
+fix b, bool
+add object arg
+capitalize function name
+fix function args in header, no commas
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/func.awk modules/gdi/func.awk
--- origmodules/gdi/func.awk	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/func.awk	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1,483 @@
+# awk.parser - recursive-descent translator for part of awk
+#   input:  awk program (very restricted subset)
+#   output: C code to implement the awk program
+
+BEGIN { program() }
+
+function advance() {      # lexical analyzer; returns next token
+    if (tok == "(eof)") return "(eof)"
+    while (length(line) == 0)
+        if (getline line == 0)
+            return tok = "(eof)"
+    sub(/^[ \t]+/, "", line)   # remove white space
+    if (match(line, /^[A-Za-z_][A-Za-z_0-9]*/) ||    # identifier
+        match(line, /^-?([0-9]+\.?[0-9]*|\.[0-9]+)/) ||  # number
+        match(line, /^(<|<=|==|!=|>=|>)/) ||         # relational
+        match(line, /^./)) {                    # everything else
+            tok = substr(line, 1, RLENGTH)
+            line = substr(line, RLENGTH+1)
+            return tok
+        }
+    error("line " NR " incomprehensible at " line)
+}
+function gen(s) {     # print s with 2*nt leading spaces
+    printf("%s%s\n", substr("                                          ", 1, 2*nt), s)
+}
+function eat(s) {     # read next token if s == tok
+    if (tok != s) error("line " NF ": saw " tok ", expected " s)
+    advance()
+}
+function nl() {       # absorb newlines and semicolons
+    while (tok == "\n" || tok == ";")
+        advance()
+}
+function error(s) { print "Error: " s | "cat 1>&2"; exit 1 }
+
+function program() {
+    advance()
+    gen("#line 1 \"funcs.c\"")
+    pastats()
+    if (tok != "(eof)") error("program continues after END")
+}
+function pastats() {
+    nt=0;
+    while (tok != "END" && tok != "(eof)") pastat()
+}
+function initCurrentNames(c,a,i,n) {
+    n = split("void int char float double long bool",a, " ")
+    for(i=1; i <=n; i++)c[a[i]]=1
+}
+# rettype funcname (args...);
+function pastat(retType, retName, funcName,args,argTypes, argNames,rest) {
+    delete currentNames
+    delete inits
+    initCurrentNames(currentNames)
+    retType = tok
+    advance()
+    funcName = tok
+    advance()
+    eat("(")
+    args=exprlist()
+    eat(")")
+    nl()
+    makeArgTypes(args,argTypes)
+    makeArgNames(args,argNames)
+    rest = 0
+    if(doHead(funcName,argNames) ~ /rest/)rest = 1
+    gen("{")
+    nt++
+    retName = makeUniqueName(tolower(retType))
+    doIdentDecl("object","arg")
+    doIdentDecl(retType,retName)
+    doIdentList(argTypes,argNames,inits)
+    doInits(inits)
+    if(rest)doRest();
+    doCall(retName, funcName, argNames)
+    doRet(retType,retName)
+    nt--; gen("}")
+}
+function doRest(){
+   # gen("skipSTACK(argcount);");
+}
+
+function makeUniqueName(n)
+{
+   if( n in currentNames)return makeUniqueNameAux(n,0)
+   else
+   {
+      currentNames[n] = 1
+      return n
+   }
+}
+function makeUniqueNameAux(n,i,v)
+{
+   v = n i
+   if( v in currentNames)return makeUniqueNameAux(n,i+1)
+   else
+   {
+      currentNames[v]=1
+      return v
+   }
+}
+function makeStringFromArray(a,n,i,s)
+{
+   n = a[0]
+   if( n >= 6)return "&rest r"
+   s = ""
+   for(i=1; i <= n; i++)s=s " " a[i]
+   return s
+}
+function doHead(f,a,s) {
+   s = makeStringFromArray(a)
+   gen("// untested - was never called")
+   gen("// uninspected - compiles but code was not checked")
+   # gen("DEFUN( GDI:" toupper(f) "," s ")")
+   gen("DEFUN( GDI:" f "," s ")")
+   return s
+}
+function doCall(r,f,a,s,i,sep) {
+   s=""
+   sep=""
+   for(i=1; i <= a[0]; i++){
+      s = s sep a[i]
+      sep = ","
+   }
+   gen("begin_call();")
+   gen(r " = " f "(" s ");")
+   gen("end_call();")
+}
+function doRet(r,name) {
+    if(r ~/H.*/)doHandle(name)
+    else if("void" == r)doVoid()
+    else if("BOOL"==r)doBool(name)
+    else if("BYTE"==r)doByte(name)
+    else if("WORD"==r)doWord(name)
+    else if("ATOM"==r)doAtom(name)
+    else if("CHAR"==r || "char" == r)doChar(name)
+    else if("int"==r || "LONG" == r || "INT" == r || "LPARAM"==r)doInt(name,"s")
+    else if("DWORD"==r || "UINT" == r)doInt(name,"u")
+}
+function doInt(name,ty){
+  gen("if(0 <=" name "){")
+  nt++
+  gen("DWORD e;")
+  gen("begin_call();");
+  gen("e = GetLastError();")
+  gen("end_call();")
+  gen("value1 = NIL;")
+  gen("value2 = uint32_to_I(e);")
+  gen("mv_count=2;")
+  nt--
+  gen("}")
+  gen("else")
+  gen("{")
+  nt++
+  gen("value1 = T;")
+  gen("value2 = "ty"int32_to_I("name");")
+  gen("mv_count=2;")
+  nt--
+  gen("}")
+  gen("return;")
+}
+function doHandle(h) {
+  gen("if(NULL ==" h "){")
+  nt++
+  gen("DWORD e;")
+  gen("begin_call();");
+  gen("e = GetLastError();")
+  gen("end_call();")
+  gen("value1 = NIL;")
+  gen("value2 = uint32_to_I(e);")
+  gen("mv_count=2;")
+  nt--
+  gen("}")
+  gen("else")
+  gen("{")
+  nt++
+  gen("value1 = T;")
+  gen("value2 = allocate_fpointer("h");")
+  gen("mv_count=2;")
+  nt--
+  gen("}")
+  gen("return;")
+}
+function doVoid()
+{
+   gen("mv_count = 0;")
+   gen("return;")
+}
+function doByte(b)
+{
+   gen("mv_count = 1;")
+   gen("value1 = uint8_to_I(" b ");")
+   gen("return;")
+}
+function doWord(b)
+{
+   gen("mv_count = 1;")
+   gen("value1 = uint16_to_I(" b ");")
+   gen("return;")
+}
+function doAtom(h) {
+  gen("if(0 ==" h "){")
+  nt++
+  gen("DWORD e;")
+  gen("begin_call();");
+  gen("e = GetLastError();")
+  gen("end_call();")
+  gen("value1 = NIL;")
+  gen("value2 = uint32_to_I(e);")
+  gen("mv_count=2;")
+  nt--
+  gen("}")
+  gen("else")
+  gen("{")
+  nt++
+  gen("value1 = T;")
+  gen("value2 = allocate_fpointer("h");")
+  gen("mv_count=2;")
+  nt--
+  gen("}")
+  gen("return;")
+}
+function doBool(b) {
+  gen("if(!" b "){")
+  nt++
+  gen("DWORD e;")
+  gen("begin_call();");
+  gen("e = GetLastError();")
+  gen("end_call();")
+  gen("value1 = NIL;")
+  gen("value2 = uint32_to_I(e);")
+  gen("mv_count=2;")
+  nt--
+  gen("}")
+  gen("else")
+  gen("{")
+  nt++
+  gen("value1 = T;")
+  gen("mv_count=1;")
+  nt--
+  gen("}")
+  gen("return;")
+}
+
+function doChar(b)
+{
+   gen("mv_count = 1;")
+   gen("value1 = int_char(" b ");")
+   gen("return;")
+}
+function pattern() { return expr() }
+
+function statlist() {
+    eat("{"); nl(); while (tok != "}") stat(); eat("}"); nl()
+}
+
+function stat() {
+    if (tok == "print") { eat("print"); gen("print(" exprlist() ");") }
+    else if (tok == "if") ifstat()
+    else if (tok == "while") whilestat()
+    else if (tok == "{") statlist()
+    else gen(simplestat() ";")
+    nl()
+}
+
+function ifstat() {
+    eat("if"); eat("("); gen("if (" expr() ") {"); eat(")"); nl(); nt++
+    stat()
+    if (tok == "else") {      # optional else
+        eat("else")
+        nl(); nt--; gen("} else {"); nt++
+        stat()
+    }
+    nt--; gen("}")
+}
+
+function whilestat() {
+    eat("while"); eat("("); gen("while (" expr() ") {"); eat(")"); nl()
+    nt++; stat(); nt--; gen("}")
+}
+
+function simplestat(   lhs) { # ident = expr | name(exprlist)
+    lhs = ident()
+    if (tok == "=") {
+        eat("=")
+        return "assign(" lhs ", " expr() ")"
+    } else return lhs
+}
+function doIdent( type, name) {
+    if(type ~ /^H.*/) {
+       gen("arg = popSTACK();")
+       gen("if(!fpointerp(arg))argumentum_inritum(arg);");
+       gen(name " = TheFpointer(arg)->fp_pointer;")
+    }
+    else if( "DWORD" == type || "UINT" == type || "DWORD32" == type ||
+              "COLORREF" == type) {
+       gen("arg = popSTACK();")
+       gen("check_uint(arg);")
+       gen(name " = I_to_uint32(arg);")
+    }
+    else if( "int" == type || "INT" == type || "LONG" == type || "LPARAM"==type){
+       gen("arg = popSTACK();")
+       gen("check_sint(arg);")
+       gen(name " = I_to_sint32(arg);")
+    }
+    else if( "LPSTR" == type || "LPCSTR" == type) {
+       gen("arg = popSTACK();")
+       gen("if(!stringp(arg))argumentum_inritum(arg);");
+       gen(name " = TheAsciz(string_to_asciz(arg,encoding));")
+    }
+    else if( "LPWSTR" == type || "LPCWSTR" == type) {
+       gen("arg = popSTACK();")
+       gen("if(!stringp(arg))argumentum_inritum(arg);");
+       gen(name " = WIDECHAR(arg,encoding);")
+    }
+    else if( "float" == type || "FLOAT" == type) {
+       gen("arg = popSTACK();")
+       gen("check_ffloat(arg);");
+       gen(name " = ffloat_value(arg);")
+    }
+    else if("BYTE_P" == type) {
+       gen("arg = popSTACK();")
+       gen("if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);");
+       gen(name " = &(TheSbvector(arg)->data);")
+    }
+    else if("INT_P" == type || "DWORD_P" == type || "LPINT" == type) {
+       gen("arg = popSTACK();")
+       gen("if(!simple_bit_vector_p(Atype_32Bit,arg))argumentum_inritum(arg);");
+       gen(name " = &(TheSbvector(arg)->data);")
+    }
+    else if("PVOID" == type || "PCVOID" == type) {
+       gen("arg = popSTACK();")
+       gen("if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);");
+       gen(name " = &(TheSbvector(arg)->data);")
+    }
+    else if(type ~ /^LPC.*/) {
+       sub("^LPC","",type)
+       gen("arg0 = popSTACK();")
+       gen("process"type"("name",arg0);")
+    }
+    else if(type ~ /^LP.*/) {
+       sub("^LP","",type)
+       gen("arg0 = popSTACK();")
+       gen("process"type"("name",arg0);")
+    }
+    else
+    {
+       sub("_P$","",type)
+       gen("arg0 = popSTACK();")
+       gen("process"type"("name",arg0);")
+    }
+}
+function doIdentDecl( e,n,i,a) {
+   if("BYTE_P" == e || "INT_P" == e || "DWORD_P" == e) {
+       sub("_P$","",e)
+       gen(e "* " n ";")
+   }
+   else if("LPINT" == e){
+       gen("int* " n ";")
+   }
+   else if("PVOID" == e || "PCVOID" == e || "void_P" == e) {
+       gen("void* " n ";")
+   }
+   else if( e ~ /_P$/){
+      sub("_P$","",e)
+      gen(e "* " n " = alloca(sizeof("e"));")
+      gen("object arg0 = 0;")
+      a[i] = "process"e"("n",arg0);"
+   }
+   else if(e ~ /^LPC.*/ && e !~ /STR/) {
+      sub("^LPC","",e)
+      gen(e "* " n " = alloca(sizeof("e"));")
+      gen("object arg0 = 0;")
+      a[i] = "process"e"("n",arg0);"
+   }
+   else if(e ~ /^LP.*/ && e !~ /STR/) {
+      sub("^LP","",e)
+      gen(e "* " n " = alloca(sizeof("e"));")
+      gen("object arg0 = 0;")
+      a[i] = "process"e"("n",arg0);"
+   }
+   else
+   {
+      gen(e " " n ";")
+   }
+   return n
+}
+function makeArgTypes( e,a, n) {
+   n = split(e,a,",")
+   a[0] = n;
+}
+function makeArgNames( e,a, n, i) {
+   n = split(e,a,",")
+   for(i=1; i <= n; i++)a[i] = makeUniqueName(tolower(a[i]))
+   a[0]=n
+   return n
+}
+
+function doInits(inits,i) {
+   for(i = 1; i <= inits[0]; i++){
+     if(i in inits)gen(inits[i])
+   }
+}
+function doIdentList( types,names,inits,i,n) {
+   n = names[0];
+   inits[0] = n
+   for(i=1; i <= n; i++)doIdentDecl(types[i],names[i],i,inits)
+   for(i=n; 1 <= i; i--)doIdent(types[i],names[i])
+}
+function exprlist(    n, e, e0) { # expr , expr , ...
+    e = ident()        # has to be at least one
+    for (n = 1; tok == ","; n++) {
+        advance()
+        e = e "," ident()
+    }
+    return e
+}
+
+function expr(e) {            # rel | rel relop rel
+    e = rel()
+    while (tok ~ /<|<=|==|!=|>=|>/) {
+        op = tok
+        advance()
+        e = sprintf("eval(\"%s\", %s, %s)", op, e, rel())
+    }
+    return e
+}
+
+function rel(op, e) {         # term | term [+-] term
+    e = term()
+    while (tok == "+" || tok == "-") {
+        op = tok
+        advance()
+        e = sprintf("eval(\"%s\", %s, %s)", op, e, term())
+    }
+    return e
+}
+
+function term(op, e) {        # fact | fact [*/%] fact
+    e = fact()
+    while (tok == "*" || tok == "/" || tok == "%") {
+        op = tok
+        advance()
+        e = sprintf("eval(\"%s\", %s, %s)", op, e, fact())
+    }
+    return e
+}
+
+function fact(  e) {          # (expr) | $fact | ident | number
+    if (tok == "(") {
+        eat("("); e = expr(); eat(")")
+        return "(" e ")"
+    } else if (tok == "$") {
+        eat("$")
+        return "field(" fact() ")"
+    } else if (tok ~ /^[A-Za-z][A-Za-z0-9]*/) {
+        return ident()
+    } else if (tok ~ /^-?([0-9]+\.?[0-9]*|\.[0-9]+)/) {
+        e = tok
+        advance()
+        return "num((float)" e ")"
+    } else
+        error("unexpected " tok " at line " NR)
+}
+
+function ident(  id, e) {     # name | name[expr] | name(exprlist)
+    if (!match(tok, /^[A-Za-z_][A-Za-z_0-9]*/))
+        error("unexpected " tok " at line " NR)
+    id = tok
+    advance()
+    if (tok == "[") {         # array
+        eat("["); e = expr(); eat("]")
+        return "array(" id ", " e ")"
+    } else if (tok == "(") {  # function call
+        eat("(")
+        if (tok != ")") {
+            e = exprlist()
+            eat(")")
+        } else eat(")")
+        return id "(" e ")"   # calls are statements
+    } else
+        return id             # variable
+}
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/funcs-count.c modules/gdi/funcs-count.c
--- origmodules/gdi/funcs-count.c	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/funcs-count.c	2007-01-09 17:20:11.937500000 +0000
@@ -0,0 +1,2075 @@
+#line 1 "funcs.c"
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ANIMATEPALETTE, hpalette uint uint0 paletteentry_p)
+{
+  object arg;
+  BOOL bool0;
+  HPALETTE hpalette;
+  UINT uint;
+  UINT uint0;
+  PALETTEENTRY* paletteentry_p = alloca(sizeof(PALETTEENTRY));
+  object arg0;
+  arg0 = popSTACK();
+  processPALETTEENTRY(paletteentry_p,arg0);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hpalette = TheFpointer(arg)->fp_pointer;
+  processPALETTEENTRY(paletteentry_p,arg0);
+  begin_system_call();
+  bool0 = AnimatePalette(hpalette,uint,uint0,paletteentry_p);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CHOOSEPIXELFORMAT, hdc pixelformatdescriptor_p)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  PIXELFORMATDESCRIPTOR* pixelformatdescriptor_p = alloca(sizeof(PIXELFORMATDESCRIPTOR));
+  object arg0;
+  arg0 = popSTACK();
+  processPIXELFORMATDESCRIPTOR(pixelformatdescriptor_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPIXELFORMATDESCRIPTOR(pixelformatdescriptor_p,arg0);
+  begin_system_call();
+  int0 = ChoosePixelFormat(hdc,pixelformatdescriptor_p);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEBITMAP, int0 int1 uint uint0 pcvoid)
+{
+  object arg;
+  HBITMAP hbitmap;
+  int int0;
+  int int1;
+  UINT uint;
+  UINT uint0;
+  void* pcvoid;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pcvoid = &(TheSbvector(arg)->data);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  begin_system_call();
+  hbitmap = CreateBitmap(int0,int1,uint,uint0,pcvoid);
+  end_system_call();
+  if(NULL ==hbitmap){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hbitmap);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEDIBPATTERNBRUSHPT, pcvoid uint)
+{
+  object arg;
+  HBRUSH hbrush;
+  void* pcvoid;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pcvoid = &(TheSbvector(arg)->data);
+  begin_system_call();
+  hbrush = CreateDIBPatternBrushPt(pcvoid,uint);
+  end_system_call();
+  if(NULL ==hbrush){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hbrush);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEPOLYPOLYGONRGN, point_p int_p int0 int1)
+{
+  object arg;
+  HRGN hrgn;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  INT* int_p;
+  int int0;
+  int int1;
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))argumentum_inritum(arg);
+  int_p = &(TheSbvector(arg)->data);
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+  processPOINT(point_p,arg0);
+  begin_system_call();
+  hrgn = CreatePolyPolygonRgn(point_p,int_p,int0,int1);
+  end_system_call();
+  if(NULL ==hrgn){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hrgn);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEPOLYGONRGN, point_p int0 int1)
+{
+  object arg;
+  HRGN hrgn;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  int int0;
+  int int1;
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+  processPOINT(point_p,arg0);
+  begin_system_call();
+  hrgn = CreatePolygonRgn(point_p,int0,int1);
+  end_system_call();
+  if(NULL ==hrgn){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hrgn);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATESCALABLEFONTRESOURCEA, dword lpcstr lpcstr0 lpcstr1)
+{
+  object arg;
+  BOOL bool0;
+  DWORD dword;
+  LPCSTR lpcstr;
+  LPCSTR lpcstr0;
+  LPCSTR lpcstr1;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr1, {
+    arg = popSTACK();
+    if(!stringp(arg))argumentum_inritum(arg);
+    with_string_0(arg,encoding, lpcstr0, {
+      arg = popSTACK();
+      if(!stringp(arg))argumentum_inritum(arg);
+      with_string_0(arg,encoding, lpcstr, {
+        dword = I_to_uint32(check_uint(popSTACK()));
+        begin_system_call();
+        bool0 = CreateScalableFontResourceA(dword,lpcstr,lpcstr0,lpcstr1);
+        end_system_call();
+        if(!bool0){
+          DWORD e;
+          begin_system_call();
+          e = GetLastError();
+          end_system_call();
+          value1 = NIL;
+          value2 = uint32_to_I(e);
+          mv_count=2;
+        }
+        else
+        {
+          value1 = T;
+          mv_count=1;
+        }
+      });
+    });
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATESCALABLEFONTRESOURCEW, dword lpcwstr lpcwstr0 lpcwstr1)
+{
+  object arg;
+  BOOL bool0;
+  DWORD dword;
+  LPCWSTR lpcwstr;
+  LPCWSTR lpcwstr0;
+  LPCWSTR lpcwstr1;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr1 = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr0 = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  begin_system_call();
+  bool0 = CreateScalableFontResourceW(dword,lpcwstr,lpcwstr0,lpcwstr1);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:DPTOLP, hdc lppoint int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(lppoint,arg0);
+  begin_system_call();
+  bool0 = DPtoLP(hdc,lppoint,int0);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:DESCRIBEPIXELFORMAT, hdc int0 uint lppixelformatdescriptor)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  UINT uint;
+  PIXELFORMATDESCRIPTOR* lppixelformatdescriptor = alloca(sizeof(PIXELFORMATDESCRIPTOR));
+  object arg0;
+  arg0 = popSTACK();
+  processPIXELFORMATDESCRIPTOR(lppixelformatdescriptor,arg0);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPIXELFORMATDESCRIPTOR(lppixelformatdescriptor,arg0);
+  begin_system_call();
+  int1 = DescribePixelFormat(hdc,int0,uint,lppixelformatdescriptor);
+  end_system_call();
+  if(0 <=int1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:DRAWESCAPE, hdc int0 int1 lpcstr)
+{
+  object arg;
+  int int2;
+  HDC hdc;
+  int int0;
+  int int1;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    check_sint(arg);
+    int1 = I_to_sint32(arg);
+    arg = popSTACK();
+    check_sint(arg);
+    int0 = I_to_sint32(arg);
+    arg = popSTACK();
+    if(!fpointerp(arg))argumentum_inritum(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+    begin_system_call();
+    int2 = DrawEscape(hdc,int0,int1,lpcstr);
+    end_system_call();
+    if(0 <=int2){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = sint32_to_I(int2);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EXTCREATEPEN, dword dword0 logbrush_p dword1 dword_p)
+{
+  object arg;
+  HPEN hpen;
+  DWORD dword;
+  DWORD dword0;
+  LOGBRUSH* logbrush_p = alloca(sizeof(LOGBRUSH));
+  object arg0;
+  DWORD dword1;
+  DWORD* dword_p;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))argumentum_inritum(arg);
+  dword_p = &(TheSbvector(arg)->data);
+  dword1 = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processLOGBRUSH(logbrush_p,arg0);
+  dword0 = I_to_uint32(check_uint(popSTACK()));
+  dword = I_to_uint32(check_uint(popSTACK()));
+  processLOGBRUSH(logbrush_p,arg0);
+  begin_system_call();
+  hpen = ExtCreatePen(dword,dword0,logbrush_p,dword1,dword_p);
+  end_system_call();
+  if(NULL ==hpen){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hpen);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EXTCREATEREGION, xform_p dword rgndata_p)
+{
+  object arg;
+  HRGN hrgn;
+  XFORM* xform_p = alloca(sizeof(XFORM));
+  object arg0;
+  DWORD dword;
+  RGNDATA* rgndata_p;
+  arg0 = popSTACK(); /* fixme arg lost?? */
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processXFORM(xform_p,arg);
+  rgndata_p = alloca(dword*sizeof(RGNDATA));
+  processRGNDATA_C(rgndata_p,arg0,dword);
+  begin_system_call();
+  hrgn = ExtCreateRegion(xform_p,dword,rgndata_p);
+  end_system_call();
+  if(NULL ==hrgn){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hrgn);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FIXBRUSHORGEX, hdc int0 int1 lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(lppoint,arg0);
+  begin_system_call();
+  bool0 = FixBrushOrgEx(hdc,int0,int1,lppoint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GDICOMMENT, hdc uint byte_p)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT uint;
+  BYTE* byte_p;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  byte_p = &(TheSbvector(arg)->data);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = GdiComment(hdc,uint,byte_p);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GDIFLUSH,)
+{
+  object arg;
+  BOOL bool0;
+  begin_system_call();
+  bool0 = GdiFlush();
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GDIGETBATCHLIMIT,)
+{
+  object arg;
+  DWORD dword;
+  begin_system_call();
+  dword = GdiGetBatchLimit();
+  end_system_call();
+  if(0 <=dword){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(dword);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:LPTODP, hdc lppoint int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(lppoint,arg0);
+  begin_system_call();
+  bool0 = LPtoDP(hdc,lppoint,int0);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:MODIFYWORLDTRANSFORM, hdc xform_p dword)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  XFORM* xform_p = alloca(sizeof(XFORM));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processXFORM(xform_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processXFORM(xform_p,arg0);
+  begin_system_call();
+  bool0 = ModifyWorldTransform(hdc,xform_p,dword);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:MOVETOEX, hdc int0 int1 lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(lppoint,arg0);
+  begin_system_call();
+  bool0 = MoveToEx(hdc,int0,int1,lppoint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:OFFSETVIEWPORTORGEX, hdc int0 int1 lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(lppoint,arg0);
+  begin_system_call();
+  bool0 = OffsetViewportOrgEx(hdc,int0,int1,lppoint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:OFFSETWINDOWORGEX, hdc int0 int1 lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(lppoint,arg0);
+  begin_system_call();
+  bool0 = OffsetWindowOrgEx(hdc,int0,int1,lppoint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PLAYENHMETAFILERECORD, hdc lphandletable enhmetarecord_p uint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HANDLETABLE* lphandletable;
+  ENHMETARECORD* enhmetarecord_p = alloca(sizeof(ENHMETARECORD));
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  processENHMETARECORD(enhmetarecord_p,arg);
+  arg = popSTACK();
+  lphandletable = alloca(uint*sizeof(HANDLETABLE));
+  processHANDLETABLE_C(lphandletable,arg,uint);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = PlayEnhMetaFileRecord(hdc,lphandletable,enhmetarecord_p,uint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PLAYMETAFILERECORD, hdc lphandletable lpmetarecord uint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HANDLETABLE* lphandletable;
+  METARECORD* lpmetarecord = alloca(sizeof(METARECORD));
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  processMETARECORD(lpmetarecord,arg);
+  arg = popSTACK();
+  lphandletable = alloca(uint*sizeof(HANDLETABLE));
+  processHANDLETABLE_C(lphandletable,arg,uint);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = PlayMetaFileRecord(hdc,lphandletable,lpmetarecord,uint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:POLYBEZIER, hdc point_p dword)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(point_p,arg0);
+  begin_system_call();
+  bool0 = PolyBezier(hdc,point_p,dword);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:POLYBEZIERTO, hdc point_p dword)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(point_p,arg0);
+  begin_system_call();
+  bool0 = PolyBezierTo(hdc,point_p,dword);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:POLYDRAW, hdc point_p byte_p int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  BYTE* byte_p;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  byte_p = &(TheSbvector(arg)->data);
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(point_p,arg0);
+  begin_system_call();
+  bool0 = PolyDraw(hdc,point_p,byte_p,int0);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:POLYPOLYGON, hdc point_p int_p int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  INT* int_p;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))argumentum_inritum(arg);
+  int_p = &(TheSbvector(arg)->data);
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(point_p,arg0);
+  begin_system_call();
+  bool0 = PolyPolygon(hdc,point_p,int_p,int0);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:POLYPOLYLINE, hdc point_p dword_p dword)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  DWORD* dword_p;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))argumentum_inritum(arg);
+  dword_p = &(TheSbvector(arg)->data);
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(point_p,arg0);
+  begin_system_call();
+  bool0 = PolyPolyline(hdc,point_p,dword_p,dword);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:POLYTEXTOUTA, hdc polytexta_p int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POLYTEXTA* polytexta_p = alloca(sizeof(POLYTEXTA));
+  object arg0;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processPOLYTEXTA(polytexta_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOLYTEXTA(polytexta_p,arg0);
+  begin_system_call();
+  bool0 = PolyTextOutA(hdc,polytexta_p,int0);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:POLYTEXTOUTW, hdc polytextw_p int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POLYTEXTW* polytextw_p = alloca(sizeof(POLYTEXTW));
+  object arg0;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processPOLYTEXTW(polytextw_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOLYTEXTW(polytextw_p,arg0);
+  begin_system_call();
+  bool0 = PolyTextOutW(hdc,polytextw_p,int0);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:POLYGON, hdc point_p int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(point_p,arg0);
+  begin_system_call();
+  bool0 = Polygon(hdc,point_p,int0);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:POLYLINE, hdc point_p int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(point_p,arg0);
+  begin_system_call();
+  bool0 = Polyline(hdc,point_p,int0);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:POLYLINETO, hdc point_p dword)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(point_p,arg0);
+  begin_system_call();
+  bool0 = PolylineTo(hdc,point_p,dword);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETBITMAPBITS, hbitmap dword pcvoid)
+{
+  object arg;
+  LONG long0;
+  HBITMAP hbitmap;
+  DWORD dword;
+  void* pcvoid;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pcvoid = &(TheSbvector(arg)->data);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hbitmap = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  long0 = SetBitmapBits(hbitmap,dword,pcvoid);
+  end_system_call();
+  if(0 <=long0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(long0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETBITMAPDIMENSIONEX, hbitmap int0 int1)
+{
+  object arg;
+  BOOL bool0;
+  HBITMAP hbitmap;
+  int int0;
+  int int1;
+  SIZE lpsize;
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hbitmap = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = SetBitmapDimensionEx(hbitmap,int0,int1,&lpsize);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    pushSTACK( uint32_to_I(lpsize.cy));
+    value2 = uint32_to_I(lpsize.cx);
+    value3 = popSTACK();
+    value1 = T;
+    mv_count=3;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETBOUNDSRECT, hdc lpcrect uint)
+{
+  object arg;
+  UINT uint0;
+  HDC hdc;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processRECT(lpcrect,arg0);
+  begin_system_call();
+  uint0 = SetBoundsRect(hdc,lpcrect,uint);
+  end_system_call();
+  if(0 <=uint0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETBRUSHORGEX, hdc int0 int1 lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(lppoint,arg0);
+  begin_system_call();
+  bool0 = SetBrushOrgEx(hdc,int0,int1,lppoint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETDIBCOLORTABLE, hdc uint uint0 rgbquad_p)
+{
+  object arg;
+  UINT uint1;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  RGBQUAD* rgbquad_p;
+  object arg0;
+  arg0 = popSTACK();
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  rgbquad_p = alloca(uint0*sizeof(RGBQUAD));
+  processRGBQUAD_C(rgbquad_p,arg0,uint0);
+  begin_system_call();
+  uint1 = SetDIBColorTable(hdc,uint,uint0,rgbquad_p);
+  end_system_call();
+  if(0 <=uint1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETENHMETAFILEBITS, uint byte_p)
+{
+  object arg;
+  HENHMETAFILE henhmetafile;
+  UINT uint;
+  BYTE* byte_p;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  byte_p = &(TheSbvector(arg)->data);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  begin_system_call();
+  henhmetafile = SetEnhMetaFileBits(uint,byte_p);
+  end_system_call();
+  if(NULL ==henhmetafile){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(henhmetafile);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETMETAFILEBITSEX, uint byte_p)
+{
+  object arg;
+  HMETAFILE hmetafile;
+  UINT uint;
+  BYTE* byte_p;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  byte_p = &(TheSbvector(arg)->data);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  begin_system_call();
+  hmetafile = SetMetaFileBitsEx(uint,byte_p);
+  end_system_call();
+  if(NULL ==hmetafile){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hmetafile);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETPALETTEENTRIES, hpalette uint uint0 paletteentry_p)
+{
+  object arg;
+  UINT uint1;
+  HPALETTE hpalette;
+  UINT uint;
+  UINT uint0;
+  PALETTEENTRY* paletteentry_p = alloca(sizeof(PALETTEENTRY));
+  object arg0;
+  arg0 = popSTACK();
+  processPALETTEENTRY(paletteentry_p,arg0);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hpalette = TheFpointer(arg)->fp_pointer;
+  processPALETTEENTRY(paletteentry_p,arg0);
+  begin_system_call();
+  uint1 = SetPaletteEntries(hpalette,uint,uint0,paletteentry_p);
+  end_system_call();
+  if(0 <=uint1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETPIXELFORMAT, hdc int0 pixelformatdescriptor_p)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  PIXELFORMATDESCRIPTOR* pixelformatdescriptor_p = alloca(sizeof(PIXELFORMATDESCRIPTOR));
+  object arg0;
+  arg0 = popSTACK();
+  processPIXELFORMATDESCRIPTOR(pixelformatdescriptor_p,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPIXELFORMATDESCRIPTOR(pixelformatdescriptor_p,arg0);
+  begin_system_call();
+  bool0 = SetPixelFormat(hdc,int0,pixelformatdescriptor_p);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETVIEWPORTEXTEX, hdc int0 int1 lpsize)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  object arg0;
+  arg0 = popSTACK();
+  processSIZE(lpsize,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processSIZE(lpsize,arg0);
+  begin_system_call();
+  bool0 = SetViewportExtEx(hdc,int0,int1,lpsize);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETVIEWPORTORGEX, hdc int0 int1 lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(lppoint,arg0);
+  begin_system_call();
+  bool0 = SetViewportOrgEx(hdc,int0,int1,lppoint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETWINMETAFILEBITS, uint byte_p hdc metafilepict_p)
+{
+  object arg;
+  HENHMETAFILE henhmetafile;
+  UINT uint;
+  BYTE* byte_p;
+  HDC hdc;
+  METAFILEPICT* metafilepict_p = alloca(sizeof(METAFILEPICT));
+  object arg0;
+  arg0 = popSTACK();
+  processMETAFILEPICT(metafilepict_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  byte_p = &(TheSbvector(arg)->data);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  processMETAFILEPICT(metafilepict_p,arg0);
+  begin_system_call();
+  henhmetafile = SetWinMetaFileBits(uint,byte_p,hdc,metafilepict_p);
+  end_system_call();
+  if(NULL ==henhmetafile){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(henhmetafile);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETWINDOWEXTEX, hdc int0 int1 lpsize)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  object arg0;
+  arg0 = popSTACK();
+  processSIZE(lpsize,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processSIZE(lpsize,arg0);
+  begin_system_call();
+  bool0 = SetWindowExtEx(hdc,int0,int1,lpsize);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETWINDOWORGEX, hdc int0 int1 lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(lppoint,arg0);
+  begin_system_call();
+  bool0 = SetWindowOrgEx(hdc,int0,int1,lppoint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:STARTDOCA, hdc docinfoa_p)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  DOCINFOA* docinfoa_p = alloca(sizeof(DOCINFOA));
+  object arg0;
+  arg0 = popSTACK();
+  processDOCINFOA(docinfoa_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processDOCINFOA(docinfoa_p,arg0);
+  begin_system_call();
+  int0 = StartDocA(hdc,docinfoa_p);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:STARTDOCW, hdc docinfow_p)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  DOCINFOW* docinfow_p = alloca(sizeof(DOCINFOW));
+  object arg0;
+  arg0 = popSTACK();
+  processDOCINFOW(docinfow_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processDOCINFOW(docinfow_p,arg0);
+  begin_system_call();
+  int0 = StartDocW(hdc,docinfow_p);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:TEXTOUTA, hdc int0 int1 lpcstr int2)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  LPCSTR lpcstr;
+  int int2;
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    check_sint(arg);
+    int1 = I_to_sint32(arg);
+    arg = popSTACK();
+    check_sint(arg);
+    int0 = I_to_sint32(arg);
+    arg = popSTACK();
+    if(!fpointerp(arg))argumentum_inritum(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+    begin_system_call();
+    bool0 = TextOutA(hdc,int0,int1,lpcstr,int2);
+    end_system_call();
+    if(!bool0){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      mv_count=1;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:TEXTOUTW, hdc int0 int1 lpcwstr int2)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  LPCWSTR lpcwstr;
+  int int2;
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = TextOutW(hdc,int0,int1,lpcwstr,int2);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:UPDATEICMREGKEYA, dword dword0 lpstr uint)
+{
+  object arg;
+  BOOL bool0;
+  DWORD dword;
+  DWORD dword0;
+  LPSTR lpstr;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpstr, {
+    dword0 = I_to_uint32(check_uint(popSTACK()));
+    dword = I_to_uint32(check_uint(popSTACK()));
+    begin_system_call();
+    bool0 = UpdateICMRegKeyA(dword,dword0,lpstr,uint);
+    end_system_call();
+    if(!bool0){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      mv_count=1;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:UPDATEICMREGKEYW, dword dword0 lpwstr uint)
+{
+  object arg;
+  BOOL bool0;
+  DWORD dword;
+  DWORD dword0;
+  LPWSTR lpwstr;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpwstr = WIDECHAR(arg,encoding);
+  dword0 = I_to_uint32(check_uint(popSTACK()));
+  dword = I_to_uint32(check_uint(popSTACK()));
+  begin_system_call();
+  bool0 = UpdateICMRegKeyW(dword,dword0,lpwstr,uint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/funcs-count.h modules/gdi/funcs-count.h
--- origmodules/gdi/funcs-count.h	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/funcs-count.h	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1,56 @@
+int          AddFontResourceA(LPCSTR);
+int          AddFontResourceW(LPCWSTR);
+BOOL         AnimatePalette(HPALETTE,UINT,UINT, PALETTEENTRY_P);
+int          ChoosePixelFormat(HDC,  PIXELFORMATDESCRIPTOR_P);
+HBITMAP      CreateBitmap(int,int,UINT,UINT,PCVOID);
+HBRUSH       CreateDIBPatternBrushPt(PCVOID,UINT);
+HRGN         CreatePolyPolygonRgn( POINT_P, INT_P,int,int);
+HRGN         CreatePolygonRgn( POINT_P,int,int);
+BOOL         CreateScalableFontResourceA(DWORD,LPCSTR,LPCSTR,LPCSTR);
+BOOL         CreateScalableFontResourceW(DWORD,LPCWSTR,LPCWSTR,LPCWSTR);
+BOOL         DPtoLP(HDC,LPPOINT,int);
+int          DescribePixelFormat(HDC,int,UINT,LPPIXELFORMATDESCRIPTOR);
+int          DrawEscape(HDC,int,int,LPCSTR);
+HPEN         ExtCreatePen(DWORD,DWORD, LOGBRUSH_P,DWORD, DWORD_P);
+HRGN         ExtCreateRegion( XFORM_P,DWORD, RGNDATA_P);
+BOOL         FixBrushOrgEx(HDC,int,int,LPPOINT);
+BOOL         GdiComment(HDC,UINT, BYTE_P);
+BOOL         GdiFlush(void);
+DWORD        GdiGetBatchLimit(void);
+BOOL         LPtoDP(HDC,LPPOINT,int);
+BOOL         ModifyWorldTransform(HDC, XFORM_P,DWORD);
+BOOL         MoveToEx(HDC,int,int,LPPOINT);
+BOOL         OffsetViewportOrgEx(HDC,int,int,LPPOINT);
+BOOL         OffsetWindowOrgEx(HDC,int,int,LPPOINT);
+BOOL         PlayEnhMetaFileRecord(HDC,LPHANDLETABLE, ENHMETARECORD_P,UINT);
+BOOL         PlayMetaFileRecord(HDC,LPHANDLETABLE,LPMETARECORD,UINT);
+BOOL         PolyBezier(HDC, POINT_P,DWORD);
+BOOL         PolyBezierTo(HDC, POINT_P,DWORD);
+BOOL         PolyDraw(HDC, POINT_P, BYTE_P,int);
+BOOL         PolyPolygon(HDC, POINT_P, INT_P,int);
+BOOL         PolyPolyline(HDC, POINT_P, DWORD_P,DWORD);
+BOOL         PolyTextOutA(HDC, POLYTEXTA_P,int);
+BOOL         PolyTextOutW(HDC, POLYTEXTW_P,int);
+BOOL         Polygon(HDC, POINT_P,int);
+BOOL         Polyline(HDC, POINT_P,int);
+BOOL         PolylineTo(HDC, POINT_P,DWORD);
+LONG         SetBitmapBits(HBITMAP,DWORD,PCVOID);
+BOOL         SetBitmapDimensionEx(HBITMAP,int,int,LPSIZE);
+UINT         SetBoundsRect(HDC,LPCRECT,UINT);
+BOOL         SetBrushOrgEx(HDC,int,int,LPPOINT);
+UINT         SetDIBColorTable(HDC,UINT,UINT, RGBQUAD_P);
+HENHMETAFILE SetEnhMetaFileBits(UINT, BYTE_P);
+HMETAFILE    SetMetaFileBitsEx(UINT, BYTE_P);
+UINT         SetPaletteEntries(HPALETTE,UINT,UINT, PALETTEENTRY_P);
+BOOL         SetPixelFormat(HDC,int,PIXELFORMATDESCRIPTOR_P);
+BOOL         SetViewportExtEx(HDC,int,int,LPSIZE);
+BOOL         SetViewportOrgEx(HDC,int,int,LPPOINT);
+HENHMETAFILE SetWinMetaFileBits(UINT, BYTE_P,HDC, METAFILEPICT_P);
+BOOL         SetWindowExtEx(HDC,int,int,LPSIZE);
+BOOL         SetWindowOrgEx(HDC,int,int,LPPOINT);
+int          StartDocA(HDC, DOCINFOA_P);
+int          StartDocW(HDC, DOCINFOW_P);
+BOOL         TextOutA(HDC,int,int,LPCSTR,int);
+BOOL         TextOutW(HDC,int,int,LPCWSTR,int);
+BOOL         UpdateICMRegKeyA(DWORD,DWORD,LPSTR,UINT);
+BOOL         UpdateICMRegKeyW(DWORD,DWORD,LPWSTR,UINT);
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/funcs-ok.c modules/gdi/funcs-ok.c
--- origmodules/gdi/funcs-ok.c	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/funcs-ok.c	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1,3817 @@
+#line 1 "funcs.c"
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ABORTDOC, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = AbortDoc(hdc);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ABORTPATH, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = AbortPath(hdc);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ADDATOMA, lpcstr)
+{
+  object arg;
+  ATOM atom;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    atom = AddAtomA(lpcstr);
+    end_system_call();
+    if(0 ==atom){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = allocate_fpointer(atom);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ADDATOMW, lpcwstr)
+{
+  object arg;
+  ATOM atom;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  atom = AddAtomW(lpcwstr);
+  end_system_call();
+  if(0 ==atom){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(atom);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:BEGINPATH, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = BeginPath(hdc);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CANCELDC, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = CancelDC(hdc);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CLOSEENHMETAFILE, hdc)
+{
+  object arg;
+  HENHMETAFILE henhmetafile;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  henhmetafile = CloseEnhMetaFile(hdc);
+  end_system_call();
+  if(NULL ==henhmetafile){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(henhmetafile);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CLOSEFIGURE, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = CloseFigure(hdc);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CLOSEMETAFILE, hdc)
+{
+  object arg;
+  HMETAFILE hmetafile;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hmetafile = CloseMetaFile(hdc);
+  end_system_call();
+  if(NULL ==hmetafile){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hmetafile);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:COLORMATCHTOTARGET, hdc hdc0 dword)
+{
+  object arg;
+  BOOL bool0 = false;
+  HDC hdc;
+  HDC hdc0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc0 = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+#ifndef __CYGWIN__
+  bool0 = ColorMatchToTarget(hdc,hdc0,dword);
+#endif
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:COMBINERGN, hrgn hrgn0 hrgn1 int0)
+{
+  object arg;
+  int int1;
+  HRGN hrgn;
+  HRGN hrgn0;
+  HRGN hrgn1;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn1 = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn0 = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int1 = CombineRgn(hrgn,hrgn0,hrgn1,int0);
+  end_system_call();
+  if(0 <=int1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATECOMPATIBLEBITMAP, hdc int0 int1)
+{
+  object arg;
+  HBITMAP hbitmap;
+  HDC hdc;
+  int int0;
+  int int1;
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hbitmap = CreateCompatibleBitmap(hdc,int0,int1);
+  end_system_call();
+  if(NULL ==hbitmap){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hbitmap);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATECOMPATIBLEDC, hdc)
+{
+  object arg;
+  HDC hdc0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hdc0 = CreateCompatibleDC(hdc);
+  end_system_call();
+  if(NULL ==hdc0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hdc0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEDIBPATTERNBRUSH, hglobal uint)
+{
+  object arg;
+  HBRUSH hbrush;
+  HGLOBAL hglobal;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hglobal = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hbrush = CreateDIBPatternBrush(hglobal,uint);
+  end_system_call();
+  if(NULL ==hbrush){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hbrush);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEDISCARDABLEBITMAP, hdc int0 int1)
+{
+  object arg;
+  HBITMAP hbitmap;
+  HDC hdc;
+  int int0;
+  int int1;
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hbitmap = CreateDiscardableBitmap(hdc,int0,int1);
+  end_system_call();
+  if(NULL ==hbitmap){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hbitmap);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEELLIPTICRGN, int0 int1 int2 int3)
+{
+  object arg;
+  HRGN hrgn;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  begin_system_call();
+  hrgn = CreateEllipticRgn(int0,int1,int2,int3);
+  end_system_call();
+  if(NULL ==hrgn){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hrgn);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEHALFTONEPALETTE, hdc)
+{
+  object arg;
+  HPALETTE hpalette;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hpalette = CreateHalftonePalette(hdc);
+  end_system_call();
+  if(NULL ==hpalette){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hpalette);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEHATCHBRUSH, int0 colorref)
+{
+  object arg;
+  HBRUSH hbrush;
+  int int0;
+  COLORREF colorref;
+  colorref = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  begin_system_call();
+  hbrush = CreateHatchBrush(int0,colorref);
+  end_system_call();
+  if(NULL ==hbrush){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hbrush);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEPATTERNBRUSH, hbitmap)
+{
+  object arg;
+  HBRUSH hbrush;
+  HBITMAP hbitmap;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hbitmap = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hbrush = CreatePatternBrush(hbitmap);
+  end_system_call();
+  if(NULL ==hbrush){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hbrush);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEPEN, int0 int1 colorref)
+{
+  object arg;
+  HPEN hpen;
+  int int0;
+  int int1;
+  COLORREF colorref;
+  colorref = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  begin_system_call();
+  hpen = CreatePen(int0,int1,colorref);
+  end_system_call();
+  if(NULL ==hpen){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hpen);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATERECTRGN, int0 int1 int2 int3)
+{
+  object arg;
+  HRGN hrgn;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  begin_system_call();
+  hrgn = CreateRectRgn(int0,int1,int2,int3);
+  end_system_call();
+  if(NULL ==hrgn){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hrgn);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATESOLIDBRUSH, colorref)
+{
+  object arg;
+  HBRUSH hbrush;
+  COLORREF colorref;
+  colorref = I_to_uint32(check_uint(popSTACK()));
+  begin_system_call();
+  hbrush = CreateSolidBrush(colorref);
+  end_system_call();
+  if(NULL ==hbrush){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hbrush);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:DELETECOLORSPACE, hcolorspace)
+{
+  object arg;
+  BOOL bool0;
+  HCOLORSPACE hcolorspace;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hcolorspace = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = DeleteColorSpace(hcolorspace);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:DELETEDC, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = DeleteDC(hdc);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:DELETEENHMETAFILE, henhmetafile)
+{
+  object arg;
+  BOOL bool0;
+  HENHMETAFILE henhmetafile;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  henhmetafile = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = DeleteEnhMetaFile(henhmetafile);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:DELETEMETAFILE, hmetafile)
+{
+  object arg;
+  BOOL bool0;
+  HMETAFILE hmetafile;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hmetafile = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = DeleteMetaFile(hmetafile);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:DELETEOBJECT, hgdiobj)
+{
+  object arg;
+  BOOL bool0;
+  HGDIOBJ hgdiobj;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hgdiobj = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = DeleteObject(hgdiobj);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ELLIPSE, hdc int0 int1 int2 int3)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = Ellipse(hdc,int0,int1,int2,int3);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ENDDOC, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = EndDoc(hdc);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ENDPAGE, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = EndPage(hdc);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ENDPATH, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = EndPath(hdc);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EQUALRGN, hrgn hrgn0)
+{
+  object arg;
+  BOOL bool0;
+  HRGN hrgn;
+  HRGN hrgn0;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn0 = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = EqualRgn(hrgn,hrgn0);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ESCAPECOMMFUNCTION, handle dword)
+{
+  object arg;
+  BOOL bool0;
+  HANDLE handle;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  handle = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = EscapeCommFunction(handle,dword);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EXCLUDECLIPRECT, hdc int0 int1 int2 int3)
+{
+  object arg;
+  int int4;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int4 = ExcludeClipRect(hdc,int0,int1,int2,int3);
+  end_system_call();
+  if(0 <=int4){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int4);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EXTFLOODFILL, hdc int0 int1 colorref uint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  COLORREF colorref;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  colorref = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = ExtFloodFill(hdc,int0,int1,colorref,uint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EXTSELECTCLIPRGN, hdc hrgn int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  HRGN hrgn;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int1 = ExtSelectClipRgn(hdc,hrgn,int0);
+  end_system_call();
+  if(0 <=int1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FILLPATH, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = FillPath(hdc);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FILLRGN, hdc hrgn hbrush)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  HRGN hrgn;
+  HBRUSH hbrush;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hbrush = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = FillRgn(hdc,hrgn,hbrush);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FINDATOMA, lpcstr)
+{
+  object arg;
+  ATOM atom;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    atom = FindAtomA(lpcstr);
+    end_system_call();
+    if(0 ==atom){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = allocate_fpointer(atom);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FINDATOMW, lpcwstr)
+{
+  object arg;
+  ATOM atom;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  atom = FindAtomW(lpcwstr);
+  end_system_call();
+  if(0 ==atom){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(atom);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FLATTENPATH, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = FlattenPath(hdc);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FLOODFILL, hdc int0 int1 colorref)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  COLORREF colorref;
+  colorref = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = FloodFill(hdc,int0,int1,colorref);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FRAMERGN, hdc hrgn hbrush int0 int1)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HRGN hrgn;
+  HBRUSH hbrush;
+  int int0;
+  int int1;
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hbrush = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = FrameRgn(hdc,hrgn,hbrush,int0,int1);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GDISETBATCHLIMIT, dword)
+{
+  object arg;
+  DWORD dword0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  begin_system_call();
+  dword0 = GdiSetBatchLimit(dword);
+  end_system_call();
+  if(0 <=dword0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(dword0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETARCDIRECTION, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = GetArcDirection(hdc);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETBKCOLOR, hdc)
+{
+  object arg;
+  COLORREF colorref;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  colorref = GetBkColor(hdc);
+  end_system_call();
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETBKMODE, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = GetBkMode(hdc);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCLIPRGN, hdc hrgn)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  HRGN hrgn;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = GetClipRgn(hdc,hrgn);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCOLORSPACE, hdc)
+{
+  object arg;
+  HANDLE handle;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  handle = GetColorSpace(hdc);
+  end_system_call();
+  if(NULL ==handle){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(handle);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCURRENTOBJECT, hdc uint)
+{
+  object arg;
+  HGDIOBJ hgdiobj;
+  HDC hdc;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hgdiobj = GetCurrentObject(hdc,uint);
+  end_system_call();
+  if(NULL ==hgdiobj){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hgdiobj);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETFONTLANGUAGEINFO, hdc)
+{
+  object arg;
+  DWORD dword;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  dword = GetFontLanguageInfo(hdc);
+  end_system_call();
+  if(0 <=dword){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(dword);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETGRAPHICSMODE, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = GetGraphicsMode(hdc);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETMAPMODE, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = GetMapMode(hdc);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETMETARGN, hdc hrgn)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  HRGN hrgn;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = GetMetaRgn(hdc,hrgn);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETNEARESTCOLOR, hdc colorref)
+{
+  object arg;
+  COLORREF colorref0;
+  HDC hdc;
+  COLORREF colorref;
+  colorref = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  colorref0 = GetNearestColor(hdc,colorref);
+  end_system_call();
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETNEARESTPALETTEINDEX, hpalette colorref)
+{
+  object arg;
+  UINT uint;
+  HPALETTE hpalette;
+  COLORREF colorref;
+  colorref = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hpalette = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  uint = GetNearestPaletteIndex(hpalette,colorref);
+  end_system_call();
+  if(0 <=uint){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETOBJECTTYPE, hgdiobj)
+{
+  object arg;
+  DWORD dword;
+  HGDIOBJ hgdiobj;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hgdiobj = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  dword = GetObjectType(hgdiobj);
+  end_system_call();
+  if(0 <=dword){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(dword);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETPIXEL, hdc int0 int1)
+{
+  object arg;
+  COLORREF colorref;
+  HDC hdc;
+  int int0;
+  int int1;
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  colorref = GetPixel(hdc,int0,int1);
+  end_system_call();
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETPIXELFORMAT, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = GetPixelFormat(hdc);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETPOLYFILLMODE, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = GetPolyFillMode(hdc);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETROP2, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = GetROP2(hdc);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETSTOCKOBJECT, int0)
+{
+  object arg;
+  HGDIOBJ hgdiobj;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  begin_system_call();
+  hgdiobj = GetStockObject(int0);
+  end_system_call();
+  if(NULL ==hgdiobj){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hgdiobj);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETSTRETCHBLTMODE, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = GetStretchBltMode(hdc);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETSYSTEMPALETTEUSE, hdc)
+{
+  object arg;
+  UINT uint;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  uint = GetSystemPaletteUse(hdc);
+  end_system_call();
+  if(0 <=uint){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETTEXTALIGN, hdc)
+{
+  object arg;
+  UINT uint;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  uint = GetTextAlign(hdc);
+  end_system_call();
+  if(0 <=uint){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETTEXTCHARACTEREXTRA, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = GetTextCharacterExtra(hdc);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETTEXTCHARSET, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = GetTextCharset(hdc);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETTEXTCOLOR, hdc)
+{
+  object arg;
+  COLORREF colorref;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  colorref = GetTextColor(hdc);
+  end_system_call();
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GLOBALADDATOMA, lpcstr)
+{
+  object arg;
+  ATOM atom;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    atom = GlobalAddAtomA(lpcstr);
+    end_system_call();
+    if(0 ==atom){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = allocate_fpointer(atom);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GLOBALADDATOMW, lpcwstr)
+{
+  object arg;
+  ATOM atom;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  atom = GlobalAddAtomW(lpcwstr);
+  end_system_call();
+  if(0 ==atom){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(atom);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GLOBALFINDATOMA, lpcstr)
+{
+  object arg;
+  ATOM atom;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    atom = GlobalFindAtomA(lpcstr);
+    end_system_call();
+    if(0 ==atom){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = allocate_fpointer(atom);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GLOBALFINDATOMW, lpcwstr)
+{
+  object arg;
+  ATOM atom;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  atom = GlobalFindAtomW(lpcwstr);
+  end_system_call();
+  if(0 ==atom){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(atom);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:INTERSECTCLIPRECT, hdc int0 int1 int2 int3)
+{
+  object arg;
+  int int4;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int4 = IntersectClipRect(hdc,int0,int1,int2,int3);
+  end_system_call();
+  if(0 <=int4){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int4);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:INVERTRGN, hdc hrgn)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HRGN hrgn;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = InvertRgn(hdc,hrgn);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:LINETO, hdc int0 int1)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = LineTo(hdc,int0,int1);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:LOADCURSORFROMFILEA, lpcstr)
+{
+  object arg;
+  HCURSOR hcursor;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    hcursor = LoadCursorFromFileA(lpcstr);
+    end_system_call();
+    if(NULL ==hcursor){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = allocate_fpointer(hcursor);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:LOADCURSORFROMFILEW, lpcwstr)
+{
+  object arg;
+  HCURSOR hcursor;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  hcursor = LoadCursorFromFileW(lpcwstr);
+  end_system_call();
+  if(NULL ==hcursor){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hcursor);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:OFFSETCLIPRGN, hdc int0 int1)
+{
+  object arg;
+  int int2;
+  HDC hdc;
+  int int0;
+  int int1;
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int2 = OffsetClipRgn(hdc,int0,int1);
+  end_system_call();
+  if(0 <=int2){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int2);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:OFFSETRGN, hrgn int0 int1)
+{
+  object arg;
+  int int2;
+  HRGN hrgn;
+  int int0;
+  int int1;
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int2 = OffsetRgn(hrgn,int0,int1);
+  end_system_call();
+  if(0 <=int2){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int2);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PAINTRGN, hdc hrgn)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HRGN hrgn;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = PaintRgn(hdc,hrgn);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PATHTOREGION, hdc)
+{
+  object arg;
+  HRGN hrgn;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hrgn = PathToRegion(hdc);
+  end_system_call();
+  if(NULL ==hrgn){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hrgn);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PLAYMETAFILE, hdc hmetafile)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HMETAFILE hmetafile;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hmetafile = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = PlayMetaFile(hdc,hmetafile);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PTINREGION, hrgn int0 int1)
+{
+  object arg;
+  BOOL bool0;
+  HRGN hrgn;
+  int int0;
+  int int1;
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = PtInRegion(hrgn,int0,int1);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PTVISIBLE, hdc int0 int1)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = PtVisible(hdc,int0,int1);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:REALIZEPALETTE, hdc)
+{
+  object arg;
+  UINT uint;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  uint = RealizePalette(hdc);
+  end_system_call();
+  if(0 <=uint){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:RECTANGLE, hdc int0 int1 int2 int3)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = Rectangle(hdc,int0,int1,int2,int3);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:RESIZEPALETTE, hpalette uint)
+{
+  object arg;
+  BOOL bool0;
+  HPALETTE hpalette;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hpalette = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = ResizePalette(hpalette,uint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:RESTOREDC, hdc int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = RestoreDC(hdc,int0);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SAVEDC, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = SaveDC(hdc);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SELECTCLIPPATH, hdc int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = SelectClipPath(hdc,int0);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SELECTCLIPRGN, hdc hrgn)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  HRGN hrgn;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = SelectClipRgn(hdc,hrgn);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SELECTOBJECT, hdc hgdiobj)
+{
+  object arg;
+  HGDIOBJ hgdiobj0;
+  HDC hdc;
+  HGDIOBJ hgdiobj;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hgdiobj = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hgdiobj0 = SelectObject(hdc,hgdiobj);
+  end_system_call();
+  if(NULL ==hgdiobj0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hgdiobj0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETARCDIRECTION, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int1 = SetArcDirection(hdc,int0);
+  end_system_call();
+  if(0 <=int1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETBKCOLOR, hdc colorref)
+{
+  object arg;
+  COLORREF colorref0;
+  HDC hdc;
+  COLORREF colorref;
+  colorref = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  colorref0 = SetBkColor(hdc,colorref);
+  end_system_call();
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETBKMODE, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int1 = SetBkMode(hdc,int0);
+  end_system_call();
+  if(0 <=int1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETCOLORSPACE, hdc hcolorspace)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HCOLORSPACE hcolorspace;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hcolorspace = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = SetColorSpace(hdc,hcolorspace);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETGRAPHICSMODE, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int1 = SetGraphicsMode(hdc,int0);
+  end_system_call();
+  if(0 <=int1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETICMMODE, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int1 = SetICMMode(hdc,int0);
+  end_system_call();
+  if(0 <=int1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETMAPMODE, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int1 = SetMapMode(hdc,int0);
+  end_system_call();
+  if(0 <=int1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETMAPPERFLAGS, hdc dword)
+{
+  object arg;
+  DWORD dword0;
+  HDC hdc;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  dword0 = SetMapperFlags(hdc,dword);
+  end_system_call();
+  if(0 <=dword0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(dword0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETMETARGN, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = SetMetaRgn(hdc);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETPOLYFILLMODE, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int1 = SetPolyFillMode(hdc,int0);
+  end_system_call();
+  if(0 <=int1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETROP2, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int1 = SetROP2(hdc,int0);
+  end_system_call();
+  if(0 <=int1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETRECTRGN, hrgn int0 int1 int2 int3)
+{
+  object arg;
+  BOOL bool0;
+  HRGN hrgn;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = SetRectRgn(hrgn,int0,int1,int2,int3);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETSTRETCHBLTMODE, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int1 = SetStretchBltMode(hdc,int0);
+  end_system_call();
+  if(0 <=int1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETSYSTEMPALETTEUSE, hdc uint)
+{
+  object arg;
+  UINT uint0;
+  HDC hdc;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  uint0 = SetSystemPaletteUse(hdc,uint);
+  end_system_call();
+  if(0 <=uint0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETTEXTALIGN, hdc uint)
+{
+  object arg;
+  UINT uint0;
+  HDC hdc;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  uint0 = SetTextAlign(hdc,uint);
+  end_system_call();
+  if(0 <=uint0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETTEXTCHARACTEREXTRA, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int1 = SetTextCharacterExtra(hdc,int0);
+  end_system_call();
+  if(0 <=int1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETTEXTJUSTIFICATION, hdc int0 int1)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = SetTextJustification(hdc,int0,int1);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SHOWWINDOW, hwnd int0)
+{
+  object arg;
+  BOOL bool0;
+  HWND hwnd;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hwnd = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = ShowWindow(hwnd,int0);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SHOWWINDOWASYNC, hwnd int0)
+{
+  object arg;
+  BOOL bool0;
+  HWND hwnd;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hwnd = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = ShowWindowAsync(hwnd,int0);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:STARTPAGE, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = StartPage(hdc);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:STROKEANDFILLPATH, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = StrokeAndFillPath(hdc);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:STROKEPATH, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = StrokePath(hdc);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SWAPBUFFERS, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = SwapBuffers(hdc);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:UNREALIZEOBJECT, hgdiobj)
+{
+  object arg;
+  BOOL bool0;
+  HGDIOBJ hgdiobj;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hgdiobj = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = UnrealizeObject(hgdiobj);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:UPDATECOLORS, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = UpdateColors(hdc);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:UPDATEWINDOW, hwnd)
+{
+  object arg;
+  BOOL bool0;
+  HWND hwnd;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hwnd = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = UpdateWindow(hwnd);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:WIDENPATH, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = WidenPath(hdc);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/funcs-ok.h modules/gdi/funcs-ok.h
--- origmodules/gdi/funcs-ok.h	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/funcs-ok.h	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1,119 @@
+int          AbortDoc(HDC);
+BOOL         AbortPath(HDC);
+ATOM         AddAtomA(LPCSTR);
+ATOM         AddAtomW(LPCWSTR);
+BOOL         BeginPath(HDC);
+BOOL         CancelDC(HDC);
+HENHMETAFILE CloseEnhMetaFile(HDC);
+BOOL         CloseFigure(HDC);
+HMETAFILE    CloseMetaFile(HDC);
+BOOL         ColorMatchToTarget(HDC,HDC,DWORD);
+int          CombineRgn(HRGN,HRGN,HRGN,int);
+HBITMAP      CreateCompatibleBitmap(HDC,int,int);
+HDC          CreateCompatibleDC(HDC);
+HBRUSH       CreateDIBPatternBrush(HGLOBAL,UINT);
+HBITMAP      CreateDiscardableBitmap(HDC,int,int);
+HRGN         CreateEllipticRgn(int,int,int,int);
+HPALETTE     CreateHalftonePalette(HDC);
+HBRUSH       CreateHatchBrush(int,COLORREF);
+HBRUSH       CreatePatternBrush(HBITMAP);
+HPEN         CreatePen(int,int,COLORREF);
+HRGN         CreateRectRgn(int,int,int,int);
+HBRUSH       CreateSolidBrush(COLORREF);
+BOOL         DeleteColorSpace(HCOLORSPACE);
+BOOL         DeleteDC(HDC);
+BOOL         DeleteEnhMetaFile(HENHMETAFILE);
+BOOL         DeleteMetaFile(HMETAFILE);
+BOOL         DeleteObject(HGDIOBJ);
+BOOL         Ellipse(HDC,int,int,int,int);
+int          EndDoc(HDC);
+int          EndPage(HDC);
+BOOL         EndPath(HDC);
+BOOL         EqualRgn(HRGN,HRGN);
+BOOL         EscapeCommFunction(HANDLE,DWORD);
+int          ExcludeClipRect(HDC,int,int,int,int);
+BOOL         ExtFloodFill(HDC,int,int,COLORREF,UINT);
+int          ExtSelectClipRgn(HDC,HRGN,int);
+BOOL         FillPath(HDC);
+int          FillRgn(HDC,HRGN,HBRUSH);
+ATOM         FindAtomA(LPCSTR);
+ATOM         FindAtomW(LPCWSTR);
+BOOL         FlattenPath(HDC);
+BOOL         FloodFill(HDC,int,int,COLORREF);
+BOOL         FrameRgn(HDC,HRGN,HBRUSH,int,int);
+DWORD        GdiSetBatchLimit(DWORD);
+int          GetArcDirection(HDC);
+COLORREF     GetBkColor(HDC);
+int          GetBkMode(HDC);
+int          GetClipRgn(HDC,HRGN);
+HANDLE       GetColorSpace(HDC);
+HGDIOBJ      GetCurrentObject(HDC,UINT);
+DWORD        GetFontLanguageInfo(HDC);
+int          GetGraphicsMode(HDC);
+int          GetMapMode(HDC);
+int          GetMetaRgn(HDC,HRGN);
+COLORREF     GetNearestColor(HDC,COLORREF);
+UINT         GetNearestPaletteIndex(HPALETTE,COLORREF);
+DWORD        GetObjectType(HGDIOBJ);
+COLORREF     GetPixel(HDC,int,int);
+int          GetPixelFormat(HDC);
+int          GetPolyFillMode(HDC);
+int          GetROP2(HDC);
+HGDIOBJ      GetStockObject(int);
+int          GetStretchBltMode(HDC);
+UINT         GetSystemPaletteUse(HDC);
+UINT         GetTextAlign(HDC);
+int          GetTextCharacterExtra(HDC);
+int          GetTextCharset(HDC);
+COLORREF     GetTextColor(HDC);
+ATOM         GlobalAddAtomA(LPCSTR);
+ATOM         GlobalAddAtomW( LPCWSTR);
+ATOM         GlobalFindAtomA(LPCSTR);
+ATOM         GlobalFindAtomW(LPCWSTR);
+int          IntersectClipRect(HDC,int,int,int,int);
+BOOL         InvertRgn(HDC,HRGN);
+BOOL         LineTo(HDC,int,int);
+HCURSOR      LoadCursorFromFileA(LPCSTR);
+HCURSOR      LoadCursorFromFileW(LPCWSTR);
+int          OffsetClipRgn(HDC,int,int);
+int          OffsetRgn(HRGN,int,int);
+BOOL         PaintRgn(HDC,HRGN);
+HRGN         PathToRegion(HDC);
+BOOL         PlayMetaFile(HDC,HMETAFILE);
+BOOL         PtInRegion(HRGN,int,int);
+BOOL         PtVisible(HDC,int,int);
+UINT         RealizePalette(HDC);
+BOOL         Rectangle(HDC,int,int,int,int);
+BOOL         ResizePalette(HPALETTE,UINT);
+BOOL         RestoreDC(HDC,int);
+int          SaveDC(HDC);
+BOOL         SelectClipPath(HDC,int);
+int          SelectClipRgn(HDC,HRGN);
+HGDIOBJ      SelectObject(HDC,HGDIOBJ);
+int          SetArcDirection(HDC,int);
+COLORREF     SetBkColor(HDC,COLORREF);
+int          SetBkMode(HDC,int);
+BOOL         SetColorSpace(HDC,HCOLORSPACE);
+int          SetGraphicsMode(HDC,int);
+int          SetICMMode(HDC,int);
+int          SetMapMode(HDC,int);
+DWORD        SetMapperFlags(HDC,DWORD);
+int          SetMetaRgn(HDC);
+int          SetPolyFillMode(HDC,int);
+int          SetROP2(HDC,int);
+BOOL         SetRectRgn(HRGN,int,int,int,int);
+int          SetStretchBltMode(HDC,int);
+UINT         SetSystemPaletteUse(HDC,UINT);
+UINT         SetTextAlign(HDC,UINT);
+int          SetTextCharacterExtra(HDC,int);
+BOOL         SetTextJustification(HDC,int,int);
+BOOL         ShowWindow(HWND,int);
+BOOL         ShowWindowAsync(HWND,int);
+int          StartPage(HDC);
+BOOL         StrokeAndFillPath(HDC);
+BOOL         StrokePath(HDC);
+BOOL         SwapBuffers(HDC);
+BOOL         UnrealizeObject(HGDIOBJ);
+BOOL         UpdateColors(HDC);
+BOOL         UpdateWindow(HWND);
+BOOL         WidenPath(HDC);
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/funcs-out.c modules/gdi/funcs-out.c
--- origmodules/gdi/funcs-out.c	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/funcs-out.c	2007-01-09 17:20:12.046875000 +0000
@@ -0,0 +1,3141 @@
+#line 1 "funcs.c"
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CHECKCOLORSINGAMUT, hdc pvoid pvoid0 dword)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  void* pvoid;
+  void* pvoid0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid0 = &(TheSbvector(arg)->data);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = CheckColorsInGamut(hdc,pvoid,pvoid0,dword);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:COMBINETRANSFORM, lpxform xform_p xform_p0)
+{
+  object arg0;
+  BOOL bool0;
+  XFORM lpxform;
+  XFORM xform_p;
+  XFORM xform_p0;
+  arg0 = popSTACK();
+  processXFORM(&xform_p0,arg0);
+  arg0 = popSTACK();
+  processXFORM(&xform_p,arg0);
+  arg0 = popSTACK();
+  begin_system_call();
+  bool0 = CombineTransform(&lpxform,&xform_p,&xform_p0);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    outputXFORM(&lpxform,arg0);
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEDIBSECTION, hdc bitmapinfo_p uint handle dword)
+{
+  object arg;
+  HBITMAP hbitmap;
+  HDC hdc;
+  BITMAPINFO* bitmapinfo_p = alloca(sizeof(BITMAPINFO));
+  UINT uint;
+  void *voidp;
+  HANDLE handle;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  handle = (nullp(arg))?0:(TheFpointer(arg)->fp_pointer);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  processBITMAPINFO(bitmapinfo_p,arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hbitmap = CreateDIBSection(hdc,bitmapinfo_p,uint,&voidp,handle,dword);
+  end_system_call();
+  if(NULL ==hbitmap){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hbitmap);
+    value3 = allocate_fpointer(voidp);
+    mv_count=3;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ENUMENHMETAFILE, hdc henhmetafile enhmfenumproc pvoid lpcrect)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HENHMETAFILE henhmetafile;
+  ENHMFENUMPROC enhmfenumproc;
+  void* pvoid;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  arg0 = popSTACK();
+  processENHMFENUMPROC(enhmfenumproc,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  henhmetafile = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processRECT(lpcrect,arg0);
+  begin_system_call();
+  bool0 = EnumEnhMetaFile(hdc,henhmetafile,enhmfenumproc,pvoid,lpcrect);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+/*
+DEFUN( GDI:ENUMFONTFAMILIESA, hdc lpcstr fontenumproca lparam)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  LPCSTR lpcstr;
+  FONTENUMPROCA fontenumproca;
+  ARAM* lparam = alloca(sizeof(ARAM));
+  object arg0;
+  arg = popSTACK();
+  check_sint(arg);
+  lparam = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processFONTENUMPROCA(fontenumproca,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    if(!fpointerp(arg))argumentum_inritum(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+    processARAM(lparam,arg0);
+    begin_system_call();
+    int0 = EnumFontFamiliesA(hdc,lpcstr,fontenumproca,lparam);
+    end_system_call();
+    if(0 <=int0){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = sint32_to_I(int0);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ENUMFONTFAMILIESEXA, hdc plogfonta fontenumproca lparam dword)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  PLOGFONTA plogfonta;
+  FONTENUMPROCA fontenumproca;
+  ARAM* lparam = alloca(sizeof(ARAM));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  check_sint(arg);
+  lparam = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processFONTENUMPROCA(fontenumproca,arg0);
+  arg0 = popSTACK();
+  processPLOGFONTA(plogfonta,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processARAM(lparam,arg0);
+  begin_system_call();
+  int0 = EnumFontFamiliesExA(hdc,plogfonta,fontenumproca,lparam,dword);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ENUMFONTFAMILIESEXW, hdc plogfontw fontenumprocw lparam dword)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  PLOGFONTW plogfontw;
+  FONTENUMPROCW fontenumprocw;
+  ARAM* lparam = alloca(sizeof(ARAM));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  check_sint(arg);
+  lparam = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processFONTENUMPROCW(fontenumprocw,arg0);
+  arg0 = popSTACK();
+  processPLOGFONTW(plogfontw,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processARAM(lparam,arg0);
+  begin_system_call();
+  int0 = EnumFontFamiliesExW(hdc,plogfontw,fontenumprocw,lparam,dword);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ENUMFONTFAMILIESW, hdc lpcwstr fontenumprocw lparam)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  FONTENUMPROCW fontenumprocw;
+  ARAM* lparam = alloca(sizeof(ARAM));
+  object arg0;
+  arg = popSTACK();
+  check_sint(arg);
+  lparam = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processFONTENUMPROCW(fontenumprocw,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processARAM(lparam,arg0);
+  begin_system_call();
+  int0 = EnumFontFamiliesW(hdc,lpcwstr,fontenumprocw,lparam);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ENUMFONTSA, hdc lpcstr fontenumproca lparam)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  LPCSTR lpcstr;
+  FONTENUMPROCA fontenumproca;
+  ARAM* lparam = alloca(sizeof(ARAM));
+  object arg0;
+  arg = popSTACK();
+  check_sint(arg);
+  lparam = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processFONTENUMPROCA(fontenumproca,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    if(!fpointerp(arg))argumentum_inritum(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+    processARAM(lparam,arg0);
+    begin_system_call();
+    int0 = EnumFontsA(hdc,lpcstr,fontenumproca,lparam);
+    end_system_call();
+    if(0 <=int0){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = sint32_to_I(int0);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ENUMFONTSW, hdc lpcwstr fontenumproca lparam)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  FONTENUMPROCA fontenumproca;
+  ARAM* lparam = alloca(sizeof(ARAM));
+  object arg0;
+  arg = popSTACK();
+  check_sint(arg);
+  lparam = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processFONTENUMPROCA(fontenumproca,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processARAM(lparam,arg0);
+  begin_system_call();
+  int0 = EnumFontsW(hdc,lpcwstr,fontenumproca,lparam);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ENUMICMPROFILESA, hdc icmenumproca lparam)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  ICMENUMPROCA icmenumproca;
+  ARAM* lparam = alloca(sizeof(ARAM));
+  object arg0;
+  arg = popSTACK();
+  check_sint(arg);
+  lparam = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processICMENUMPROCA(icmenumproca,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processARAM(lparam,arg0);
+  begin_system_call();
+  int0 = EnumICMProfilesA(hdc,icmenumproca,lparam);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ENUMICMPROFILESW, hdc icmenumprocw lparam)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  ICMENUMPROCW icmenumprocw;
+  ARAM* lparam = alloca(sizeof(ARAM));
+  object arg0;
+  arg = popSTACK();
+  check_sint(arg);
+  lparam = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processICMENUMPROCW(icmenumprocw,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processARAM(lparam,arg0);
+  begin_system_call();
+  int0 = EnumICMProfilesW(hdc,icmenumprocw,lparam);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ENUMMETAFILE, hdc hmetafile mfenumproc lparam)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HMETAFILE hmetafile;
+  MFENUMPROC mfenumproc;
+  ARAM* lparam = alloca(sizeof(ARAM));
+  object arg0;
+  arg = popSTACK();
+  check_sint(arg);
+  lparam = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processMFENUMPROC(mfenumproc,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hmetafile = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processARAM(lparam,arg0);
+  begin_system_call();
+  bool0 = EnumMetaFile(hdc,hmetafile,mfenumproc,lparam);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ENUMOBJECTS, hdc int0 gobjenumproc lparam)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  GOBJENUMPROC gobjenumproc;
+  ARAM* lparam = alloca(sizeof(ARAM));
+  object arg0;
+  arg = popSTACK();
+  check_sint(arg);
+  lparam = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processGOBJENUMPROC(gobjenumproc,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processARAM(lparam,arg0);
+  begin_system_call();
+  int1 = EnumObjects(hdc,int0,gobjenumproc,lparam);
+  end_system_call();
+  if(0 <=int1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int1);
+    mv_count=2;
+  }
+  return;
+}
+*/
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETASPECTRATIOFILTEREX, hdc lpsize)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  object arg0;
+  arg0 = popSTACK();
+  processSIZE(lpsize,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processSIZE(lpsize,arg0);
+  begin_system_call();
+  bool0 = GetAspectRatioFilterEx(hdc,lpsize);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETBITMAPBITS, hbitmap long0 pvoid)
+{
+  object arg;
+  LONG long1;
+  HBITMAP hbitmap;
+  LONG long0;
+  void* pvoid;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  arg = popSTACK();
+  check_sint(arg);
+  long0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hbitmap = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  long1 = GetBitmapBits(hbitmap,long0,pvoid);
+  end_system_call();
+  if(0 <=long1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(long1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETBITMAPDIMENSIONEX, hbitmap)
+{
+  object arg;
+  BOOL bool0;
+  HBITMAP hbitmap;
+  SIZE lpsize;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hbitmap = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = GetBitmapDimensionEx(hbitmap,&lpsize);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    pushSTACK( uint32_to_I(lpsize.cy));
+    value2 = uint32_to_I(lpsize.cx);
+    value3 = popSTACK();
+    value1 = T;
+    mv_count=3;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETBOUNDSRECT, hdc lprect uint)
+{
+  object arg;
+  UINT uint0;
+  HDC hdc;
+  RECT* lprect = alloca(sizeof(RECT));
+  object arg0;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processRECT(lprect,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processRECT(lprect,arg0);
+  begin_system_call();
+  uint0 = GetBoundsRect(hdc,lprect,uint);
+  end_system_call();
+  if(0 <=uint0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETBRUSHORGEX, hdc lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(lppoint,arg0);
+  begin_system_call();
+  bool0 = GetBrushOrgEx(hdc,lppoint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCHARABCWIDTHSA, hdc uint uint0 lpabc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  ABC* lpabc = alloca(sizeof(ABC));
+  object arg0;
+  arg0 = popSTACK();
+  processABC(lpabc,arg0);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processABC(lpabc,arg0);
+  begin_system_call();
+  bool0 = GetCharABCWidthsA(hdc,uint,uint0,lpabc);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCHARABCWIDTHSFLOATA, hdc uint uint0 lpabcfloat)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  ABCFLOAT* lpabcfloat = alloca(sizeof(ABCFLOAT));
+  object arg0;
+  arg0 = popSTACK();
+  processABCFLOAT(lpabcfloat,arg0);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processABCFLOAT(lpabcfloat,arg0);
+  begin_system_call();
+  bool0 = GetCharABCWidthsFloatA(hdc,uint,uint0,lpabcfloat);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCHARABCWIDTHSFLOATW, hdc uint uint0 lpabcfloat)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  ABCFLOAT* lpabcfloat = alloca(sizeof(ABCFLOAT));
+  object arg0;
+  arg0 = popSTACK();
+  processABCFLOAT(lpabcfloat,arg0);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processABCFLOAT(lpabcfloat,arg0);
+  begin_system_call();
+  bool0 = GetCharABCWidthsFloatW(hdc,uint,uint0,lpabcfloat);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCHARABCWIDTHSW, hdc uint uint0 lpabc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  ABC* lpabc = alloca(sizeof(ABC));
+  object arg0;
+  arg0 = popSTACK();
+  processABC(lpabc,arg0);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processABC(lpabc,arg0);
+  begin_system_call();
+  bool0 = GetCharABCWidthsW(hdc,uint,uint0,lpabc);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCHARWIDTH32A, hdc uint uint0 lpint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  int* lpint;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))argumentum_inritum(arg);
+  lpint = &(TheSbvector(arg)->data);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = GetCharWidth32A(hdc,uint,uint0,lpint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCHARWIDTH32W, hdc uint uint0 lpint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  int* lpint;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))argumentum_inritum(arg);
+  lpint = &(TheSbvector(arg)->data);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = GetCharWidth32W(hdc,uint,uint0,lpint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCHARWIDTHA, hdc uint uint0 lpint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  int* lpint;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))argumentum_inritum(arg);
+  lpint = &(TheSbvector(arg)->data);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = GetCharWidthA(hdc,uint,uint0,lpint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCHARWIDTHW, hdc uint uint0 lpint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  int* lpint;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))argumentum_inritum(arg);
+  lpint = &(TheSbvector(arg)->data);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = GetCharWidthW(hdc,uint,uint0,lpint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCLIENTRECT, hwnd lprect)
+{
+  object arg;
+  BOOL bool0;
+  HWND hwnd;
+  RECT* lprect = alloca(sizeof(RECT));
+  object arg0 = popSTACK();
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hwnd = TheFpointer(arg)->fp_pointer;
+  begin_call();
+  bool0 = GetClientRect(hwnd,lprect);
+  end_call();
+  if(!bool0){
+    DWORD e;
+    begin_call();
+    e = GetLastError();
+    end_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    outputRECT(arg0,lprect);
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCLIPBOX, hdc lprect)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  RECT* lprect = alloca(sizeof(RECT));
+  object arg0;
+  arg0 = popSTACK();
+  processRECT(lprect,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processRECT(lprect,arg0);
+  begin_system_call();
+  int0 = GetClipBox(hdc,lprect);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCOLORADJUSTMENT, hdc lpcoloradjustment)
+{
+  BOOL bool0;
+  HDC hdc;
+  COLORADJUSTMENT lpcoloradjustment;
+  object arg0 = popSTACK();
+  object arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = GetColorAdjustment(hdc,&lpcoloradjustment);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    outputCOLORADJUSTMENT(&lpcoloradjustment,arg0);
+    value2 = arg0;
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCURRENTPOSITIONEX, hdc lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(lppoint,arg0);
+  begin_system_call();
+  bool0 = GetCurrentPositionEx(hdc,lppoint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETDCORGEX, hdc lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(lppoint,arg0);
+  begin_system_call();
+  bool0 = GetDCOrgEx(hdc,lppoint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETDIBCOLORTABLE, hdc uint uint0 rgbquad_p)
+{
+  object arg;
+  UINT uint1;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  RGBQUAD* rgbquad_p = alloca(sizeof(RGBQUAD));
+  object arg0;
+  arg0 = popSTACK();
+  processRGBQUAD(rgbquad_p,arg0);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processRGBQUAD(rgbquad_p,arg0);
+  begin_system_call();
+  uint1 = GetDIBColorTable(hdc,uint,uint0,rgbquad_p);
+  end_system_call();
+  if(0 <=uint1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETDEVICEGAMMARAMP, hdc pvoid)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  void* pvoid;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = GetDeviceGammaRamp(hdc,pvoid);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETENHMETAFILEA, lpcstr)
+{
+  object arg;
+  HENHMETAFILE henhmetafile;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    henhmetafile = GetEnhMetaFileA(lpcstr);
+    end_system_call();
+    if(NULL ==henhmetafile){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = allocate_fpointer(henhmetafile);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETENHMETAFILEDESCRIPTIONA, henhmetafile uint lpstr)
+{
+  object arg;
+  UINT uint0;
+  HENHMETAFILE henhmetafile;
+  UINT uint;
+  LPSTR lpstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpstr, {
+    uint = I_to_uint32(check_uint(popSTACK()));
+    arg = popSTACK();
+    if(!fpointerp(arg))argumentum_inritum(arg);
+    henhmetafile = TheFpointer(arg)->fp_pointer;
+    begin_system_call();
+    uint0 = GetEnhMetaFileDescriptionA(henhmetafile,uint,lpstr);
+    end_system_call();
+    if(0 <=uint0){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = uint32_to_I(uint0);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETENHMETAFILEDESCRIPTIONW, henhmetafile uint lpwstr)
+{
+  object arg;
+  UINT uint0;
+  HENHMETAFILE henhmetafile;
+  UINT uint;
+  LPWSTR lpwstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpwstr = WIDECHAR(arg,encoding);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  henhmetafile = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  uint0 = GetEnhMetaFileDescriptionW(henhmetafile,uint,lpwstr);
+  end_system_call();
+  if(0 <=uint0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETENHMETAFILEHEADER, henhmetafile uint lpenhmetaheader)
+{
+  object arg;
+  UINT uint0;
+  HENHMETAFILE henhmetafile;
+  UINT uint;
+  ENHMETAHEADER* lpenhmetaheader = alloca(sizeof(ENHMETAHEADER));
+  object arg0;
+  arg0 = popSTACK();
+  processENHMETAHEADER(lpenhmetaheader,arg0);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  henhmetafile = TheFpointer(arg)->fp_pointer;
+  processENHMETAHEADER(lpenhmetaheader,arg0);
+  begin_system_call();
+  uint0 = GetEnhMetaFileHeader(henhmetafile,uint,lpenhmetaheader);
+  end_system_call();
+  if(0 <=uint0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETENHMETAFILEPALETTEENTRIES, henhmetafile uint lppaletteentry)
+{
+  object arg;
+  UINT uint0;
+  HENHMETAFILE henhmetafile;
+  UINT uint;
+  PALETTEENTRY* lppaletteentry = alloca(sizeof(PALETTEENTRY));
+  object arg0;
+  arg0 = popSTACK();
+  processPALETTEENTRY(lppaletteentry,arg0);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  henhmetafile = TheFpointer(arg)->fp_pointer;
+  processPALETTEENTRY(lppaletteentry,arg0);
+  begin_system_call();
+  uint0 = GetEnhMetaFilePaletteEntries(henhmetafile,uint,lppaletteentry);
+  end_system_call();
+  if(0 <=uint0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETENHMETAFILEPIXELFORMAT, henhmetafile dword pixelformatdescriptor_p)
+{
+  object arg;
+  UINT uint;
+  HENHMETAFILE henhmetafile;
+  DWORD dword;
+  PIXELFORMATDESCRIPTOR* pixelformatdescriptor_p = alloca(sizeof(PIXELFORMATDESCRIPTOR));
+  object arg0;
+  arg0 = popSTACK();
+  processPIXELFORMATDESCRIPTOR(pixelformatdescriptor_p,arg0);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  henhmetafile = TheFpointer(arg)->fp_pointer;
+  processPIXELFORMATDESCRIPTOR(pixelformatdescriptor_p,arg0);
+  begin_system_call();
+  uint = GetEnhMetaFilePixelFormat(henhmetafile,dword,pixelformatdescriptor_p);
+  end_system_call();
+  if(0 <=uint){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETENHMETAFILEW, lpcwstr)
+{
+  object arg;
+  HENHMETAFILE henhmetafile;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  henhmetafile = GetEnhMetaFileW(lpcwstr);
+  end_system_call();
+  if(NULL ==henhmetafile){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(henhmetafile);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETFONTDATA, hdc dword dword0 pvoid dword1)
+{
+  object arg;
+  DWORD dword2;
+  HDC hdc;
+  DWORD dword;
+  DWORD dword0;
+  void* pvoid;
+  DWORD dword1;
+  dword1 = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  dword0 = I_to_uint32(check_uint(popSTACK()));
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  dword2 = GetFontData(hdc,dword,dword0,pvoid,dword1);
+  end_system_call();
+  if(0 <=dword2){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(dword2);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETICMPROFILEA, hdc dword lpstr)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  DWORD dword;
+  LPSTR lpstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpstr, {
+    dword = I_to_uint32(check_uint(popSTACK()));
+    arg = popSTACK();
+    if(!fpointerp(arg))argumentum_inritum(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+    begin_system_call();
+    bool0 = GetICMProfileA(hdc,dword,lpstr);
+    end_system_call();
+    if(!bool0){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      mv_count=1;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETICMPROFILEW, hdc dword lpwstr)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  DWORD dword;
+  LPWSTR lpwstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpwstr = WIDECHAR(arg,encoding);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = GetICMProfileW(hdc,dword,lpwstr);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETKERNINGPAIRSA, hdc dword lpkerningpair)
+{
+  object arg;
+  DWORD dword0;
+  HDC hdc;
+  DWORD dword;
+  KERNINGPAIR* lpkerningpair = alloca(sizeof(KERNINGPAIR));
+  object arg0;
+  arg0 = popSTACK();
+  processKERNINGPAIR(lpkerningpair,arg0);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processKERNINGPAIR(lpkerningpair,arg0);
+  begin_system_call();
+  dword0 = GetKerningPairsA(hdc,dword,lpkerningpair);
+  end_system_call();
+  if(0 <=dword0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(dword0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETKERNINGPAIRSW, hdc dword lpkerningpair)
+{
+  object arg;
+  DWORD dword0;
+  HDC hdc;
+  DWORD dword;
+  KERNINGPAIR* lpkerningpair = alloca(sizeof(KERNINGPAIR));
+  object arg0;
+  arg0 = popSTACK();
+  processKERNINGPAIR(lpkerningpair,arg0);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processKERNINGPAIR(lpkerningpair,arg0);
+  begin_system_call();
+  dword0 = GetKerningPairsW(hdc,dword,lpkerningpair);
+  end_system_call();
+  if(0 <=dword0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(dword0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETLOGCOLORSPACEA, hcolorspace lplogcolorspacea dword)
+{
+  object arg;
+  BOOL bool0;
+  HCOLORSPACE hcolorspace;
+  LOGCOLORSPACEA* lplogcolorspacea = alloca(sizeof(LOGCOLORSPACEA));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processLOGCOLORSPACEA(lplogcolorspacea,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hcolorspace = TheFpointer(arg)->fp_pointer;
+  processLOGCOLORSPACEA(lplogcolorspacea,arg0);
+  begin_system_call();
+  bool0 = GetLogColorSpaceA(hcolorspace,lplogcolorspacea,dword);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETLOGCOLORSPACEW, hcolorspace lplogcolorspacew dword)
+{
+  object arg;
+  BOOL bool0;
+  HCOLORSPACE hcolorspace;
+  LOGCOLORSPACEW* lplogcolorspacew = alloca(sizeof(LOGCOLORSPACEW));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processLOGCOLORSPACEW(lplogcolorspacew,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hcolorspace = TheFpointer(arg)->fp_pointer;
+  processLOGCOLORSPACEW(lplogcolorspacew,arg0);
+  begin_system_call();
+  bool0 = GetLogColorSpaceW(hcolorspace,lplogcolorspacew,dword);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETMETAFILEA, lpcstr)
+{
+  object arg;
+  HMETAFILE hmetafile;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    hmetafile = GetMetaFileA(lpcstr);
+    end_system_call();
+    if(NULL ==hmetafile){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = allocate_fpointer(hmetafile);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETMETAFILEBITSEX, hmetafile uint pvoid)
+{
+  object arg;
+  UINT uint0;
+  HMETAFILE hmetafile;
+  UINT uint;
+  void* pvoid;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hmetafile = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  uint0 = GetMetaFileBitsEx(hmetafile,uint,pvoid);
+  end_system_call();
+  if(0 <=uint0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETMETAFILEW, lpcwstr)
+{
+  object arg;
+  HMETAFILE hmetafile;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  hmetafile = GetMetaFileW(lpcwstr);
+  end_system_call();
+  if(NULL ==hmetafile){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hmetafile);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETOBJECTA, hgdiobj int0 pvoid)
+{
+  object arg;
+  int int1;
+  HGDIOBJ hgdiobj;
+  int int0;
+  void* pvoid;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hgdiobj = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int1 = GetObjectA(hgdiobj,int0,pvoid);
+  end_system_call();
+  if(0 <=int1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETOBJECTW, hgdiobj int0 pvoid)
+{
+  object arg;
+  int int1;
+  HGDIOBJ hgdiobj;
+  int int0;
+  void* pvoid;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hgdiobj = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int1 = GetObjectW(hgdiobj,int0,pvoid);
+  end_system_call();
+  if(0 <=int1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETOUTLINETEXTMETRICSA, hdc uint lpoutlinetextmetrica)
+{
+  object arg;
+  UINT uint0;
+  HDC hdc;
+  UINT uint;
+  OUTLINETEXTMETRICA* lpoutlinetextmetrica = alloca(sizeof(OUTLINETEXTMETRICA));
+  object arg0;
+  arg0 = popSTACK();
+  processOUTLINETEXTMETRICA(lpoutlinetextmetrica,arg0);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processOUTLINETEXTMETRICA(lpoutlinetextmetrica,arg0);
+  begin_system_call();
+  uint0 = GetOutlineTextMetricsA(hdc,uint,lpoutlinetextmetrica);
+  end_system_call();
+  if(0 <=uint0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETOUTLINETEXTMETRICSW, hdc uint lpoutlinetextmetricw)
+{
+  object arg;
+  UINT uint0;
+  HDC hdc;
+  UINT uint;
+  OUTLINETEXTMETRICW* lpoutlinetextmetricw = alloca(sizeof(OUTLINETEXTMETRICW));
+  object arg0;
+  arg0 = popSTACK();
+  processOUTLINETEXTMETRICW(lpoutlinetextmetricw,arg0);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processOUTLINETEXTMETRICW(lpoutlinetextmetricw,arg0);
+  begin_system_call();
+  uint0 = GetOutlineTextMetricsW(hdc,uint,lpoutlinetextmetricw);
+  end_system_call();
+  if(0 <=uint0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETPALETTEENTRIES, hpalette uint uint0 lppaletteentry)
+{
+  object arg;
+  UINT uint1;
+  HPALETTE hpalette;
+  UINT uint;
+  UINT uint0;
+  PALETTEENTRY* lppaletteentry = alloca(sizeof(PALETTEENTRY));
+  object arg0;
+  arg0 = popSTACK();
+  processPALETTEENTRY(lppaletteentry,arg0);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hpalette = TheFpointer(arg)->fp_pointer;
+  processPALETTEENTRY(lppaletteentry,arg0);
+  begin_system_call();
+  uint1 = GetPaletteEntries(hpalette,uint,uint0,lppaletteentry);
+  end_system_call();
+  if(0 <=uint1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETPATH, hdc lppoint pbyte int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  PBYTE pbyte;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processPBYTE(pbyte,arg0);
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(lppoint,arg0);
+  begin_system_call();
+  int1 = GetPath(hdc,lppoint,pbyte,int0);
+  end_system_call();
+  if(0 <=int1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETRASTERIZERCAPS, lprasterizer_status uint)
+{
+  object arg;
+  BOOL bool0;
+  RASTERIZER_STATUS* lprasterizer_status = alloca(sizeof(RASTERIZER_STATUS));
+  object arg0;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processRASTERIZER_STATUS(lprasterizer_status,arg0);
+  processRASTERIZER_STATUS(lprasterizer_status,arg0);
+  begin_system_call();
+  bool0 = GetRasterizerCaps(lprasterizer_status,uint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETREGIONDATA, hrgn dword lprgndata)
+{
+  object arg;
+  DWORD dword0;
+  HRGN hrgn;
+  DWORD dword;
+  RGNDATA* lprgndata = alloca(sizeof(RGNDATA));
+  object arg0;
+  arg0 = popSTACK();
+  processRGNDATA(lprgndata,arg0);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  processRGNDATA(lprgndata,arg0);
+  begin_system_call();
+  dword0 = GetRegionData(hrgn,dword,lprgndata);
+  end_system_call();
+  if(0 <=dword0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(dword0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETRGNBOX, hrgn lprect)
+{
+  object arg;
+  int int0;
+  HRGN hrgn;
+  RECT* lprect = alloca(sizeof(RECT));
+  object arg0;
+  arg0 = popSTACK();
+  processRECT(lprect,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  processRECT(lprect,arg0);
+  begin_system_call();
+  int0 = GetRgnBox(hrgn,lprect);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETSYSTEMPALETTEENTRIES, hdc uint uint0 lppaletteentry)
+{
+  object arg;
+  UINT uint1;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  PALETTEENTRY* lppaletteentry = alloca(sizeof(PALETTEENTRY));
+  object arg0;
+  arg0 = popSTACK();
+  processPALETTEENTRY(lppaletteentry,arg0);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPALETTEENTRY(lppaletteentry,arg0);
+  begin_system_call();
+  uint1 = GetSystemPaletteEntries(hdc,uint,uint0,lppaletteentry);
+  end_system_call();
+  if(0 <=uint1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETTEXTCHARSETINFO, hdc lpfontsignature dword)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  FONTSIGNATURE* lpfontsignature = alloca(sizeof(FONTSIGNATURE));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processFONTSIGNATURE(lpfontsignature,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processFONTSIGNATURE(lpfontsignature,arg0);
+  begin_system_call();
+  int0 = GetTextCharsetInfo(hdc,lpfontsignature,dword);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETTEXTEXTENTPOINT32A, hdc lpcstr int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  LPCSTR lpcstr;
+  int int0;
+  SIZE lpsize;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg); // fixme remove this argument, and get string length
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    if(!fpointerp(arg))argumentum_inritum(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+    begin_system_call();
+    bool0 = GetTextExtentPoint32A(hdc,lpcstr,int0,&lpsize);
+    end_system_call();
+    if(!bool0){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      pushSTACK( uint32_to_I(lpsize.cy));
+      value2 = uint32_to_I(lpsize.cx);
+      value3 = popSTACK();
+      value1 = T;
+      mv_count=3;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETTEXTEXTENTPOINT32W, hdc lpcwstr int0 lpsize)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  int int0;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  object arg0;
+  arg0 = popSTACK();
+  processSIZE(lpsize,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processSIZE(lpsize,arg0);
+  begin_system_call();
+  bool0 = GetTextExtentPoint32W(hdc,lpcwstr,int0,lpsize);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETTEXTEXTENTPOINTA, hdc lpcstr int0 lpsize)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  LPCSTR lpcstr;
+  int int0;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  object arg0;
+  arg0 = popSTACK();
+  processSIZE(lpsize,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processSIZE(lpsize,arg0);
+  begin_system_call();
+  bool0 = GetTextExtentPointA(hdc,lpcstr,int0,lpsize);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETTEXTEXTENTPOINTW, hdc lpcwstr int0 lpsize)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  int int0;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  object arg0;
+  arg0 = popSTACK();
+  processSIZE(lpsize,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processSIZE(lpsize,arg0);
+  begin_system_call();
+  bool0 = GetTextExtentPointW(hdc,lpcwstr,int0,lpsize);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETTEXTFACEA, hdc int0 lpstr)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  LPSTR lpstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpstr, {
+    arg = popSTACK();
+    check_sint(arg);
+    int0 = I_to_sint32(arg);
+    arg = popSTACK();
+    if(!fpointerp(arg))argumentum_inritum(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+    begin_system_call();
+    int1 = GetTextFaceA(hdc,int0,lpstr);
+    end_system_call();
+    if(0 <=int1){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = sint32_to_I(int1);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETTEXTFACEW, hdc int0 lpwstr)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  LPWSTR lpwstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpwstr = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int1 = GetTextFaceW(hdc,int0,lpwstr);
+  end_system_call();
+  if(0 <=int1){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETTEXTMETRICSA, hdc lptextmetrica)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  TEXTMETRICA lptextmetrica;
+  object arg0 = popSTACK();
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = GetTextMetricsA(hdc,&lptextmetrica);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    outputTEXTMETRICA(&lptextmetrica,arg0);
+    value2 = arg0;
+    value1 = T;
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETTEXTMETRICSW, hdc lptextmetricw)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  TEXTMETRICW* lptextmetricw = alloca(sizeof(TEXTMETRICW));
+  object arg0;
+  arg0 = popSTACK();
+  processTEXTMETRICW(lptextmetricw,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processTEXTMETRICW(lptextmetricw,arg0);
+  begin_system_call();
+  bool0 = GetTextMetricsW(hdc,lptextmetricw);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETVIEWPORTEXTEX, hdc lpsize)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  object arg0;
+  arg0 = popSTACK();
+  processSIZE(lpsize,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processSIZE(lpsize,arg0);
+  begin_system_call();
+  bool0 = GetViewportExtEx(hdc,lpsize);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETVIEWPORTORGEX, hdc lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(lppoint,arg0);
+  begin_system_call();
+  bool0 = GetViewportOrgEx(hdc,lppoint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETWINMETAFILEBITS, henhmetafile uint lpbyte int0 hdc)
+{
+  object arg;
+  UINT uint0;
+  HENHMETAFILE henhmetafile;
+  UINT uint;
+  BYTE* lpbyte = alloca(sizeof(BYTE));
+  object arg0;
+  INT int0;
+  HDC hdc;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg0 = popSTACK();
+  processBYTE(lpbyte,arg0);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  henhmetafile = TheFpointer(arg)->fp_pointer;
+  processBYTE(lpbyte,arg0);
+  begin_system_call();
+  uint0 = GetWinMetaFileBits(henhmetafile,uint,lpbyte,int0,hdc);
+  end_system_call();
+  if(0 <=uint0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETWINDOWEXTEX, hdc lpsize)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  object arg0;
+  arg0 = popSTACK();
+  processSIZE(lpsize,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processSIZE(lpsize,arg0);
+  begin_system_call();
+  bool0 = GetWindowExtEx(hdc,lpsize);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETWINDOWORGEX, hdc lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processPOINT(lppoint,arg0);
+  begin_system_call();
+  bool0 = GetWindowOrgEx(hdc,lppoint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETWORLDTRANSFORM, hdc lpxform)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  XFORM* lpxform = alloca(sizeof(XFORM));
+  object arg0;
+  arg0 = popSTACK();
+  processXFORM(lpxform,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processXFORM(lpxform,arg0);
+  begin_system_call();
+  bool0 = GetWorldTransform(hdc,lpxform);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ESCAPE, hdc int0 int1 lpcstr pvoid)
+{
+  object arg;
+  int int2;
+  HDC hdc;
+  int int0;
+  int int1;
+  LPCSTR lpcstr;
+  void* pvoid;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    check_sint(arg);
+    int1 = I_to_sint32(arg);
+    arg = popSTACK();
+    check_sint(arg);
+    int0 = I_to_sint32(arg);
+    arg = popSTACK();
+    if(!fpointerp(arg))argumentum_inritum(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+    begin_system_call();
+    int2 = Escape(hdc,int0,int1,lpcstr,pvoid);
+    end_system_call();
+    if(0 <=int2){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = sint32_to_I(int2);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+/*
+DEFUN( GDI:SETABORTPROC, hdc abortproc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  ABORTPROC abortproc;
+  arg0 = popSTACK();
+  processABORTPROC(abortproc,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = SetAbortProc(hdc,abortproc);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+*/
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCHARWIDTHFLOATA, hdc uint uint0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  UINT length;
+  FLOAT* pfloat;
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  length = uint0 - uint + 1;
+  pfloat = alloca(sizeof(FLOAT)*length);
+  begin_system_call();
+  bool0 = GetCharWidthFloatA(hdc,uint,uint0,pfloat);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value2 = outputFLOATS(pfloat,length);
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCHARWIDTHFLOATW, hdc uint uint0 pfloat)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  FLOAT* pfloat;
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  pfloat = alloca(sizeof(FLOAT)*(uint0 - uint + 1));
+  begin_system_call();
+  bool0 = GetCharWidthFloatW(hdc,uint,uint0,pfloat);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value2 = outputFLOATS(pfloat,0);
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETMITERLIMIT, hdc pfloat)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  FLOAT pfloat;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = GetMiterLimit(hdc,&pfloat);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value2 = allocate_ffloat(pfloat);
+    value1 = T;
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETMITERLIMIT, hdc float0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  FLOAT float0;
+  FLOAT pfloat;
+  ffloatjanus jfloat0;
+  FF_to_c_float(check_ffloat(popSTACK()),&jfloat0);
+  float0 = (float)(jfloat0.eksplicit);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = SetMiterLimit(hdc,float0,&pfloat);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value2 = allocate_ffloat(pfloat);
+    value1 = T;
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:LINEDDA, lppoint lppoint0 lineddaproc lparam)
+{
+  object arg;
+  BOOL bool0;
+  POINT lppoint;
+  POINT lppoint0;
+  LINEDDAPROC lineddaproc;
+  void* lparam;
+  arg = popSTACK();
+  check_sint(arg);
+  lparam = I_to_sint32(arg);
+  arg = popSTACK();
+  processLINEDDAPROC(lineddaproc,arg);
+  arg = popSTACK();
+  processPOINT(&lppoint0,arg);
+  arg = popSTACK();
+  processPOINT(&lppoint,arg);
+  begin_system_call();
+  bool0 = LineDDA(lppoint.x,lppoint.y,lppoint0.x,lppoint0.y,lineddaproc,lparam);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// Not implemented in Windows NT
+/*
+DEFUN( GDI:TRANSLATECHARSETINFO, dword_p lpcharsetinfo dword)
+{
+  object arg;
+  BOOL bool0;
+  DWORD* dword_p;
+  HARSETINFO* lpcharsetinfo = alloca(sizeof(CHARSETINFO));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processCHARSETINFO(lpcharsetinfo,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))argumentum_inritum(arg);
+  dword_p = &(TheSbvector(arg)->data);
+  processHARSETINFO(lpcharsetinfo,arg0);
+  begin_system_call();
+  bool0 = TranslateCharsetInfo(dword_p,lpcharsetinfo,dword);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+*/
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/funcs-out.h modules/gdi/funcs-out.h
--- origmodules/gdi/funcs-out.h	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/funcs-out.h	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1,84 @@
+BOOL         CheckColorsInGamut(HDC,PVOID,PVOID,DWORD);
+BOOL         CombineTransform(LPXFORM, XFORM_P, XFORM_P);
+HBITMAP      CreateDIBSection(HDC, BITMAPINFO_P,UINT,HANDLE,DWORD);
+BOOL         EnumEnhMetaFile(HDC,HENHMETAFILE,ENHMFENUMPROC,PVOID,LPCRECT);
+int          EnumFontFamiliesA(HDC,LPCSTR,FONTENUMPROCA,LPARAM);
+int          EnumFontFamiliesExA(HDC,PLOGFONTA,FONTENUMPROCA,LPARAM,DWORD);
+int          EnumFontFamiliesExW(HDC,PLOGFONTW,FONTENUMPROCW,LPARAM,DWORD);
+int          EnumFontFamiliesW(HDC,LPCWSTR,FONTENUMPROCW,LPARAM);
+int          EnumFontsA(HDC,LPCSTR,FONTENUMPROCA,LPARAM);
+int          EnumFontsW(HDC,LPCWSTR,FONTENUMPROCA,LPARAM);
+int          EnumICMProfilesA(HDC,ICMENUMPROCA,LPARAM);
+int          EnumICMProfilesW(HDC,ICMENUMPROCW,LPARAM);
+BOOL         EnumMetaFile(HDC,HMETAFILE,MFENUMPROC,LPARAM);
+int          EnumObjects(HDC,int,GOBJENUMPROC,LPARAM);
+BOOL         GetAspectRatioFilterEx(HDC,LPSIZE);
+LONG         GetBitmapBits(HBITMAP,LONG,PVOID);
+BOOL         GetBitmapDimensionEx(HBITMAP,LPSIZE);
+UINT         GetBoundsRect(HDC,LPRECT,UINT);
+BOOL         GetBrushOrgEx(HDC,LPPOINT);
+BOOL         GetCharABCWidthsA(HDC,UINT,UINT,LPABC);
+BOOL         GetCharABCWidthsFloatA(HDC,UINT,UINT,LPABCFLOAT);
+BOOL         GetCharABCWidthsFloatW(HDC,UINT,UINT,LPABCFLOAT);
+BOOL         GetCharABCWidthsW(HDC,UINT,UINT,LPABC);
+BOOL         GetCharWidth32A(HDC,UINT,UINT,LPINT);
+BOOL         GetCharWidth32W(HDC,UINT,UINT,LPINT);
+BOOL         GetCharWidthA(HDC,UINT,UINT,LPINT);
+BOOL         GetCharWidthW(HDC,UINT,UINT,LPINT);
+BOOL         GetClientRect(HWND,LPRECT);
+int          GetClipBox(HDC,LPRECT);
+BOOL         GetColorAdjustment(HDC,LPCOLORADJUSTMENT);
+BOOL         GetCurrentPositionEx(HDC,LPPOINT);
+BOOL         GetDCOrgEx(HDC,LPPOINT);
+UINT         GetDIBColorTable(HDC,UINT,UINT,RGBQUAD_P);
+BOOL         GetDeviceGammaRamp(HDC,PVOID);
+HENHMETAFILE GetEnhMetaFileA(LPCSTR);
+UINT         GetEnhMetaFileDescriptionA(HENHMETAFILE,UINT,LPSTR);
+UINT         GetEnhMetaFileDescriptionW(HENHMETAFILE,UINT,LPWSTR);
+UINT         GetEnhMetaFileHeader(HENHMETAFILE,UINT,LPENHMETAHEADER);
+UINT         GetEnhMetaFilePaletteEntries(HENHMETAFILE,UINT,LPPALETTEENTRY);
+UINT         GetEnhMetaFilePixelFormat(HENHMETAFILE,DWORD,PIXELFORMATDESCRIPTOR_P);
+HENHMETAFILE GetEnhMetaFileW(LPCWSTR);
+DWORD        GetFontData(HDC,DWORD,DWORD,PVOID,DWORD);
+BOOL         GetICMProfileA(HDC,DWORD,LPSTR);
+BOOL         GetICMProfileW(HDC,DWORD,LPWSTR);
+DWORD        GetKerningPairsA(HDC,DWORD,LPKERNINGPAIR);
+DWORD        GetKerningPairsW(HDC,DWORD,LPKERNINGPAIR);
+BOOL         GetLogColorSpaceA(HCOLORSPACE,LPLOGCOLORSPACEA,DWORD);
+BOOL         GetLogColorSpaceW(HCOLORSPACE,LPLOGCOLORSPACEW,DWORD);
+HMETAFILE    GetMetaFileA(LPCSTR);
+UINT         GetMetaFileBitsEx(HMETAFILE,UINT,PVOID);
+HMETAFILE    GetMetaFileW(LPCWSTR);
+int          GetObjectA(HGDIOBJ,int,PVOID);
+int          GetObjectW(HGDIOBJ,int,PVOID);
+UINT         GetOutlineTextMetricsA(HDC,UINT,LPOUTLINETEXTMETRICA);
+UINT         GetOutlineTextMetricsW(HDC,UINT,LPOUTLINETEXTMETRICW);
+UINT         GetPaletteEntries(HPALETTE,UINT,UINT,LPPALETTEENTRY);
+int          GetPath(HDC,LPPOINT,PBYTE,int);
+BOOL         GetRasterizerCaps(LPRASTERIZER_STATUS,UINT);
+DWORD        GetRegionData(HRGN,DWORD,LPRGNDATA);
+int          GetRgnBox(HRGN,LPRECT);
+UINT         GetSystemPaletteEntries(HDC,UINT,UINT,LPPALETTEENTRY);
+int          GetTextCharsetInfo(HDC,LPFONTSIGNATURE,DWORD);
+BOOL         GetTextExtentPoint32A(HDC,LPCSTR,int,LPSIZE);
+BOOL         GetTextExtentPoint32W( HDC,LPCWSTR,int,LPSIZE);
+BOOL         GetTextExtentPointA(HDC,LPCSTR,int,LPSIZE);
+BOOL         GetTextExtentPointW(HDC,LPCWSTR,int,LPSIZE);
+int          GetTextFaceA(HDC,int,LPSTR);
+int          GetTextFaceW(HDC,int,LPWSTR);
+BOOL         GetTextMetricsA(HDC,LPTEXTMETRICA);
+BOOL         GetTextMetricsW(HDC,LPTEXTMETRICW);
+BOOL         GetViewportExtEx(HDC,LPSIZE);
+BOOL         GetViewportOrgEx(HDC,LPPOINT);
+UINT         GetWinMetaFileBits(HENHMETAFILE,UINT,LPBYTE,INT,HDC);
+BOOL         GetWindowExtEx(HDC,LPSIZE);
+BOOL         GetWindowOrgEx(HDC,LPPOINT);
+BOOL         GetWorldTransform(HDC,LPXFORM);
+int          Escape(HDC,int,int,LPCSTR,PVOID);
+int          SetAbortProc(HDC,ABORTPROC);
+BOOL         GetCharWidthFloatA(HDC,UINT,UINT,PFLOAT);
+BOOL         GetCharWidthFloatW(HDC,UINT,UINT,PFLOAT);
+BOOL         GetMiterLimit(HDC,PFLOAT);
+BOOL         SetMiterLimit(HDC,FLOAT,PFLOAT);
+BOOL         LineDDA(LPPOINT,LPPOINT,LINEDDAPROC,LPARAM);
+BOOL         TranslateCharsetInfo(DWORD_P,LPCHARSETINFO,DWORD);
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/funcs-prob.c modules/gdi/funcs-prob.c
--- origmodules/gdi/funcs-prob.c	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/funcs-prob.c	2007-01-09 17:20:12.078125000 +0000
@@ -0,0 +1,1725 @@
+#line 1 "funcs.c"
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ADDFONTRESOURCEA, lpcstr)
+{
+  object arg;
+  int int0;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    int0 = AddFontResourceA(lpcstr);
+    end_system_call();
+    if(0 <=int0){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = sint32_to_I(int0);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ADDFONTRESOURCEW, lpcwstr)
+{
+  object arg;
+  int int0;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  int0 = AddFontResourceW(lpcwstr);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:COPYENHMETAFILEA, henhmetafile lpcstr)
+{
+  object arg;
+  HENHMETAFILE henhmetafile0;
+  HENHMETAFILE henhmetafile;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    if(!fpointerp(arg))argumentum_inritum(arg);
+    henhmetafile = TheFpointer(arg)->fp_pointer;
+    begin_system_call();
+    henhmetafile0 = CopyEnhMetaFileA(henhmetafile,lpcstr);
+    end_system_call();
+    if(NULL ==henhmetafile0){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = allocate_fpointer(henhmetafile0);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:COPYENHMETAFILEW, henhmetafile lpcwstr)
+{
+  object arg;
+  HENHMETAFILE henhmetafile0;
+  HENHMETAFILE henhmetafile;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = 0; //WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  henhmetafile = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  henhmetafile0 = CopyEnhMetaFileW(henhmetafile,lpcwstr);
+  end_system_call();
+  if(NULL ==henhmetafile0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(henhmetafile0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:COPYMETAFILEA, hmetafile lpcstr)
+{
+  object arg;
+  HMETAFILE hmetafile0;
+  HMETAFILE hmetafile;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    if(!fpointerp(arg))argumentum_inritum(arg);
+    hmetafile = TheFpointer(arg)->fp_pointer;
+    begin_system_call();
+    hmetafile0 = CopyMetaFileA(hmetafile,lpcstr);
+    end_system_call();
+    if(NULL ==hmetafile0){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = allocate_fpointer(hmetafile0);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:COPYMETAFILEW, hmetafile lpcwstr)
+{
+  object arg;
+  HMETAFILE hmetafile0;
+  HMETAFILE hmetafile;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hmetafile = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hmetafile0 = CopyMetaFileW(hmetafile,lpcwstr);
+  end_system_call();
+  if(NULL ==hmetafile0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hmetafile0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEBITMAPINDIRECT, bitmap_p)
+{
+  object arg;
+  HBITMAP hbitmap;
+  BITMAP* bitmap_p = alloca(sizeof(BITMAP));
+  object arg0;
+  arg0 = popSTACK();
+  processBITMAP(bitmap_p,arg0);
+  begin_system_call();
+  hbitmap = CreateBitmapIndirect(bitmap_p);
+  end_system_call();
+  if(NULL ==hbitmap){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hbitmap);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEBRUSHINDIRECT, logbrush_p)
+{
+  object arg;
+  HBRUSH hbrush;
+  LOGBRUSH* logbrush_p = alloca(sizeof(LOGBRUSH));
+  object arg0;
+  arg0 = popSTACK();
+  processLOGBRUSH(logbrush_p,arg0);
+  begin_system_call();
+  hbrush = CreateBrushIndirect(logbrush_p);
+  end_system_call();
+  if(NULL ==hbrush){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hbrush);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATECOLORSPACEA, lplogcolorspacea)
+{
+  object arg;
+  HCOLORSPACE hcolorspace;
+  LOGCOLORSPACEA* lplogcolorspacea = alloca(sizeof(LOGCOLORSPACEA));
+  object arg0;
+  arg0 = popSTACK();
+  processLOGCOLORSPACEA(lplogcolorspacea,arg0);
+  begin_system_call();
+  hcolorspace = CreateColorSpaceA(lplogcolorspacea);
+  end_system_call();
+  if(NULL ==hcolorspace){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hcolorspace);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATECOLORSPACEW, lplogcolorspacew)
+{
+  object arg;
+  HCOLORSPACE hcolorspace;
+  LOGCOLORSPACEW* lplogcolorspacew = alloca(sizeof(LOGCOLORSPACEW));
+  object arg0;
+  arg0 = popSTACK();
+  processLOGCOLORSPACEW(lplogcolorspacew,arg0);
+  begin_system_call();
+  hcolorspace = CreateColorSpaceW(lplogcolorspacew);
+  end_system_call();
+  if(NULL ==hcolorspace){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hcolorspace);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEDCA, lpcstr lpcstr0 lpcstr1 devmodea_p)
+{
+  object arg;
+  HDC hdc;
+  LPCSTR lpcstr;
+  LPCSTR lpcstr0;
+  LPCSTR lpcstr1;
+  DEVMODEA* devmodea_p = alloca(sizeof(DEVMODEA));
+  object arg0;
+  arg0 = popSTACK();
+  processDEVMODEA(devmodea_p,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr1, {
+    arg = popSTACK();
+    if(!stringp(arg))argumentum_inritum(arg);
+    with_string_0(arg,encoding, lpcstr0, {
+      arg = popSTACK();
+      if(!stringp(arg))argumentum_inritum(arg);
+      with_string_0(arg,encoding, lpcstr, {
+        processDEVMODEA(devmodea_p,arg0);
+        begin_system_call();
+        hdc = CreateDCA(lpcstr,lpcstr0,lpcstr1,devmodea_p);
+        end_system_call();
+        if(NULL ==hdc){
+          DWORD e;
+          begin_system_call();
+          e = GetLastError();
+          end_system_call();
+          value1 = NIL;
+          value2 = uint32_to_I(e);
+          mv_count=2;
+        }
+        else
+        {
+          value1 = T;
+          value2 = allocate_fpointer(hdc);
+          mv_count=2;
+        }
+      });
+    });
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEDCW, lpcwstr lpcwstr0 lpcwstr1 devmodew_p)
+{
+  object arg;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  LPCWSTR lpcwstr0;
+  LPCWSTR lpcwstr1;
+  DEVMODEW* devmodew_p = alloca(sizeof(DEVMODEW));
+  object arg0;
+  arg0 = popSTACK();
+  processDEVMODEW(devmodew_p,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr1 = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr0 = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  processDEVMODEW(devmodew_p,arg0);
+  begin_system_call();
+  hdc = CreateDCW(lpcwstr,lpcwstr0,lpcwstr1,devmodew_p);
+  end_system_call();
+  if(NULL ==hdc){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hdc);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEELLIPTICRGNINDIRECT, lpcrect)
+{
+  object arg;
+  HRGN hrgn;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  begin_system_call();
+  hrgn = CreateEllipticRgnIndirect(lpcrect);
+  end_system_call();
+  if(NULL ==hrgn){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hrgn);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEENHMETAFILEA, hdc lpcstr lpcrect lpcstr0)
+{
+  object arg;
+  HDC hdc0;
+  HDC hdc;
+  LPCSTR lpcstr;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  LPCSTR lpcstr0;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr0, {
+    arg0 = popSTACK();
+    processRECT(lpcrect,arg0);
+    arg = popSTACK();
+    if(!stringp(arg))argumentum_inritum(arg);
+    with_string_0(arg,encoding, lpcstr, {
+      arg = popSTACK();
+      if(!fpointerp(arg))argumentum_inritum(arg);
+      hdc = TheFpointer(arg)->fp_pointer;
+      processRECT(lpcrect,arg0);
+      begin_system_call();
+      hdc0 = CreateEnhMetaFileA(hdc,lpcstr,lpcrect,lpcstr0);
+      end_system_call();
+      if(NULL ==hdc0){
+        DWORD e;
+        begin_system_call();
+        e = GetLastError();
+        end_system_call();
+        value1 = NIL;
+        value2 = uint32_to_I(e);
+        mv_count=2;
+      }
+      else
+      {
+        value1 = T;
+        value2 = allocate_fpointer(hdc0);
+        mv_count=2;
+      }
+    });
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEENHMETAFILEW, hdc lpcwstr lpcrect lpcwstr0)
+{
+  object arg;
+  HDC hdc0;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  LPCWSTR lpcwstr0;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr0 = WIDECHAR(arg,encoding);
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processRECT(lpcrect,arg0);
+  begin_system_call();
+  hdc0 = CreateEnhMetaFileW(hdc,lpcwstr,lpcrect,lpcwstr0);
+  end_system_call();
+  if(NULL ==hdc0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hdc0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEFONTINDIRECTA, logfonta_p)
+{
+  object arg;
+  HFONT hfont;
+  LOGFONTA* logfonta_p = alloca(sizeof(LOGFONTA));
+  object arg0;
+  arg0 = popSTACK();
+  processLOGFONTA(logfonta_p,arg0);
+  begin_system_call();
+  hfont = CreateFontIndirectA(logfonta_p);
+  end_system_call();
+  if(NULL ==hfont){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hfont);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEFONTINDIRECTW, logfontw_p)
+{
+  object arg;
+  HFONT hfont;
+  LOGFONTW* logfontw_p = alloca(sizeof(LOGFONTW));
+  object arg0;
+  arg0 = popSTACK();
+  processLOGFONTW(logfontw_p,arg0);
+  begin_system_call();
+  hfont = CreateFontIndirectW(logfontw_p);
+  end_system_call();
+  if(NULL ==hfont){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hfont);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEICA, lpcstr lpcstr0 lpcstr1 devmodea_p)
+{
+  object arg;
+  HDC hdc;
+  LPCSTR lpcstr;
+  LPCSTR lpcstr0;
+  LPCSTR lpcstr1;
+  DEVMODEA* devmodea_p = alloca(sizeof(DEVMODEA));
+  object arg0;
+  arg0 = popSTACK();
+  processDEVMODEA(devmodea_p,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr1, {
+    arg = popSTACK();
+    if(!stringp(arg))argumentum_inritum(arg);
+    with_string_0(arg,encoding, lpcstr0, {
+      arg = popSTACK();
+      if(!stringp(arg))argumentum_inritum(arg);
+      with_string_0(arg,encoding, lpcstr, {
+        processDEVMODEA(devmodea_p,arg0);
+        begin_system_call();
+        hdc = CreateICA(lpcstr,lpcstr0,lpcstr1,devmodea_p);
+        end_system_call();
+        if(NULL ==hdc){
+          DWORD e;
+          begin_system_call();
+          e = GetLastError();
+          end_system_call();
+          value1 = NIL;
+          value2 = uint32_to_I(e);
+          mv_count=2;
+        }
+        else
+        {
+          value1 = T;
+          value2 = allocate_fpointer(hdc);
+          mv_count=2;
+        }
+      });
+    });
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEICW, lpcwstr lpcwstr0 lpcwstr1 devmodew_p)
+{
+  object arg;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  LPCWSTR lpcwstr0;
+  LPCWSTR lpcwstr1;
+  DEVMODEW* devmodew_p = alloca(sizeof(DEVMODEW));
+  object arg0;
+  arg0 = popSTACK();
+  processDEVMODEW(devmodew_p,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr1 = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr0 = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  processDEVMODEW(devmodew_p,arg0);
+  begin_system_call();
+  hdc = CreateICW(lpcwstr,lpcwstr0,lpcwstr1,devmodew_p);
+  end_system_call();
+  if(NULL ==hdc){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hdc);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEICONFROMRESOURCE, pbyte dword bool0 dword0)
+{
+  object arg;
+  object arg0;
+  HICON hicon;
+  PBYTE pbyte;
+  DWORD dword;
+  BOOL bool0;
+  DWORD dword0;
+  dword0 = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processBOOL(bool0,arg0);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processPBYTE(pbyte,arg0);
+  begin_system_call();
+  hicon = CreateIconFromResource(pbyte,dword,bool0,dword0);
+  end_system_call();
+  if(NULL ==hicon){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hicon);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEICONINDIRECT, piconinfo)
+{
+  object arg;
+  HICON hicon;
+  ICONINFO iconinfo;
+  arg = popSTACK();
+  processICONINFO(&iconinfo,arg);
+  begin_system_call();
+  hicon = CreateIconIndirect(&iconinfo);
+  end_system_call();
+  if(NULL ==hicon){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hicon);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEMETAFILEA, lpcstr)
+{
+  object arg;
+  HDC hdc;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    hdc = CreateMetaFileA(lpcstr);
+    end_system_call();
+    if(NULL ==hdc){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = allocate_fpointer(hdc);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEMETAFILEW, lpcwstr)
+{
+  object arg;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  hdc = CreateMetaFileW(lpcwstr);
+  end_system_call();
+  if(NULL ==hdc){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hdc);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEPALETTE, logpalette_p)
+{
+  object arg;
+  HPALETTE hpalette;
+  LOGPALETTE* logpalette_p = alloca(sizeof(LOGPALETTE));
+  object arg0;
+  arg0 = popSTACK();
+  processLOGPALETTE(logpalette_p,arg0);
+  processLOGPALETTE(logpalette_p,arg0);
+  begin_system_call();
+  hpalette = CreatePalette(logpalette_p);
+  end_system_call();
+  if(NULL ==hpalette){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hpalette);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEPENINDIRECT, logpen_p)
+{
+  object arg;
+  HPEN hpen;
+  LOGPEN* logpen_p = alloca(sizeof(LOGPEN));
+  object arg0;
+  arg0 = popSTACK();
+  processLOGPEN(logpen_p,arg0);
+  processLOGPEN(logpen_p,arg0);
+  begin_system_call();
+  hpen = CreatePenIndirect(logpen_p);
+  end_system_call();
+  if(NULL ==hpen){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hpen);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATERECTRGNINDIRECT, lpcrect)
+{
+  object arg;
+  HRGN hrgn;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  processRECT(lpcrect,arg0);
+  begin_system_call();
+  hrgn = CreateRectRgnIndirect(lpcrect);
+  end_system_call();
+  if(NULL ==hrgn){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hrgn);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEWINDOWINDIRECTA, cs)
+{
+  object arg;
+  HWND hwnd;
+  CREATESTRUCT* p = alloca(sizeof(CREATESTRUCT));
+  object arg0;
+//asm("int3");
+  arg0 = popSTACK();
+  processCREATESTRUCTA(p,arg0);
+  begin_system_call();
+  hwnd = CreateWindowEx(p->dwExStyle, p->lpszClass, p->lpszName, p->style,
+    p->x, p->y, p->cx, p->cy, p->hwndParent, p->hMenu, p->hInstance,
+    p->lpCreateParams);
+  end_system_call();
+  if(NULL ==hwnd){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hwnd);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FILLRECT, hdc lpcrect hbrush)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  HBRUSH hbrush;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hbrush = TheFpointer(arg)->fp_pointer;
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processRECT(lpcrect,arg0);
+  begin_system_call();
+  bool0 = FillRect(hdc,lpcrect,hbrush);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN(GDI:GETDC, dc)
+{
+  object arg = popSTACK();
+  DWORD e = 0;
+  HWND h = (nullp(arg))?0:(TheFpointer(arg)->fp_pointer);
+  begin_system_call();
+  h = GetDC(h);
+  end_system_call();
+  if(NULL == h){
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(h);
+    mv_count=2;
+  }
+  return;
+}
+// Nothing in the docs indicates that this function can return a error code,
+// so to be consistant, I will return T and the result.
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETDEVICECAPS, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int1 = GetDeviceCaps(hdc,int0);
+  end_system_call();
+  if(0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETSYSTEMMETRICS, int0)
+{
+  object arg;
+  int int1;
+  int int0;
+  arg = popSTACK();
+  int0 = I_to_sint32(arg);
+  begin_system_call();
+  int1 = GetSystemMetrics(int0);
+  end_system_call();
+  value1 = sint32_to_I(int1);
+  mv_count=1;
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:LOADCURSORA, hinstance lpcstr)
+{
+  object arg;
+  HCURSOR hcursor;
+  HINSTANCE hinstance;
+  void* lpcstr;
+  arg = popSTACK();
+
+  if(stringp(arg))
+  {
+     lpcstr = TheAsciz(string_to_asciz(arg,encoding));
+  }
+  else if(fpointerp(arg))
+  {
+     lpcstr = TheFpointer(arg)->fp_pointer;
+  }
+  else argumentum_inritum(arg);
+  arg = popSTACK();
+  if(nullp(arg))
+  {
+     hinstance = NULL;
+  }
+  else if(fpointerp(arg))
+  {
+     hinstance = TheFpointer(arg)->fp_pointer;
+  }
+  else argumentum_inritum(arg);
+  begin_system_call();
+  hcursor = LoadCursorA(hinstance,lpcstr);
+  end_system_call();
+  if(NULL ==hcursor){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hcursor);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:LOADCURSORW, hinstance lpcwstr)
+{
+  object arg;
+  HCURSOR hcursor;
+  HINSTANCE hinstance;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hinstance = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hcursor = LoadCursorW(hinstance,lpcwstr);
+  end_system_call();
+  if(NULL ==hcursor){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hcursor);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PLAYENHMETAFILE, hdc henhmetafile lpcrect)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HENHMETAFILE henhmetafile;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  henhmetafile = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processRECT(lpcrect,arg0);
+  begin_system_call();
+  bool0 = PlayEnhMetaFile(hdc,henhmetafile,lpcrect);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:RECTINREGION, hrgn lpcrect)
+{
+  object arg;
+  BOOL bool0;
+  HRGN hrgn;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  processRECT(lpcrect,arg0);
+  begin_system_call();
+  bool0 = RectInRegion(hrgn,lpcrect);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:RECTVISIBLE, hdc lpcrect)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processRECT(lpcrect,arg0);
+  begin_system_call();
+  bool0 = RectVisible(hdc,lpcrect);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:REGISTERCLASSA, wndclassa_p)
+{
+  object arg;
+  ATOM atom;
+  WNDCLASSA* wndclassa_p = alloca(sizeof(WNDCLASSA));
+  object arg0;
+  arg0 = popSTACK();
+//asm("int3");
+  processWNDCLASSA(wndclassa_p,arg0);
+  begin_system_call();
+  atom = RegisterClassA(wndclassa_p);
+  end_system_call();
+  if(0 ==atom){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(atom);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:REGISTERCLASSW, wndclassw_p)
+{
+  object arg;
+  ATOM atom;
+  WNDCLASSW* wndclassw_p = alloca(sizeof(WNDCLASSW));
+  object arg0;
+  arg0 = popSTACK();
+  processWNDCLASSW(wndclassw_p,arg0);
+  begin_system_call();
+  atom = RegisterClassW(wndclassw_p);
+  end_system_call();
+  if(0 ==atom){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(atom);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:REMOVEFONTRESOURCEA, lpcstr)
+{
+  object arg;
+  BOOL bool0;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcstr = TheAsciz(string_to_asciz(arg,encoding));
+  begin_system_call();
+  bool0 = RemoveFontResourceA(lpcstr);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:REMOVEFONTRESOURCEW, lpcwstr)
+{
+  object arg;
+  BOOL bool0;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  bool0 = RemoveFontResourceW(lpcwstr);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:RESETDCA, hdc devmodea_p)
+{
+  object arg;
+  HDC hdc0;
+  HDC hdc;
+  DEVMODEA* devmodea_p = alloca(sizeof(DEVMODEA));
+  object arg0;
+  arg0 = popSTACK();
+  processDEVMODEA(devmodea_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processDEVMODEA(devmodea_p,arg0);
+  begin_system_call();
+  hdc0 = ResetDCA(hdc,devmodea_p);
+  end_system_call();
+  if(NULL ==hdc0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hdc0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:RESETDCW, hdc devmodew_p)
+{
+  object arg;
+  HDC hdc0;
+  HDC hdc;
+  DEVMODEW* devmodew_p = alloca(sizeof(DEVMODEW));
+  object arg0;
+  arg0 = popSTACK();
+  processDEVMODEW(devmodew_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processDEVMODEW(devmodew_p,arg0);
+  begin_system_call();
+  hdc0 = ResetDCW(hdc,devmodew_p);
+  end_system_call();
+  if(NULL ==hdc0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hdc0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SELECTPALETTE, hdc hpalette bool0)
+{
+  object arg;
+  HPALETTE hpalette0;
+  HDC hdc;
+  HPALETTE hpalette;
+  BOOL bool0;
+  arg = popSTACK();
+  bool0 = nullp(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hpalette = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hpalette0 = SelectPalette(hdc,hpalette,bool0);
+  end_system_call();
+  if(NULL ==hpalette0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hpalette0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETCOLORADJUSTMENT, hdc coloradjustment_p)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  COLORADJUSTMENT* coloradjustment_p = alloca(sizeof(COLORADJUSTMENT));
+  object arg0;
+  arg0 = popSTACK();
+  processCOLORADJUSTMENT(coloradjustment_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processCOLORADJUSTMENT(coloradjustment_p,arg0);
+  begin_system_call();
+  bool0 = SetColorAdjustment(hdc,coloradjustment_p);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETDEVICEGAMMARAMP, hdc pvoid)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  void* pvoid;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = SetDeviceGammaRamp(hdc,pvoid);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETICMPROFILEA, hdc lpstr)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  LPSTR lpstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpstr = TheAsciz(string_to_asciz(arg,encoding));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = SetICMProfileA(hdc,lpstr);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETICMPROFILEW, hdc lpwstr)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  LPWSTR lpwstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpwstr = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = SetICMProfileW(hdc,lpwstr);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETPIXEL, hdc int0 int1 colorref)
+{
+  object arg;
+  COLORREF colorref0;
+  HDC hdc;
+  int int0;
+  int int1;
+  COLORREF colorref;
+  arg = popSTACK();
+  colorref = processCOLORREF(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  colorref0 = SetPixel(hdc,int0,int1,colorref);
+  end_system_call();
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETPIXELV, hdc int0 int1 colorref)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  COLORREF colorref;
+  arg = popSTACK();
+  colorref = processCOLORREF(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = SetPixelV(hdc,int0,int1,colorref);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETTEXTCOLOR, hdc colorref)
+{
+  object arg;
+  COLORREF colorref0;
+  HDC hdc;
+  COLORREF colorref;
+  arg = popSTACK();
+  colorref = processCOLORREF(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  colorref0 = SetTextColor(hdc,colorref);
+  end_system_call();
+  if(CLR_INVALID == colorref0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = fixnum(colorref0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETWORLDTRANSFORM, hdc xform_p)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  XFORM* xform_p = alloca(sizeof(XFORM));
+  object arg0;
+  arg0 = popSTACK();
+  processXFORM(xform_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processXFORM(xform_p,arg0);
+  begin_system_call();
+  bool0 = SetWorldTransform(hdc,xform_p);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/funcs-prob.h modules/gdi/funcs-prob.h
--- origmodules/gdi/funcs-prob.h	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/funcs-prob.h	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1,47 @@
+int          AddFontResourceA(LPCSTR);
+int          AddFontResourceW(LPCWSTR);
+HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE,LPCSTR);
+HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE,LPCWSTR);
+HMETAFILE    CopyMetaFileA(HMETAFILE,LPCSTR);
+HMETAFILE    CopyMetaFileW(HMETAFILE,LPCWSTR);
+HBITMAP      CreateBitmapIndirect( BITMAP_P);
+HBRUSH       CreateBrushIndirect( LOGBRUSH_P);
+HCOLORSPACE  CreateColorSpaceA(LPLOGCOLORSPACEA);
+HCOLORSPACE  CreateColorSpaceW(LPLOGCOLORSPACEW);
+HDC          CreateDCA(LPCSTR,LPCSTR,LPCSTR, DEVMODEA_P);
+HDC          CreateDCW(LPCWSTR,LPCWSTR,LPCWSTR, DEVMODEW_P);
+HRGN         CreateEllipticRgnIndirect(LPCRECT);
+HDC          CreateEnhMetaFileA(HDC,LPCSTR,LPCRECT,LPCSTR);
+HDC          CreateEnhMetaFileW(HDC,LPCWSTR,LPCRECT,LPCWSTR);
+HFONT        CreateFontIndirectA( LOGFONTA_P);
+HFONT        CreateFontIndirectW( LOGFONTW_P);
+HDC          CreateICA(LPCSTR,LPCSTR,LPCSTR, DEVMODEA_P);
+HDC          CreateICW(LPCWSTR,LPCWSTR,LPCWSTR, DEVMODEW_P);
+HICON        CreateIconFromResource(PBYTE,DWORD,BOOL,DWORD);
+HICON        CreateIconIndirect(PICONINFO);
+HDC          CreateMetaFileA(LPCSTR);
+HDC          CreateMetaFileW(LPCWSTR);
+HPALETTE     CreatePalette( LOGPALETTE_P);
+HPEN         CreatePenIndirect( LOGPEN_P);
+HRGN         CreateRectRgnIndirect(LPCRECT);
+BOOL         FillRect(HDC,LPCRECT,HBRUSH);
+HCURSOR      LoadCursorA(HINSTANCE,LPCSTR);
+HCURSOR      LoadCursorW(HINSTANCE,LPCWSTR);
+BOOL         PlayEnhMetaFile(HDC,HENHMETAFILE,LPCRECT);
+BOOL         RectInRegion(HRGN,LPCRECT);
+BOOL         RectVisible(HDC,LPCRECT);
+ATOM         RegisterClassA(WNDCLASSA_P);
+ATOM         RegisterClassW(WNDCLASSW_P);
+BOOL         RemoveFontResourceA(LPCSTR);
+BOOL         RemoveFontResourceW(LPCWSTR);
+HDC          ResetDCA(HDC, DEVMODEA_P);
+HDC          ResetDCW(HDC, DEVMODEW_P);
+HPALETTE     SelectPalette(HDC,HPALETTE,BOOL);
+BOOL         SetColorAdjustment(HDC, COLORADJUSTMENT_P);
+BOOL         SetDeviceGammaRamp(HDC,PVOID);
+BOOL         SetICMProfileA(HDC,LPSTR);
+BOOL         SetICMProfileW(HDC,LPWSTR);
+COLORREF     SetPixel(HDC,int,int,COLORREF);
+BOOL         SetPixelV(HDC,int,int,COLORREF);
+COLORREF     SetTextColor(HDC,COLORREF);
+BOOL         SetWorldTransform(HDC, XFORM_P);
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/funcs-rest.c modules/gdi/funcs-rest.c
--- origmodules/gdi/funcs-rest.c	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/funcs-rest.c	2007-01-09 17:20:12.125000000 +0000
@@ -0,0 +1,2235 @@
+#line 1 "funcs.c"
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ANGLEARC,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  DWORD dword;
+  FLOAT float0;
+  FLOAT float1;
+  ffloatjanus jfloat;
+  FF_to_c_float(check_ffloat(popSTACK()),&jfloat);
+  float1 = (float)(jfloat.eksplicit);
+  FF_to_c_float(check_ffloat(popSTACK()),&jfloat);
+  float0 = (float)(jfloat.eksplicit);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = AngleArc(hdc,int0,int1,dword,float0,float1);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ARC,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int int4;
+  int int5;
+  int int6;
+  int int7;
+  arg = popSTACK();
+  check_sint(arg);
+  int7 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int6 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int5 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int4 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = Arc(hdc,int0,int1,int2,int3,int4,int5,int6,int7);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ARCTO,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int int4;
+  int int5;
+  int int6;
+  int int7;
+  arg = popSTACK();
+  check_sint(arg);
+  int7 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int6 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int5 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int4 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = ArcTo(hdc,int0,int1,int2,int3,int4,int5,int6,int7);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:BITBLT,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  HDC hdc0;
+  int int4;
+  int int5;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  check_sint(arg);
+  int5 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int4 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc0 = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = BitBlt(hdc,int0,int1,int2,int3,hdc0,int4,int5,dword);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CHORD,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int int4;
+  int int5;
+  int int6;
+  int int7;
+  arg = popSTACK();
+  check_sint(arg);
+  int7 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int6 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int5 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int4 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = Chord(hdc,int0,int1,int2,int3,int4,int5,int6,int7);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEDIBITMAP,&rest r)
+{
+  object arg;
+  HBITMAP hbitmap;
+  HDC hdc;
+  BITMAPINFOHEADER* bitmapinfoheader_p = alloca(sizeof(BITMAPINFOHEADER));
+  object arg0;
+  DWORD dword;
+  void* pcvoid;
+  BITMAPINFO* bitmapinfo_p = alloca(sizeof(BITMAPINFO));
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processBITMAPINFO(bitmapinfo_p,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pcvoid = &(TheSbvector(arg)->data);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processBITMAPINFOHEADER(bitmapinfoheader_p,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processBITMAPINFOHEADER(bitmapinfoheader_p,arg0);
+  processBITMAPINFO(bitmapinfo_p,arg0);
+  begin_system_call();
+  hbitmap = CreateDIBitmap(hdc,bitmapinfoheader_p,dword,pcvoid,bitmapinfo_p,uint);
+  end_system_call();
+  if(NULL ==hbitmap){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hbitmap);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEFONTA,&rest r)
+{
+  object arg;
+  HFONT hfont;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int int4;
+  DWORD dword;
+  DWORD dword0;
+  DWORD dword1;
+  DWORD dword2;
+  DWORD dword3;
+  DWORD dword4;
+  DWORD dword5;
+  DWORD dword6;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+     dword6 = I_to_uint32(check_uint(popSTACK()));
+     dword5 = I_to_uint32(check_uint(popSTACK()));
+     dword4 = I_to_uint32(check_uint(popSTACK()));
+     dword3 = I_to_uint32(check_uint(popSTACK()));
+     dword2 = I_to_uint32(check_uint(popSTACK()));
+     dword1 = I_to_uint32(check_uint(popSTACK()));
+     dword0 = I_to_uint32(check_uint(popSTACK()));
+     dword = I_to_uint32(check_uint(popSTACK()));
+     arg = popSTACK();
+     check_sint(arg);
+     int4 = I_to_sint32(arg);
+     arg = popSTACK();
+     check_sint(arg);
+     int3 = I_to_sint32(arg);
+     arg = popSTACK();
+     check_sint(arg);
+     int2 = I_to_sint32(arg);
+     arg = popSTACK();
+     check_sint(arg);
+     int1 = I_to_sint32(arg);
+     arg = popSTACK();
+     check_sint(arg);
+     int0 = I_to_sint32(arg);
+     begin_system_call();
+     hfont = CreateFontA(int0,int1,int2,int3,int4,dword,dword0,dword1,dword2,dword3,dword4,dword5,dword6,lpcstr);
+     end_system_call();
+  });
+  if(NULL ==hfont){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hfont);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEFONTW,&rest r)
+{
+  object arg;
+  HFONT hfont;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int int4;
+  DWORD dword;
+  DWORD dword0;
+  DWORD dword1;
+  DWORD dword2;
+  DWORD dword3;
+  DWORD dword4;
+  DWORD dword5;
+  DWORD dword6;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  dword6 = I_to_uint32(check_uint(popSTACK()));
+  dword5 = I_to_uint32(check_uint(popSTACK()));
+  dword4 = I_to_uint32(check_uint(popSTACK()));
+  dword3 = I_to_uint32(check_uint(popSTACK()));
+  dword2 = I_to_uint32(check_uint(popSTACK()));
+  dword1 = I_to_uint32(check_uint(popSTACK()));
+  dword0 = I_to_uint32(check_uint(popSTACK()));
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  check_sint(arg);
+  int4 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  begin_system_call();
+  hfont = CreateFontW(int0,int1,int2,int3,int4,dword,dword0,dword1,dword2,dword3,dword4,dword5,dword6,lpcwstr);
+  end_system_call();
+  if(NULL ==hfont){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hfont);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEICON,&rest r)
+{
+  object arg;
+  object arg0;
+  HICON hicon;
+  HINSTANCE hinstance;
+  int int0;
+  int int1;
+  BYTE byte;
+  BYTE byte0;
+  PBYTE pbyte;
+  PBYTE pbyte0;
+  arg0 = popSTACK();
+  processPBYTE(pbyte0,arg0);
+  arg0 = popSTACK();
+  processPBYTE(pbyte,arg0);
+  arg0 = popSTACK();
+  processBYTE(byte0,arg0);
+  arg0 = popSTACK();
+  processBYTE(byte,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hinstance = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hicon = CreateIcon(hinstance,int0,int1,byte,byte0,pbyte,pbyte0);
+  end_system_call();
+  if(NULL ==hicon){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hicon);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEICONFROMRESOURCEEX,&rest r)
+{
+  object arg;
+  object arg0;
+  HICON hicon;
+  PBYTE pbyte;
+  DWORD dword;
+  BOOL bool0;
+  DWORD dword0;
+  int int0;
+  int int1;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));;
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  dword0 = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processBOOL(bool0,arg0);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processPBYTE(pbyte,arg0);
+  begin_system_call();
+  hicon = CreateIconFromResourceEx(pbyte,dword,bool0,dword0,int0,int1,uint);
+  end_system_call();
+  if(NULL ==hicon){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hicon);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEROUNDRECTRGN,&rest r)
+{
+  object arg;
+  HRGN hrgn;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int int4;
+  int int5;
+  arg = popSTACK();
+  check_sint(arg);
+  int5 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int4 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  begin_system_call();
+  hrgn = CreateRoundRectRgn(int0,int1,int2,int3,int4,int5);
+  end_system_call();
+  if(NULL ==hrgn){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hrgn);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEWINDOWEXA,&rest r)
+{
+  object arg;
+  HWND hwnd0;
+  DWORD dword;
+  LPCSTR lpcstr;
+  LPCSTR lpcstr0;
+  DWORD dword0;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  HWND hwnd;
+  HMENU hmenu;
+  HINSTANCE hinstance;
+  void* lpvoid = alloca(sizeof(long));
+  object arg0;
+  arg0 = popSTACK();
+  arg = popSTACK();
+  processvoid(lpvoid,arg0);
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hinstance = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hmenu = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hwnd = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  dword0 = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding,lpcstr0, {
+    arg = popSTACK();
+    if(!stringp(arg))argumentum_inritum(arg);
+    with_string_0(arg,encoding, lpcstr,{
+      dword = I_to_uint32(check_uint(popSTACK()));
+      begin_system_call();
+      hwnd0 = CreateWindowExA(dword,lpcstr,lpcstr0,dword0,int0,int1,int2,int3,hwnd,hmenu,hinstance,lpvoid);
+      end_system_call();
+      if(NULL ==hwnd0){
+        DWORD e;
+        begin_system_call();
+        e = GetLastError();
+        end_system_call();
+        value1 = NIL;
+        value2 = uint32_to_I(e);
+        mv_count=2;
+      }
+      else
+      {
+        value1 = T;
+        value2 = allocate_fpointer(hwnd0);
+        mv_count=2;
+      }
+      return;
+    });
+  });
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CREATEWINDOWEXW,&rest r)
+{
+  object arg;
+  HWND hwnd0;
+  DWORD dword;
+  LPCWSTR lpcwstr;
+  LPCWSTR lpcwstr0;
+  DWORD dword0;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  HWND hwnd;
+  HMENU hmenu;
+  HINSTANCE hinstance;
+  void* lpvoid = alloca(sizeof(long));
+  object arg0;
+  arg0 = popSTACK();
+  processvoid(lpvoid,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hinstance = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hmenu = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hwnd = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  dword0 = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr0 = 0; //(WIDECHAR(arg,encoding));
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = 0; //(WIDECHAR(arg,encoding));
+  dword = I_to_uint32(check_uint(popSTACK()));
+  processvoid(lpvoid,arg0);
+  begin_system_call();
+  hwnd0 = CreateWindowExW(dword,lpcwstr,lpcwstr0,dword0,int0,int1,int2,int3,hwnd,hmenu,hinstance,lpvoid);
+  end_system_call();
+  if(NULL ==hwnd0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(hwnd0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EXTESCAPE,&rest r)
+{
+  object arg;
+  int int3;
+  HDC hdc;
+  int int0;
+  int int1;
+  LPCSTR lpcstr;
+  int int2;
+  LPSTR lpstr;
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpstr, {
+    arg = popSTACK();
+    check_sint(arg);
+    int2 = I_to_sint32(arg);
+    arg = popSTACK();
+    if(!stringp(arg))argumentum_inritum(arg);
+    with_string_0(arg,encoding, lpcstr, {
+      arg = popSTACK();
+      check_sint(arg);
+      int1 = I_to_sint32(arg);
+      arg = popSTACK();
+      check_sint(arg);
+      int0 = I_to_sint32(arg);
+      arg = popSTACK();
+      if(!fpointerp(arg))argumentum_inritum(arg);
+      hdc = TheFpointer(arg)->fp_pointer;
+      begin_system_call();
+      int3 = ExtEscape(hdc,int0,int1,lpcstr,int2,lpstr);
+      end_system_call();
+      if(0 <=int3){
+        DWORD e;
+        begin_system_call();
+        e = GetLastError();
+        end_system_call();
+        value1 = NIL;
+        value2 = uint32_to_I(e);
+        mv_count=2;
+      }
+      else
+      {
+        value1 = T;
+        value2 = sint32_to_I(int3);
+        mv_count=2;
+      }
+    });
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EXTTEXTOUTA,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  UINT uint;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  LPCSTR lpcstr;
+  UINT uint0;
+  PINT pint;
+  arg0 = popSTACK();
+  processPINT(pint,arg0);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg0 = popSTACK();
+    processRECT(lpcrect,arg0);
+    uint = I_to_uint32(check_uint(popSTACK()));
+    arg = popSTACK();
+    check_sint(arg);
+    int1 = I_to_sint32(arg);
+    arg = popSTACK();
+    check_sint(arg);
+    int0 = I_to_sint32(arg);
+    arg = popSTACK();
+    if(!fpointerp(arg))argumentum_inritum(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+    processRECT(lpcrect,arg0);
+    begin_system_call();
+    bool0 = ExtTextOutA(hdc,int0,int1,uint,lpcrect,lpcstr,uint0,pint);
+    end_system_call();
+    if(!bool0){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      mv_count=1;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EXTTEXTOUTW,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  UINT uint;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  LPCWSTR lpcwstr;
+  UINT uint0;
+  PINT pint;
+  arg0 = popSTACK();
+  processPINT(pint,arg0);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processRECT(lpcrect,arg0);
+  begin_system_call();
+  bool0 = ExtTextOutW(hdc,int0,int1,uint,lpcrect,lpcwstr,uint0,pint);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FINDFIRSTFILEEXA,&rest r)
+{
+  object arg;
+  object arg0;
+  HANDLE handle;
+  LPCSTR lpcstr;
+  FINDEX_INFO_LEVELS findex_info_levels;
+  void* pvoid;
+  FINDEX_SEARCH_OPS findex_search_ops;
+  void* pvoid0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid0 = &(TheSbvector(arg)->data);
+  arg0 = popSTACK();
+  processFINDEX_SEARCH_OPS(&findex_search_ops,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  arg0 = popSTACK();
+  processFINDEX_INFO_LEVELS(&findex_info_levels,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    handle = FindFirstFileExA(lpcstr,findex_info_levels,pvoid,findex_search_ops,pvoid0,dword);
+    end_system_call();
+    if(NULL ==handle){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = allocate_fpointer(handle);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FINDFIRSTFILEEXW,&rest r)
+{
+  object arg;
+  object arg0;
+  HANDLE handle;
+  LPCWSTR lpcwstr;
+  FINDEX_INFO_LEVELS findex_info_levels;
+  void* pvoid;
+  FINDEX_SEARCH_OPS findex_search_ops;
+  void* pvoid0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid0 = &(TheSbvector(arg)->data);
+  arg0 = popSTACK();
+  processFINDEX_SEARCH_OPS(&findex_search_ops,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  arg0 = popSTACK();
+  processFINDEX_INFO_LEVELS(&findex_info_levels,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  handle = FindFirstFileExW(lpcwstr,findex_info_levels,pvoid,findex_search_ops,pvoid0,dword);
+  end_system_call();
+  if(NULL ==handle){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = allocate_fpointer(handle);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCHARACTERPLACEMENTA,&rest r)
+{
+  object arg;
+  DWORD dword0;
+  HDC hdc;
+  LPCSTR lpcstr;
+  int int0;
+  int int1;
+  GCP_RESULTSA* lpgcp_resultsa = alloca(sizeof(GCP_RESULTSA));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processGCP_RESULTSA(lpgcp_resultsa,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    if(!fpointerp(arg))argumentum_inritum(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+    processGCP_RESULTSA(lpgcp_resultsa,arg0);
+    begin_system_call();
+    dword0 = GetCharacterPlacementA(hdc,lpcstr,int0,int1,lpgcp_resultsa,dword);
+    end_system_call();
+    if(0 <=dword0){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = uint32_to_I(dword0);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETCHARACTERPLACEMENTW,&rest r)
+{
+  object arg;
+  DWORD dword0;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  int int0;
+  int int1;
+  GCP_RESULTSW* lpgcp_resultsw = alloca(sizeof(GCP_RESULTSW));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processGCP_RESULTSW(lpgcp_resultsw,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processGCP_RESULTSW(lpgcp_resultsw,arg0);
+  begin_system_call();
+  dword0 = GetCharacterPlacementW(hdc,lpcwstr,int0,int1,lpgcp_resultsw,dword);
+  end_system_call();
+  if(0 <=dword0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(dword0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETDIBITS,&rest r)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  HBITMAP hbitmap;
+  UINT uint;
+  UINT uint0;
+  void* pvoid;
+  BITMAPINFO* lpbitmapinfo = alloca(sizeof(BITMAPINFO));
+  object arg0;
+  UINT uint1;
+  uint1 = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processBITMAPINFO(lpbitmapinfo,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hbitmap = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processBITMAPINFO(lpbitmapinfo,arg0);
+  begin_system_call();
+  int0 = GetDIBits(hdc,hbitmap,uint,uint0,pvoid,lpbitmapinfo,uint1);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETGLYPHOUTLINEA,&rest r)
+{
+  object arg;
+  DWORD dword0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  GLYPHMETRICS* lpglyphmetrics = alloca(sizeof(GLYPHMETRICS));
+  object arg0;
+  DWORD dword;
+  void* pvoid;
+  MAT2 pmat2;
+  arg0 = popSTACK();
+  processMAT2(&pmat2,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processGLYPHMETRICS(lpglyphmetrics,arg0);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processGLYPHMETRICS(lpglyphmetrics,arg0);
+  begin_system_call();
+  dword0 = GetGlyphOutlineA(hdc,uint,uint0,lpglyphmetrics,dword,pvoid,&pmat2);
+  end_system_call();
+  if(0 <=dword0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(dword0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETGLYPHOUTLINEW,&rest r)
+{
+  object arg;
+  DWORD dword0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  GLYPHMETRICS* lpglyphmetrics = alloca(sizeof(GLYPHMETRICS));
+  object arg0;
+  DWORD dword;
+  void* pvoid;
+  MAT2 pmat2;
+  arg0 = popSTACK();
+  processMAT2(&pmat2,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processGLYPHMETRICS(lpglyphmetrics,arg0);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processGLYPHMETRICS(lpglyphmetrics,arg0);
+  begin_system_call();
+  dword0 = GetGlyphOutlineW(hdc,uint,uint0,lpglyphmetrics,dword,pvoid,&pmat2);
+  end_system_call();
+  if(0 <=dword0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(dword0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETTEXTEXTENTEXPOINTA,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  LPCSTR lpcstr;
+  int int0;
+  int int1;
+  int* lpint;
+  int* lpint0;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  object arg0;
+  arg0 = popSTACK();
+  processSIZE(lpsize,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))argumentum_inritum(arg);
+  lpint0 = &(TheSbvector(arg)->data);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))argumentum_inritum(arg);
+  lpint = &(TheSbvector(arg)->data);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    if(!fpointerp(arg))argumentum_inritum(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+    processSIZE(lpsize,arg0);
+    begin_system_call();
+    bool0 = GetTextExtentExPointA(hdc,lpcstr,int0,int1,lpint,lpint0,lpsize);
+    end_system_call();
+    if(!bool0){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      mv_count=1;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETTEXTEXTENTEXPOINTW,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  int int0;
+  int int1;
+  int* lpint;
+  int* lpint0;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  object arg0;
+  arg0 = popSTACK();
+  processSIZE(lpsize,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))argumentum_inritum(arg);
+  lpint0 = &(TheSbvector(arg)->data);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))argumentum_inritum(arg);
+  lpint = &(TheSbvector(arg)->data);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processSIZE(lpsize,arg0);
+  begin_system_call();
+  bool0 = GetTextExtentExPointW(hdc,lpcwstr,int0,int1,lpint,lpint0,lpsize);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:MASKBLT,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  HDC hdc0;
+  int int4;
+  int int5;
+  HBITMAP hbitmap;
+  int int6;
+  int int7;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  check_sint(arg);
+  int7 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int6 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hbitmap = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  check_sint(arg);
+  int5 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int4 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc0 = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = MaskBlt(hdc,int0,int1,int2,int3,hdc0,int4,int5,hbitmap,int6,int7,dword);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PATBLT,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = PatBlt(hdc,int0,int1,int2,int3,dword);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PIE,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int int4;
+  int int5;
+  int int6;
+  int int7;
+  arg = popSTACK();
+  check_sint(arg);
+  int7 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int6 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int5 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int4 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = Pie(hdc,int0,int1,int2,int3,int4,int5,int6,int7);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PLGBLT,&rest r)
+{
+  object arg;
+  object arg0;
+  BOOL bool0;
+  HDC hdc;
+  PPOINT ppoint;
+  HDC hdc0;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  HBITMAP hbitmap;
+  int int4;
+  int int5;
+  arg = popSTACK();
+  check_sint(arg);
+  int5 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int4 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hbitmap = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc0 = TheFpointer(arg)->fp_pointer;
+  arg0 = popSTACK();
+  processPPOINT(ppoint,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = PlgBlt(hdc,ppoint,hdc0,int0,int1,int2,int3,hbitmap,int4,int5);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ROUNDRECT,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int int4;
+  int int5;
+  arg = popSTACK();
+  check_sint(arg);
+  int5 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int4 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = RoundRect(hdc,int0,int1,int2,int3,int4,int5);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SCALEVIEWPORTEXTEX,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  object arg0;
+  arg0 = popSTACK();
+  processSIZE(lpsize,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processSIZE(lpsize,arg0);
+  begin_system_call();
+  bool0 = ScaleViewportExtEx(hdc,int0,int1,int2,int3,lpsize);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SCALEWINDOWEXTEX,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  object arg0;
+  arg0 = popSTACK();
+  processSIZE(lpsize,arg0);
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  processSIZE(lpsize,arg0);
+  begin_system_call();
+  bool0 = ScaleWindowExtEx(hdc,int0,int1,int2,int3,lpsize);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETDIBITS,&rest r)
+{
+  object arg;
+  object arg0;
+  int int0;
+  HDC hdc;
+  HBITMAP hbitmap;
+  UINT uint;
+  UINT uint0;
+  void* pcvoid;
+  PBITMAPINFO pbitmapinfo;
+  UINT uint1;
+  uint1 = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processPBITMAPINFO(pbitmapinfo,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pcvoid = &(TheSbvector(arg)->data);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hbitmap = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int0 = SetDIBits(hdc,hbitmap,uint,uint0,pcvoid,pbitmapinfo,uint1);
+  end_system_call();
+  if(0 <=int0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SETDIBITSTODEVICE,&rest r)
+{
+  object arg;
+  object arg0;
+  int int4;
+  HDC hdc;
+  int int0;
+  int int1;
+  DWORD dword;
+  DWORD dword0;
+  int int2;
+  int int3;
+  UINT uint;
+  UINT uint0;
+  void* pcvoid;
+  PBITMAPINFO pbitmapinfo;
+  UINT uint1;
+  uint1 = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processPBITMAPINFO(pbitmapinfo,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pcvoid = &(TheSbvector(arg)->data);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  dword0 = I_to_uint32(check_uint(popSTACK()));
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int4 = SetDIBitsToDevice(hdc,int0,int1,dword,dword0,int2,int3,uint,uint0,pcvoid,pbitmapinfo,uint1);
+  end_system_call();
+  if(0 <=int4){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int4);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:STRETCHBLT,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  HDC hdc0;
+  int int4;
+  int int5;
+  int int6;
+  int int7;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  check_sint(arg);
+  int7 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int6 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int5 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int4 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc0 = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = StretchBlt(hdc,int0,int1,int2,int3,hdc0,int4,int5,int6,int7,dword);
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:STRETCHDIBITS,&rest r)
+{
+  object arg;
+  object arg0;
+  int int8;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int int4;
+  int int5;
+  int int6;
+  int int7;
+  void* pvoid;
+  PBITMAPINFO pbitmapinfo;
+  UINT uint;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processPBITMAPINFO(pbitmapinfo,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))argumentum_inritum(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  arg = popSTACK();
+  check_sint(arg);
+  int7 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int6 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int5 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int4 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int8 = StretchDIBits(hdc,int0,int1,int2,int3,int4,int5,int6,int7,pvoid,pbitmapinfo,uint,dword);
+  end_system_call();
+  if(0 <=int8){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int8);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:TABBEDTEXTOUTA,&rest r)
+{
+  object arg;
+  LONG long0;
+  HDC hdc;
+  int int0;
+  int int1;
+  LPCSTR lpcstr;
+  int int2;
+  int int3;
+  int* lpint;
+  int int4;
+  arg = popSTACK();
+  check_sint(arg);
+  int4 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))argumentum_inritum(arg);
+  lpint = &(TheSbvector(arg)->data);
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    check_sint(arg);
+    int1 = I_to_sint32(arg);
+    arg = popSTACK();
+    check_sint(arg);
+    int0 = I_to_sint32(arg);
+    arg = popSTACK();
+    if(!fpointerp(arg))argumentum_inritum(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+    begin_system_call();
+    long0 = TabbedTextOutA(hdc,int0,int1,lpcstr,int2,int3,lpint,int4);
+    end_system_call();
+    if(0 <=long0){
+      DWORD e;
+      begin_system_call();
+      e = GetLastError();
+      end_system_call();
+      value1 = NIL;
+      value2 = uint32_to_I(e);
+      mv_count=2;
+    }
+    else
+    {
+      value1 = T;
+      value2 = sint32_to_I(long0);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:TABBEDTEXTOUTW,&rest r)
+{
+  object arg;
+  LONG long0;
+  HDC hdc;
+  int int0;
+  int int1;
+  LPCWSTR lpcwstr;
+  int int2;
+  int int3;
+  int* lpint;
+  int int4;
+  arg = popSTACK();
+  check_sint(arg);
+  int4 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))argumentum_inritum(arg);
+  lpint = &(TheSbvector(arg)->data);
+  arg = popSTACK();
+  check_sint(arg);
+  int3 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int2 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  check_sint(arg);
+  int1 = I_to_sint32(arg);
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))argumentum_inritum(arg);
+  hdc = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  long0 = TabbedTextOutW(hdc,int0,int1,lpcwstr,int2,int3,lpint,int4);
+  end_system_call();
+  if(0 <=long0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(long0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SEARCHPATHA,&rest r)
+{
+  object arg;
+  DWORD dword0;
+  LPCSTR lpcstr;
+  LPCSTR lpcstr0;
+  LPCSTR lpcstr1;
+  DWORD dword;
+  LPSTR lpstr;
+  LPSTR* lpstr_p = alloca(sizeof(LPSTR));
+  object arg0;
+  arg0 = popSTACK();
+  processSTR_P(lpstr_p,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  with_string_0(arg,encoding, lpstr, {
+    dword = I_to_uint32(check_uint(popSTACK()));
+    arg = popSTACK();
+    if(!stringp(arg))argumentum_inritum(arg);
+    with_string_0(arg,encoding, lpcstr1, {
+      arg = popSTACK();
+      if(!stringp(arg))argumentum_inritum(arg);
+      with_string_0(arg,encoding, lpcstr0, {
+        arg = popSTACK();
+        if(!stringp(arg))argumentum_inritum(arg);
+        with_string_0(arg,encoding, lpcstr, {
+          processLPSTR(lpstr_p,arg0);
+          begin_system_call();
+          dword0 = SearchPathA(lpcstr,lpcstr0,lpcstr1,dword,lpstr,lpstr_p);
+          end_system_call();
+          if(0 <=dword0){
+            DWORD e;
+            begin_system_call();
+            e = GetLastError();
+            end_system_call();
+            value1 = NIL;
+            value2 = uint32_to_I(e);
+            mv_count=2;
+          }
+          else
+          {
+            value1 = T;
+            value2 = uint32_to_I(dword0);
+            mv_count=2;
+          }
+        });
+      });
+    });
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SEARCHPATHW,&rest r)
+{
+  object arg;
+  DWORD dword0;
+  LPCWSTR lpcwstr;
+  LPCWSTR lpcwstr0;
+  LPCWSTR lpcwstr1;
+  DWORD dword;
+  LPWSTR lpwstr;
+  LPWSTR* lpwstr_p = alloca(sizeof(LPWSTR));
+  object arg0;
+  arg0 = popSTACK();
+  processWSTR_P(lpwstr_p,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpwstr = 0; //WIDECHAR(arg,encoding);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr1 = 0; //WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr0 = 0; //WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!stringp(arg))argumentum_inritum(arg);
+  lpcwstr = 0; //WIDECHAR(arg,encoding);
+  processLPWSTR(lpwstr_p,arg0);
+  begin_system_call();
+  dword0 = SearchPathW(lpcwstr,lpcwstr0,lpcwstr1,dword,lpwstr,lpwstr_p);
+  end_system_call();
+  if(0 <=dword0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(dword0);
+    mv_count=2;
+  }
+  return;
+}
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/funcs-rest.h modules/gdi/funcs-rest.h
--- origmodules/gdi/funcs-rest.h	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/funcs-rest.h	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1,41 @@
+BOOL         AngleArc(HDC,int,int,DWORD,FLOAT,FLOAT);
+BOOL         Arc(HDC,int,int,int,int,int,int,int,int);
+BOOL         ArcTo(HDC,int,int,int,int,int,int,int,int);
+BOOL         BitBlt(HDC,int,int,int,int,HDC,int,int,DWORD);
+BOOL         Chord(HDC,int,int,int,int,int,int,int,int);
+HBITMAP      CreateDIBitmap(HDC, BITMAPINFOHEADER_P,DWORD,PCVOID, BITMAPINFO_P,UINT);
+HFONT        CreateFontA(int,int,int,int,int,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPCSTR);
+HFONT        CreateFontW(int,int,int,int,int,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPCWSTR);
+HICON        CreateIcon(HINSTANCE,int,int,BYTE,BYTE,PBYTE,PBYTE);
+HICON        CreateIconFromResourceEx(PBYTE,DWORD,BOOL,DWORD,int,int,UINT);
+HRGN         CreateRoundRectRgn(int,int,int,int,int,int);
+HWND         CreateWindowExA(DWORD,LPCSTR,LPCSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);
+HWND         CreateWindowExW(DWORD,LPCWSTR,LPCWSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);
+int          ExtEscape(HDC,int,int,LPCSTR,int,LPSTR);
+BOOL         ExtTextOutA(HDC,int,int,UINT,LPCRECT,LPCSTR,UINT,PINT);
+BOOL         ExtTextOutW(HDC,int,int,UINT,LPCRECT,LPCWSTR,UINT,PINT);
+HANDLE       FindFirstFileExA(LPCSTR,FINDEX_INFO_LEVELS,PVOID,FINDEX_SEARCH_OPS,PVOID,DWORD);
+HANDLE       FindFirstFileExW(LPCWSTR,FINDEX_INFO_LEVELS,PVOID,FINDEX_SEARCH_OPS,PVOID,DWORD);
+DWORD        GetCharacterPlacementA(HDC,LPCSTR,int,int,LPGCP_RESULTSA,DWORD);
+DWORD        GetCharacterPlacementW(HDC,LPCWSTR,int,int,LPGCP_RESULTSW,DWORD);
+int          GetDIBits(HDC,HBITMAP,UINT,UINT,PVOID,LPBITMAPINFO,UINT);
+DWORD        GetGlyphOutlineA(HDC,UINT,UINT,LPGLYPHMETRICS,DWORD,PVOID,PMAT2);
+DWORD        GetGlyphOutlineW(HDC,UINT,UINT,LPGLYPHMETRICS,DWORD,PVOID,PMAT2);
+BOOL         GetTextExtentExPointA(HDC,LPCSTR,int,int,LPINT,LPINT,LPSIZE);
+BOOL         GetTextExtentExPointW( HDC,LPCWSTR,int,int,LPINT,LPINT,LPSIZE );
+BOOL         MaskBlt(HDC,int,int,int,int,HDC,int,int,HBITMAP,int,int,DWORD);
+BOOL         PatBlt(HDC,int,int,int,int,DWORD);
+BOOL         Pie(HDC,int,int,int,int,int,int,int,int);
+BOOL         PlgBlt(HDC,PPOINT,HDC,int,int,int,int,HBITMAP,int,int);
+BOOL         RoundRect(HDC,int,int,int,int,int,int);
+BOOL         ScaleViewportExtEx(HDC,int,int,int,int,LPSIZE);
+BOOL         ScaleWindowExtEx(HDC,int,int,int,int,LPSIZE);
+int          SetDIBits(HDC,HBITMAP,UINT,UINT,PCVOID,PBITMAPINFO,UINT);
+int          SetDIBitsToDevice(HDC,int,int,DWORD,DWORD,int,int,UINT,UINT,PCVOID,PBITMAPINFO,UINT);
+int          SetDIBitsToDevice(HDC,int,int,DWORD,DWORD,int,int,UINT,UINT,PCVOID,PBITMAPINFO,UINT);
+BOOL         StretchBlt(HDC,int,int,int,int,HDC,int,int,int,int,DWORD);
+int          StretchDIBits(HDC,int,int,int,int,int,int,int,int,PVOID,PBITMAPINFO,UINT,DWORD);
+LONG         TabbedTextOutA(HDC,int,int,LPCSTR,int,int,LPINT,int);
+LONG         TabbedTextOutW(HDC,int,int,LPCWSTR,int,int,LPINT,int);
+DWORD        SearchPathA(LPCSTR,LPCSTR,LPCSTR,DWORD,LPSTR,LPSTR_P);
+DWORD        SearchPathW(LPCWSTR,LPCWSTR,LPCWSTR,DWORD,LPWSTR,LPWSTR_P);
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/funcs-rest.sh modules/gdi/funcs-rest.sh
--- origmodules/gdi/funcs-rest.sh	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/funcs-rest.sh	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1,3 @@
+awk -f func.awk <funcs-rest.h >funcs-rest.c
+sed "s/popSTACK()/BEFORE(args_end_pointer)/" <funcs-rest.c >funcs-rest.c1
+mv funcs-rest.c1 funcs-rest.c
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/gdi-preload.lisp modules/gdi/gdi-preload.lisp
--- origmodules/gdi/gdi-preload.lisp	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/gdi-preload.lisp	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1 @@
+(make-package "GDI")
+;;;(make-package "GDI" :case-sensitive T)
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/gdi.lisp modules/gdi/gdi.lisp
--- origmodules/gdi/gdi.lisp	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/gdi.lisp	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1,1939 @@
+(defpackage "GDI"
+  (
+   :export
+   POINT POINT-FLOAT RECT *white* *black* pixarray-1-element-type 
+   pixarray-4-element-type pixarray-8-element-type pixarray-16-element-type
+   pixarray-24-element-type pixarray-32-element-type
+   make-point make-point-float make-logfont make-textmetric make-iconinfo
+   make-createstruct make-wndclass add-callbacks *current-event*
+   bitmap-image
+   SM_CXSCREEN SM_CYSCREEN SM_CXVSCROLL SM_CYHSCROLL SM_CYCAPTION
+   SM_CXBORDER SM_CYBORDER SM_CXDLGFRAME SM_CXFIXEDFRAME SM_CYDLGFRAME
+   SM_CYFIXEDFRAME SM_CYVTHUMB SM_CXHTHUMB SM_CXICON SM_CYICON SM_CXCURSOR
+   SM_CYCURSOR SM_CYMENU SM_CXFULLSCREEN SM_CYFULLSCREEN SM_CYKANJIWINDOW
+   SM_MOUSEPRESENT SM_CYVSCROLL SM_CXHSCROLL SM_DEBUG SM_SWAPBUTTON
+   SM_RESERVED1 SM_RESERVED2 SM_RESERVED3 SM_RESERVED4 SM_CXMIN SM_CYMIN
+   SM_CXSIZE SM_CYSIZE SM_CXSIZEFRAME SM_CXFRAME SM_CYSIZEFRAME SM_CYFRAME
+   SM_CXMINTRACK SM_CYMINTRACK SM_CXDOUBLECLK SM_CYDOUBLECLK SM_CXICONSPACING
+   SM_CYICONSPACING SM_MENUDROPALIGNMENT SM_PENWINDOWS SM_DBCSENABLED
+   SM_CMOUSEBUTTONS SM_SECURE SM_CXEDGE SM_CYEDGE SM_CXMINSPACING
+   SM_CYMINSPACING SM_CXSMICON SM_CYSMICON SM_CYSMCAPTION SM_CXSMSIZE
+   SM_CYSMSIZE SM_CXMENUSIZE SM_CYMENUSIZE SM_ARRANGE SM_CXMINIMIZED
+   SM_CYMINIMIZED SM_CXMAXTRACK SM_CYMAXTRACK SM_CXMAXIMIZED SM_CYMAXIMIZED
+   SM_NETWORK SM_CLEANBOOT SM_CXDRAG SM_CYDRAG SM_SHOWSOUNDS SM_CXMENUCHECK
+   SM_CYMENUCHECK SM_SLOWMACHINE SM_MIDEASTENABLED SM_MOUSEWHEELPRESENT
+   SM_XVIRTUALSCREEN SM_YVIRTUALSCREEN SM_CXVIRTUALSCREEN SM_CYVIRTUALSCREEN
+   SM_CMONITORS SM_SAMEDISPLAYFORMAT SM_CMETRICS
+   BI_RGB BI_RLE8 BI_RLE4 BI_BITFIELDS LF_FACESIZE LF_FULLFACESIZE
+   CA_NEGATIVE CA_LOG_FILTER ILLUMINANT_DEVICE_DEFAULT ILLUMINANT_A
+   ILLUMINANT_B ILLUMINANT_C ILLUMINANT_D50 ILLUMINANT_D55 ILLUMINANT_D65
+   ILLUMINANT_D75 ILLUMINANT_F2 ILLUMINANT_MAX_INDEX ILLUMINANT_FLUORESCENT
+   RGB_GAMMA_MIN RGB_GAMMA_MAX REFERENCE_WHITE_MIN REFERENCE_WHITE_MAX
+   REFERENCE_BLACK_MIN REFERENCE_BLACK_MAX COLOR_ADJ_MAX CCHDEVICENAME
+   CCHFORMNAME DI_COMPAT DI_DEFAULTSIZE DI_IMAGE DI_MASK DI_NORMAL
+   DI_APPBANDING EMR_HEADER EMR_POLYBEZIER EMR_POLYGON EMR_POLYLINE
+   EMR_POLYBEZIERTO EMR_POLYLINETO EMR_POLYPOLYLINE EMR_POLYPOLYGON
+   EMR_SETWINDOWEXTEX EMR_SETWINDOWORGEX EMR_SETVIEWPORTEXTEX
+   EMR_SETVIEWPORTORGEX EMR_SETBRUSHORGEX EMR_EOF EMR_SETPIXELV
+   EMR_SETMAPPERFLAGS EMR_SETMAPMODE EMR_SETBKMODE EMR_SETPOLYFILLMODE
+   EMR_SETROP2 EMR_SETSTRETCHBLTMODE EMR_SETTEXTALIGN EMR_SETCOLORADJUSTMENT
+   EMR_SETTEXTCOLOR EMR_SETBKCOLOR EMR_OFFSETCLIPRGN EMR_MOVETOEX
+   EMR_SETMETARGN EMR_EXCLUDECLIPRECT EMR_INTERSECTCLIPRECT
+   EMR_SCALEVIEWPORTEXTEX EMR_SCALEWINDOWEXTEX EMR_SAVEDC EMR_RESTOREDC
+   EMR_SETWORLDTRANSFORM EMR_MODIFYWORLDTRANSFORM EMR_SELECTOBJECT
+   EMR_CREATEPEN EMR_CREATEBRUSHINDIRECT EMR_DELETEOBJECT EMR_ANGLEARC
+   EMR_ELLIPSE EMR_RECTANGLE EMR_ROUNDRECT EMR_ARC EMR_CHORD EMR_PIE
+   EMR_SELECTPALETTE EMR_CREATEPALETTE EMR_SETPALETTEENTRIES
+   EMR_RESIZEPALETTE EMR_REALIZEPALETTE EMR_EXTFLOODFILL EMR_LINETO EMR_ARCTO
+   EMR_POLYDRAW EMR_SETARCDIRECTION EMR_SETMITERLIMIT EMR_BEGINPATH
+   EMR_ENDPATH EMR_CLOSEFIGURE EMR_FILLPATH EMR_STROKEANDFILLPATH
+   EMR_STROKEPATH EMR_FLATTENPATH EMR_WIDENPATH EMR_SELECTCLIPPATH
+   EMR_ABORTPATH EMR_GDICOMMENT EMR_FILLRGN EMR_FRAMERGN EMR_INVERTRGN
+   EMR_PAINTRGN EMR_EXTSELECTCLIPRGN EMR_BITBLT EMR_STRETCHBLT EMR_MASKBLT
+   EMR_PLGBLT EMR_SETDIBITSTODEVICE EMR_STRETCHDIBITS EMR_EXTCREATEFONTINDIRECTW
+   EMR_EXTTEXTOUTA EMR_EXTTEXTOUTW EMR_POLYBEZIER16 EMR_POLYGON16 EMR_POLYLINE16
+   EMR_POLYBEZIERTO16 EMR_POLYLINETO16 EMR_POLYPOLYLINE16 EMR_POLYPOLYGON16
+   EMR_POLYDRAW16 EMR_CREATEMONOBRUSH EMR_CREATEDIBPATTERNBRUSHPT
+   EMR_EXTCREATEPEN EMR_POLYTEXTOUTA EMR_POLYTEXTOUTW EMR_SETICMMODE
+   EMR_CREATECOLORSPACE EMR_SETCOLORSPACE EMR_DELETECOLORSPACE EMR_GLSRECORD
+   EMR_GLSBOUNDEDRECORD EMR_PIXELFORMAT ENHMETA_SIGNATURE EPS_SIGNATURE
+   META_SETBKCOLOR META_SETBKMODE META_SETMAPMODE META_SETROP2 META_SETRELABS
+   META_SETPOLYFILLMODE META_SETSTRETCHBLTMODE META_SETTEXTCHAREXTRA
+   META_SETTEXTCOLOR META_SCALEWINDOWEXT META_OFFSETVIEWPORTORG
+   META_SCALEVIEWPORTEXT META_LINETO META_MOVETO META_EXCLUDECLIPRECT
+   META_INTERSECTCLIPRECT META_ARC META_ELLIPSE META_FLOODFILL
+   META_OFFSETCLIPRGN META_TEXTOUT META_BITBLT META_STRETCHBLT META_POLYGON
+   META_POLYLINE META_ESCAPE META_RESTOREDC META_FILLREGION META_FRAMEREGION
+   META_CHORD META_SETMAPPERFLAGS META_EXTTEXTOUT META_SETDIBTODEV
+   META_SELECTPALETTE META_REALIZEPALETTE META_ANIMATEPALETTE META_SETPALENTRIES
+   META_POLYPOLYGON META_RESIZEPALETTE META_DIBBITBLT META_DIBSTRETCHBLT
+   META_DIBCREATEPATTERNBRUSH META_STRETCHDIB META_EXTFLOODFILL
+   META_DELETEOBJECT META_CREATEPALETTE META_CREATEPATTERNBRUSH
+   PT_MOVETO PT_LINETO PT_BEZIERTO PT_CLOSEFIGURE ELF_VENDOR_SIZE
+   ELF_VERSION ELF_CULTURE_LATIN PFD_TYPE_RGBA PFD_TYPE_COLORINDEX
+   PFD_MAIN_PLANE PFD_OVERLAY_PLANE PFD_DOUBLEBUFFER PFD_STEREO
+   PFD_DRAW_TO_WINDOW PFD_DRAW_TO_BITMAP PFD_SUPPORT_GDI PFD_SUPPORT_OPENGL
+   PFD_GENERIC_FORMAT PFD_NEED_PALETTE PFD_NEED_SYSTEM_PALETTE PFD_SWAP_EXCHANGE
+   PFD_SWAP_COPY PFD_DOUBLEBUFFER_DONTCARE PFD_STEREO_DONTCARE
+   BLACKNESS NOTSRCERASE NOTSRCCOPY SRCERASE DSTINVERT PATINVERT SRCINVERT
+   SRCAND MERGEPAINT SRCCOPY SRCPAINT PATCOPY PATPAINT WHITENESS R2_BLACK
+   R2_COPYPEN R2_MASKNOTPEN R2_MASKPEN R2_MASKPENNOT R2_MERGENOTPEN
+   R2_MERGEPEN R2_MERGEPENNOT R2_NOP R2_NOT R2_NOTCOPYPEN R2_NOTMASKPEN
+   R2_NOTMERGEPEN R2_NOTXORPEN R2_WHITE R2_XORPEN CM_OUT_OF_GAMUT
+   CM_IN_GAMUT RGN_AND RGN_COPY RGN_DIFF RGN_OR RGN_XOR NULLREGION SIMPLEREGION
+   COMPLEXREGION #|ERROR|# CBM_INIT DIB_PAL_COLORS DIB_RGB_COLORS FW_DONTCARE
+   FW_THIN FW_EXTRALIGHT FW_LIGHT FW_NORMAL FW_REGULAR FW_MEDIUM FW_SEMIBOLD
+   FW_BOLD FW_EXTRABOLD FW_HEAVY ANSI_CHARSET DEFAULT_CHARSET SYMBOL_CHARSET
+   SHIFTJIS_CHARSET HANGEUL_CHARSET HANGUL_CHARSET GB2312_CHARSET
+   CHINESEBIG5_CHARSET GREEK_CHARSET TURKISH_CHARSET HEBREW_CHARSET
+   ARABIC_CHARSET BALTIC_CHARSET RUSSIAN_CHARSET THAI_CHARSET EASTEUROPE_CHARSET
+   OEM_CHARSET JOHAB_CHARSET VIETNAMESE_CHARSET MAC_CHARSET BALTIC_CHARSET
+   JOHAB_CHARSET VIETNAMESE_CHARSET OUT_DEFAULT_PRECIS OUT_STRING_PRECIS
+   OUT_CHARACTER_PRECIS OUT_STROKE_PRECIS OUT_TT_PRECIS OUT_DEVICE_PRECIS
+   OUT_RASTER_PRECIS OUT_TT_ONLY_PRECIS OUT_OUTLINE_PRECIS CLIP_DEFAULT_PRECIS
+   CLIP_CHARACTER_PRECIS CLIP_STROKE_PRECIS CLIP_MASK CLIP_LH_ANGLES
+   CLIP_TT_ALWAYS CLIP_EMBEDDED DEFAULT_QUALITY DRAFT_QUALITY PROOF_QUALITY
+   NONANTIALIASED_QUALITY ANTIALIASED_QUALITY DEFAULT_PITCH FIXED_PITCH
+   VARIABLE_PITCH MONO_FONT FF_DECORATIVE FF_DONTCARE FF_MODERN FF_ROMAN
+   FF_SCRIPT FF_SWISS PANOSE_COUNT PAN_FAMILYTYPE_INDEX PAN_SERIFSTYLE_INDEX
+   PAN_WEIGHT_INDEX PAN_PROPORTION_INDEX PAN_CONTRAST_INDEX
+   PAN_STROKEVARIATION_INDEX PAN_ARMSTYLE_INDEX PAN_LETTERFORM_INDEX
+   PAN_MIDLINE_INDEX PAN_XHEIGHT_INDEX PAN_CULTURE_LATIN PAN_ANY PAN_NO_FIT
+   PAN_FAMILY_TEXT_DISPLAY PAN_FAMILY_SCRIPT PAN_FAMILY_DECORATIVE
+   PAN_FAMILY_PICTORIAL PAN_SERIF_COVE PAN_SERIF_OBTUSE_COVE
+   PAN_SERIF_SQUARE_COVE PAN_SERIF_OBTUSE_SQUARE_COVE PAN_SERIF_SQUARE
+   PAN_SERIF_THIN PAN_SERIF_BONE PAN_SERIF_EXAGGERATED PAN_SERIF_TRIANGLE
+   PAN_SERIF_NORMAL_SANS PAN_SERIF_OBTUSE_SANS PAN_SERIF_PERP_SANS
+   PAN_SERIF_FLARED PAN_SERIF_ROUNDED PAN_WEIGHT_VERY_LIGHT PAN_WEIGHT_LIGHT
+   PAN_WEIGHT_THIN PAN_WEIGHT_BOOK PAN_WEIGHT_MEDIUM PAN_WEIGHT_DEMI
+   PAN_WEIGHT_BOLD PAN_WEIGHT_HEAVY PAN_WEIGHT_BLACK PAN_WEIGHT_NORD
+   PAN_PROP_OLD_STYLE PAN_PROP_MODERN PAN_PROP_EVEN_WIDTH
+   PAN_PROP_EXPANDED PAN_PROP_CONDENSED PAN_PROP_VERY_EXPANDED
+   PAN_PROP_VERY_CONDENSED PAN_PROP_MONOSPACED PAN_CONTRAST_NONE
+   PAN_CONTRAST_VERY_LOW PAN_CONTRAST_LOW PAN_CONTRAST_MEDIUM_LOW
+   PAN_CONTRAST_MEDIUM PAN_CONTRAST_MEDIUM_HIGH PAN_CONTRAST_HIGH
+   PAN_CONTRAST_VERY_HIGH PAN_STROKE_GRADUAL_DIAG PAN_STROKE_GRADUAL_TRAN
+   PAN_STROKE_GRADUAL_VERT PAN_STROKE_GRADUAL_HORZ PAN_STROKE_RAPID_VERT
+   PAN_STROKE_RAPID_HORZ PAN_STROKE_INSTANT_VERT PAN_STRAIGHT_ARMS_HORZ
+   PAN_STRAIGHT_ARMS_WEDGE PAN_STRAIGHT_ARMS_VERT PAN_STRAIGHT_ARMS_SINGLE_SERIF
+   PAN_STRAIGHT_ARMS_DOUBLE_SERIF PAN_BENT_ARMS_HORZ PAN_BENT_ARMS_WEDGE
+   PAN_BENT_ARMS_VERT PAN_BENT_ARMS_SINGLE_SERIF PAN_BENT_ARMS_DOUBLE_SERIF
+   PAN_LETT_NORMAL_CONTACT PAN_LETT_NORMAL_WEIGHTED PAN_LETT_NORMAL_BOXED
+   PAN_LETT_NORMAL_FLATTENED PAN_LETT_NORMAL_ROUNDED PAN_LETT_NORMAL_OFF_CENTER
+   PAN_LETT_NORMAL_SQUARE PAN_LETT_OBLIQUE_CONTACT PAN_LETT_OBLIQUE_WEIGHTED
+   PAN_LETT_OBLIQUE_BOXED PAN_LETT_OBLIQUE_FLATTENED PAN_LETT_OBLIQUE_ROUNDED
+   PAN_LETT_OBLIQUE_OFF_CENTER PAN_LETT_OBLIQUE_SQUARE
+   PAN_MIDLINE_STANDARD_TRIMMED PAN_MIDLINE_STANDARD_POINTED
+   PAN_MIDLINE_STANDARD_SERIFED PAN_MIDLINE_HIGH_TRIMMED
+   PAN_MIDLINE_HIGH_POINTED PAN_MIDLINE_HIGH_SERIFED
+   PAN_MIDLINE_CONSTANT_TRIMMED PAN_MIDLINE_CONSTANT_POINTED
+   PAN_MIDLINE_CONSTANT_SERIFED PAN_MIDLINE_LOW_TRIMMED PAN_MIDLINE_LOW_POINTED
+   PAN_MIDLINE_LOW_SERIFED PAN_XHEIGHT_CONSTANT_SMALL PAN_XHEIGHT_CONSTANT_STD
+   PAN_XHEIGHT_CONSTANT_LARGE PAN_XHEIGHT_DUCKING_SMALL PAN_XHEIGHT_DUCKING_STD
+   PAN_XHEIGHT_DUCKING_LARGE FS_LATIN1 FS_LATIN2 FS_CYRILLIC FS_GREEK FS_TURKISH
+   FS_HEBREW FS_ARABIC FS_BALTIC FS_THAI FS_JISJAPAN FS_CHINESESIMP FS_WANSUNG
+   FS_CHINESETRAD FS_JOHAB FS_SYMBOL HS_BDIAGONAL HS_CROSS HS_DIAGCROSS
+   HS_FDIAGONAL HS_HORIZONTAL HS_VERTICAL PS_GEOMETRIC PS_COSMETIC
+   PS_ALTERNATE PS_SOLID PS_DASH PS_DOT PS_DASHDOT PS_DASHDOTDOT
+   PS_NULL PS_USERSTYLE PS_INSIDEFRAME PS_ENDCAP_ROUND PS_ENDCAP_SQUARE
+   PS_ENDCAP_FLAT PS_JOIN_BEVEL PS_JOIN_MITER PS_JOIN_ROUND PS_STYLE_MASK
+   PS_ENDCAP_MASK PS_TYPE_MASK ALTERNATE #|WINDING|# DC_BINNAMES DC_BINS
+   DC_COPIES DC_DRIVER DC_DATATYPE_PRODUCED DC_DUPLEX DC_EMF_COMPLIANT
+   DC_ENUMRESOLUTIONS DC_EXTRA DC_FIELDS DC_FILEDEPENDENCIES DC_MAXEXTENT
+   DC_MINEXTENT DC_ORIENTATION DC_PAPERNAMES DC_PAPERS DC_PAPERSIZE
+   DC_SIZE DC_TRUETYPE DCTT_BITMAP DCTT_DOWNLOAD DCTT_SUBDEV
+   DCTT_DOWNLOAD_OUTLINE DC_VERSION DC_BINADJUST DC_EMF_COMPLIANT
+   DC_DATATYPE_PRODUCED DC_MANUFACTURER DC_MODEL DCBA_FACEUPNONE
+   DCBA_FACEUPCENTER DCBA_FACEUPLEFT DCBA_FACEUPRIGHT DCBA_FACEDOWNNONE
+   DCBA_FACEDOWNCENTER DCBA_FACEDOWNLEFT DCBA_FACEDOWNRIGHT FLOODFILLBORDER
+   FLOODFILLSURFACE ETO_CLIPPED ETO_GLYPH_INDEX ETO_OPAQUE ETO_RTLREADING
+   GDICOMMENT_BEGINGROUP GDICOMMENT_ENDGROUP GDICOMMENT_MULTIFORMATS
+   GDICOMMENT_IDENTIFIER AD_COUNTERCLOCKWISE AD_CLOCKWISE RDH_RECTANGLES
+   GCPCLASS_LATIN GCPCLASS_HEBREW GCPCLASS_ARABIC GCPCLASS_NEUTRAL
+   GCPCLASS_LOCALNUMBER GCPCLASS_LATINNUMBER GCPCLASS_LATINNUMERICTERMINATOR
+   GCPCLASS_LATINNUMERICSEPARATOR GCPCLASS_NUMERICSEPARATOR GCPCLASS_PREBOUNDLTR
+   GCPCLASS_PREBOUNDRTL GCPCLASS_POSTBOUNDLTR GCPCLASS_POSTBOUNDRTL
+   GCPGLYPH_LINKBEFORE GCPGLYPH_LINKAFTER DCB_DISABLE DCB_ENABLE DCB_RESET
+   DCB_SET DCB_ACCUMULATE DCB_DIRTY OBJ_BRUSH OBJ_PEN OBJ_PAL OBJ_FONT
+   OBJ_BITMAP OBJ_EXTPEN OBJ_REGION OBJ_DC OBJ_MEMDC OBJ_METAFILE OBJ_METADC
+   OBJ_ENHMETAFILE OBJ_ENHMETADC DRIVERVERSION TECHNOLOGY DT_PLOTTER
+   DT_RASDISPLAY DT_RASPRINTER DT_RASCAMERA DT_CHARSTREAM DT_METAFILE
+   DT_DISPFILE HORZSIZE VERTSIZE HORZRES VERTRES LOGPIXELSX LOGPIXELSY BITSPIXEL
+   PLANES NUMBRUSHES NUMPENS NUMFONTS NUMCOLORS NUMMARKERS ASPECTX
+   ASPECTY ASPECTXY PDEVICESIZE CLIPCAPS SIZEPALETTE NUMRESERVED
+   COLORRES PHYSICALWIDTH PHYSICALHEIGHT PHYSICALOFFSETX PHYSICALOFFSETY
+   SCALINGFACTORX SCALINGFACTORY VREFRESH DESKTOPHORZRES DESKTOPVERTRES
+   BLTALIGNMENT RASTERCAPS RC_BANDING RC_BITBLT RC_BITMAP64 RC_DI_BITMAP
+   RC_DIBTODEV RC_FLOODFILL RC_GDI20_OUTPUT RC_PALETTE RC_SCALING
+   RC_STRETCHBLT RC_STRETCHDIB RC_DEVBITS RC_OP_DX_OUTPUT CURVECAPS
+   CC_NONE CC_CIRCLES CC_PIE CC_CHORD CC_ELLIPSES CC_WIDE CC_STYLED
+   CC_WIDESTYLED CC_INTERIORS CC_ROUNDRECT LINECAPS LC_NONE LC_POLYLINE
+   LC_MARKER LC_POLYMARKER LC_WIDE LC_STYLED LC_WIDESTYLED LC_INTERIORS
+   POLYGONALCAPS RC_BANDING RC_BIGFONT RC_BITBLT RC_BITMAP64 RC_DEVBITS
+   RC_DI_BITMAP RC_GDI20_OUTPUT RC_GDI20_STATE RC_NONE RC_OP_DX_OUTPUT
+   RC_PALETTE RC_SAVEBITMAP RC_SCALING PC_NONE PC_POLYGON PC_POLYPOLYGON
+   PC_PATHS PC_RECTANGLE PC_WINDPOLYGON PC_SCANLINE PC_TRAPEZOID PC_WIDE
+   PC_STYLED PC_WIDESTYLED PC_INTERIORS PC_PATHS TEXTCAPS TC_OP_CHARACTER
+   TC_OP_STROKE TC_CP_STROKE TC_CR_90 TC_CR_ANY TC_SF_X_YINDEP TC_SA_DOUBLE
+   TC_SA_INTEGER TC_SA_CONTIN TC_EA_DOUBLE TC_IA_ABLE TC_UA_ABLE TC_SO_ABLE
+   TC_RA_ABLE TC_VA_ABLE TC_RESERVED TC_SCROLLBLT GCP_DBCS GCP_ERROR GCP_CLASSIN
+   GCP_DIACRITIC GCP_DISPLAYZWG GCP_GLYPHSHAPE GCP_JUSTIFY GCP_JUSTIFYIN
+   GCP_KASHIDA GCP_LIGATE GCP_MAXEXTENT GCP_NEUTRALOVERRIDE GCP_NUMERICOVERRIDE
+   GCP_NUMERICSLATIN GCP_NUMERICSLOCAL GCP_REORDER GCP_SYMSWAPOFF GCP_USEKERNING
+   FLI_GLYPHS GGO_BITMAP GGO_NATIVE GGO_METRICS GGO_GRAY2_BITMAP
+   GGO_GRAY4_BITMAP GGO_GRAY8_BITMAP GGO_GLYPH_INDEX GM_COMPATIBLE GM_ADVANCED
+   MM_ANISOTROPIC MM_HIENGLISH MM_HIMETRIC MM_ISOTROPIC MM_LOENGLISH MM_LOMETRIC
+   MM_TEXT MM_TWIPS ABSOLUTE RELATIVE PC_EXPLICIT PC_NOCOLLAPSE PC_RESERVED
+   CLR_DEFAULT PT_MOVETO PT_LINETO PT_BEZIERTO PT_CLOSEFIGURE TT_AVAILABLE
+   TT_ENABLED BLACK_BRUSH DKGRAY_BRUSH GRAY_BRUSH HOLLOW_BRUSH LTGRAY_BRUSH
+   NULL_BRUSH WHITE_BRUSH BLACK_PEN NULL_PEN WHITE_PEN ANSI_FIXED_FONT
+   ANSI_VAR_FONT DEVICE_DEFAULT_FONT DEFAULT_GUI_FONT OEM_FIXED_FONT
+   SYSTEM_FONT SYSTEM_FIXED_FONT DEFAULT_PALETTE SYSPAL_NOSTATIC SYSPAL_STATIC
+   SYSPAL_ERROR TA_BASELINE TA_BOTTOM TA_TOP TA_CENTER TA_LEFT TA_RIGHT
+   TA_RTLREADING TA_NOUPDATECP TA_UPDATECP VTA_BASELINE VTA_CENTER MWT_IDENTITY
+   MWT_LEFTMULTIPLY MWT_RIGHTMULTIPLY OPAQUE TRANSPARENT BLACKONWHITE
+   WHITEONBLACK COLORONCOLOR HALFTONE MAXSTRETCHBLTMODE STRETCH_ANDSCANS
+   STRETCH_DELETESCANS STRETCH_HALFTONE STRETCH_ORSCANS TCI_SRCCHARSET
+   TCI_SRCCODEPAGE TCI_SRCFONTSIG ICM_ON ICM_OFF ICM_QUERY NEWFRAME ABORTDOC
+   NEXTBAND SETCOLORTABLE GETCOLORTABLE FLUSHOUTPUT DRAFTMODE QUERYESCSUPPORT
+   SETABORTPROC STARTDOC ENDDOC GETPHYSPAGESIZE GETPRINTINGOFFSET
+   GETSCALINGFACTOR MFCOMMENT GETPENWIDTH SETCOPYCOUNT SELECTPAPERSOURCE
+   DEVICEDATA PASSTHROUGH GETTECHNOLGY GETTECHNOLOGY SETLINECAP SETLINEJOIN
+   SETMITERLIMIT BANDINFO DRAWPATTERNRECT GETVECTORPENSIZE GETVECTORBRUSHSIZE
+   ENABLEDUPLEX GETSETPAPERBINS GETSETPRINTORIENT ENUMPAPERBINS SETDIBSCALING
+   EPSPRINTING ENUMPAPERMETRICS GETSETPAPERMETRICS POSTSCRIPT_DATA
+   POSTSCRIPT_IGNORE MOUSETRAILS GETDEVICEUNITS GETEXTENDEDTEXTMETRICS
+   GETEXTENTTABLE GETPAIRKERNTABLE GETTRACKKERNTABLE EXTTEXTOUT GETFACENAME
+   DOWNLOADFACE ENABLERELATIVEWIDTHS ENABLEPAIRKERNING SETKERNTRACK
+   SETALLJUSTVALUES SETCHARSET STRETCHBLT GETSETSCREENPARAMS QUERYDIBSUPPORT
+   BEGIN_PATH CLIP_TO_PATH END_PATH EXT_DEVICE_CAPS RESTORE_CTM SAVE_CTM
+   SET_ARC_DIRECTION SET_BACKGROUND_COLOR SET_POLY_MODE SET_SCREEN_ANGLE
+   SET_SPREAD TRANSFORM_CTM SET_CLIP_BOX SET_BOUNDS SET_MIRROR_MODE
+   OPENCHANNEL DOWNLOADHEADER CLOSECHANNEL POSTSCRIPT_PASSTHROUGH
+   ENCAPSULATED_POSTSCRIPT QDI_SETDIBITS QDI_GETDIBITS QDI_DIBTOSCREEN
+   QDI_STRETCHDIB SP_NOTREPORTED PR_JOBSTATUS ASPECT_FILTERING BS_SOLID
+   BS_NULL BS_HOLLOW BS_HATCHED BS_PATTERN BS_INDEXED BS_DIBPATTERN
+   BS_DIBPATTERNPT BS_PATTERN8X8 BS_DIBPATTERN8X8 LCS_CALIBRATED_RGB
+   LCS_DEVICE_RGB LCS_DEVICE_CMYK LCS_GM_BUSINESS LCS_GM_GRAPHICS
+   LCS_GM_IMAGES RASTER_FONTTYPE DEVICE_FONTTYPE TRUETYPE_FONTTYPE
+   DMORIENT_PORTRAIT DMORIENT_LANDSCAPE DMPAPER_FIRST DMPAPER_LETTER
+   DMPAPER_LETTERSMALL DMPAPER_TABLOID DMPAPER_LEDGER DMPAPER_LEGAL
+   DMPAPER_STATEMENT DMPAPER_EXECUTIVE DMPAPER_A3 DMPAPER_A4 DMPAPER_A4SMALL
+   DMPAPER_A5 DMPAPER_B4 DMPAPER_B5 DMPAPER_FOLIO DMPAPER_QUARTO DMPAPER_10X14
+   DMPAPER_11X17 DMPAPER_NOTE DMPAPER_ENV_9 DMPAPER_ENV_10 DMPAPER_ENV_11
+   DMPAPER_ENV_12 DMPAPER_ENV_14 DMPAPER_CSHEET DMPAPER_DSHEET DMPAPER_ESHEET
+   DMPAPER_ENV_DL DMPAPER_ENV_C5 DMPAPER_ENV_C3 DMPAPER_ENV_C4 DMPAPER_ENV_C6
+   DMPAPER_ENV_C65 DMPAPER_ENV_B4 DMPAPER_ENV_B5 DMPAPER_ENV_B6
+   DMPAPER_ENV_ITALY DMPAPER_ENV_MONARCH DMPAPER_ENV_PERSONAL DMPAPER_FANFOLD_US
+   DMPAPER_FANFOLD_STD_GERMAN DMPAPER_FANFOLD_LGL_GERMAN DMPAPER_ISO_B4
+   DMPAPER_JAPANESE_POSTCARD DMPAPER_9X11 DMPAPER_10X11 DMPAPER_15X11
+   DMPAPER_ENV_INVITE DMPAPER_RESERVED_48 DMPAPER_RESERVED_49
+   DMPAPER_LETTER_EXTRA DMPAPER_LEGAL_EXTRA DMPAPER_TABLOID_EXTRA
+   DMPAPER_A4_EXTRA DMPAPER_LETTER_TRANSVERSE DMPAPER_A4_TRANSVERSE
+   DMPAPER_LETTER_EXTRA_TRANSVERSE DMPAPER_A_PLUS DMPAPER_B_PLUS
+   DMPAPER_LETTER_PLUS DMPAPER_A4_PLUS DMPAPER_A5_TRANSVERSE
+   DMPAPER_B5_TRANSVERSE DMPAPER_A3_EXTRA DMPAPER_A5_EXTRA DMPAPER_B5_EXTRA
+   DMPAPER_A2 DMPAPER_A3_TRANSVERSE DMPAPER_A3_EXTRA_TRANSVERSE DMPAPER_LAST
+   DMPAPER_USER DMBIN_FIRST DMBIN_UPPER DMBIN_ONLYONE DMBIN_LOWER DMBIN_MIDDLE
+   DMBIN_MANUAL DMBIN_ENVELOPE DMBIN_ENVMANUAL DMBIN_AUTO DMBIN_TRACTOR
+   DMBIN_SMALLFMT DMBIN_LARGEFMT DMBIN_LARGECAPACITY DMBIN_CASSETTE
+   DMBIN_FORMSOURCE DMBIN_LAST DMBIN_USER DMCOLOR_MONOCHROME DMCOLOR_COLOR
+   DMDUP_SIMPLEX DMDUP_VERTICAL DMDUP_HORIZONTAL DMTT_BITMAP DMTT_DOWNLOAD
+   DMTT_SUBDEV DMTT_DOWNLOAD_OUTLINE DMCOLLATE_FALSE DMCOLLATE_TRUE
+   DM_GRAYSCALE DM_INTERLACED DM_UPDATE DM_COPY DM_PROMPT DM_MODIFY
+   DM_ORIENTATION DM_PAPERSIZE DM_PAPERLENGTH DM_PAPERWIDTH DM_SCALE DM_COPIES
+   DM_DEFAULTSOURCE DM_PRINTQUALITY DM_COLOR DM_DUPLEX DM_YRESOLUTION
+   DM_TTOPTION DM_COLLATE DM_FORMNAME DM_LOGPIXELS DM_BITSPERPEL DM_PELSWIDTH
+   DM_PELSHEIGHT DM_DISPLAYFLAGS DM_DISPLAYFREQUENCY DM_ICMMETHOD DM_ICMINTENT
+   DM_MEDIATYPE DM_DITHERTYPE DMICMMETHOD_NONE DMICMMETHOD_SYSTEM
+   DMICMMETHOD_DRIVER DMICMMETHOD_DEVICE DMICMMETHOD_USER DMICM_SATURATE
+   DMICM_CONTRAST DMICM_COLORMETRIC DMICM_USER DMMEDIA_STANDARD
+   DMMEDIA_TRANSPARENCY DMMEDIA_GLOSSY DMMEDIA_USER DMDITHER_NONE
+   DMDITHER_COARSE DMDITHER_FINE DMDITHER_LINEART DMDITHER_ERRORDIFFUSION
+   DMDITHER_RESERVED6 DMDITHER_RESERVED7 DMDITHER_RESERVED8 DMDITHER_RESERVED9
+   DMDITHER_GRAYSCALE DMDITHER_USER TMPF_FIXED_PITCH TMPF_VECTOR TMPF_TRUETYPE
+   TMPF_DEVICE NTM_ITALIC NTM_BOLD NTM_REGULAR TT_POLYGON_TYPE TT_PRIM_LINE
+   TT_PRIM_QSPLINE FONTMAPPER_MAX ENHMETA_STOCK_OBJECT WGL_FONT_LINES
+   WGL_FONT_POLYGONS LPD_DOUBLEBUFFER LPD_STEREO LPD_SUPPORT_GDI
+   LPD_SUPPORT_OPENGL LPD_SHARE_DEPTH LPD_SHARE_STENCIL LPD_SHARE_ACCUM
+   LPD_SWAP_EXCHANGE LPD_SWAP_COPY LPD_TRANSPARENT LPD_TYPE_RGBA
+   LPD_TYPE_COLORINDEX IDC_STATIC IDC_ARROW IDC_IBEAM IDC_WAIT IDC_CROSS
+   IDC_UPARROW IDC_SIZENWSE IDC_SIZENESW IDC_SIZEWE IDC_SIZENS IDC_SIZEALL
+   IDC_NO IDC_HAND IDC_APPSTARTING IDC_HELP IDC_ICON IDC_SIZE
+   WGL_SWAP_MAIN_PLANE WGL_SWAP_OVERLAY1 WGL_SWAP_OVERLAY2
+   WGL_SWAP_OVERLAY3 WGL_SWAP_OVERLAY4 WGL_SWAP_OVERLAY5 WGL_SWAP_OVERLAY6
+   WGL_SWAP_OVERLAY7 WGL_SWAP_OVERLAY8 WGL_SWAP_OVERLAY9 WGL_SWAP_OVERLAY10
+   WGL_SWAP_OVERLAY11 WGL_SWAP_OVERLAY12 WGL_SWAP_OVERLAY13 WGL_SWAP_OVERLAY14
+   WGL_SWAP_OVERLAY15 WGL_SWAP_UNDERLAY1 WGL_SWAP_UNDERLAY2 WGL_SWAP_UNDERLAY3
+   WGL_SWAP_UNDERLAY4 WGL_SWAP_UNDERLAY5 WGL_SWAP_UNDERLAY6 WGL_SWAP_UNDERLAY7
+   WGL_SWAP_UNDERLAY8 WGL_SWAP_UNDERLAY9 WGL_SWAP_UNDERLAY10 WGL_SWAP_UNDERLAY11
+   WGL_SWAP_UNDERLAY12 WGL_SWAP_UNDERLAY13 WGL_SWAP_UNDERLAY14
+   WGL_SWAP_UNDERLAY15 RGB
+   WS_BORDER WS_CAPTION WS_CHILD WS_CHILDWINDOW WS_CLIPCHILDREN WS_CLIPSIBLINGS
+   WS_DISABLED WS_DLGFRAME WS_GROUP WS_HSCROLL WS_ICONIC WS_MAXIMIZE
+   WS_MAXIMIZEBOX WS_MINIMIZE WS_MINIMIZEBOX WS_OVERLAPPED WS_OVERLAPPEDWINDOW
+   WS_POPUP WS_POPUPWINDOW WS_SIZEBOX WS_SYSMENU WS_TABSTOP WS_THICKFRAME
+   WS_TILED WS_TILEDWINDOW WS_VISIBLE WS_VSCROLL WS_EX_ACCEPTFILES
+   WS_EX_APPWINDOW WS_EX_CLIENTEDGE WS_EX_CONTEXTHELP WS_EX_CONTROLPARENT
+   WS_EX_DLGMODALFRAME WS_EX_LEFT WS_EX_LEFTSCROLLBAR WS_EX_LTRREADING
+   WS_EX_MDICHILD WS_EX_NOPARENTNOTIFY WS_EX_OVERLAPPEDWINDOW
+   WS_EX_PALETTEWINDOW WS_EX_RIGHT WS_EX_RIGHTSCROLLBAR WS_EX_RTLREADING
+   WS_EX_STATICEDGE WS_EX_TOOLWINDOW WS_EX_TOPMOST WS_EX_TRANSPARENT
+   WS_EX_WINDOWEDGE
+   WM_ACTIVATE WM_ACTIVATEAPP WM_AFXFIRST WM_AFXLAST WM_ASKCBFORMATNAME
+   WM_CANCELJOURNAL WM_CANCELMODE WM_CAPTURECHANGED WM_CHANGECBCHAIN
+   WM_CHAR WM_CHARTOITEM WM_CHILDACTIVATE WM_CLEAR WM_CLOSE WM_COMMAND
+   WM_COMPACTING WM_COMPAREITEM WM_CONTEXTMENU WM_COPY WM_COPYDATA WM_CREATE
+   WM_CTLCOLORBTN WM_CTLCOLORDLG WM_CTLCOLOREDIT WM_CTLCOLORLISTBOX
+   WM_CTLCOLORMSGBOX WM_CTLCOLORSCROLLBAR WM_CTLCOLORSTATIC WM_CUT WM_DEADCHAR
+   WM_DELETEITEM WM_DESTROY WM_DESTROYCLIPBOARD WM_DEVICECHANGE WM_DEVMODECHANGE
+   WM_DISPLAYCHANGE WM_DRAWCLIPBOARD WM_DRAWITEM WM_DROPFILES WM_ENABLE
+   WM_ENDSESSION WM_ENTERIDLE WM_ENTERMENULOOP WM_ENTERSIZEMOVE WM_ERASEBKGND
+   WM_EXITMENULOOP WM_EXITSIZEMOVE WM_FONTCHANGE WM_GETDLGCODE WM_GETFONT
+   WM_GETHOTKEY WM_GETICON WM_GETMINMAXINFO WM_GETTEXT WM_GETTEXTLENGTH
+   WM_HANDHELDFIRST WM_HANDHELDLAST WM_HELP WM_HOTKEY WM_HSCROLL
+   WM_HSCROLLCLIPBOARD WM_ICONERASEBKGND WM_INITDIALOG WM_INITMENU
+   WM_INITMENUPOPUP WM_INPUTLANGCHANGE WM_INPUTLANGCHANGEREQUEST WM_KEYDOWN
+   WM_KEYUP WM_KILLFOCUS WM_MDIACTIVATE WM_MDICASCADE WM_MDICREATE WM_MDIDESTROY
+   WM_MDIGETACTIVE WM_MDIICONARRANGE WM_MDIMAXIMIZE WM_MDINEXT WM_MDIREFRESHMENU
+   WM_MDIRESTORE WM_MDISETMENU WM_MDITILE WM_MEASUREITEM WM_MENUCHAR
+   WM_MENUSELECT WM_NEXTMENU WM_MOVE WM_MOVING WM_NCACTIVATE WM_NCCALCSIZE
+   WM_NCCREATE WM_NCDESTROY WM_NCHITTEST WM_NCLBUTTONDBLCLK WM_NCLBUTTONDOWN
+   WM_NCLBUTTONUP WM_NCMBUTTONDBLCLK WM_NCMBUTTONDOWN WM_NCMBUTTONUP
+   WM_NCMOUSEMOVE WM_NCPAINT WM_NCRBUTTONDBLCLK WM_NCRBUTTONDOWN WM_NCRBUTTONUP
+   WM_NEXTDLGCTL WM_NEXTMENU WM_NOTIFY WM_NOTIFYFORMAT WM_NULL WM_PAINT
+   WM_PAINTCLIPBOARD WM_PAINTICON WM_PALETTECHANGED WM_PALETTEISCHANGING
+   WM_PARENTNOTIFY WM_PASTE WM_PENWINFIRST WM_PENWINLAST WM_POWER
+   WM_POWERBROADCAST WM_PRINT WM_PRINTCLIENT WM_QUERYDRAGICON
+   WM_QUERYENDSESSION WM_QUERYNEWPALETTE WM_QUERYOPEN WM_QUEUESYNC WM_QUIT
+   WM_RENDERALLFORMATS WM_RENDERFORMAT WM_SETCURSOR WM_SETFOCUS WM_SETFONT
+   WM_SETHOTKEY WM_SETICON WM_SETREDRAW WM_SETTEXT WM_SETTINGCHANGE
+   WM_SHOWWINDOW WM_SIZE WM_SIZECLIPBOARD WM_SIZING WM_SPOOLERSTATUS
+   WM_STYLECHANGED WM_STYLECHANGING WM_SYSCHAR WM_SYSCOLORCHANGE WM_SYSCOMMAND
+   WM_SYSDEADCHAR WM_SYSKEYDOWN WM_SYSKEYUP WM_TCARD WM_TIMECHANGE WM_TIMER
+   WM_UNDO WM_USER WM_USERCHANGED WM_VKEYTOITEM WM_VSCROLL WM_VSCROLLCLIPBOARD
+   WM_WINDOWPOSCHANGED WM_WINDOWPOSCHANGING WM_WININICHANGE WM_KEYFIRST
+   WM_KEYLAST WM_SYNCPAINT WM_MOUSEACTIVATE WM_MOUSEMOVE WM_LBUTTONDOWN
+   WM_LBUTTONUP WM_LBUTTONDBLCLK WM_RBUTTONDOWN WM_RBUTTONUP WM_RBUTTONDBLCLK
+   WM_MBUTTONDOWN WM_MBUTTONUP WM_MBUTTONDBLCLK WM_MOUSEWHEEL WM_MOUSEFIRST
+   WM_MOUSELAST WM_MOUSEHOVER WM_MOUSELEAVE
+   SW_HIDE SW_NORMAL SW_SHOWNORMAL SW_SHOWMINIMIZED SW_MAXIMIZE
+   SW_SHOWMAXIMIZED SW_SHOWNOACTIVATE SW_SHOW SW_MINIMIZE SW_SHOWMINNOACTIVE
+   SW_SHOWNA SW_RESTORE SW_SHOWDEFAULT SW_FORCEMINIMIZE SW_MAX
+   SW_PARENTCLOSING SW_OTHERZOOM SW_PARENTOPENING SW_OTHERUNZOOM
+   SW_SCROLLCHILDREN SW_INVALIDATE SW_ERASE))
+
+(in-package "GDI")
+
+(push :gdi *features*)
+(defconstant SM_CXSCREEN 0)
+(defconstant SM_CYSCREEN 1)
+(defconstant SM_CXVSCROLL 2)
+(defconstant SM_CYHSCROLL 3)
+(defconstant SM_CYCAPTION 4)
+(defconstant SM_CXBORDER 5)
+(defconstant SM_CYBORDER 6)
+(defconstant SM_CXDLGFRAME 7)
+(defconstant SM_CXFIXEDFRAME 7)
+(defconstant SM_CYDLGFRAME 8)
+(defconstant SM_CYFIXEDFRAME 8)
+(defconstant SM_CYVTHUMB 9)
+(defconstant SM_CXHTHUMB 10)
+(defconstant SM_CXICON 11)
+(defconstant SM_CYICON 12)
+(defconstant SM_CXCURSOR 13)
+(defconstant SM_CYCURSOR 14)
+(defconstant SM_CYMENU 15)
+(defconstant SM_CXFULLSCREEN 16)
+(defconstant SM_CYFULLSCREEN 17)
+(defconstant SM_CYKANJIWINDOW 18)
+(defconstant SM_MOUSEPRESENT 19)
+(defconstant SM_CYVSCROLL 20)
+(defconstant SM_CXHSCROLL 21)
+(defconstant SM_DEBUG 22)
+(defconstant SM_SWAPBUTTON 23)
+(defconstant SM_RESERVED1 24)
+(defconstant SM_RESERVED2 25)
+(defconstant SM_RESERVED3 26)
+(defconstant SM_RESERVED4 27)
+(defconstant SM_CXMIN 28)
+(defconstant SM_CYMIN 29)
+(defconstant SM_CXSIZE 30)
+(defconstant SM_CYSIZE 31)
+(defconstant SM_CXSIZEFRAME 32)
+(defconstant SM_CXFRAME 32)
+(defconstant SM_CYSIZEFRAME 33)
+(defconstant SM_CYFRAME 33)
+(defconstant SM_CXMINTRACK 34)
+(defconstant SM_CYMINTRACK 35)
+(defconstant SM_CXDOUBLECLK 36)
+(defconstant SM_CYDOUBLECLK 37)
+(defconstant SM_CXICONSPACING 38)
+(defconstant SM_CYICONSPACING 39)
+(defconstant SM_MENUDROPALIGNMENT 40)
+(defconstant SM_PENWINDOWS 41)
+(defconstant SM_DBCSENABLED 42)
+(defconstant SM_CMOUSEBUTTONS 43)
+(defconstant SM_SECURE 44)
+(defconstant SM_CXEDGE 45)
+(defconstant SM_CYEDGE 46)
+(defconstant SM_CXMINSPACING 47)
+(defconstant SM_CYMINSPACING 48)
+(defconstant SM_CXSMICON 49)
+(defconstant SM_CYSMICON 50)
+(defconstant SM_CYSMCAPTION 51)
+(defconstant SM_CXSMSIZE 52)
+(defconstant SM_CYSMSIZE 53)
+(defconstant SM_CXMENUSIZE 54)
+(defconstant SM_CYMENUSIZE 55)
+(defconstant SM_ARRANGE 56)
+(defconstant SM_CXMINIMIZED 57)
+(defconstant SM_CYMINIMIZED 58)
+(defconstant SM_CXMAXTRACK 59)
+(defconstant SM_CYMAXTRACK 60)
+(defconstant SM_CXMAXIMIZED 61)
+(defconstant SM_CYMAXIMIZED 62)
+(defconstant SM_NETWORK 63)
+(defconstant SM_CLEANBOOT 67)
+(defconstant SM_CXDRAG 68)
+(defconstant SM_CYDRAG 69)
+(defconstant SM_SHOWSOUNDS 70)
+(defconstant SM_CXMENUCHECK 71)
+(defconstant SM_CYMENUCHECK 72)
+(defconstant SM_SLOWMACHINE 73)
+(defconstant SM_MIDEASTENABLED 74)
+(defconstant SM_MOUSEWHEELPRESENT 75)
+(defconstant SM_XVIRTUALSCREEN 76)
+(defconstant SM_YVIRTUALSCREEN 77)
+(defconstant SM_CXVIRTUALSCREEN 78)
+(defconstant SM_CYVIRTUALSCREEN 79)
+(defconstant SM_CMONITORS 80)
+(defconstant SM_SAMEDISPLAYFORMAT 81)
+;(defconstant SM_CMETRICS 76) use on versions of nt < 4.0
+(defconstant SM_CMETRICS 83)
+
+(defconstant BI_RGB 0)
+(defconstant BI_RLE8 1)
+(defconstant BI_RLE4 2)
+(defconstant BI_BITFIELDS 3)
+(defconstant LF_FACESIZE 32)
+(defconstant LF_FULLFACESIZE 64)
+(defconstant CA_NEGATIVE 1)
+(defconstant CA_LOG_FILTER 2)
+(defconstant ILLUMINANT_DEVICE_DEFAULT 0)
+(defconstant ILLUMINANT_A 1)
+(defconstant ILLUMINANT_B 2)
+(defconstant ILLUMINANT_C 3)
+(defconstant ILLUMINANT_D50 4)
+(defconstant ILLUMINANT_D55 5)
+(defconstant ILLUMINANT_D65 6)
+(defconstant ILLUMINANT_D75 7)
+(defconstant ILLUMINANT_F2 8)
+(defconstant ILLUMINANT_MAX_INDEX ILLUMINANT_F2)
+(defconstant ILLUMINANT_FLUORESCENT ILLUMINANT_F2)
+(defconstant RGB_GAMMA_MIN 2500)
+(defconstant RGB_GAMMA_MAX 65000)
+(defconstant REFERENCE_WHITE_MIN 6000)
+(defconstant REFERENCE_WHITE_MAX 10000)
+(defconstant REFERENCE_BLACK_MIN 0)
+(defconstant REFERENCE_BLACK_MAX 4000)
+(defconstant COLOR_ADJ_MAX 100)
+(defconstant CCHDEVICENAME 32)
+(defconstant CCHFORMNAME 32)
+(defconstant DI_COMPAT 4)
+(defconstant DI_DEFAULTSIZE 8)
+(defconstant DI_IMAGE 2)
+(defconstant DI_MASK 1)
+(defconstant DI_NORMAL 3)
+(defconstant DI_APPBANDING 1)
+(defconstant EMR_HEADER 1)
+(defconstant EMR_POLYBEZIER 2)
+(defconstant EMR_POLYGON 3)
+(defconstant EMR_POLYLINE 4)
+(defconstant EMR_POLYBEZIERTO 5)
+(defconstant EMR_POLYLINETO 6)
+(defconstant EMR_POLYPOLYLINE 7)
+(defconstant EMR_POLYPOLYGON 8)
+(defconstant EMR_SETWINDOWEXTEX 9)
+(defconstant EMR_SETWINDOWORGEX 10)
+(defconstant EMR_SETVIEWPORTEXTEX 11)
+(defconstant EMR_SETVIEWPORTORGEX 12)
+(defconstant EMR_SETBRUSHORGEX 13)
+(defconstant EMR_EOF 14)
+(defconstant EMR_SETPIXELV 15)
+(defconstant EMR_SETMAPPERFLAGS 16)
+(defconstant EMR_SETMAPMODE 17)
+(defconstant EMR_SETBKMODE 18)
+(defconstant EMR_SETPOLYFILLMODE 19)
+(defconstant EMR_SETROP2 20)
+(defconstant EMR_SETSTRETCHBLTMODE 21)
+(defconstant EMR_SETTEXTALIGN 22)
+(defconstant EMR_SETCOLORADJUSTMENT 23)
+(defconstant EMR_SETTEXTCOLOR 24)
+(defconstant EMR_SETBKCOLOR 25)
+(defconstant EMR_OFFSETCLIPRGN 26)
+(defconstant EMR_MOVETOEX 27)
+(defconstant EMR_SETMETARGN 28)
+(defconstant EMR_EXCLUDECLIPRECT 29)
+(defconstant EMR_INTERSECTCLIPRECT 30)
+(defconstant EMR_SCALEVIEWPORTEXTEX 31)
+(defconstant EMR_SCALEWINDOWEXTEX 32)
+(defconstant EMR_SAVEDC 33)
+(defconstant EMR_RESTOREDC 34)
+(defconstant EMR_SETWORLDTRANSFORM 35)
+(defconstant EMR_MODIFYWORLDTRANSFORM 36)
+(defconstant EMR_SELECTOBJECT 37)
+(defconstant EMR_CREATEPEN 38)
+(defconstant EMR_CREATEBRUSHINDIRECT 39)
+(defconstant EMR_DELETEOBJECT 40)
+(defconstant EMR_ANGLEARC 41)
+(defconstant EMR_ELLIPSE 42)
+(defconstant EMR_RECTANGLE 43)
+(defconstant EMR_ROUNDRECT 44)
+(defconstant EMR_ARC 45)
+(defconstant EMR_CHORD 46)
+(defconstant EMR_PIE 47)
+(defconstant EMR_SELECTPALETTE 48)
+(defconstant EMR_CREATEPALETTE 49)
+(defconstant EMR_SETPALETTEENTRIES 50)
+(defconstant EMR_RESIZEPALETTE 51)
+(defconstant EMR_REALIZEPALETTE 52)
+(defconstant EMR_EXTFLOODFILL 53)
+(defconstant EMR_LINETO 54)
+(defconstant EMR_ARCTO 55)
+(defconstant EMR_POLYDRAW 56)
+(defconstant EMR_SETARCDIRECTION 57)
+(defconstant EMR_SETMITERLIMIT 58)
+(defconstant EMR_BEGINPATH 59)
+(defconstant EMR_ENDPATH 60)
+(defconstant EMR_CLOSEFIGURE 61)
+(defconstant EMR_FILLPATH 62)
+(defconstant EMR_STROKEANDFILLPATH 63)
+(defconstant EMR_STROKEPATH 64)
+(defconstant EMR_FLATTENPATH 65)
+(defconstant EMR_WIDENPATH 66)
+(defconstant EMR_SELECTCLIPPATH 67)
+(defconstant EMR_ABORTPATH 68)
+(defconstant EMR_GDICOMMENT 70)
+(defconstant EMR_FILLRGN 71)
+(defconstant EMR_FRAMERGN 72)
+(defconstant EMR_INVERTRGN 73)
+(defconstant EMR_PAINTRGN 74)
+(defconstant EMR_EXTSELECTCLIPRGN 75)
+(defconstant EMR_BITBLT 76)
+(defconstant EMR_STRETCHBLT 77)
+(defconstant EMR_MASKBLT 78)
+(defconstant EMR_PLGBLT 79)
+(defconstant EMR_SETDIBITSTODEVICE 80)
+(defconstant EMR_STRETCHDIBITS 81)
+(defconstant EMR_EXTCREATEFONTINDIRECTW 82)
+(defconstant EMR_EXTTEXTOUTA 83)
+(defconstant EMR_EXTTEXTOUTW 84)
+(defconstant EMR_POLYBEZIER16 85)
+(defconstant EMR_POLYGON16 86)
+(defconstant EMR_POLYLINE16 87)
+(defconstant EMR_POLYBEZIERTO16 88)
+(defconstant EMR_POLYLINETO16 89)
+(defconstant EMR_POLYPOLYLINE16 90)
+(defconstant EMR_POLYPOLYGON16 91)
+(defconstant EMR_POLYDRAW16 92)
+(defconstant EMR_CREATEMONOBRUSH 93)
+(defconstant EMR_CREATEDIBPATTERNBRUSHPT 94)
+(defconstant EMR_EXTCREATEPEN 95)
+(defconstant EMR_POLYTEXTOUTA 96)
+(defconstant EMR_POLYTEXTOUTW 97)
+(defconstant EMR_SETICMMODE 98)
+(defconstant EMR_CREATECOLORSPACE 99)
+(defconstant EMR_SETCOLORSPACE 100)
+(defconstant EMR_DELETECOLORSPACE 101)
+(defconstant EMR_GLSRECORD 102)
+(defconstant EMR_GLSBOUNDEDRECORD 103)
+(defconstant EMR_PIXELFORMAT 104)
+(defconstant ENHMETA_SIGNATURE 1179469088)
+(defconstant EPS_SIGNATURE #x46535045)
+(defconstant META_SETBKCOLOR #x201)
+(defconstant META_SETBKMODE #x102)
+(defconstant META_SETMAPMODE #x103)
+(defconstant META_SETROP2 #x104)
+(defconstant META_SETRELABS #x105)
+(defconstant META_SETPOLYFILLMODE #x106)
+(defconstant META_SETSTRETCHBLTMODE #x107)
+(defconstant META_SETTEXTCHAREXTRA #x108)
+(defconstant META_SETTEXTCOLOR #x209)
+(defconstant META_SCALEWINDOWEXT #x410)
+(defconstant META_OFFSETVIEWPORTORG #x211)
+(defconstant META_SCALEVIEWPORTEXT #x412)
+(defconstant META_LINETO #x213)
+(defconstant META_MOVETO #x214)
+(defconstant META_EXCLUDECLIPRECT #x415)
+(defconstant META_INTERSECTCLIPRECT #x416)
+(defconstant META_ARC #x817)
+(defconstant META_ELLIPSE #x418)
+(defconstant META_FLOODFILL #x419)
+(defconstant META_OFFSETCLIPRGN #x220)
+(defconstant META_TEXTOUT #x521)
+(defconstant META_BITBLT #x922)
+(defconstant META_STRETCHBLT #xB23)
+(defconstant META_POLYGON #x324)
+(defconstant META_POLYLINE #x325)
+(defconstant META_ESCAPE #x626)
+(defconstant META_RESTOREDC #x127)
+(defconstant META_FILLREGION #x228)
+(defconstant META_FRAMEREGION #x429)
+(defconstant META_CHORD #x830)
+(defconstant META_SETMAPPERFLAGS #x231)
+(defconstant META_EXTTEXTOUT #xa32)
+(defconstant META_SETDIBTODEV #xd33)
+(defconstant META_SELECTPALETTE #x234)
+(defconstant META_REALIZEPALETTE #x35)
+(defconstant META_ANIMATEPALETTE #x436)
+(defconstant META_SETPALENTRIES #x37)
+(defconstant META_POLYPOLYGON #x538)
+(defconstant META_RESIZEPALETTE #x139)
+(defconstant META_DIBBITBLT #x940)
+(defconstant META_DIBSTRETCHBLT #xb41)
+(defconstant META_DIBCREATEPATTERNBRUSH #x142)
+(defconstant META_STRETCHDIB #xf43)
+(defconstant META_EXTFLOODFILL #x548)
+(defconstant META_DELETEOBJECT #x1f0)
+(defconstant META_CREATEPALETTE #xf7)
+(defconstant META_CREATEPATTERNBRUSH #x1F9)
+(defconstant PT_MOVETO 6)
+(defconstant PT_LINETO 2)
+(defconstant PT_BEZIERTO 4)
+(defconstant PT_CLOSEFIGURE 1)
+(defconstant ELF_VENDOR_SIZE 4)
+(defconstant ELF_VERSION 0)
+(defconstant ELF_CULTURE_LATIN 0)
+(defconstant PFD_TYPE_RGBA 0)
+(defconstant PFD_TYPE_COLORINDEX 1)
+(defconstant PFD_MAIN_PLANE 0)
+(defconstant PFD_OVERLAY_PLANE 1)
+(defconstant PFD_DOUBLEBUFFER 1)
+(defconstant PFD_STEREO 2)
+(defconstant PFD_DRAW_TO_WINDOW 4)
+(defconstant PFD_DRAW_TO_BITMAP 8)
+(defconstant PFD_SUPPORT_GDI 16)
+(defconstant PFD_SUPPORT_OPENGL 32)
+(defconstant PFD_GENERIC_FORMAT 64)
+(defconstant PFD_NEED_PALETTE 128)
+(defconstant PFD_NEED_SYSTEM_PALETTE #x00000100)
+(defconstant PFD_SWAP_EXCHANGE #x00000200)
+(defconstant PFD_SWAP_COPY #x00000400)
+(defconstant PFD_DOUBLEBUFFER_DONTCARE #x40000000)
+(defconstant PFD_STEREO_DONTCARE #x80000000)
+(defconstant BLACKNESS #x42)
+(defconstant NOTSRCERASE #x1100A6)
+(defconstant NOTSRCCOPY #x330008)
+(defconstant SRCERASE #x440328)
+(defconstant DSTINVERT #x550009)
+(defconstant PATINVERT #x5A0049)
+(defconstant SRCINVERT #x660046)
+(defconstant SRCAND #x8800C6)
+(defconstant MERGEPAINT #xBB0226)
+(defconstant SRCCOPY #xCC0020)
+(defconstant SRCPAINT #xEE0086)
+(defconstant PATCOPY #xF00021)
+(defconstant PATPAINT #xFB0A09)
+(defconstant WHITENESS #xFF0062)
+(defconstant R2_BLACK 1)
+(defconstant R2_COPYPEN 13)
+(defconstant R2_MASKNOTPEN 3)
+(defconstant R2_MASKPEN 9)
+(defconstant R2_MASKPENNOT 5)
+(defconstant R2_MERGENOTPEN 12)
+(defconstant R2_MERGEPEN 15)
+(defconstant R2_MERGEPENNOT 14)
+(defconstant R2_NOP 11)
+(defconstant R2_NOT 6)
+(defconstant R2_NOTCOPYPEN 4)
+(defconstant R2_NOTMASKPEN 8)
+(defconstant R2_NOTMERGEPEN 2)
+(defconstant R2_NOTXORPEN 10)
+(defconstant R2_WHITE 16)
+(defconstant R2_XORPEN 7)
+(defconstant CM_OUT_OF_GAMUT 255)
+(defconstant CM_IN_GAMUT 0)
+(defconstant RGN_AND 1)
+(defconstant RGN_COPY 5)
+(defconstant RGN_DIFF 4)
+(defconstant RGN_OR 2)
+(defconstant RGN_XOR 3)
+(defconstant NULLREGION 1)
+(defconstant SIMPLEREGION 2)
+(defconstant COMPLEXREGION 3)
+;(defconstant ERROR 0)
+(defconstant CBM_INIT 4)
+(defconstant DIB_PAL_COLORS 1)
+(defconstant DIB_RGB_COLORS 0)
+(defconstant FW_DONTCARE 0)
+(defconstant FW_THIN 100)
+(defconstant FW_EXTRALIGHT 200)
+(defconstant FW_LIGHT 300)
+(defconstant FW_NORMAL 400)
+(defconstant FW_REGULAR 400)
+(defconstant FW_MEDIUM 500)
+(defconstant FW_SEMIBOLD 600)
+(defconstant FW_BOLD 700)
+(defconstant FW_EXTRABOLD 800)
+(defconstant FW_HEAVY 900)
+(defconstant ANSI_CHARSET 0)
+(defconstant DEFAULT_CHARSET 1)
+(defconstant SYMBOL_CHARSET 2)
+(defconstant SHIFTJIS_CHARSET 128)
+(defconstant HANGEUL_CHARSET 129)
+(defconstant HANGUL_CHARSET 129)
+(defconstant GB2312_CHARSET 134)
+(defconstant CHINESEBIG5_CHARSET 136)
+(defconstant GREEK_CHARSET 161)
+(defconstant TURKISH_CHARSET 162)
+(defconstant HEBREW_CHARSET 177)
+(defconstant ARABIC_CHARSET 178)
+(defconstant BALTIC_CHARSET 186)
+(defconstant RUSSIAN_CHARSET 204)
+(defconstant THAI_CHARSET 222)
+(defconstant EASTEUROPE_CHARSET 238)
+(defconstant OEM_CHARSET 255)
+(defconstant JOHAB_CHARSET 130)
+(defconstant VIETNAMESE_CHARSET 163)
+(defconstant MAC_CHARSET 77)
+(defconstant BALTIC_CHARSET 186)
+(defconstant JOHAB_CHARSET 130)
+(defconstant VIETNAMESE_CHARSET 163)
+(defconstant OUT_DEFAULT_PRECIS 0)
+(defconstant OUT_STRING_PRECIS 1)
+(defconstant OUT_CHARACTER_PRECIS 2)
+(defconstant OUT_STROKE_PRECIS 3)
+(defconstant OUT_TT_PRECIS 4)
+(defconstant OUT_DEVICE_PRECIS 5)
+(defconstant OUT_RASTER_PRECIS 6)
+(defconstant OUT_TT_ONLY_PRECIS 7)
+(defconstant OUT_OUTLINE_PRECIS 8)
+(defconstant CLIP_DEFAULT_PRECIS 0)
+(defconstant CLIP_CHARACTER_PRECIS 1)
+(defconstant CLIP_STROKE_PRECIS 2)
+(defconstant CLIP_MASK 15)
+(defconstant CLIP_LH_ANGLES 16)
+(defconstant CLIP_TT_ALWAYS 32)
+(defconstant CLIP_EMBEDDED 128)
+(defconstant DEFAULT_QUALITY 0)
+(defconstant DRAFT_QUALITY 1)
+(defconstant PROOF_QUALITY 2)
+(defconstant NONANTIALIASED_QUALITY 3)
+(defconstant ANTIALIASED_QUALITY 4)
+(defconstant DEFAULT_PITCH 0)
+(defconstant FIXED_PITCH 1)
+(defconstant VARIABLE_PITCH 2)
+(defconstant MONO_FONT 8)
+(defconstant FF_DECORATIVE 80)
+(defconstant FF_DONTCARE 0)
+(defconstant FF_MODERN 48)
+(defconstant FF_ROMAN 16)
+(defconstant FF_SCRIPT 64)
+(defconstant FF_SWISS 32)
+(defconstant PANOSE_COUNT 10)
+(defconstant PAN_FAMILYTYPE_INDEX 0)
+(defconstant PAN_SERIFSTYLE_INDEX 1)
+(defconstant PAN_WEIGHT_INDEX 2)
+(defconstant PAN_PROPORTION_INDEX 3)
+(defconstant PAN_CONTRAST_INDEX 4)
+(defconstant PAN_STROKEVARIATION_INDEX 5)
+(defconstant PAN_ARMSTYLE_INDEX 6)
+(defconstant PAN_LETTERFORM_INDEX 7)
+(defconstant PAN_MIDLINE_INDEX 8)
+(defconstant PAN_XHEIGHT_INDEX 9)
+(defconstant PAN_CULTURE_LATIN 0)
+(defconstant PAN_ANY 0)
+(defconstant PAN_NO_FIT 1)
+(defconstant PAN_FAMILY_TEXT_DISPLAY 2)
+(defconstant PAN_FAMILY_SCRIPT 3)
+(defconstant PAN_FAMILY_DECORATIVE 4)
+(defconstant PAN_FAMILY_PICTORIAL 5)
+(defconstant PAN_SERIF_COVE 2)
+(defconstant PAN_SERIF_OBTUSE_COVE 3)
+(defconstant PAN_SERIF_SQUARE_COVE 4)
+(defconstant PAN_SERIF_OBTUSE_SQUARE_COVE 5)
+(defconstant PAN_SERIF_SQUARE 6)
+(defconstant PAN_SERIF_THIN 7)
+(defconstant PAN_SERIF_BONE 8)
+(defconstant PAN_SERIF_EXAGGERATED 9)
+(defconstant PAN_SERIF_TRIANGLE 10)
+(defconstant PAN_SERIF_NORMAL_SANS 11)
+(defconstant PAN_SERIF_OBTUSE_SANS 12)
+(defconstant PAN_SERIF_PERP_SANS 13)
+(defconstant PAN_SERIF_FLARED 14)
+(defconstant PAN_SERIF_ROUNDED 15)
+(defconstant PAN_WEIGHT_VERY_LIGHT 2)
+(defconstant PAN_WEIGHT_LIGHT 3)
+(defconstant PAN_WEIGHT_THIN 4)
+(defconstant PAN_WEIGHT_BOOK 5)
+(defconstant PAN_WEIGHT_MEDIUM 6)
+(defconstant PAN_WEIGHT_DEMI 7)
+(defconstant PAN_WEIGHT_BOLD 8)
+(defconstant PAN_WEIGHT_HEAVY 9)
+(defconstant PAN_WEIGHT_BLACK 10)
+(defconstant PAN_WEIGHT_NORD 11)
+(defconstant PAN_PROP_OLD_STYLE 2)
+(defconstant PAN_PROP_MODERN 3)
+(defconstant PAN_PROP_EVEN_WIDTH 4)
+(defconstant PAN_PROP_EXPANDED 5)
+(defconstant PAN_PROP_CONDENSED 6)
+(defconstant PAN_PROP_VERY_EXPANDED 7)
+(defconstant PAN_PROP_VERY_CONDENSED 8)
+(defconstant PAN_PROP_MONOSPACED 9)
+(defconstant PAN_CONTRAST_NONE 2)
+(defconstant PAN_CONTRAST_VERY_LOW 3)
+(defconstant PAN_CONTRAST_LOW 4)
+(defconstant PAN_CONTRAST_MEDIUM_LOW 5)
+(defconstant PAN_CONTRAST_MEDIUM 6)
+(defconstant PAN_CONTRAST_MEDIUM_HIGH 7)
+(defconstant PAN_CONTRAST_HIGH 8)
+(defconstant PAN_CONTRAST_VERY_HIGH 9)
+(defconstant PAN_STROKE_GRADUAL_DIAG 2)
+(defconstant PAN_STROKE_GRADUAL_TRAN 3)
+(defconstant PAN_STROKE_GRADUAL_VERT 4)
+(defconstant PAN_STROKE_GRADUAL_HORZ 5)
+(defconstant PAN_STROKE_RAPID_VERT 6)
+(defconstant PAN_STROKE_RAPID_HORZ 7)
+(defconstant PAN_STROKE_INSTANT_VERT 8)
+(defconstant PAN_STRAIGHT_ARMS_HORZ 2)
+(defconstant PAN_STRAIGHT_ARMS_WEDGE 3)
+(defconstant PAN_STRAIGHT_ARMS_VERT 4)
+(defconstant PAN_STRAIGHT_ARMS_SINGLE_SERIF 5)
+(defconstant PAN_STRAIGHT_ARMS_DOUBLE_SERIF 6)
+(defconstant PAN_BENT_ARMS_HORZ 7)
+(defconstant PAN_BENT_ARMS_WEDGE 8)
+(defconstant PAN_BENT_ARMS_VERT 9)
+(defconstant PAN_BENT_ARMS_SINGLE_SERIF 10)
+(defconstant PAN_BENT_ARMS_DOUBLE_SERIF 11)
+(defconstant PAN_LETT_NORMAL_CONTACT 2)
+(defconstant PAN_LETT_NORMAL_WEIGHTED 3)
+(defconstant PAN_LETT_NORMAL_BOXED 4)
+(defconstant PAN_LETT_NORMAL_FLATTENED 5)
+(defconstant PAN_LETT_NORMAL_ROUNDED 6)
+(defconstant PAN_LETT_NORMAL_OFF_CENTER 7)
+(defconstant PAN_LETT_NORMAL_SQUARE 8)
+(defconstant PAN_LETT_OBLIQUE_CONTACT 9)
+(defconstant PAN_LETT_OBLIQUE_WEIGHTED 10)
+(defconstant PAN_LETT_OBLIQUE_BOXED 11)
+(defconstant PAN_LETT_OBLIQUE_FLATTENED 12)
+(defconstant PAN_LETT_OBLIQUE_ROUNDED 13)
+(defconstant PAN_LETT_OBLIQUE_OFF_CENTER 14)
+(defconstant PAN_LETT_OBLIQUE_SQUARE 15)
+(defconstant PAN_MIDLINE_STANDARD_TRIMMED 2)
+(defconstant PAN_MIDLINE_STANDARD_POINTED 3)
+(defconstant PAN_MIDLINE_STANDARD_SERIFED 4)
+(defconstant PAN_MIDLINE_HIGH_TRIMMED 5)
+(defconstant PAN_MIDLINE_HIGH_POINTED 6)
+(defconstant PAN_MIDLINE_HIGH_SERIFED 7)
+(defconstant PAN_MIDLINE_CONSTANT_TRIMMED 8)
+(defconstant PAN_MIDLINE_CONSTANT_POINTED 9)
+(defconstant PAN_MIDLINE_CONSTANT_SERIFED 10)
+(defconstant PAN_MIDLINE_LOW_TRIMMED 11)
+(defconstant PAN_MIDLINE_LOW_POINTED 12)
+(defconstant PAN_MIDLINE_LOW_SERIFED 13)
+(defconstant PAN_XHEIGHT_CONSTANT_SMALL 2)
+(defconstant PAN_XHEIGHT_CONSTANT_STD 3)
+(defconstant PAN_XHEIGHT_CONSTANT_LARGE 4)
+(defconstant PAN_XHEIGHT_DUCKING_SMALL 5)
+(defconstant PAN_XHEIGHT_DUCKING_STD 6)
+(defconstant PAN_XHEIGHT_DUCKING_LARGE 7)
+(defconstant FS_LATIN1 1)
+(defconstant FS_LATIN2 2)
+(defconstant FS_CYRILLIC 4)
+(defconstant FS_GREEK 8)
+(defconstant FS_TURKISH 16)
+(defconstant FS_HEBREW 32)
+(defconstant FS_ARABIC 64)
+(defconstant FS_BALTIC 128)
+(defconstant FS_THAI #x10000)
+(defconstant FS_JISJAPAN #x20000)
+(defconstant FS_CHINESESIMP #x40000)
+(defconstant FS_WANSUNG #x80000)
+(defconstant FS_CHINESETRAD #x100000)
+(defconstant FS_JOHAB #x200000)
+(defconstant FS_SYMBOL #x80000000)
+(defconstant HS_BDIAGONAL 3)
+(defconstant HS_CROSS 4)
+(defconstant HS_DIAGCROSS 5)
+(defconstant HS_FDIAGONAL 2)
+(defconstant HS_HORIZONTAL 0)
+(defconstant HS_VERTICAL 1)
+(defconstant PS_GEOMETRIC 65536)
+(defconstant PS_COSMETIC 0)
+(defconstant PS_ALTERNATE 8)
+(defconstant PS_SOLID 0)
+(defconstant PS_DASH 1)
+(defconstant PS_DOT 2)
+(defconstant PS_DASHDOT 3)
+(defconstant PS_DASHDOTDOT 4)
+(defconstant PS_NULL 5)
+(defconstant PS_USERSTYLE 7)
+(defconstant PS_INSIDEFRAME 6)
+(defconstant PS_ENDCAP_ROUND 0)
+(defconstant PS_ENDCAP_SQUARE 256)
+(defconstant PS_ENDCAP_FLAT 512)
+(defconstant PS_JOIN_BEVEL 4096)
+(defconstant PS_JOIN_MITER 8192)
+(defconstant PS_JOIN_ROUND 0)
+(defconstant PS_STYLE_MASK 15)
+(defconstant PS_ENDCAP_MASK 3840)
+(defconstant PS_TYPE_MASK 983040)
+(defconstant ALTERNATE 1)
+(defconstant WINDING 2)
+(defconstant DC_BINNAMES 12)
+(defconstant DC_BINS 6)
+(defconstant DC_COPIES 18)
+(defconstant DC_DRIVER 11)
+(defconstant DC_DATATYPE_PRODUCED 21)
+(defconstant DC_DUPLEX 7)
+(defconstant DC_EMF_COMPLIANT 20)
+(defconstant DC_ENUMRESOLUTIONS 13)
+(defconstant DC_EXTRA 9)
+(defconstant DC_FIELDS 1)
+(defconstant DC_FILEDEPENDENCIES 14)
+(defconstant DC_MAXEXTENT 5)
+(defconstant DC_MINEXTENT 4)
+(defconstant DC_ORIENTATION 17)
+(defconstant DC_PAPERNAMES 16)
+(defconstant DC_PAPERS 2)
+(defconstant DC_PAPERSIZE 3)
+(defconstant DC_SIZE 8)
+(defconstant DC_TRUETYPE 15)
+(defconstant DCTT_BITMAP 1)
+(defconstant DCTT_DOWNLOAD 2)
+(defconstant DCTT_SUBDEV 4)
+(defconstant DCTT_DOWNLOAD_OUTLINE 8)
+(defconstant DC_VERSION 10)
+(defconstant DC_BINADJUST 19)
+(defconstant DC_EMF_COMPLIANT 20)
+(defconstant DC_DATATYPE_PRODUCED 21)
+(defconstant DC_MANUFACTURER 23)
+(defconstant DC_MODEL 24)
+(defconstant DCBA_FACEUPNONE 0)
+(defconstant DCBA_FACEUPCENTER 1)
+(defconstant DCBA_FACEUPLEFT 2)
+(defconstant DCBA_FACEUPRIGHT 3)
+(defconstant DCBA_FACEDOWNNONE 256)
+(defconstant DCBA_FACEDOWNCENTER 257)
+(defconstant DCBA_FACEDOWNLEFT 258)
+(defconstant DCBA_FACEDOWNRIGHT 259)
+(defconstant FLOODFILLBORDER 0)
+(defconstant FLOODFILLSURFACE 1)
+(defconstant ETO_CLIPPED 4)
+(defconstant ETO_GLYPH_INDEX 16)
+(defconstant ETO_OPAQUE 2)
+(defconstant ETO_RTLREADING 128)
+(defconstant GDICOMMENT_BEGINGROUP 2)
+(defconstant GDICOMMENT_ENDGROUP 3)
+(defconstant GDICOMMENT_MULTIFORMATS 1073741828)
+(defconstant GDICOMMENT_IDENTIFIER 1128875079)
+(defconstant AD_COUNTERCLOCKWISE 1)
+(defconstant AD_CLOCKWISE 2)
+(defconstant RDH_RECTANGLES 1)
+(defconstant GCPCLASS_LATIN 1)
+(defconstant GCPCLASS_HEBREW 2)
+(defconstant GCPCLASS_ARABIC 2)
+(defconstant GCPCLASS_NEUTRAL 3)
+(defconstant GCPCLASS_LOCALNUMBER 4)
+(defconstant GCPCLASS_LATINNUMBER 5)
+(defconstant GCPCLASS_LATINNUMERICTERMINATOR 6)
+(defconstant GCPCLASS_LATINNUMERICSEPARATOR 7)
+(defconstant GCPCLASS_NUMERICSEPARATOR 8)
+(defconstant GCPCLASS_PREBOUNDLTR 128)
+(defconstant GCPCLASS_PREBOUNDRTL 64)
+(defconstant GCPCLASS_POSTBOUNDLTR 32)
+(defconstant GCPCLASS_POSTBOUNDRTL 16)
+(defconstant GCPGLYPH_LINKBEFORE #x8000)
+(defconstant GCPGLYPH_LINKAFTER #x4000)
+(defconstant DCB_DISABLE 8)
+(defconstant DCB_ENABLE 4)
+(defconstant DCB_RESET 1)
+(defconstant DCB_SET 3)
+(defconstant DCB_ACCUMULATE 2)
+(defconstant DCB_DIRTY 2)
+(defconstant OBJ_BRUSH 2)
+(defconstant OBJ_PEN 1)
+(defconstant OBJ_PAL 5)
+(defconstant OBJ_FONT 6)
+(defconstant OBJ_BITMAP 7)
+(defconstant OBJ_EXTPEN 11)
+(defconstant OBJ_REGION 8)
+(defconstant OBJ_DC 3)
+(defconstant OBJ_MEMDC 10)
+(defconstant OBJ_METAFILE 9)
+(defconstant OBJ_METADC 4)
+(defconstant OBJ_ENHMETAFILE 13)
+(defconstant OBJ_ENHMETADC 12)
+(defconstant DRIVERVERSION 0)
+(defconstant TECHNOLOGY 2)
+(defconstant DT_PLOTTER 0)
+(defconstant DT_RASDISPLAY 1)
+(defconstant DT_RASPRINTER 2)
+(defconstant DT_RASCAMERA 3)
+(defconstant DT_CHARSTREAM 4)
+(defconstant DT_METAFILE 5)
+(defconstant DT_DISPFILE 6)
+(defconstant HORZSIZE 4)
+(defconstant VERTSIZE 6)
+(defconstant HORZRES 8)
+(defconstant VERTRES 10)
+(defconstant LOGPIXELSX 88)
+(defconstant LOGPIXELSY 90)
+(defconstant BITSPIXEL 12)
+(defconstant PLANES 14)
+(defconstant NUMBRUSHES 16)
+(defconstant NUMPENS 18)
+(defconstant NUMFONTS 22)
+(defconstant NUMCOLORS 24)
+(defconstant NUMMARKERS 20)
+(defconstant ASPECTX 40)
+(defconstant ASPECTY 42)
+(defconstant ASPECTXY 44)
+(defconstant PDEVICESIZE 26)
+(defconstant CLIPCAPS 36)
+(defconstant SIZEPALETTE 104)
+(defconstant NUMRESERVED 106)
+(defconstant COLORRES 108)
+(defconstant PHYSICALWIDTH 110)
+(defconstant PHYSICALHEIGHT 111)
+(defconstant PHYSICALOFFSETX 112)
+(defconstant PHYSICALOFFSETY 113)
+(defconstant SCALINGFACTORX 114)
+(defconstant SCALINGFACTORY 115)
+(defconstant VREFRESH 116)
+(defconstant DESKTOPHORZRES 118)
+(defconstant DESKTOPVERTRES 117)
+(defconstant BLTALIGNMENT 119)
+(defconstant RASTERCAPS 38)
+(defconstant RC_BANDING 2)
+(defconstant RC_BITBLT 1)
+(defconstant RC_BITMAP64 8)
+(defconstant RC_DI_BITMAP 128)
+(defconstant RC_DIBTODEV 512)
+(defconstant RC_FLOODFILL 4096)
+(defconstant RC_GDI20_OUTPUT 16)
+(defconstant RC_PALETTE 256)
+(defconstant RC_SCALING 4)
+(defconstant RC_STRETCHBLT 2048)
+(defconstant RC_STRETCHDIB 8192)
+(defconstant RC_DEVBITS #x8000)
+(defconstant RC_OP_DX_OUTPUT #x4000)
+(defconstant CURVECAPS 28)
+(defconstant CC_NONE 0)
+(defconstant CC_CIRCLES 1)
+(defconstant CC_PIE 2)
+(defconstant CC_CHORD 4)
+(defconstant CC_ELLIPSES 8)
+(defconstant CC_WIDE 16)
+(defconstant CC_STYLED 32)
+(defconstant CC_WIDESTYLED 64)
+(defconstant CC_INTERIORS 128)
+(defconstant CC_ROUNDRECT 256)
+(defconstant LINECAPS 30)
+(defconstant LC_NONE 0)
+(defconstant LC_POLYLINE 2)
+(defconstant LC_MARKER 4)
+(defconstant LC_POLYMARKER 8)
+(defconstant LC_WIDE 16)
+(defconstant LC_STYLED 32)
+(defconstant LC_WIDESTYLED 64)
+(defconstant LC_INTERIORS 128)
+(defconstant POLYGONALCAPS 32)
+(defconstant RC_BANDING 2)
+(defconstant RC_BIGFONT 1024)
+(defconstant RC_BITBLT 1)
+(defconstant RC_BITMAP64 8)
+(defconstant RC_DEVBITS #x8000)
+(defconstant RC_DI_BITMAP 128)
+(defconstant RC_GDI20_OUTPUT 16)
+(defconstant RC_GDI20_STATE 32)
+(defconstant RC_NONE 0)
+(defconstant RC_OP_DX_OUTPUT #x4000)
+(defconstant RC_PALETTE 256)
+(defconstant RC_SAVEBITMAP 64)
+(defconstant RC_SCALING 4)
+(defconstant PC_NONE 0)
+(defconstant PC_POLYGON 1)
+(defconstant PC_POLYPOLYGON 256)
+(defconstant PC_PATHS 512)
+(defconstant PC_RECTANGLE 2)
+(defconstant PC_WINDPOLYGON 4)
+(defconstant PC_SCANLINE 8)
+(defconstant PC_TRAPEZOID 4)
+(defconstant PC_WIDE 16)
+(defconstant PC_STYLED 32)
+(defconstant PC_WIDESTYLED 64)
+(defconstant PC_INTERIORS 128)
+(defconstant PC_PATHS 512)
+(defconstant TEXTCAPS 34)
+(defconstant TC_OP_CHARACTER 1)
+(defconstant TC_OP_STROKE 2)
+(defconstant TC_CP_STROKE 4)
+(defconstant TC_CR_90 8)
+(defconstant TC_CR_ANY 16)
+(defconstant TC_SF_X_YINDEP 32)
+(defconstant TC_SA_DOUBLE 64)
+(defconstant TC_SA_INTEGER 128)
+(defconstant TC_SA_CONTIN 256)
+(defconstant TC_EA_DOUBLE 512)
+(defconstant TC_IA_ABLE 1024)
+(defconstant TC_UA_ABLE 2048)
+(defconstant TC_SO_ABLE 4096)
+(defconstant TC_RA_ABLE 8192)
+(defconstant TC_VA_ABLE 16384)
+(defconstant TC_RESERVED 32768)
+(defconstant TC_SCROLLBLT 65536)
+(defconstant GCP_DBCS 1)
+(defconstant GCP_ERROR #x8000)
+(defconstant GCP_CLASSIN #x80000)
+(defconstant GCP_DIACRITIC 256)
+(defconstant GCP_DISPLAYZWG #x400000)
+(defconstant GCP_GLYPHSHAPE 16)
+(defconstant GCP_JUSTIFY #x10000)
+(defconstant GCP_JUSTIFYIN #x200000)
+(defconstant GCP_KASHIDA 1024)
+(defconstant GCP_LIGATE 32)
+(defconstant GCP_MAXEXTENT #x100000)
+(defconstant GCP_NEUTRALOVERRIDE #x2000000)
+(defconstant GCP_NUMERICOVERRIDE #x1000000)
+(defconstant GCP_NUMERICSLATIN #x4000000)
+(defconstant GCP_NUMERICSLOCAL #x8000000)
+(defconstant GCP_REORDER 2)
+(defconstant GCP_SYMSWAPOFF #x800000)
+(defconstant GCP_USEKERNING 8)
+(defconstant FLI_GLYPHS #x40000)
+(defconstant GGO_BITMAP 1)
+(defconstant GGO_NATIVE 2)
+(defconstant GGO_METRICS 0)
+(defconstant GGO_GRAY2_BITMAP 4)
+(defconstant GGO_GRAY4_BITMAP 5)
+(defconstant GGO_GRAY8_BITMAP 6)
+(defconstant GGO_GLYPH_INDEX 128)
+(defconstant GM_COMPATIBLE 1)
+(defconstant GM_ADVANCED 2)
+(defconstant MM_ANISOTROPIC 8)
+(defconstant MM_HIENGLISH 5)
+(defconstant MM_HIMETRIC 3)
+(defconstant MM_ISOTROPIC 7)
+(defconstant MM_LOENGLISH 4)
+(defconstant MM_LOMETRIC 2)
+(defconstant MM_TEXT 1)
+(defconstant MM_TWIPS 6)
+(defconstant ABSOLUTE 1)
+(defconstant RELATIVE 2)
+(defconstant PC_EXPLICIT 2)
+(defconstant PC_NOCOLLAPSE 4)
+(defconstant PC_RESERVED 1)
+(defconstant CLR_DEFAULT #xff000000)
+(defconstant PT_MOVETO 6)
+(defconstant PT_LINETO 2)
+(defconstant PT_BEZIERTO 4)
+(defconstant PT_CLOSEFIGURE 1)
+(defconstant TT_AVAILABLE 1)
+(defconstant TT_ENABLED 2)
+(defconstant BLACK_BRUSH 4)
+(defconstant DKGRAY_BRUSH 3)
+(defconstant GRAY_BRUSH 2)
+(defconstant HOLLOW_BRUSH 5)
+(defconstant LTGRAY_BRUSH 1)
+(defconstant NULL_BRUSH 5)
+(defconstant WHITE_BRUSH 0)
+(defconstant BLACK_PEN 7)
+(defconstant NULL_PEN 8)
+(defconstant WHITE_PEN 6)
+(defconstant ANSI_FIXED_FONT 11)
+(defconstant ANSI_VAR_FONT 12)
+(defconstant DEVICE_DEFAULT_FONT 14)
+(defconstant DEFAULT_GUI_FONT 17)
+(defconstant OEM_FIXED_FONT 10)
+(defconstant SYSTEM_FONT 13)
+(defconstant SYSTEM_FIXED_FONT 16)
+(defconstant DEFAULT_PALETTE 15)
+(defconstant SYSPAL_NOSTATIC 2)
+(defconstant SYSPAL_STATIC 1)
+(defconstant SYSPAL_ERROR 0)
+(defconstant TA_BASELINE 24)
+(defconstant TA_BOTTOM 8)
+(defconstant TA_TOP 0)
+(defconstant TA_CENTER 6)
+(defconstant TA_LEFT 0)
+(defconstant TA_RIGHT 2)
+(defconstant TA_RTLREADING 256)
+(defconstant TA_NOUPDATECP 0)
+(defconstant TA_UPDATECP 1)
+(defconstant VTA_BASELINE 24)
+(defconstant VTA_CENTER 6)
+(defconstant MWT_IDENTITY 1)
+(defconstant MWT_LEFTMULTIPLY 2)
+(defconstant MWT_RIGHTMULTIPLY 3)
+(defconstant OPAQUE 2)
+(defconstant TRANSPARENT 1)
+(defconstant BLACKONWHITE 1)
+(defconstant WHITEONBLACK 2)
+(defconstant COLORONCOLOR 3)
+(defconstant HALFTONE 4)
+(defconstant MAXSTRETCHBLTMODE 4)
+(defconstant STRETCH_ANDSCANS 1)
+(defconstant STRETCH_DELETESCANS 3)
+(defconstant STRETCH_HALFTONE 4)
+(defconstant STRETCH_ORSCANS 2)
+(defconstant TCI_SRCCHARSET 1)
+(defconstant TCI_SRCCODEPAGE 2)
+(defconstant TCI_SRCFONTSIG 3)
+(defconstant ICM_ON 2)
+(defconstant ICM_OFF 1)
+(defconstant ICM_QUERY 3)
+(defconstant NEWFRAME 1)
+(defconstant ABORTDOC 2)
+(defconstant NEXTBAND 3)
+(defconstant SETCOLORTABLE 4)
+(defconstant GETCOLORTABLE 5)
+(defconstant FLUSHOUTPUT 6)
+(defconstant DRAFTMODE 7)
+(defconstant QUERYESCSUPPORT 8)
+(defconstant SETABORTPROC 9)
+(defconstant STARTDOC 10)
+(defconstant ENDDOC 11)
+(defconstant GETPHYSPAGESIZE 12)
+(defconstant GETPRINTINGOFFSET 13)
+(defconstant GETSCALINGFACTOR 14)
+(defconstant MFCOMMENT 15)
+(defconstant GETPENWIDTH 16)
+(defconstant SETCOPYCOUNT 17)
+(defconstant SELECTPAPERSOURCE 18)
+(defconstant DEVICEDATA 19)
+(defconstant PASSTHROUGH 19)
+(defconstant GETTECHNOLGY 20)
+(defconstant GETTECHNOLOGY 20)
+(defconstant SETLINECAP 21)
+(defconstant SETLINEJOIN 22)
+(defconstant SETMITERLIMIT 23)
+(defconstant BANDINFO 24)
+(defconstant DRAWPATTERNRECT 25)
+(defconstant GETVECTORPENSIZE 26)
+(defconstant GETVECTORBRUSHSIZE 27)
+(defconstant ENABLEDUPLEX 28)
+(defconstant GETSETPAPERBINS 29)
+(defconstant GETSETPRINTORIENT 30)
+(defconstant ENUMPAPERBINS 31)
+(defconstant SETDIBSCALING 32)
+(defconstant EPSPRINTING 33)
+(defconstant ENUMPAPERMETRICS 34)
+(defconstant GETSETPAPERMETRICS 35)
+(defconstant POSTSCRIPT_DATA 37)
+(defconstant POSTSCRIPT_IGNORE 38)
+(defconstant MOUSETRAILS 39)
+(defconstant GETDEVICEUNITS 42)
+(defconstant GETEXTENDEDTEXTMETRICS 256)
+(defconstant GETEXTENTTABLE 257)
+(defconstant GETPAIRKERNTABLE 258)
+(defconstant GETTRACKKERNTABLE 259)
+(defconstant EXTTEXTOUT 512)
+(defconstant GETFACENAME 513)
+(defconstant DOWNLOADFACE 514)
+(defconstant ENABLERELATIVEWIDTHS 768)
+(defconstant ENABLEPAIRKERNING 769)
+(defconstant SETKERNTRACK 770)
+(defconstant SETALLJUSTVALUES 771)
+(defconstant SETCHARSET 772)
+(defconstant STRETCHBLT 2048)
+(defconstant GETSETSCREENPARAMS 3072)
+(defconstant QUERYDIBSUPPORT 3073)
+(defconstant BEGIN_PATH 4096)
+(defconstant CLIP_TO_PATH 4097)
+(defconstant END_PATH 4098)
+(defconstant EXT_DEVICE_CAPS 4099)
+(defconstant RESTORE_CTM 4100)
+(defconstant SAVE_CTM 4101)
+(defconstant SET_ARC_DIRECTION 4102)
+(defconstant SET_BACKGROUND_COLOR 4103)
+(defconstant SET_POLY_MODE 4104)
+(defconstant SET_SCREEN_ANGLE 4105)
+(defconstant SET_SPREAD 4106)
+(defconstant TRANSFORM_CTM 4107)
+(defconstant SET_CLIP_BOX 4108)
+(defconstant SET_BOUNDS 4109)
+(defconstant SET_MIRROR_MODE 4110)
+(defconstant OPENCHANNEL 4110)
+(defconstant DOWNLOADHEADER 4111)
+(defconstant CLOSECHANNEL 4112)
+(defconstant POSTSCRIPT_PASSTHROUGH 4115)
+(defconstant ENCAPSULATED_POSTSCRIPT 4116)
+(defconstant QDI_SETDIBITS 1)
+(defconstant QDI_GETDIBITS 2)
+(defconstant QDI_DIBTOSCREEN 4)
+(defconstant QDI_STRETCHDIB 8)
+(defconstant SP_NOTREPORTED #x4000)
+(defconstant PR_JOBSTATUS 0)
+(defconstant ASPECT_FILTERING 1)
+(defconstant BS_SOLID 0)
+(defconstant BS_NULL 1)
+(defconstant BS_HOLLOW 1)
+(defconstant BS_HATCHED 2)
+(defconstant BS_PATTERN 3)
+(defconstant BS_INDEXED 4)
+(defconstant BS_DIBPATTERN 5)
+(defconstant BS_DIBPATTERNPT 6)
+(defconstant BS_PATTERN8X8 7)
+(defconstant BS_DIBPATTERN8X8 8)
+(defconstant LCS_CALIBRATED_RGB 0)
+(defconstant LCS_DEVICE_RGB 1)
+(defconstant LCS_DEVICE_CMYK 2)
+(defconstant LCS_GM_BUSINESS 1)
+(defconstant LCS_GM_GRAPHICS 2)
+(defconstant LCS_GM_IMAGES 4)
+(defconstant RASTER_FONTTYPE 1)
+(defconstant DEVICE_FONTTYPE 2)
+(defconstant TRUETYPE_FONTTYPE 4)
+(defconstant DMORIENT_PORTRAIT 1)
+(defconstant DMORIENT_LANDSCAPE 2)
+(defconstant DMPAPER_FIRST 1)
+(defconstant DMPAPER_LETTER 1)
+(defconstant DMPAPER_LETTERSMALL 2)
+(defconstant DMPAPER_TABLOID 3)
+(defconstant DMPAPER_LEDGER 4)
+(defconstant DMPAPER_LEGAL 5)
+(defconstant DMPAPER_STATEMENT 6)
+(defconstant DMPAPER_EXECUTIVE 7)
+(defconstant DMPAPER_A3 8)
+(defconstant DMPAPER_A4 9)
+(defconstant DMPAPER_A4SMALL 10)
+(defconstant DMPAPER_A5 11)
+(defconstant DMPAPER_B4 12)
+(defconstant DMPAPER_B5 13)
+(defconstant DMPAPER_FOLIO 14)
+(defconstant DMPAPER_QUARTO 15)
+(defconstant DMPAPER_10X14 16)
+(defconstant DMPAPER_11X17 17)
+(defconstant DMPAPER_NOTE 18)
+(defconstant DMPAPER_ENV_9 19)
+(defconstant DMPAPER_ENV_10 20)
+(defconstant DMPAPER_ENV_11 21)
+(defconstant DMPAPER_ENV_12 22)
+(defconstant DMPAPER_ENV_14 23)
+(defconstant DMPAPER_CSHEET 24)
+(defconstant DMPAPER_DSHEET 25)
+(defconstant DMPAPER_ESHEET 26)
+(defconstant DMPAPER_ENV_DL 27)
+(defconstant DMPAPER_ENV_C5 28)
+(defconstant DMPAPER_ENV_C3 29)
+(defconstant DMPAPER_ENV_C4 30)
+(defconstant DMPAPER_ENV_C6 31)
+(defconstant DMPAPER_ENV_C65 32)
+(defconstant DMPAPER_ENV_B4 33)
+(defconstant DMPAPER_ENV_B5 34)
+(defconstant DMPAPER_ENV_B6 35)
+(defconstant DMPAPER_ENV_ITALY 36)
+(defconstant DMPAPER_ENV_MONARCH 37)
+(defconstant DMPAPER_ENV_PERSONAL 38)
+(defconstant DMPAPER_FANFOLD_US 39)
+(defconstant DMPAPER_FANFOLD_STD_GERMAN 40)
+(defconstant DMPAPER_FANFOLD_LGL_GERMAN 41)
+(defconstant DMPAPER_ISO_B4 42)
+(defconstant DMPAPER_JAPANESE_POSTCARD 43)
+(defconstant DMPAPER_9X11 44)
+(defconstant DMPAPER_10X11 45)
+(defconstant DMPAPER_15X11 46)
+(defconstant DMPAPER_ENV_INVITE 47)
+(defconstant DMPAPER_RESERVED_48 48)
+(defconstant DMPAPER_RESERVED_49 49)
+(defconstant DMPAPER_LETTER_EXTRA 50)
+(defconstant DMPAPER_LEGAL_EXTRA 51)
+(defconstant DMPAPER_TABLOID_EXTRA 52)
+(defconstant DMPAPER_A4_EXTRA 53)
+(defconstant DMPAPER_LETTER_TRANSVERSE 54)
+(defconstant DMPAPER_A4_TRANSVERSE 55)
+(defconstant DMPAPER_LETTER_EXTRA_TRANSVERSE 56)
+(defconstant DMPAPER_A_PLUS 57)
+(defconstant DMPAPER_B_PLUS 58)
+(defconstant DMPAPER_LETTER_PLUS 59)
+(defconstant DMPAPER_A4_PLUS 60)
+(defconstant DMPAPER_A5_TRANSVERSE 61)
+(defconstant DMPAPER_B5_TRANSVERSE 62)
+(defconstant DMPAPER_A3_EXTRA 63)
+(defconstant DMPAPER_A5_EXTRA 64)
+(defconstant DMPAPER_B5_EXTRA 65)
+(defconstant DMPAPER_A2 66)
+(defconstant DMPAPER_A3_TRANSVERSE 67)
+(defconstant DMPAPER_A3_EXTRA_TRANSVERSE 68)
+(defconstant DMPAPER_LAST 68)
+(defconstant DMPAPER_USER 256)
+(defconstant DMBIN_FIRST 1)
+(defconstant DMBIN_UPPER 1)
+(defconstant DMBIN_ONLYONE 1)
+(defconstant DMBIN_LOWER 2)
+(defconstant DMBIN_MIDDLE 3)
+(defconstant DMBIN_MANUAL 4)
+(defconstant DMBIN_ENVELOPE 5)
+(defconstant DMBIN_ENVMANUAL 6)
+(defconstant DMBIN_AUTO 7)
+(defconstant DMBIN_TRACTOR 8)
+(defconstant DMBIN_SMALLFMT 9)
+(defconstant DMBIN_LARGEFMT 10)
+(defconstant DMBIN_LARGECAPACITY 11)
+(defconstant DMBIN_CASSETTE 14)
+(defconstant DMBIN_FORMSOURCE 15)
+(defconstant DMBIN_LAST 15)
+(defconstant DMBIN_USER 256)
+(defconstant DMCOLOR_MONOCHROME 1)
+(defconstant DMCOLOR_COLOR 2)
+(defconstant DMDUP_SIMPLEX 1)
+(defconstant DMDUP_VERTICAL 2)
+(defconstant DMDUP_HORIZONTAL 3)
+(defconstant DMTT_BITMAP 1)
+(defconstant DMTT_DOWNLOAD 2)
+(defconstant DMTT_SUBDEV 3)
+(defconstant DMTT_DOWNLOAD_OUTLINE 4)
+(defconstant DMCOLLATE_FALSE 0)
+(defconstant DMCOLLATE_TRUE 1)
+(defconstant DM_GRAYSCALE 1)
+(defconstant DM_INTERLACED 2)
+(defconstant DM_UPDATE 1)
+(defconstant DM_COPY 2)
+(defconstant DM_PROMPT 4)
+(defconstant DM_MODIFY 8)
+(defconstant DM_ORIENTATION 1)
+(defconstant DM_PAPERSIZE 2)
+(defconstant DM_PAPERLENGTH 4)
+(defconstant DM_PAPERWIDTH 8)
+(defconstant DM_SCALE 16)
+(defconstant DM_COPIES 256)
+(defconstant DM_DEFAULTSOURCE 512)
+(defconstant DM_PRINTQUALITY 1024)
+(defconstant DM_COLOR 2048)
+(defconstant DM_DUPLEX 4096)
+(defconstant DM_YRESOLUTION 8192)
+(defconstant DM_TTOPTION 16384)
+(defconstant DM_COLLATE 32768)
+(defconstant DM_FORMNAME 65536)
+(defconstant DM_LOGPIXELS #x20000)
+(defconstant DM_BITSPERPEL #x40000)
+(defconstant DM_PELSWIDTH #x80000)
+(defconstant DM_PELSHEIGHT #x100000)
+(defconstant DM_DISPLAYFLAGS #x200000)
+(defconstant DM_DISPLAYFREQUENCY #x400000)
+(defconstant DM_ICMMETHOD #x800000)
+(defconstant DM_ICMINTENT #x1000000)
+(defconstant DM_MEDIATYPE #x2000000)
+(defconstant DM_DITHERTYPE #x4000000)
+(defconstant DMICMMETHOD_NONE 1)
+(defconstant DMICMMETHOD_SYSTEM 2)
+(defconstant DMICMMETHOD_DRIVER 3)
+(defconstant DMICMMETHOD_DEVICE 4)
+(defconstant DMICMMETHOD_USER 256)
+(defconstant DMICM_SATURATE 1)
+(defconstant DMICM_CONTRAST 2)
+(defconstant DMICM_COLORMETRIC 3)
+(defconstant DMICM_USER 256)
+(defconstant DMMEDIA_STANDARD 1)
+(defconstant DMMEDIA_TRANSPARENCY 2)
+(defconstant DMMEDIA_GLOSSY 3)
+(defconstant DMMEDIA_USER 256)
+(defconstant DMDITHER_NONE 1)
+(defconstant DMDITHER_COARSE 2)
+(defconstant DMDITHER_FINE 3)
+(defconstant DMDITHER_LINEART 4)
+(defconstant DMDITHER_ERRORDIFFUSION 5)
+(defconstant DMDITHER_RESERVED6 6)
+(defconstant DMDITHER_RESERVED7 7)
+(defconstant DMDITHER_RESERVED8 8)
+(defconstant DMDITHER_RESERVED9 9)
+(defconstant DMDITHER_GRAYSCALE 10)
+(defconstant DMDITHER_USER 256)
+(defconstant TMPF_FIXED_PITCH 1)
+(defconstant TMPF_VECTOR 2)
+(defconstant TMPF_TRUETYPE 4)
+(defconstant TMPF_DEVICE 8)
+(defconstant NTM_ITALIC 1)
+(defconstant NTM_BOLD 32)
+(defconstant NTM_REGULAR 64)
+(defconstant TT_POLYGON_TYPE 24)
+(defconstant TT_PRIM_LINE 1)
+(defconstant TT_PRIM_QSPLINE 2)
+(defconstant FONTMAPPER_MAX 10)
+(defconstant ENHMETA_STOCK_OBJECT #x80000000)
+(defconstant WGL_FONT_LINES 0)
+(defconstant WGL_FONT_POLYGONS 1)
+(defconstant LPD_DOUBLEBUFFER 1)
+(defconstant LPD_STEREO 2)
+(defconstant LPD_SUPPORT_GDI 16)
+(defconstant LPD_SUPPORT_OPENGL 32)
+(defconstant LPD_SHARE_DEPTH 64)
+(defconstant LPD_SHARE_STENCIL 128)
+(defconstant LPD_SHARE_ACCUM 256)
+(defconstant LPD_SWAP_EXCHANGE 512)
+(defconstant LPD_SWAP_COPY 1024)
+(defconstant LPD_TRANSPARENT 4096)
+(defconstant LPD_TYPE_RGBA 0)
+(defconstant LPD_TYPE_COLORINDEX 1)
+(defconstant WGL_SWAP_MAIN_PLANE 1)
+(defconstant WGL_SWAP_OVERLAY1 2)
+(defconstant WGL_SWAP_OVERLAY2 4)
+(defconstant WGL_SWAP_OVERLAY3 8)
+(defconstant WGL_SWAP_OVERLAY4 16)
+(defconstant WGL_SWAP_OVERLAY5 32)
+(defconstant WGL_SWAP_OVERLAY6 64)
+(defconstant WGL_SWAP_OVERLAY7 128)
+(defconstant WGL_SWAP_OVERLAY8 256)
+(defconstant WGL_SWAP_OVERLAY9 512)
+(defconstant WGL_SWAP_OVERLAY10 1024)
+(defconstant WGL_SWAP_OVERLAY11 2048)
+(defconstant WGL_SWAP_OVERLAY12 4096)
+(defconstant WGL_SWAP_OVERLAY13 8192)
+(defconstant WGL_SWAP_OVERLAY14 16384)
+(defconstant WGL_SWAP_OVERLAY15 32768)
+(defconstant WGL_SWAP_UNDERLAY1 65536)
+(defconstant WGL_SWAP_UNDERLAY2 #x20000)
+(defconstant WGL_SWAP_UNDERLAY3 #x40000)
+(defconstant WGL_SWAP_UNDERLAY4 #x80000)
+(defconstant WGL_SWAP_UNDERLAY5 #x100000)
+(defconstant WGL_SWAP_UNDERLAY6 #x200000)
+(defconstant WGL_SWAP_UNDERLAY7 #x400000)
+(defconstant WGL_SWAP_UNDERLAY8 #x800000)
+(defconstant WGL_SWAP_UNDERLAY9 #x1000000)
+(defconstant WGL_SWAP_UNDERLAY10 #x2000000)
+(defconstant WGL_SWAP_UNDERLAY11 #x4000000)
+(defconstant WGL_SWAP_UNDERLAY12 #x8000000)
+(defconstant WGL_SWAP_UNDERLAY13 #x10000000)
+(defconstant WGL_SWAP_UNDERLAY14 #x20000000)
+(defconstant WGL_SWAP_UNDERLAY15 #x40000000)
+(defconstant WS_BORDER	#x800000)
+(defconstant WS_CAPTION	#xc00000)
+(defconstant WS_CHILD	#x40000000)
+(defconstant WS_CHILDWINDOW	#x40000000)
+(defconstant WS_CLIPCHILDREN #x2000000)
+(defconstant WS_CLIPSIBLINGS #x4000000)
+(defconstant WS_DISABLED	#x8000000)
+(defconstant WS_DLGFRAME	#x400000)
+(defconstant WS_GROUP	#x20000)
+(defconstant WS_HSCROLL	#x100000)
+(defconstant WS_ICONIC	#x20000000)
+(defconstant WS_MAXIMIZE	#x1000000)
+(defconstant WS_MAXIMIZEBOX	#x10000)
+(defconstant WS_MINIMIZE	#x20000000)
+(defconstant WS_MINIMIZEBOX	#x20000)
+(defconstant WS_OVERLAPPED	0)
+(defconstant WS_OVERLAPPEDWINDOW	#xcf0000)
+(defconstant WS_POPUP	#x80000000)
+(defconstant WS_POPUPWINDOW	#x80880000)
+(defconstant WS_SIZEBOX	#x40000)
+(defconstant WS_SYSMENU	#x80000)
+(defconstant WS_TABSTOP	#x10000)
+(defconstant WS_THICKFRAME	#x40000)
+(defconstant WS_TILED	0)
+(defconstant WS_TILEDWINDOW	#xcf0000)
+(defconstant WS_VISIBLE	#x10000000)
+(defconstant WS_VSCROLL	#x200000)
+(defconstant WS_EX_ACCEPTFILES 16)
+(defconstant WS_EX_APPWINDOW #x40000)
+(defconstant WS_EX_CLIENTEDGE 512)
+(defconstant WS_EX_CONTEXTHELP #x400)
+(defconstant WS_EX_CONTROLPARENT #x10000)
+(defconstant WS_EX_DLGMODALFRAME 1)
+(defconstant WS_EX_LEFT 0)
+(defconstant WS_EX_LEFTSCROLLBAR #x4000)
+(defconstant WS_EX_LTRREADING 0)
+(defconstant WS_EX_MDICHILD 64)
+(defconstant WS_EX_NOPARENTNOTIFY 4)
+(defconstant WS_EX_OVERLAPPEDWINDOW #x300)
+(defconstant WS_EX_PALETTEWINDOW #x188)
+(defconstant WS_EX_RIGHT #x1000)
+(defconstant WS_EX_RIGHTSCROLLBAR 0)
+(defconstant WS_EX_RTLREADING #x2000)
+(defconstant WS_EX_STATICEDGE #x20000)
+(defconstant WS_EX_TOOLWINDOW 128)
+(defconstant WS_EX_TOPMOST 8)
+(defconstant WS_EX_TRANSPARENT 32)
+(defconstant WS_EX_WINDOWEDGE 256)
+(defconstant IDC_STATIC 0)
+(defconstant IDC_ARROW 1)
+(defconstant IDC_IBEAM 2)
+(defconstant IDC_WAIT 3)
+(defconstant IDC_CROSS 4)
+(defconstant IDC_UPARROW 5)
+(defconstant IDC_SIZENWSE 6)
+(defconstant IDC_SIZENESW 7)
+(defconstant IDC_SIZEWE 8)
+(defconstant IDC_SIZENS 9)
+(defconstant IDC_SIZEALL 10)
+(defconstant IDC_NO 11)
+(defconstant IDC_HAND 12)
+(defconstant IDC_APPSTARTING 13)
+(defconstant IDC_HELP 14)
+(defconstant IDC_ICON 15)
+(defconstant IDC_SIZE 16)
+(defconstant WM_ACTIVATE 6)
+(defconstant WM_ACTIVATEAPP 28)
+(defconstant WM_AFXFIRST 864)
+(defconstant WM_AFXLAST 895)
+(defconstant WM_ASKCBFORMATNAME 780)
+(defconstant WM_CANCELJOURNAL 75)
+(defconstant WM_CANCELMODE 31)
+(defconstant WM_CAPTURECHANGED 533)
+(defconstant WM_CHANGECBCHAIN 781)
+(defconstant WM_CHAR 258)
+(defconstant WM_CHARTOITEM 47)
+(defconstant WM_CHILDACTIVATE 34)
+(defconstant WM_CLEAR 771)
+(defconstant WM_CLOSE 16)
+(defconstant WM_COMMAND 273)
+(defconstant WM_COMPACTING 65)
+(defconstant WM_COMPAREITEM 57)
+(defconstant WM_CONTEXTMENU 123)
+(defconstant WM_COPY 769)
+(defconstant WM_COPYDATA 74)
+(defconstant WM_CREATE 1)
+(defconstant WM_CTLCOLORBTN 309)
+(defconstant WM_CTLCOLORDLG 310)
+(defconstant WM_CTLCOLOREDIT 307)
+(defconstant WM_CTLCOLORLISTBOX 308)
+(defconstant WM_CTLCOLORMSGBOX 306)
+(defconstant WM_CTLCOLORSCROLLBAR 311)
+(defconstant WM_CTLCOLORSTATIC 312)
+(defconstant WM_CUT 768)
+(defconstant WM_DEADCHAR 259)
+(defconstant WM_DELETEITEM 45)
+(defconstant WM_DESTROY 2)
+(defconstant WM_DESTROYCLIPBOARD 775)
+(defconstant WM_DEVICECHANGE 537)
+(defconstant WM_DEVMODECHANGE 27)
+(defconstant WM_DISPLAYCHANGE 126)
+(defconstant WM_DRAWCLIPBOARD 776)
+(defconstant WM_DRAWITEM 43)
+(defconstant WM_DROPFILES 563)
+(defconstant WM_ENABLE 10)
+(defconstant WM_ENDSESSION 22)
+(defconstant WM_ENTERIDLE 289)
+(defconstant WM_ENTERMENULOOP 529)
+(defconstant WM_ENTERSIZEMOVE 561)
+(defconstant WM_ERASEBKGND 20)
+(defconstant WM_EXITMENULOOP 530)
+(defconstant WM_EXITSIZEMOVE 562)
+(defconstant WM_FONTCHANGE 29)
+(defconstant WM_GETDLGCODE 135)
+(defconstant WM_GETFONT 49)
+(defconstant WM_GETHOTKEY 51)
+(defconstant WM_GETICON 127)
+(defconstant WM_GETMINMAXINFO 36)
+(defconstant WM_GETTEXT 13)
+(defconstant WM_GETTEXTLENGTH 14)
+(defconstant WM_HANDHELDFIRST 856)
+(defconstant WM_HANDHELDLAST 863)
+(defconstant WM_HELP 83)
+(defconstant WM_HOTKEY 786)
+(defconstant WM_HSCROLL 276)
+(defconstant WM_HSCROLLCLIPBOARD 782)
+(defconstant WM_ICONERASEBKGND 39)
+(defconstant WM_INITDIALOG 272)
+(defconstant WM_INITMENU 278)
+(defconstant WM_INITMENUPOPUP 279)
+(defconstant WM_INPUTLANGCHANGE 81)
+(defconstant WM_INPUTLANGCHANGEREQUEST 80)
+(defconstant WM_KEYDOWN 256)
+(defconstant WM_KEYUP 257)
+(defconstant WM_KILLFOCUS 8)
+(defconstant WM_MDIACTIVATE 546)
+(defconstant WM_MDICASCADE 551)
+(defconstant WM_MDICREATE 544)
+(defconstant WM_MDIDESTROY 545)
+(defconstant WM_MDIGETACTIVE 553)
+(defconstant WM_MDIICONARRANGE 552)
+(defconstant WM_MDIMAXIMIZE 549)
+(defconstant WM_MDINEXT 548)
+(defconstant WM_MDIREFRESHMENU 564)
+(defconstant WM_MDIRESTORE 547)
+(defconstant WM_MDISETMENU 560)
+(defconstant WM_MDITILE 550)
+(defconstant WM_MEASUREITEM 44)
+(defconstant WM_MENUCHAR 288)
+(defconstant WM_MENUSELECT 287)
+(defconstant WM_NEXTMENU 531)
+(defconstant WM_MOVE 3)
+(defconstant WM_MOVING 534)
+(defconstant WM_NCACTIVATE 134)
+(defconstant WM_NCCALCSIZE 131)
+(defconstant WM_NCCREATE 129)
+(defconstant WM_NCDESTROY 130)
+(defconstant WM_NCHITTEST 132)
+(defconstant WM_NCLBUTTONDBLCLK 163)
+(defconstant WM_NCLBUTTONDOWN 161)
+(defconstant WM_NCLBUTTONUP 162)
+(defconstant WM_NCMBUTTONDBLCLK 169)
+(defconstant WM_NCMBUTTONDOWN 167)
+(defconstant WM_NCMBUTTONUP 168)
+(defconstant WM_NCMOUSEMOVE 160)
+(defconstant WM_NCPAINT 133)
+(defconstant WM_NCRBUTTONDBLCLK 166)
+(defconstant WM_NCRBUTTONDOWN 164)
+(defconstant WM_NCRBUTTONUP 165)
+(defconstant WM_NEXTDLGCTL 40)
+(defconstant WM_NEXTMENU 531)
+(defconstant WM_NOTIFY 78)
+(defconstant WM_NOTIFYFORMAT 85)
+(defconstant WM_NULL 0)
+(defconstant WM_PAINT 15)
+(defconstant WM_PAINTCLIPBOARD 777)
+(defconstant WM_PAINTICON 38)
+(defconstant WM_PALETTECHANGED 785)
+(defconstant WM_PALETTEISCHANGING 784)
+(defconstant WM_PARENTNOTIFY 528)
+(defconstant WM_PASTE 770)
+(defconstant WM_PENWINFIRST 896)
+(defconstant WM_PENWINLAST 911)
+(defconstant WM_POWER 72)
+(defconstant WM_POWERBROADCAST 536)
+(defconstant WM_PRINT 791)
+(defconstant WM_PRINTCLIENT 792)
+(defconstant WM_QUERYDRAGICON 55)
+(defconstant WM_QUERYENDSESSION 17)
+(defconstant WM_QUERYNEWPALETTE 783)
+(defconstant WM_QUERYOPEN 19)
+(defconstant WM_QUEUESYNC 35)
+(defconstant WM_QUIT 18)
+(defconstant WM_RENDERALLFORMATS 774)
+(defconstant WM_RENDERFORMAT 773)
+(defconstant WM_SETCURSOR 32)
+(defconstant WM_SETFOCUS 7)
+(defconstant WM_SETFONT 48)
+(defconstant WM_SETHOTKEY 50)
+(defconstant WM_SETICON 128)
+(defconstant WM_SETREDRAW 11)
+(defconstant WM_SETTEXT 12)
+(defconstant WM_SETTINGCHANGE 26)
+(defconstant WM_SHOWWINDOW 24)
+(defconstant WM_SIZE 5)
+(defconstant WM_SIZECLIPBOARD 779)
+(defconstant WM_SIZING 532)
+(defconstant WM_SPOOLERSTATUS 42)
+(defconstant WM_STYLECHANGED 125)
+(defconstant WM_STYLECHANGING 124)
+(defconstant WM_SYSCHAR 262)
+(defconstant WM_SYSCOLORCHANGE 21)
+(defconstant WM_SYSCOMMAND 274)
+(defconstant WM_SYSDEADCHAR 263)
+(defconstant WM_SYSKEYDOWN 260)
+(defconstant WM_SYSKEYUP 261)
+(defconstant WM_TCARD 82)
+(defconstant WM_TIMECHANGE 30)
+(defconstant WM_TIMER 275)
+(defconstant WM_UNDO 772)
+(defconstant WM_USER 1024)
+(defconstant WM_USERCHANGED 84)
+(defconstant WM_VKEYTOITEM 46)
+(defconstant WM_VSCROLL 277)
+(defconstant WM_VSCROLLCLIPBOARD 778)
+(defconstant WM_WINDOWPOSCHANGED 71)
+(defconstant WM_WINDOWPOSCHANGING 70)
+(defconstant WM_WININICHANGE 26)
+(defconstant WM_KEYFIRST 256)
+(defconstant WM_KEYLAST 264)
+(defconstant WM_SYNCPAINT  136)
+(defconstant WM_MOUSEACTIVATE 33)
+(defconstant WM_MOUSEMOVE 512)
+(defconstant WM_LBUTTONDOWN 513)
+(defconstant WM_LBUTTONUP 514)
+(defconstant WM_LBUTTONDBLCLK 515)
+(defconstant WM_RBUTTONDOWN 516)
+(defconstant WM_RBUTTONUP 517)
+(defconstant WM_RBUTTONDBLCLK 518)
+(defconstant WM_MBUTTONDOWN 519)
+(defconstant WM_MBUTTONUP 520)
+(defconstant WM_MBUTTONDBLCLK 521)
+(defconstant WM_MOUSEWHEEL 522)
+(defconstant WM_MOUSEFIRST 512)
+(defconstant WM_MOUSELAST 522)
+(defconstant WM_MOUSEHOVER #x2A1)
+(defconstant WM_MOUSELEAVE #x2A3)
+(defconstant SW_HIDE 0)
+(defconstant SW_NORMAL 1)
+(defconstant SW_SHOWNORMAL 1)
+(defconstant SW_SHOWMINIMIZED 2)
+(defconstant SW_MAXIMIZE 3)
+(defconstant SW_SHOWMAXIMIZED 3)
+(defconstant SW_SHOWNOACTIVATE 4)
+(defconstant SW_SHOW 5)
+(defconstant SW_MINIMIZE 6)
+(defconstant SW_SHOWMINNOACTIVE 7)
+(defconstant SW_SHOWNA 8)
+(defconstant SW_RESTORE 9)
+(defconstant SW_SHOWDEFAULT 10)
+(defconstant SW_FORCEMINIMIZE 11)
+(defconstant SW_MAX  11)
+(defconstant SW_PARENTCLOSING 1)
+(defconstant SW_OTHERZOOM 2)
+(defconstant SW_PARENTOPENING 3)
+(defconstant SW_OTHERUNZOOM 4)
+(defconstant SW_SCROLLCHILDREN 1)
+(defconstant SW_INVALIDATE 2)
+(defconstant SW_ERASE 4)
+
+(defstruct (RGB (:constructor make-rgb (r g b))) r g b)
+(defconstant *black* (make-rgb 0 0 0))
+(defconstant *white* (make-rgb #xff #xff #xff))
+
+(deftype pixarray-1-element-type ()  'bit)
+(deftype pixarray-4-element-type ()  '(unsigned-byte 4))
+(deftype pixarray-8-element-type ()  '(unsigned-byte 8))
+(deftype pixarray-16-element-type () '(unsigned-byte 16))
+(deftype pixarray-24-element-type () '(unsigned-byte 24))
+(deftype pixarray-32-element-type () '(unsigned-byte 32))
+
+(defstruct (rect (:constructor make-rect (&optional left top right bottom)))
+   left top right bottom)
+
+(defstruct (point (:constructor make-point (&optional x y)))
+  (x 0 :type integer) (y 0 :type integer))
+(defstruct (point-float (:constructor make-point-float (&optional x y)))
+  (x 0.0 :type short-float) (y 0.0 :type short-float))
+
+(defstruct (logfont (:constructor make-logfont (&optional
+   lfheight lfwidth lfescapement lforientation lfweight lfitalic
+   lfunderline lfstrikeout lfcharset lfoutprecision lfclipprecision
+   lfquality lfpitchandfamily lffacename)))
+   (lfheight 0 :type fixnum)
+   (lfwidth 0 :type fixnum)
+   (lfescapement 0 :type fixnum)
+   (lforientation 0 :type fixnum)
+   (lfweight 0 :type fixnum)
+   (lfitalic 0 :type fixnum)
+   (lfunderline 0 :type fixnum)
+   (lfstrikeout 0 :type fixnum)
+   (lfcharset 0 :type fixnum)
+   (lfoutprecision 0 :type fixnum)
+   (lfclipprecision 0 :type fixnum)
+   (lfquality 0 :type fixnum)
+   (lfpitchandfamily 0 :type fixnum)
+   (lffacename "" :type string))
+
+(defstruct (createstruct (:constructor make-createstruct (&optional
+   dwexstyle lpszclass lpszname style x y cx cy hwndparent hmenu 
+   hinstance lpcreateparams)))
+   (dwexstyle 0 :type (unsigned 32))
+   (lpszclass "" :type string)
+   (lpszname "" :type string)
+   (style 0 :type (unsigned 32))
+   (x 0 :type fixnum)
+   (y 0 :type fixnum)
+   (cx 0 :type fixnum)
+   (cy 0 :type fixnum)
+   (hwndparent 0 :type foreign)
+   (hmenu 0 :type foreign)
+   (hinstance 0 :type foreign)
+   (lpcreateparams 0 :type foreign))
+
+(defstruct (iconinfo (:constructor make-iconinfo (&optional
+	fIcon xHotspot yHotspot hbmMask hbmColor)))
+	fIcon
+	xHotspot
+	yHotspot
+	hbmMask
+	hbmColor)
+
+(defstruct (wndclass (:constructor make-wndclass (&optional
+   style cbclsextra cbwndextra hinstance hicon hcursor
+   hbrbackground lpszmenuname lpszclassname)))
+   (style 0 :type fixnum)
+   (cbclsextra 0 :type fixnum)
+   (cbwndextra 0 :type fixnum)
+   (hinstance 0 :type foreign)
+   (hicon 0 :type foreign)
+   (hcursor 0 :type foreign)
+   (hbrbackground 0 :type foreign)
+   (lpszmenuname "" :type string)
+   (lpszclassname "" :type string))
+
+(defstruct (textmetric (:constructor make-textmetric (&optional
+    tmheight tmascent tmdescent tminternalleading tmexternalleading
+    tmavecharwidth tmmaxcharwidth tmweight tmoverhang tmdigitizedaspectx
+    tmdigitizedaspecty tmfirstchar tmlastchar tmdefaultchar tmbreakchar
+    tmitalic tmunderlined tmstruckout tmpitchandfamily tmcharset)))
+   (tmheight 0 :type fixnum)
+   (tmascent 0 :type fixnum)
+   (tmdescent 0 :type fixnum)
+   (tminternalleading 0 :type fixnum)
+   (tmexternalleading 0 :type fixnum)
+   (tmavecharwidth 0 :type fixnum)
+   (tmmaxcharwidth 0 :type fixnum)
+   (tmweight 0 :type fixnum)
+   (tmoverhang 0 :type fixnum)
+   (tmdigitizedaspectx 0 :type fixnum)
+   (tmdigitizedaspecty 0 :type fixnum)
+   (tmfirstchar #\space :type character)
+   (tmlastchar #\space :type character)
+   (tmdefaultchar #\space :type fixnum)
+   (tmbreakchar #\space :type fixnum)
+   (tmitalic 0 :type fixnum)
+   (tmunderlined 0 :type fixnum)
+   (tmstruckout 0 :type fixnum)
+   (tmpitchandfamily 0 :type fixnum)
+   (tmcharset 0 :type fixnum))
+
+;;; This function is similar to the clx function draw-arc.
+;;; To avoid using optional arguments, args are passed in as points.
+(defun draw-arc (hdc pPosition pDimension pAngle)
+   (let* ((x (point-x pPosition))
+          (y (point-y pPosition))
+          (width (point-x pDimension))
+          (height (point-y pDimension))
+          (angle (point-float-y pAngle))
+          angle1 angle2)
+      (if (>= angle 0.0)
+          (setf angle1 (point-float-x pAngle) angle2 (+ angle angle1))
+          (setf angle2 (point-float-x pAngle) angle1 (- angle2 angle)))
+      (ARC hdc x y (+ x width -1) (+ y height -1)
+          (truncate (+ x (/ width 2) (* width (cos angle1))))
+          (truncate (+ y (/ height 2) (- (* height (sin angle1)))))
+          (truncate (+ x (/ width 2) (* width (cos angle2))))
+          (truncate (+ y (/ height 2) (- (* height (sin angle2))))))))
+
+(defun bitmap-image (&rest r)
+  (declare (ignore r))
+  t)
+
+; I am not sure if this is needed, it is from the mac implementation
+(defvar *current-event* nil)
+; If we switch to a fixnum for this, it will be faster
+; but for now, get it working
+(defvar *functions* (make-hash-table :test #'equalp))
+(defun onCreate (hWnd)
+   (let* ((k (cons 0 WM_NCCREATE))
+          (alist (gethash k *functions*)))
+      (when alist (remhash k *functions*))
+      (mapc #'(lambda (c)
+              (setf (gethash (cons hWnd (car c)) *functions*) (cdr c)))
+         alist)))
+
+(defun init-gdi () (GDI::InitC *functions* #'onCreate))
+(defvar *hinstance* (init-gdi))
+
+(defun create-gcontext (&rest r)
+  (declare (ignore r))
+  t)
+
+(defun add-callbacks (message-id a)
+   (let ((key (cons  0 message-id )))
+        (setf (gethash key *functions*) a)))
+(defun remove-callback (hwnd message-id)
+   (remhash (cons hwnd message-id) *functions*))
+
+(defun handle-textmetric (hfont)
+  (let* ((hdc (multiple-value-bind (retval h) (GDI::GetDC nil)
+                 (if retval h (error "getdc ~S" h))))
+         (tm (make-textmetric))
+         (hOldFont (multiple-value-bind (retval h)
+                  (GDI::SelectObject hdc hfont)
+                  (if retval h (error "SelectObject ~S" h)))))
+     (multiple-value-bind (retval h)
+        (GDI::GetTextMetricsA hdc tm)
+        (unless retval (error "GetTextMetricsA ~S" h)))
+     (multiple-value-bind (retval h)
+        (GDI::SelectObject hdc hOldFont)
+        (if retval h (error "SelectObject ~S" h)))
+       tm))
+
+(defun max-char-ascent (hfont)
+   (textmetric-tmascent (handle-textmetric hfont)))
+
+(defun max-char-descent (hfont)
+   (textmetric-tmdescent (handle-textmetric hfont)))
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/gdi.m modules/gdi/gdi.m
--- origmodules/gdi/gdi.m	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/gdi.m	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1,229 @@
+/* The basic idea of this module is to create lisp callable functions
+   for the T symbols in the cygwin library libgdi32.a.  To do this, I
+   used a awk program which parsed the function headers, and created
+   the functions here.  So most of them are not tested.
+   Once a function is tested remove the untested comment from the function.
+   This file is LGPL'd, and copyright assigned to the FSF.
+   Dan Stanger 4/9/02
+*/
+#include "clisp.h"
+#define DEFMODULE(a,b)
+#define DEFUN(funname,lambdalist,signature) LISPFUN signature
+#define DEFVAR(varname)
+#define WIDECHAR(o,e)  &TheS16string(o)->data[0]
+#define memclr(p,n) memset(p,0,n)
+#define NO_STRICT
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#define encoding (C_terminal_encoding(),value1)
+DEFMODULE(gdi,"GDI")
+
+static object lookupHash(HWND hwnd, int message);
+
+LRESULT CALLBACK WindowProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
+{
+printf("HWND %x UINT %d WPARAM %d LPARAM %d\n",hWnd,message,wParam,lParam);
+  switch (message) {
+   // When window is created, the callback gets done before the createwindow
+   // returns with a handle.  To get around this, and this is NOT thread
+   // safe, store a alist of messages and functions.  Then call a
+   // lisp function with the window handle and the alist, and store
+   // the new list in the hash table.
+   case WM_NCCREATE:
+   {
+     object p;
+     begin_callback();
+     p = allocate_fpointer(hWnd);
+     pushSTACK(p);
+     funcall(O(onCreate),1);
+     end_callback();
+     return TRUE;
+   }
+   case WM_CREATE:
+   {
+      break;
+   }
+   case WM_PAINT:
+   {
+     PAINTSTRUCT paintStruct;
+     object func;
+//asm("int3");
+     BeginPaint(hWnd,&paintStruct);
+     begin_callback();
+     func = lookupHash(hWnd, message);
+     if(!nullp(func))
+     {
+        pushSTACK(allocate_fpointer(paintStruct.hdc));
+        funcall(func,1);
+     }
+     end_callback();
+     EndPaint(hWnd,&paintStruct);
+     break;
+   }
+   case WM_CLOSE:
+   {
+     object func;
+//asm("int3");
+     begin_callback();
+     func = lookupHash(hWnd, message);
+     if(!nullp(func))
+     {
+        pushSTACK(allocate_fpointer(hWnd));
+        funcall(func,1);
+        end_callback();
+     }
+     else
+     {
+        end_callback();
+        return (DefWindowProc(hWnd, message, wParam, lParam));
+     }
+     break;
+   }
+   case WM_KEYDOWN:
+     switch (wParam)
+     {
+       case VK_CANCEL:
+       case VK_CLEAR:
+       case VK_PAUSE:
+       case VK_PRIOR:
+       case VK_NEXT:
+       case VK_END:
+       case VK_HOME:
+       case VK_LEFT:
+       case VK_UP:
+       case VK_RIGHT:
+       case VK_DOWN:
+       case VK_SELECT:
+       case VK_PRINT:
+       case VK_EXECUTE:
+       case VK_INSERT:
+       case VK_DELETE:
+       case VK_HELP:
+       case VK_NUMLOCK:
+       case VK_SCROLL:
+       case VK_F1:
+       case VK_F2:
+       case VK_F3:
+       case VK_F4:
+       case VK_F5:
+       case VK_F6:
+       case VK_F7:
+       case VK_F8:
+       case VK_F9:
+       case VK_F10:
+       case VK_F11:
+       case VK_F12:
+       default:
+       {
+         begin_callback();
+         object func = lookupHash(hWnd, message);
+         if(!nullp(func))
+         {
+            /* This cast assumes that sizeof(void*)==sizeof(LPARAM) */
+            pushSTACK(allocate_fpointer((void*)lParam));
+            pushSTACK(fixnum(wParam));
+            funcall(func,2);
+         }
+         end_callback();
+         break;
+       }
+     }
+     break;
+   case WM_LBUTTONDOWN:
+   case WM_MBUTTONDOWN:
+   case WM_RBUTTONDOWN:
+   case WM_MBUTTONUP:
+   case WM_LBUTTONUP:
+   case WM_RBUTTONUP:
+   case WM_MOUSEMOVE:
+   case WM_MOUSEWHEEL:
+   case WM_ERASEBKGND:
+   case WM_KILLFOCUS:
+   case WM_SETFOCUS:
+   case WM_QUIT:
+   case WM_DESTROY:
+   case WM_SYSCHAR: /* alt-keys go here */
+   case WM_CHAR:
+   case WM_LBUTTONDBLCLK:
+   case WM_MBUTTONDBLCLK:
+   case WM_RBUTTONDBLCLK:
+   case WM_MOVE:	
+   case WM_SIZE:			
+   case WM_DESTROYCLIPBOARD:
+   default:        /* Passes it on if unproccessed    */
+     return (DefWindowProc(hWnd, message, wParam, lParam));
+    }
+    return 0L;
+}
+static object lookupHash(HWND hwnd, int message){
+printf("lookupHash hwnd %x message %d\n",hwnd,message);
+   Car(O(localCons)) = allocate_fpointer(hwnd);
+   Cdr(O(localCons)) = fixnum(message);
+   pushSTACK(O(localCons));
+   pushSTACK(O(functions));
+   funcall(S(gethash),2);
+   return value1;
+}
+
+DEFVAR(functions,`NIL`)
+DEFVAR(localCons,`NIL`)
+DEFVAR(onCreate,`NIL`)
+/* TODO: on case-sensitive T change to GDI:InitC */
+DEFUN( GDI:INITC, h f)
+{
+  O(localCons) = allocate_cons();
+  O(onCreate) = popSTACK();
+  O(functions) = popSTACK();
+  value1 = allocate_fpointer(GetModuleHandle(0));
+  mv_count=1;
+  return;
+}
+static LPSTR idc[] ={
+   0,
+   (LPSTR)IDC_ARROW,
+   (LPSTR)IDC_IBEAM,
+   (LPSTR)IDC_WAIT,
+   (LPSTR)IDC_CROSS,
+   (LPSTR)IDC_UPARROW,
+   (LPSTR)IDC_SIZENWSE,
+   (LPSTR)IDC_SIZENESW,
+   (LPSTR)IDC_SIZEWE,
+   (LPSTR)IDC_SIZENS,
+   (LPSTR)IDC_SIZEALL,
+   (LPSTR)IDC_NO,
+   (LPSTR)IDC_HAND,
+   (LPSTR)IDC_APPSTARTING,
+   (LPSTR)IDC_HELP,
+   (LPSTR)IDC_ICON,
+   (LPSTR)IDC_SIZE
+};
+/* TODO: on case-sensitive T change to GDI:GetIDC */
+DEFUN( GDI:GETIDC, h)
+{
+  object arg = popSTACK();
+  check_uint32(arg);
+  value1 = allocate_fpointer(idc[I_to_uint32(arg)]);
+  mv_count=1;
+  return;
+}
+ 
+/* TODO: on case-sensitive T change to GDI:MakeFPointer */
+DEFUN( GDI:MAKEFPOINTER, h)
+{
+  /* This cast assumes that sizeof(void*)==sizeof(uint32) */
+  value1 = allocate_fpointer((void*)I_to_uint32(popSTACK()));
+  mv_count=1;
+  return;
+}
+/* TODO: on case-sensitive T change to GDI:MessageLoop */
+DEFUN( GDI:MESSAGELOOP,)
+{
+  MSG m;
+  while (GetMessage(&m, (HWND) NULL, 0, 0)) { 
+    TranslateMessage(&m); 
+    DispatchMessage(&m); 
+  } 
+  value1 = fixnum(m.wParam);
+  mv_count=1;
+  return;
+}
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/gdi.txt modules/gdi/gdi.txt
--- origmodules/gdi/gdi.txt	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/gdi.txt	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1,17 @@
+/*
+do we need a with a with-pen macro or a  with-dc macro?
+following the motifzone document
+we define a device-context structure (or should it be a class)
+we use functions which call the corresponding win32 function to
+manipulate the the device context.
+The gdi uses handles which is a 32 bit unsigned int.
+Since the most-positive-fixnum in clisp is 24 bits, the
+foreign-pointer is used (pointer to void).  All handles are
+this type.
+Since out parameters are passed as multiple values,
+adopt the convention that the return value is first,
+
+change of plan we use cparse to generate structure assignment
+code in c.  then call directly from c.
+ */
+
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/gdi.xml modules/gdi/gdi.xml
--- origmodules/gdi/gdi.xml	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/gdi.xml	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<section id="gdi"><title>GDI Interface</title>
+
+<para>This is an &ffi-pac;-based interface to the Windows GDI32.dll, 
+to allow writing native Windows GUI's.</para>
+
+<simpara>When this module is present, &features-var;
+ contains the symbol <constant>:GDI</constant>.</simpara>
+
+<warning><para>TODO: List functions and variables here.</para></warning>
+
+</section>
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/input.awk modules/gdi/input.awk
--- origmodules/gdi/input.awk	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/input.awk	2007-04-03 10:46:52.359375000 +0100
@@ -0,0 +1,42 @@
+function doIdent( type, name, arg) {
+    if(type ~ /^H.*/) {
+       return (name " = TheFpointer("arg")->fp_pointer;")
+    }
+    else if( "DWORD" == type || "UINT" == type || "DWORD32" == type ||
+              "COLORREF" == type) {
+       return (name " = I_to_uint32("arg");")
+    }
+    else if( "int" == type || "INT" == type || "LONG" == type || "LPARAM"==type){
+       return (name " = I_to_sint32("arg");")
+    }
+    else if( "LPSTR" == type || "LPCSTR" == type) {
+       return (name " = string_to_asciz("arg",encoding);")
+    }
+    else if( "LPWSTR" == type || "LPCWSTR" == type) {
+       return (name " = WIDECHAR("arg",encoding);")
+    }
+    else if( "float" == type || "FLOAT" == type) {
+       return (name " = ffloat_value("arg");")
+    }
+    else if("BYTE_P" == type) {
+       return (name " = &(TheSbvector("arg")->data);")
+    }
+    else if("INT_P" == type || "DWORD_P" == type || "LPINT" == type) {
+       return (name " = &(TheSbvector("arg")->data);")
+    }
+    else if("PVOID" == type || "PCVOID" == type) {
+       return (name " = &(TheSbvector("arg")->data);")
+    }
+    else if(type ~ /^LPC.*/) {
+       return (name " = &(TheSbvector("arg")->data);")
+    }
+    else if(type ~ /^LP.*/) {
+       return (name " = &(TheSbvector("arg")->data);")
+    }
+    else
+    {
+       sub("_P$","",type)
+       return (name " = &(TheSbvector("arg")->data);")
+    }
+}
+{ print doIdent( $1, "  p->" gensub(/;/, / /, "g",$2), "TheRecord(arg)->recdata[i++]") }
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/link.sh modules/gdi/link.sh
--- origmodules/gdi/link.sh	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/link.sh	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1,6 @@
+make clisp-module INCLUDES='-I.. -I'"$absolute_linkkitdir"
+NEW_FILES='gdi-preload.lisp gdi.o'
+NEW_LIBS='gdi.o -lgdi32'
+NEW_MODULES='gdi'
+TO_LOAD='gdi'
+TO_PRELOAD='gdi-preload.lisp'
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/local.c modules/gdi/local.c
--- origmodules/gdi/local.c	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/local.c	2007-04-02 14:08:14.328125000 +0100
@@ -0,0 +1,417 @@
+#line 1 "local.c"
+static void processBOOL(void *p,object arg){}
+static void processFINDEX_INFO_LEVELS(void *p,object arg){}
+static void processFINDEX_SEARCH_OPS(void *p,object arg){}
+static void processLPSTR(void *p,object arg){}
+static void processLPWSTR(void *p,object arg){}
+static void processPBITMAPINFO(void *p,object arg){}
+static void processPINT(void *p,object arg){}
+static void processPPOINT(void *p,object arg){}
+static void processSTR_P(void *p,object arg){}
+static void processWSTR_P(void *p,object arg){}
+static void outputCOLORADJUSTMENT(COLORADJUSTMENT *p, object arg){}
+static void outputXFORM(XFORM *p, object arg){}
+static void processABC(ABC *p, object arg){}
+static void processPBYTE(BYTE *p, object arg){}
+static void processBYTE(BYTE *p, object arg){}
+static void processABCFLOAT(ABCFLOAT *p, object arg){}
+static void processENHMETAHEADER(void *p, object arg){}
+static void processFONTSIGNATURE(void *p, object arg){}
+static void processKERNINGPAIR(void *p, object arg){}
+static void processOUTLINETEXTMETRICA(void *p, object arg){}
+static void processOUTLINETEXTMETRICW(void *p, object arg){}
+static void processRASTERIZER_STATUS(void *p, object arg){}
+static void processRGBQUAD(RGBQUAD *p, object arg){}
+static void processTEXTMETRICW(TEXTMETRICW*p, object arg){}
+static void outputGLYPHMETRICS(GLYPHMETRICS* p, object arg){}
+static void processGCP_RESULTSA(GCP_RESULTSA* p, object arg){}
+static void processGCP_RESULTSW(GCP_RESULTSW* p, object arg){}
+static void processHANDLETABLE_C(HANDLETABLE* p, object arg, unsigned int count){}
+static void processLOGCOLORSPACEA(LOGCOLORSPACEA* p, object arg){}
+static void processLOGCOLORSPACEW(LOGCOLORSPACEW* p, object arg){}
+static void processMETARECORD(METARECORD* p, object arg){}
+static void processPOLYTEXTW(POLYTEXTW* p, object arg){}
+static void processSIZE(SIZE* p, object arg){}
+static void processvoid(void* p, object arg){}
+
+static void processABORTPROC(ABORTPROC *p,object arg){}
+static void processBITMAPINFO(BITMAPINFO *p,object arg){}
+static void processBITMAPINFOHEADER(BITMAPINFOHEADER *p,object arg){}
+static void processDEVMODEA(DEVMODEA *p,object arg){}
+static void processDEVMODEW(DEVMODEW *p,object arg){}
+static void processDOCINFOA(DOCINFOA *p,object arg){}
+static void processDOCINFOW(DOCINFOW *p,object arg){}
+static void processENHMETARECORD(ENHMETARECORD *p,object arg){}
+static void processENHMFENUMPROC(ENHMFENUMPROC *p,object arg){}
+static void processFONTENUMPROCA(FONTENUMPROCA *p,object arg){}
+static void processFONTENUMPROCW(FONTENUMPROCW *p,object arg){}
+static void processGLYPHMETRICS(GLYPHMETRICS *p,object arg){}
+static void processGOBJENUMPROC(GOBJENUMPROC *p,object arg){}
+static void processICMENUMPROCA(ICMENUMPROCA *p,object arg){}
+static void processICMENUMPROCW(ICMENUMPROCW *p,object arg){}
+static void processLINEDDAPROC(LINEDDAPROC *p,object arg){}
+static void processLOGPALETTE(LOGPALETTE *p,object arg){}
+static void processLOGPEN(LOGPEN *p,object arg){}
+static void processLPABC(LPABC *p,object arg){}
+static void processLPABCFLOAT(LPABCFLOAT *p,object arg){}
+static void processLPBITMAPINFO(LPBITMAPINFO *p,object arg){}
+static void processLPCHARSETINFO(LPCHARSETINFO *p,object arg){}
+static void processLPCOLORADJUSTMENT(LPCOLORADJUSTMENT *p,object arg){}
+static void processLPCRECT(LPCRECT *p,object arg){}
+static void processLPENHMETAHEADER(LPENHMETAHEADER *p,object arg){}
+static void processLPFONTSIGNATURE(LPFONTSIGNATURE *p,object arg){}
+static void processLPGCP_RESULTSA(LPGCP_RESULTSA *p,object arg){}
+static void processLPGCP_RESULTSW(LPGCP_RESULTSW *p,object arg){}
+static void processLPHANDLETABLE(LPHANDLETABLE *p,object arg){}
+static void processLPINT(LPINT *p,object arg){}
+static void processLPKERNINGPAIR(LPKERNINGPAIR *p,object arg){}
+static void processLPLOGCOLORSPACEA(LPLOGCOLORSPACEA *p,object arg){}
+static void processLPLOGCOLORSPACEW(LPLOGCOLORSPACEW *p,object arg){}
+static void processLPMETARECORD(LPMETARECORD *p,object arg){}
+static void processLPOUTLINETEXTMETRICA(LPOUTLINETEXTMETRICA *p,object arg){}
+static void processLPOUTLINETEXTMETRICW(LPOUTLINETEXTMETRICW *p,object arg){}
+static void processLPPALETTEENTRY(LPPALETTEENTRY *p,object arg){}
+static void processLPPIXELFORMATDESCRIPTOR(LPPIXELFORMATDESCRIPTOR *p,object arg){}
+static void processLPPOINT(LPPOINT *p,object arg){}
+static void processLPRASTERIZER_STATUS(LPRASTERIZER_STATUS *p,object arg){}
+static void processLPRECT(LPRECT *p,object arg){}
+static void processLPSIZE(LPSIZE *p,object arg){}
+static void processLPTEXTMETRICA(LPTEXTMETRICA *p,object arg){}
+static void processLPTEXTMETRICW(LPTEXTMETRICW *p,object arg){}
+//static void processLPXFORM(LPXFORM *p,object arg){}
+static void processMFENUMPROC(MFENUMPROC *p,object arg){}
+static void processPFLOAT(PFLOAT *p,object arg){}
+static void processRGNDATA(RGNDATA *p,object arg){}
+static void processRGNDATA_C(RGNDATA *p,object arg, int count){}
+
+nonreturning_function(static, argumentum_inritum, (object obj)) {
+  pushSTACK(obj);
+  error(error_condition,GETTEXT("~ is a invalid argument"));
+}
+
+static void processICONINFO(ICONINFO *p,object arg)
+{
+   int i = 1;
+   p->fIcon = nullp(TheRecord(arg)->recdata[i++]);
+   p->xHotspot = I_to_L(TheRecord(arg)->recdata[i++]);
+   p->yHotspot = I_to_L(TheRecord(arg)->recdata[i++]);
+   p->hbmMask = TheFpointer(TheRecord(arg)->recdata[i++])->fp_pointer;
+   p->hbmColor = TheFpointer(TheRecord(arg)->recdata[i++])->fp_pointer;
+}
+static void processLOGFONTA(LOGFONTA *p,object arg)
+{
+   int i = 1;
+   p->lfHeight = I_to_L(TheRecord(arg)->recdata[i++]);
+   p->lfWidth = I_to_L(TheRecord(arg)->recdata[i++]);
+   p->lfEscapement = I_to_L(TheRecord(arg)->recdata[i++]);
+   p->lfOrientation = I_to_L(TheRecord(arg)->recdata[i++]);
+   p->lfWeight = I_to_L(TheRecord(arg)->recdata[i++]);
+   p->lfItalic = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->lfUnderline = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->lfStrikeOut = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->lfCharSet = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->lfOutPrecision = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->lfClipPrecision = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->lfQuality = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->lfPitchAndFamily = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   strncpy(p->lfFaceName,
+      TheAsciz(string_to_asciz(TheRecord(arg)->recdata[i++],encoding)),
+      sizeof(p->lfFaceName));
+}
+static void processLOGFONTW(LOGFONTW *p,object arg){}
+static void outputRECT(object p, RECT *r)
+{
+  int i = 0;
+  object num;
+  pushSTACK(p); // Push the record to keep it safe from gc
+  num = UL_to_I(r->left); // Can cause gc
+  TheRecord(STACK_0)->recdata[i++] = num;
+  num = UL_to_I(r->top); // Can cause gc
+  TheRecord(STACK_0)->recdata[i++] = num;
+  num = UL_to_I(r->right); // Can cause gc
+  TheRecord(STACK_0)->recdata[i++] = num;
+  num = UL_to_I(r->bottom); // Can cause gc
+  TheRecord(popSTACK())->recdata[i++] = num;
+}
+// untested - was never called
+static void processPALETTEENTRY(PALETTEENTRY* p, object arg)
+{
+   int i = 0;
+   p->peRed = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->peGreen = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->peBlue = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->peFlags = I_to_uint8(TheRecord(arg)->recdata[i++]);
+}
+// untested - was never called
+static void processRGBQUAD_C(RGBQUAD* p, object args,DWORD length)
+{
+   int j;
+   for(j = 0; j < length; j++,p++)
+   {
+      int i = 0;
+      object arg = TheSvector(args)->data[j];
+      p->rgbRed = I_to_uint8(TheRecord(arg)->recdata[i++]);
+      p->rgbGreen = I_to_uint8(TheRecord(arg)->recdata[i++]);
+      p->rgbBlue = I_to_uint8(TheRecord(arg)->recdata[i++]);
+      p->rgbReserved = 0;
+   }
+}
+static DWORD processCOLORREF(object arg)
+{
+    int i = 0;
+    BYTE r = I_to_uint8(TheRecord(arg)->recdata[i++]);
+    BYTE g = I_to_uint8(TheRecord(arg)->recdata[i++]);
+    BYTE b = I_to_uint8(TheRecord(arg)->recdata[i++]);
+    return RGB(r,g,b);
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+static void processXFORM(XFORM *p, object arg)
+{
+    int i = 0;
+    ffloatjanus jfloat;
+    FF_to_c_float(TheRecord(arg)->recdata[i++],&jfloat);
+    p->eM11 = (float)(jfloat.eksplicit);
+    FF_to_c_float(TheRecord(arg)->recdata[i++],&jfloat);
+    p->eM12 = (float)(jfloat.eksplicit);
+    FF_to_c_float(TheRecord(arg)->recdata[i++],&jfloat);
+    p->eM21 = (float)(jfloat.eksplicit);
+    FF_to_c_float(TheRecord(arg)->recdata[i++],&jfloat);
+    p->eM22 = (float)(jfloat.eksplicit);
+    FF_to_c_float(TheRecord(arg)->recdata[i++],&jfloat);
+    p->eDx = (float)(jfloat.eksplicit);
+    FF_to_c_float(TheRecord(arg)->recdata[i++],&jfloat);
+    p->eDy = (float)(jfloat.eksplicit);
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+static void outputLPSIZE(LPSIZE lpsize,object arg)
+{
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+static void processPOINT(POINT* p, object arg)
+{
+   int i = 0;
+   p->x = I_to_sint32(TheRecord(arg)->recdata[i++]);
+   p->y = I_to_sint32(TheRecord(arg)->recdata[i++]);
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+static void processRECT(RECT* p, object arg)
+{
+  int i = 0;
+  p->left = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->top = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->right = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->bottom = I_to_sint32(TheRecord(arg)->recdata[i++]);
+}
+static void processPOLYTEXTA(POLYTEXTA* p, object arg)
+{
+  int i = 0;
+  p->x = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->y = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->n = I_to_uint32(TheRecord(arg)->recdata[i++]);
+  p->lpstr = TheAsciz(TheRecord(arg)->recdata[i++]);
+  p->uiFlags = I_to_uint32(TheRecord(arg)->recdata[i++]);
+  processRECT(&p->rcl, TheRecord(arg)->recdata[i++]);
+  p->pdx = I_to_sint32(TheRecord(arg)->recdata[i++]);
+}
+// untested - was never called
+static void processCOLORADJUSTMENT(COLORADJUSTMENT *p, object arg)
+{
+   int i;
+   WORD *w = (WORD*)p;
+   SHORT *s = (SHORT*)p;
+   for(i = 0; i < 8; i++)w[i]= I_to_uint16(TheRecord(arg)->recdata[i]);
+   for(; i < 12; i++)s[i] = I_to_sint16(TheRecord(arg)->recdata[i]);
+}
+// untested - was never called
+static void processPIXELFORMATDESCRIPTOR(PIXELFORMATDESCRIPTOR* p,object arg)
+{
+  int i = 0;
+  p->nSize = I_to_uint16(TheRecord(arg)->recdata[i++]);
+  p->nVersion = I_to_uint16(TheRecord(arg)->recdata[i++]);
+  p->dwFlags = I_to_uint32(TheRecord(arg)->recdata[i++]);
+  p->iPixelType = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cColorBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cRedBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cRedShift = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cGreenBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cGreenShift = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cBlueBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cBlueShift = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cAlphaBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cAlphaShift = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cAccumBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cAccumRedBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cAccumGreenBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cAccumBlueBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cAccumAlphaBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cDepthBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cStencilBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cAuxBuffers = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->iLayerType = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->bReserved = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->dwLayerMask = I_to_uint32(TheRecord(arg)->recdata[i++]);
+  p->dwVisibleMask = I_to_uint32(TheRecord(arg)->recdata[i++]);
+  p->dwDamageMask = I_to_uint32(TheRecord(arg)->recdata[i++]);
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+// known not to work
+static FIXED toFixed(float f)
+{
+  FIXED fixed;
+  fixed.value = (int)f;
+  fixed.fract = (WORD)(10000*(f - fixed.value));
+  return fixed;
+}
+
+static void processMAT2(MAT2 *p, object arg)
+{
+  int i = 0;
+  ffloatjanus f;
+  FF_to_c_float(TheRecord(arg)->recdata[i++],&f);
+  p->eM11 = toFixed((float)(f.eksplicit));
+  FF_to_c_float(TheRecord(arg)->recdata[i++],&f);
+  p->eM12 = toFixed((float)(f.eksplicit));
+  FF_to_c_float(TheRecord(arg)->recdata[i++],&f);
+  p->eM21 = toFixed((float)(f.eksplicit));
+  FF_to_c_float(TheRecord(arg)->recdata[i++],&f);
+  p->eM22 = toFixed((float)(f.eksplicit));
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+static void processBITMAP(BITMAP *p,object arg)
+{
+  int i = 0;
+  p->bmType = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->bmWidth = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->bmHeight = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->bmWidthBytes = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->bmPlanes = I_to_uint16(TheRecord(arg)->recdata[i++]);
+  p->bmBitsPixel = I_to_uint16(TheRecord(arg)->recdata[i++]);
+  p->bmBits = &TheSbvector( TheRecord(arg)->recdata[i++])->data[0];
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+static void processLOGBRUSH(LOGBRUSH* p, object arg)
+{
+   int i = 0;
+   p->lbStyle = I_to_uint32(TheRecord(arg)->recdata[i++]);
+   p->lbColor = processCOLORREF(TheRecord(arg)->recdata[i++]);
+   p->lbHatch = I_to_sint32(TheRecord(arg)->recdata[i++]);
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+static void processMETAFILEPICT(METAFILEPICT *p,object arg)
+{
+  int i = 0;
+  p->mm = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->xExt = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->yExt = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->hMF = TheFpointer(TheRecord(arg)->recdata[i++])->fp_pointer;
+}
+
+static void processWNDCLASSA(WNDCLASSA *p, object arg)
+{
+  object s;
+  int i = 1;
+  p->style = I_to_uint32(TheRecord(arg)->recdata[i++]);
+  p->lpfnWndProc  = WindowProc;
+  p->cbClsExtra = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->cbWndExtra = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->hInstance = TheFpointer(TheRecord(arg)->recdata[i++])->fp_pointer;
+  s = TheRecord(arg)->recdata[i++];
+  p->hIcon = nullp(s)?0:TheFpointer(s)->fp_pointer;
+  p->hCursor = TheFpointer(TheRecord(arg)->recdata[i++])->fp_pointer;
+  p->hbrBackground = TheFpointer(TheRecord(arg)->recdata[i++])->fp_pointer;
+  s = TheRecord(arg)->recdata[i++];
+  if(nullp(s))
+  {
+     p->lpszMenuName = NULL;
+  }
+  else if(stringp(s))
+  {
+     p->lpszMenuName = TheAsciz(string_to_asciz(s,encoding));
+  }
+  else if(fpointerp(s))
+  {
+     p->lpszMenuName = TheFpointer(s)->fp_pointer;
+  }
+  else argumentum_inritum(s);
+  s = TheRecord(arg)->recdata[i++];
+  p->lpszClassName = stringp(s)?
+       TheAsciz(string_to_asciz(s,encoding)):
+       TheFpointer(s)->fp_pointer;
+}
+
+static void processWNDCLASSW(WNDCLASSW *p, object arg){}
+
+static void processCREATESTRUCTA(CREATESTRUCT *p, object arg)
+{
+  object s;
+  int i = 1;
+  p->dwExStyle = I_to_uint32(TheRecord(arg)->recdata[i++]);
+  s = TheRecord(arg)->recdata[i++];
+  p->lpszClass = stringp(s)?
+       TheAsciz(string_to_asciz(s,encoding)):
+       TheFpointer(s)->fp_pointer;
+  p->lpszName = TheAsciz(string_to_asciz(TheRecord(arg)->recdata[i++],encoding));
+  p->style = I_to_uint32(TheRecord(arg)->recdata[i++]);
+  p->x = I_to_L(TheRecord(arg)->recdata[i++]);
+  p->y = I_to_L(TheRecord(arg)->recdata[i++]);
+  p->cx = I_to_L(TheRecord(arg)->recdata[i++]);
+  p->cy = I_to_L(TheRecord(arg)->recdata[i++]);
+  s = TheRecord(arg)->recdata[i++];
+  p->hwndParent = nullp(s)?0:TheFpointer(s)->fp_pointer;
+  s = TheRecord(arg)->recdata[i++];
+  p->hMenu = nullp(s)?0:TheFpointer(s)->fp_pointer;
+  s = TheRecord(arg)->recdata[i++];
+  p->hInstance = nullp(s)?0:TheFpointer(s)->fp_pointer;
+  p->lpCreateParams = 0;  //= I_to_uint8(TheRecord(arg)->recdata[i++]);
+}
+static void outputCREATESTRUCTA(CREATESTRUCT *p, object arg)
+{
+  int i = 1;
+  pushSTACK(arg);
+  TheRecord(STACK_0)->recdata[i++] = UL_to_I(p->dwExStyle);
+  TheRecord(STACK_0)->recdata[i++] = asciz_to_string(p->lpszClass,encoding);
+  TheRecord(STACK_0)->recdata[i++] = asciz_to_string(p->lpszName,encoding);
+  TheRecord(STACK_0)->recdata[i++] = UL_to_I(p->style);
+  TheRecord(STACK_0)->recdata[i++] = L_to_I(p->x);
+  TheRecord(STACK_0)->recdata[i++] = L_to_I(p->y);
+  TheRecord(STACK_0)->recdata[i++] = L_to_I(p->cx);
+  TheRecord(STACK_0)->recdata[i++] = L_to_I(p->cy);
+  TheRecord(STACK_0)->recdata[i++] = allocate_fpointer(p->hwndParent);
+  TheRecord(STACK_0)->recdata[i++] = allocate_fpointer(p->hMenu);
+  TheRecord(STACK_0)->recdata[i++] = allocate_fpointer(p->hInstance);
+  TheRecord(popSTACK())->recdata[i++] = NIL; //L_to_I(p->lpCreateParams);
+}
+static void outputTEXTMETRICA(TEXTMETRICA *p, object arg)
+{
+  int i = 1;
+  pushSTACK(arg);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmHeight);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmAscent);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmDescent);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmInternalLeading);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmExternalLeading);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmAveCharWidth);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmMaxCharWidth);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmWeight);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmOverhang);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmDigitizedAspectX);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmDigitizedAspectY);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmFirstChar);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmLastChar);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmDefaultChar);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmBreakChar);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmItalic);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmUnderlined);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmStruckOut);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmPitchAndFamily);
+  TheRecord(popSTACK())->recdata[i++] = fixnum(p->tmCharSet);
+}
+static object outputFLOATS(FLOAT *p, UINT length){}
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/p1.lisp modules/gdi/p1.lisp
--- origmodules/gdi/p1.lisp	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/p1.lisp	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1,39 @@
+(use-package "GDI")
+(defun f ()
+  (let* ((hdc (multiple-value-bind (retval h) (GDI::GetDC nil)
+                 (if retval h (error "getdc ~S" h))))
+         (sy (multiple-value-bind (retval l)
+                         (GDI::GetDeviceCaps hdc LOGPIXELSY)
+                 (if retval l (error "getdevicecaps ~S" l))))
+         (logfont (make-logfont
+              (- sy) 0 0 0 FW_BOLD 1 0 0 ANSI_CHARSET
+              OUT_TT_PRECIS CLIP_DEFAULT_PRECIS
+              PROOF_QUALITY VARIABLE_PITCH
+              "Times New Roman"))
+         (hfont (multiple-value-bind (retval h)
+                  (GDI::CreateFontIndirectA logfont)
+                  (if retval h (error "CreateFontA ~S" h))))
+         (x (/ (GDI::GetSystemMetrics SM_CXSCREEN) 2))
+         (y (/ (GDI::GetSystemMetrics SM_CYSCREEN) 2))
+         (hold (multiple-value-bind (retval h) (GDI::SelectObject hdc hfont)
+                 (if retval h (error "GetDC ~S" h)))))
+     (GDI::SetTextAlign hdc (logior TA_CENTER TA_BASELINE))
+     (GDI::SetBkMode hdc TRANSPARENT)
+     (GDI::SetTextColor hdc (GDI::make-rgb 0 0 #xff))
+     (GDI::TextOutA hdc x y "HELLO WORLD" 11)
+     (GDI::SelectObject hdc hold)
+     (GDI::DeleteObject hfont)))
+
+(trace GDI::CreateFontIndirectA)
+(trace GDI::DeleteObject)
+(trace GDI::GetDC)
+(trace GDI::GetDeviceCaps)
+(trace GDI::GetSystemMetrics)
+(trace GDI::make-rgb)
+(trace GDI::make-logfont)
+(trace GDI::SelectObject)
+(trace GDI::SetBkMode)
+(trace GDI::SetTextAlign)
+(trace GDI::SetTextColor)
+(trace GDI::TextOutA)
+(f)
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/p2.lisp modules/gdi/p2.lisp
--- origmodules/gdi/p2.lisp	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/p2.lisp	2007-04-02 14:21:51.296875000 +0100
@@ -0,0 +1,55 @@
+(use-package "GDI")
+(defun f ()
+  (let* ((hwnd (multiple-value-bind (retval h)
+                  (GDI::CreateFontA (- (GDI::GetDeviceCaps hdc LOGPIXELSY))
+                                    0 0 0 FW_BOLD T NIL NIL ANSI_CHARSET
+                                    OUT_TT_PRECIS CLIP_DEFAULT_PRECIS
+                                    PROOF_QUALITY VARIABLE_PITCH
+                                    "Times New Roman")
+                  (if retval h (error "CreateFontA ~S" h))))
+         (x (/ (GDI::GetSystemMetrics SM_CXSCREEN) 2))
+         (y (/ (GDI::GetSystemMetrics SM_CYSCREEN) 2))
+         (hold (multiple-value-bind (retval h) (GDI::SelectObject hdc hfont)
+                 (if retval h (error "getdc ~S" h)))))
+     (GDI::SetTextAlign hdc (logior TA_CENTER TA_BASELINE))
+     (GDI::SetBkMode hdc TRANSPARENT)
+     (GDI::SetTextColor hdc (GDI::make-rgb 0 0 #xff))
+     (GDI::TextOutA hdc x y "HELLO WORLD" 11)
+     (GDI::SelectObject hdc hold)
+     (GDI::DeleteObject hfont)))
+
+(defun onDraw (hdc)
+     (GDI::TextOutA hdc 0 0 "HELLO WORLD" 11))
+
+(defun onKeyDown (wparam lparam) (quit))
+
+(defun main ()
+   (add-callbacks WM_NCCREATE (list (cons WM_PAINT #'onDraw) (cons WM_KEYDOWN #'onKeyDown)))
+   (let* (
+           (cn "HelloWorld")
+           (wc (or (GDI::FindAtomA cn) (GDI::GlobalFindAtomA cn)
+                     (multiple-value-bind (retval h)
+                      (GDI::RegisterClassA
+                         (GDI::make-wndclass 0 0 0 GDI::*hinstance* NIL
+                           (multiple-value-bind (retval h)
+                               (GDI::LoadCursorA NIL (GDI::GetIDC IDC_ARROW))
+                             (if retval h (error "LoadCursor ~S" h)))
+                           (multiple-value-bind (retval h) (GDI::GetStockObject WHITE_BRUSH)
+                             (if retval h (error "GetStockObject ~S" h)))
+                           NIL cn))
+                          (if retval h (error "RegisterClassA ~S" h)))))
+           (cr (GDI::make-createstruct 0 wc "Hello World"
+                  WS_POPUP 0 0 (/ (GDI::GetSystemMetrics SM_CXSCREEN) 2)
+                  (/ (GDI::GetSystemMetrics SM_CYSCREEN) 2)
+                  NIL NIL GDI::*hinstance* NIL))
+           (win (multiple-value-bind (retval h) (GDI::CreateWindowIndirectA cr)
+                  (if retval h (error "CreateWindowIndirect ~S" h)))))
+        (GDI::ShowWindow win SW_SHOWNORMAL)
+        (GDI::UpdateWindow win)
+        (GDI::MessageLoop)))
+(trace GDI:make-wndclass)
+(trace GDI:make-createstruct)
+(trace GDI::add-callbacks)
+(trace onDraw)
+(trace GDI::onCreate)
+(main)
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/struct1.awk modules/gdi/struct1.awk
--- origmodules/gdi/struct1.awk	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/struct1.awk	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1 @@
+{ printf("  p->%s = I_to_uint8(TheRecord(arg)->recdata[i++]);\n",$2) }
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/struct2.awk modules/gdi/struct2.awk
--- origmodules/gdi/struct2.awk	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/struct2.awk	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1 @@
+{ printf("(%s 0 :type fixnum)\n",tolower($2))}
diff -urN -x CYGWIN-PATCHES -x 'aclocal.m4*' -x ltmain.sh -x 'config.*' -x depcomp -x install-sh -x missing -x mkinstalldirs -x autom4te.cache -x '*compile' -x Makefile.in.in -x 'intltool*.in' -x 'xml-i18n-*.in' -x '*.pyc' -x '*.mo' -x '*.gmo' -x ABOUT-NLS -x Makevars.template -x COPYING -x INSTALL -x mdate-sh -x '*.orig' -x '*.rej' -x '*~' -x '*.temp' -x texinfo.tex -x ylwrap -x gnome-doc-utils.make -x gnome-doc-utils.m4 -x intltool.m4 -x omf.make -x xmldocs.make -x build origmodules/gdi/struct3.awk modules/gdi/struct3.awk
--- origmodules/gdi/struct3.awk	1970-01-01 00:00:00.000000000 +0000
+++ modules/gdi/struct3.awk	2007-04-04 13:52:28.000000000 +0100
@@ -0,0 +1 @@
+{ printf("  TheRecord(STACK_0)->recdata[i++] = fixnum(p->%s);\n",$1) }
