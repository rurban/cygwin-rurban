diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/APIFile/File.pm perl-libwin32-0.24/APIFile/File.pm
--- libwin32-0.24-orig/APIFile/File.pm	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/APIFile/File.pm	2004-12-01 23:55:52.000000000 +0000
@@ -5,12 +5,30 @@
 use strict;
 use Carp;
 use Fcntl qw( O_RDONLY O_RDWR O_WRONLY O_APPEND O_BINARY O_TEXT );
+use Config;
+use integer;
 use vars qw( $VERSION @ISA );
 use vars qw( @EXPORT @EXPORT_OK @EXPORT_FAIL %EXPORT_TAGS );
 $VERSION= '0.09';
 
-use base qw( Exporter DynaLoader );
+use base qw( Exporter DynaLoader Tie::Handle IO::File );
 
+use constant FALSE => 0;
+use constant TRUE  => 1;
+
+# Math::BigInt optimizations courtesy of Tels
+BEGIN {
+	require Math::BigInt;
+	Math::BigInt->import(lib => 'GMP') if $Math::BigInt::VERSION >= 1.60;
+}
+
+my $_64BITINT  = defined $Config{use64bitint} &&
+		 $Config{use64bitint} eq 'define';
+
+my $THIRTY_TWO = $_64BITINT ? 32 : new Math::BigInt 32;
+
+my $FFFFFFFF   = $_64BITINT ? 0xFFFFFFFF : new Math::BigInt 0xFFFFFFFF;
+		
 @EXPORT= qw();
 %EXPORT_TAGS= (
     Func =>	[qw(		attrLetsToBits		createFile
@@ -23,7 +41,8 @@
 	IsContainerPartition	MoveFile		MoveFileEx
 	OsFHandleOpen		OsFHandleOpenFd		QueryDosDevice
 	ReadFile		SetErrorMode		SetFilePointer
-	SetHandleInformation	WriteFile )],
+	SetHandleInformation	WriteFile		GetFileSize
+	getFileSize		setFilePointer		GetOverlappedResult)],
     FuncA =>	[qw(
 	CopyFileA		CreateFileA		DefineDosDeviceA
 	DeleteFileA		GetDriveTypeA		GetLogicalDriveStringsA
@@ -179,18 +198,29 @@
     return 0;
 }
 
-BEGIN {
-    my $code= 'return _fileLastError(@_)';
-    local( $!, $^E )= ( 1, 1 );
-    if(  $! ne $^E  ) {
-	$code= '
-	    local( $^E )= _fileLastError(@_);
-	    my $ret= $^E;
-	    return $ret;
-	';
-    }
-    eval "sub fileLastError { $code }";
-    die "$@"   if  $@;
+package Win32API::File::_error;
+
+use overload
+  '""' => sub {
+	use Win32;
+	$_ = Win32::FormatMessage(Win32API::File::_fileLastError());
+	tr/\r\n//d; return $_;
+  },
+  '0+' => sub { Win32API::File::_fileLastError() },
+  'fallback' => 1;
+
+sub new { return bless {}, shift }
+sub set { Win32API::File::_fileLastError($_[1]); return $_[0] }
+
+package Win32API::File;
+
+my $_error = new Win32API::File::_error;
+
+sub fileLastError {
+	croak 'Usage: ',__PACKAGE__,'::fileLastError( [$setWin32ErrCode] )'
+		if @_ > 1;
+	$_error->set($_[0]) if defined $_[0];
+	return $_error;
 }
 
 # Since we ISA DynaLoader which ISA AutoLoader, we ISA AutoLoader so we
@@ -259,9 +289,15 @@
 	$mode |= $o_text;
     }
     $mode |= O_BINARY   if  $access =~ /b/i;
-    my $fd= OsFHandleOpenFd( $osfh, $mode );
-    return  undef   if  $fd < 0;
-    return  open( $fh, $pref."&=".$fd );
+    undef $@;
+    my $fd = eval {
+	OsFHandleOpenFd( $osfh, $mode );
+    }; if ($@) {
+	return tie *{$fh}, __PACKAGE__, $osfh;
+    } else {
+	return  undef   if  $fd < 0;
+	return  open( $fh, $pref."&=".$fd );
+    }
 }
 
 sub GetOsFHandle {
@@ -274,7 +310,17 @@
 	    $file= caller() . "::" . $file;
 	}
 	no strict "refs";
-	$file= \*{$file};
+	 
+# The eval "" is necessary in Perl 5.6, avoid it otherwise.
+	my $tied = !defined($^]) || $^] < 5.008 ?
+		eval "tied *{$file}" :
+		tied *{$file};
+
+	if (UNIVERSAL::isa($tied => __PACKAGE__)) {
+		return $tied->win32_handle;
+	}
+
+	$file= *{$file};
     }
     my( $fd )= fileno($file);
     if(  ! defined( $fd )  ) {
@@ -293,6 +339,52 @@
     return $h;
 }
 
+sub getFileSize {
+	croak 'Win32API::File Usage:  $size= getFileSize($hNativeHandle)'
+		if @_ != 1;
+
+	my $handle    = shift;
+	my $high_size = 0;
+
+	my $low_size = GetFileSize($handle, $high_size);
+
+	my $retval = $_64BITINT ?
+		$high_size : new Math::BigInt $high_size;
+
+	$retval <<= $THIRTY_TWO;
+	$retval +=  $low_size;
+
+	return $retval;
+}
+
+sub setFilePointer {
+	croak 'Win32API::File Usage:  $pos= setFilePointer($hNativeHandle, $posl, $from_where)'
+		if @_ != 3;
+
+	my ($handle, $pos, $from_where) = @_;
+
+	my ($pos_low, $pos_high) = ($pos, 0);
+
+	if ($_64BITINT) {
+		$pos_low  = ($pos & $FFFFFFFF);
+		$pos_high = (($pos >> $THIRTY_TWO) & $FFFFFFFF);
+	} elsif (UNIVERSAL::isa($pos => 'Math::BigInt')) {
+		$pos_low  = ($pos & $FFFFFFFF)->numify();
+		$pos_high = (($pos >> $THIRTY_TWO) & $FFFFFFFF)->numify();
+	}
+
+	my $retval = SetFilePointer($handle, $pos_low, $pos_high, $from_where);
+
+	if (defined $pos_high && $pos_high != 0) {
+		$retval   = new Math::BigInt $retval   unless $_64BITINT;
+		$pos_high = new Math::BigInt $pos_high unless $_64BITINT;
+
+		$retval += $pos_high << $THIRTY_TWO;
+	}
+
+	return $retval;
+}
+
 sub attrLetsToBits
 {
     my( $lets )= @_;
@@ -443,6 +535,253 @@
     return $ref;
 }
 
+###############################################################################
+#   Experimental Tied Handle and Object Oriented interface.                   #
+###############################################################################
+
+sub new {
+	my $class = shift;
+	$class = ref $class || $class;
+
+	my $self = IO::File::new($class);
+	tie *$self, __PACKAGE__;
+
+	$self->open(@_) if @_;
+
+	return $self;
+}
+
+sub TIEHANDLE {
+	my ($class, $win32_handle) = @_;
+	$class = ref $class || $class;
+
+	return bless {
+		_win32_handle => $win32_handle,
+		_binmode      => FALSE,
+		_buffered     => FALSE,
+		_buffer       => '',
+		_eof          => FALSE,
+		_fileno       => undef,
+		_access       => 'r',
+		_append       => FALSE,
+	}, $class;
+}
+
+# This is called for getting the tied object from hard refs to glob refs in
+# some cases, for reasons I don't quite grok.
+
+sub FETCH { return $_[0] }
+
+# Public accessors
+
+sub win32_handle{ $_[0]->{_win32_handle}||= $_[1] }
+
+# Protected accessors
+
+sub _buffer	{ $_[0]->{_buffer}	||= $_[1] }
+sub _binmode	{ $_[0]->{_binmode}	||= $_[1] }
+sub _fileno	{ $_[0]->{_fileno}	||= $_[1] }
+sub _access	{ $_[0]->{_access}	||= $_[1] }
+sub _append	{ $_[0]->{_append}	||= $_[1] }
+
+# Tie interface
+
+sub OPEN {
+	my $self  = shift;
+	my $expr  = shift;
+	croak "Only the two argument form of open is supported at this time" if @_;
+# FIXME: this needs to parse the full Perl open syntax in $expr
+
+	my ($mixed, $mode, $path) =
+		($expr =~ /^\s* (\+)? \s* (<|>|>>)? \s* (.*?) \s*$/x);
+
+	croak "Unsupported open mode" if not $path;
+
+	my $access = 'r';
+	my $append = $mode eq '>>' ? TRUE : FALSE;
+
+	if ($mixed) {
+		$access = 'rw';
+	} elsif($mode eq '>') {
+		$access = 'w';
+	}
+
+	my $w32_handle = createFile($path, $access);
+
+	$self->win32_handle($w32_handle);
+
+	$self->seek(1,2) if $append;
+
+	$self->_access($access);
+	$self->_append($append);
+
+	return TRUE;
+}
+
+sub BINMODE {
+	$_[0]->_binmode(TRUE);
+}
+
+sub WRITE {
+	my ($self, $buf, $len, $offset, $overlap) = @_;
+
+	if ($offset) {
+		$buf = substr($buf, $offset);
+		$len = length($buf);
+	}
+
+	$len       = length($buf) if not defined $len;
+
+	$overlap   = [] if not defined $overlap;;
+
+	my $bytes_written = 0;
+
+	WriteFile (
+		$self->win32_handle, $buf, $len,
+		$bytes_written, $overlap
+	);
+
+	return $bytes_written;
+}
+
+sub PRINT {
+	my $self = shift;
+
+	my $buf = join defined $, ? $, : "" => @_;
+
+	$buf =~ s/\012/\015\012/sg unless $self->_binmode();
+
+	$buf .= $\ if defined $\;
+
+	$self->WRITE($buf, length($buf), 0);
+}
+
+sub READ {
+	my $self = shift;
+	my $into = \$_[0]; shift;
+	my ($len, $offset, $overlap) = @_;
+
+	my $buffer     = defined $self->_buffer ? $self->_buffer : "";
+	my $buf_length = length($buffer);
+	my $bytes_read = 0;
+	my $data;
+	$offset        = 0 if not defined $offset;
+
+	if ($buf_length >= $len) {
+		$data       = substr($buffer, 0, $len => "");
+		$bytes_read = $len;
+		$self->_buffer($buffer);
+	} else {
+		if ($buf_length > 0) {
+			$len -= $buf_length;
+			substr($$into, $offset) = $buffer;
+			$offset += $buf_length;
+		}
+
+		$overlap ||= [];
+
+		ReadFile (
+			$self->win32_handle, $data, $len,
+			$bytes_read, $overlap
+		);
+	}
+
+	$$into = "" if not defined $$into;
+
+	substr($$into, $offset) = $data;
+
+	return $bytes_read;
+}
+
+sub READLINE {
+	my $self = shift;
+	my $line = "";
+
+	while ((index $line, $/) == $[-1) { # read until end of line marker
+		my $char = $self->GETC();
+
+		last if !defined $char || $char eq '';
+
+		$line .= $char;
+	}
+
+	return undef if $line eq '';
+
+	return $line;
+}
+
+
+sub FILENO {
+	my $self = shift;
+
+	return $self->_fileno() if defined $self->_fileno();
+
+	return -1 if $^O eq 'cygwin';
+
+# FIXME: We don't always open the handle, better to query the handle or to set
+# the right access info at TIEHANDLE time.
+
+	my $access = $self->_access();
+	my $mode   = $access eq 'rw' ? O_RDWR :
+		$access eq 'w' ? O_WRONLY : O_RDONLY;
+
+	$mode |= O_APPEND if $self->_append();
+
+	$mode |= O_TEXT   if not $self->_binmode();
+
+	return $self->_fileno ( OsfHandleOpenFd (
+		$self->win32_handle, $mode
+	));
+}
+
+sub SEEK {
+	my ($self, $pos, $whence) = @_;
+
+	$whence = 0 if not defined $whence;
+	my @file_consts = map {
+		fileConstant($_)
+	} qw(FILE_BEGIN FILE_CURRENT FILE_END);
+
+	my $from_where = $file_consts[$whence];
+
+	return setFilePointer($self->win32_handle, $pos, $from_where);
+}
+
+sub TELL {
+# SetFilePointer with position 0 at FILE_CURRENT will return position.
+	return $_[0]->SEEK(0, 1);
+}
+
+sub EOF {
+	my $self = shift;
+
+	my $current = $self->TELL() + 0;
+	my $end     = getFileSize($self->win32_handle) + 0;
+
+	return $current == $end;
+}
+
+sub CLOSE {
+	my $self = shift;
+
+	my $retval = TRUE;
+	
+	if (defined $self->win32_handle) {
+		$retval = CloseHandle($self->win32_handle);
+
+		$self->win32_handle(undef);
+	}
+
+	return $retval;
+}
+
+# Only close the handle on explicit close, too many problems otherwise.
+sub UNTIE {}
+
+sub DESTROY {}
+
+# End of Tie/OO Interface
+
 # Autoload methods go after =cut, and are processed by the autosplit program.
 
 1;
@@ -476,6 +815,26 @@
 All functions, unless otherwise noted, return a true value for success
 and a false value for failure and set C<$^E> on failure.
 
+=head2 Object Oriented/Tied Handle Interface
+
+WARNING: this is new code, use at your own risk.
+
+This version of C<Win32API::File> can be used like an C<IO::File> object. Ie:
+
+  my $file = new Win32API::File "+> foo";
+  binmode $file;
+  print $file "hello there\n";
+  seek $file, 0, 0;
+  my $line = <$file>;
+  $file->close;
+
+It also supports tying via a win32 handle (for example, from C<createFile()>):
+
+  tie FILE, 'Win32API::File', $win32_handle;
+  print FILE "...";
+
+It has not been extensively tested yet and buffered I/O is not yet implemented.
+
 =head2 Exports
 
 Nothing is exported by default.  The following tags can be used to
@@ -500,7 +859,8 @@
 C<IsContainerPartition>,  C<MoveFile>,             C<MoveFileEx>,
 C<OsFHandleOpen>,         C<OsFHandleOpenFd>,      C<QueryDosDevice>,
 C<ReadFile>,              C<SetErrorMode>,         C<SetFilePointer>,
-C<SetHandleInformation>,  and                      C<WriteFile>.
+C<SetHandleInformation>,  C<GetFileSize>,          C<getFileSize>,
+C<setFilePointer>,        C<WriteFile> and         C<GetOverlappedResult>
 
 =over
 
@@ -1234,6 +1594,39 @@
 
 =back
 
+=item getFileSize
+
+=item C<$size= getFileSize( $hFile )>
+
+This is a Perl-friendly wrapper for the C<GetFileSize> (below) API call.
+
+It takes a Win32 native file handle and returns the size in bytes. Since the
+size can be a 64 bit value, on non 64 bit integer Perls the value returned will
+be an object of type C<Math::BigInt>.
+
+=item GetFileSize
+
+=item C<$iSizeLow= GetFileSize($win32Handle, $iSizeHigh)>
+
+Returns the size of a file pointed to by C<$win32Handle>, optionally storing
+the high order 32 bits into C<$iSizeHigh> if it is not C<[]>. If $iSizeHigh is
+C<[]>, a non-zero value indicates success. Otherwise, on failure the return
+value will be C<0xffffffff> and C<fileLastError()> will not be C<NO_ERROR>.
+
+=item GetOverlappedResult
+
+=item C<$bRetval= GetOverlappedResult( $win32Handle, $pOverlapped,
+ $numBytesTransferred, $bWait )>
+
+Used for asynchronous IO in Win32 to get the result of a pending IO operation,
+such as when a file operation returns C<ERROR_IO_PENDING>. Returns a false
+value on failure. The C<$overlapped> structure and C<$numBytesTransferred>
+will be modified with the results of the operation.
+
+As far as creating the C<$pOverlapped> structure, you are currently on your own.
+
+See L<http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/getoverlappedresult.asp> for more information.
+
 =item GetLogicalDrives
 
 =item C<$uDriveBits= GetLogicalDrives()>
@@ -1505,12 +1898,11 @@
 Opens a file descriptor [C<$ivFD>] based on an already open Win32
 native file handle, C<$hNativeHandle>.  This just calls the
 Win32-specific C routine C<_open_osfhandle()> or Perl's "improved"
-version called C<win32_open_osfhandle()>.  Prior to Perl5.005, C's
-C<_open_osfhandle()> is called which will fail if
-C<GetFileType($hNativeHandle)> would return C<FILE_TYPE_UNKNOWN>.  
-For Perl5.005 and later, C<OsFHandleOpenFd> calls
-C<win32_open_osfhandle()> from the Perl DLL which doesn't have this
-restriction.
+version called C<win32_open_osfhandle()>.  Prior to Perl5.005 and in Cygwin
+Perl, C's C<_open_osfhandle()> is called which will fail if
+C<GetFileType($hNativeHandle)> would return C<FILE_TYPE_UNKNOWN>.  For
+Perl5.005 and later, C<OsFHandleOpenFd> calls C<win32_open_osfhandle()> from
+the Perl DLL which doesn't have this restriction.
 
 C<$uMode> the logical combination of zero or more C<O_*> constants
 exported by the C<Fcntl> module.  Currently only C<O_APPEND> and
@@ -1632,6 +2024,15 @@
 
 =back
 
+=item setFilePointer
+
+=item C<$uNewPos= setFilePointer( $hFile, $ivOffset, $uFromWhere )>
+
+This is a perl-friendly wrapper for the SetFilePointer API (below).
+C<$ivOffset> can be a 64 bit integer or C<Math::BigInt> object if your Perl
+doesn't have 64 bit integers. The return value is the new offset and will
+likewise be a 64 bit integer or a C<Math::BigInt> object.
+
 =item SetFilePointer
 
 =item C<$uNewPos= SetFilePointer( $hFile, $ivOffset, $ioivOffsetHigh, $uFromWhere )>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/APIFile/File.xs perl-libwin32-0.24/APIFile/File.xs
--- libwin32-0.24-orig/APIFile/File.xs	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/APIFile/File.xs	2005-02-14 18:08:32.718750000 +0000
@@ -476,11 +457,40 @@
 	opBuffer	trunc_buf_l( RETVAL, opBuffer,ST(1), olBytesRead );
 	olBytesRead
 
+BOOL
+GetOverlappedResult( hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait)
+	HANDLE hFile
+	LPOVERLAPPED lpOverlapped
+	LPDWORD lpNumberOfBytesTransferred
+	BOOL bWait
+    CODE:
+    	RETVAL= GetOverlappedResult( hFile, lpOverlapped,
+	 lpNumberOfBytesTransferred, bWait);
+	SaveErr( !RETVAL );
+    OUTPUT:
+    	RETVAL
+	lpOverlapped
+	lpNumberOfBytesTransferred
+
+DWORD
+GetFileSize( hFile, lpFileSizeHigh )
+	HANDLE hFile
+	LPDWORD lpFileSizeHigh
+    CODE:
+    	RETVAL= GetFileSize( hFile, lpFileSizeHigh );
+	SaveErr( NO_ERROR != GetLastError() );
+    OUTPUT:
+    	RETVAL
+	lpFileSizeHigh
+
 
 UINT
 SetErrorMode( uNewMode )
 	UINT	uNewMode
-
+    CODE:
+    	RETVAL= SetErrorMode( uNewMode );
+    OUTPUT:
+    	RETVAL
 
 LONG
 SetFilePointer( hFile, ivOffset, ioivOffsetHigh, uFromWhere )
@@ -490,7 +500,7 @@
 	DWORD	uFromWhere
     CODE:
 	RETVAL= SetFilePointer( hFile, ivOffset, ioivOffsetHigh, uFromWhere );
-	if(  ~0 == RETVAL  ) {
+	if(  RETVAL == INVALID_SET_FILE_POINTER && (GetLastError() != NO_ERROR)  ) {
 	    SaveErr( 1 );
 	    XST_mNO(0);
 	} else if(  0 == RETVAL  ) {
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/APIFile/MANIFEST perl-libwin32-0.24/APIFile/MANIFEST
--- libwin32-0.24-orig/APIFile/MANIFEST	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/APIFile/MANIFEST	2004-12-01 23:55:52.000000000 +0000
@@ -8,8 +8,8 @@
 const2perl.h
 cFile.h
 cFile.pc
 ppport.h
 test.pl
+t/tie.t
 typemap
 ExtUtils/Myconst2perl.pm
 ex/CopyBoot.bat
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/APIFile/t/tie.t perl-libwin32-0.24/APIFile/t/tie.t
--- libwin32-0.24-orig/APIFile/t/tie.t	1970-01-01 00:00:00.000000000 +0000
+++ perl-libwin32-0.24/APIFile/t/tie.t	2004-12-01 23:55:52.000000000 +0000
@@ -0,0 +1,79 @@
+#!perl
+# vim:syntax=perl:
+
+BEGIN { $|= 1; print "1..10\n"; }
+END   { print "not ok 1\n" unless $main::loaded; }
+
+use strict;
+use warnings;
+use Win32API::File qw(:ALL);
+use IO::File;
+
+$main::loaded = 1;
+
+print "ok 1\n";
+
+unlink "foo.txt";
+
+my $fh = new Win32API::File "+> foo.txt"
+	or die fileLastError();
+
+my $tell = tell $fh;
+print "# tell \$fh == '$tell'\n";
+print "not " unless
+	tell $fh == 0;
+print "ok 2\n";
+
+my $text = "some text\n";
+
+print "not " unless
+	print $fh $text;
+print "ok 3\n";
+
+$tell = tell $fh;
+print "# after printing 'some text\\n', tell is: '$tell'\n";
+print "not " unless
+	$tell == length($text) + 1;
+print "ok 4\n";
+
+print "not " unless
+	seek($fh, 0, 0) == 0;
+print "ok 5\n";
+
+print "not " unless
+	not eof $fh;
+print "ok 6\n";
+
+my $readline = <$fh>;
+
+my $pretty_readline = $readline;
+$pretty_readline =~ s/\r/\\r/g;  $pretty_readline =~ s/\n/\\n/g;  
+print "# read line is '$pretty_readline'\n";
+
+print "not " unless
+	$readline eq "some text\r\n";
+print "ok 7\n";
+
+print "not " unless
+	eof $fh;
+print "ok 8\n";
+
+print "not " unless
+	close $fh;
+print "ok 9\n";
+
+# Test out binmode (should be only LF with print, no CR).
+
+$fh = new Win32API::File "+> foo.txt"
+	or die fileLastError();
+binmode $fh;
+print $fh "hello there\n";
+seek $fh, 0, 0;
+
+print "not " unless
+	<$fh> eq "hello there\n";
+print "ok 10\n";
+
+close $fh;
+
+unlink "foo.txt";
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/APIFile/test.pl perl-libwin32-0.24/APIFile/test.pl
--- libwin32-0.24-orig/APIFile/test.pl	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/APIFile/test.pl	2004-12-01 23:55:52.000000000 +0000
@@ -1,22 +1,17 @@
-#!/usr/bin/perl -w
-# Before `make install' is performed this script should be runnable with
-# `make test'. After `make install' it should work as `perl test.pl'
+#!perl
+# vim:syntax=perl:
 
 ######################### We start with some black magic to print on failure.
 
-BEGIN { $|= 1; print "1..245\n"; }
+BEGIN { $|= 1; print "1..249\n"; }
 END {print "not ok 1\n" unless $loaded;}
 use Win32API::File qw(:ALL);
+use Cwd;
 $loaded = 1;
 print "ok 1\n";
 
 ######################### End of black magic.
 
-$Debug=  ( -t STDIN ) != ( -t STDOUT );
-if(  $Debug  ) {
-    warn "# Running tests in debug mode ",
-      "since exactly one of STDIN/STDOUT is a tty.\n";
-}
 $test= 1;
 
 use strict qw(subs);
@@ -27,20 +22,23 @@
 $temp= "."		unless -d $temp;
 $dir= "W32ApiF.tmp";
 
+$ENV{WINDIR} = $ENV{SYSTEMROOT} if not exists $ENV{WINDIR};
+
 chdir( $temp )
   or  die "# Can't cd to temp directory, $temp: $!\n";
 
 if(  -d $dir  ) {
-    if(  glob( "$dir/*" )  ) {
-	system( "attrib -r -h -s $dir\\*" );
-	$Debug && warn "# echo y | del $temp\\$dir\\*\n";
-	system( "echo y | del $dir\\*" );
+    print "# deleting $temp\\$dir\\*\n" if glob "$dir/*";
+
+    for (glob "$dir/*") {
+	chmod 0777, $_;
+	unlink $_;
     }
-    system( "rd $dir" );
+    rmdir $dir or die "Could not rmdir $dir: $!";
 }
 mkdir( $dir, 0777 )
   or  die "# Can't create temp dir, $temp/$dir: $!\n";
-$Debug && warn "# chdir $temp\\$dir\n";
+print "# chdir $temp/$dir\n";
 chdir( $dir )
   or  die "# Can't cd to my dir, $temp/$dir: $!\n";
 
@@ -50,104 +48,110 @@
 if(  ! $ok  ) {   CloseHandle($h1);   unlink("ReadOnly.txt");   }
 
 $ok= $h1= createFile( "ReadOnly.txt", "wcn", { Attributes=>"r" } );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 3
 
 $ok= WriteFile( $h1, "Original text\n", 0, [], [] );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 4
 
 $h2= createFile( "ReadOnly.txt", "rcn" );
 $ok= ! $h2  &&  fileLastError() =~ /file exists?/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 5
 if(  ! $ok  ) {   CloseHandle($h2);   }
 
 $h2= createFile( "ReadOnly.txt", "rwke" );
 $ok= ! $h2  &&  fileLastError() =~ /access is denied?/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 6
 if(  ! $ok  ) {   CloseHandle($h2);   }
 
 $ok= $h2= createFile( "ReadOnly.txt", "r" );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 7
 
 $ok= SetFilePointer( $h1, length("Original"), [], FILE_BEGIN );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 8
 
 $ok= WriteFile( $h1, "ly was other text\n", 0, $len, [] )
   &&  $len == length("ly was other text\n");
-$Debug && !$ok && warn "# <$len> should be <",
+!$ok && print "# <$len> should be <",
   length("ly was other text\n"),">: ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 9
 
 $ok= ReadFile( $h2, $text, 80, $len, [] )
  &&  $len == length($text);
-$Debug && !$ok && warn "# <$len> should be <",length($text),
+!$ok && print "# <$len> should be <",length($text),
   ">: ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 10
 
 $ok= $text eq "Originally was other text\n";
-if(  $Debug  &&  ! $ok  ) {
+if(   ! $ok  ) {
     $text =~ s/\r/\\r/g;   $text =~ s/\n/\\n/g;
-    warn "# <$text> should be <Originally was other text\\n>.\n";
+    print "# <$text> should be <Originally was other text\\n>.\n";
 }
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 11
 
 $ok= CloseHandle($h2);
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 12
 
 $ok= ! ReadFile( $h2, $text, 80, $len, [] )
  &&  fileLastError() =~ /handle is invalid?/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 13
 
 CloseHandle($h1);
 
 $ok= $h1= createFile( "CanWrite.txt", "rw", FILE_SHARE_WRITE,
 	      { Create=>CREATE_ALWAYS } );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 14
 
 $ok= WriteFile( $h1, "Just this and not this", 10, [], [] );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 15
 
 $ok= $h2= createFile( "CanWrite.txt", "wk", { Share=>"rw" } );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 16
 
 $ok= OsFHandleOpen( "APP", $h2, "wat" );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 17
 
 $ok=  $h2 == GetOsFHandle( "APP" );
-$Debug && !$ok && warn "# $h2 != ",GetOsFHandle("APP"),"\n";
+!$ok && print "# $h2 != ",GetOsFHandle("APP"),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 18
 
-{   my $save= select(APP);   $|= 1;  select($save);   }
+{   my $save= select(APP) ;   $|= 1;  select($save);   }
 $ok= print APP "is enough\n";
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "#-> ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 19
 
-$ok= ReadFile( $h1, $text, 0, [], [] );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+SetFilePointer($h1, 0, [], FILE_BEGIN) if $^O eq 'cygwin';
+
+$ok= ReadFile( $h1, $text, 0, [], []);
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 20
 
-$ok=  $text eq "is enough\r\n";
-if(  $Debug  &&  ! $ok  ) {
-    $text =~ s/\r/\\r/g;
-    $text =~ s/\n/\\n/g;
-    warn "# <$text> should be <is enough\\r\\n>\n";
+$ok=  $text eq "is enough\015\012";
+if(   ! $ok  ) {
+    $text     =~ s/\r/\\r/g; $text     =~ s/\n/\\n/g;
+    print "# <$text> should be <is enough\\r\\n>\n";
 }
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 21
 
-$ok= ! unlink( "CanWrite.txt" )
- &&  $! =~ /permission denied/i;
-$Debug && !$ok && warn "# $!\n";
+if ($^O eq 'cygwin') {
+	$ok = 1;
+	print "# skipped on cygwin\n";
+} else {
+	unlink("CanWrite.txt");
+	$ok= -e "CanWrite.txt" &&  $! =~ /permission denied/i;
+	!$ok && print "# $!\n";
+}
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 22
 
 close(APP);		# Also does C<CloseHandle($h2)>
@@ -156,73 +160,73 @@
 
 $ok= ! DeleteFile( "ReadOnly.txt" )
  &&  fileLastError() =~ /access is denied?/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 23
 
 $ok= ! CopyFile( "ReadOnly.txt", "CanWrite.txt", 1 )
  &&  fileLastError() =~ /file exists?/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 24
 
 $ok= ! CopyFile( "CanWrite.txt", "ReadOnly.txt", 0 )
  &&  fileLastError() =~ /access is denied?/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 25
 
 $ok= ! MoveFile( "NoSuchFile", "NoSuchDest" )
  &&  fileLastError() =~ /not find the file/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 26
 
 $ok= ! MoveFileEx( "NoSuchFile", "NoSuchDest", 0 )
  &&  fileLastError() =~ /not find the file/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 27
 
 $ok= ! MoveFile( "ReadOnly.txt", "CanWrite.txt" )
  &&  fileLastError() =~ /file already exists?/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 28
 
 $ok= ! MoveFileEx( "ReadOnly.txt", "CanWrite.txt", 0 )
  &&  fileLastError() =~ /file already exists?/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 29
 
 $ok= CopyFile( "ReadOnly.txt", "ReadOnly.cp", 1 )
  &&  CopyFile( "CanWrite.txt", "CanWrite.cp", 1 );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 30
 
 $ok= ! MoveFileEx( "CanWrite.txt", "ReadOnly.cp", MOVEFILE_REPLACE_EXISTING )
- &&  fileLastError() =~ /access is denied?|cannot create/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+ &&  fileLastError() =~ /access is denied?|cannot create|cannot access/i;
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 31
 
 $ok= MoveFileEx( "ReadOnly.cp", "CanWrite.cp", MOVEFILE_REPLACE_EXISTING );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 32
 
 $ok= MoveFile( "CanWrite.cp", "Moved.cp" );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 33
 
 $ok= ! unlink( "ReadOnly.cp" )
  &&  $! =~ /no such file/i
  &&  ! unlink( "CanWrite.cp" )
  &&  $! =~ /no such file/i;
-$Debug && !$ok && warn "# $!\n";
+!$ok && print "# $!\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 34
 
 $ok= ! DeleteFile( "Moved.cp" )
  &&  fileLastError() =~ /access is denied?/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 35
 
-system( "attrib -r Moved.cp" );
+chmod 0777, "Moved.cp";
 
 $ok= DeleteFile( "Moved.cp" );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 36
 
 $new= SEM_FAILCRITICALERRORS|SEM_NOOPENFILEERRORBOX;
@@ -231,45 +235,45 @@
 $reold= SetErrorMode( $old );
 
 $ok= $old == $reold;
-$Debug && !$ok && warn "# $old != $reold: ",fileLastError(),"\n";
+!$ok && print "# $old != $reold: ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 37
 
 $ok= ($renew&$new) == $new;
-$Debug && !$ok && warn "# $new != $renew: ",fileLastError(),"\n";
+!$ok && print "# $new != $renew: ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 38
 
 $ok= @drives= getLogicalDrives();
-$Debug && $ok && warn "# @drives\n";
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+$ok && print "# @drives\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 39
 
 $ok=  $drives[0] !~ /^[ab]/  ||  DRIVE_REMOVABLE == GetDriveType($drives[0]);
-$Debug && !$ok && warn "# ",DRIVE_REMOVABLE," != ",GetDriveType($drives[0]),
+!$ok && print "# ",DRIVE_REMOVABLE," != ",GetDriveType($drives[0]),
   ": ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 40
 
-$drive= substr( $ENV{windir}, 0, 3 );
+$drive= substr( $ENV{WINDIR}, 0, 3 );
 
 $ok= 1 == grep /^\Q$drive\E/i, @drives;
-$Debug && !$ok && warn "# No $drive found in list of drives.\n";
+!$ok && print "# No $drive found in list of drives.\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 41
 
 $ok= DRIVE_FIXED == GetDriveType( $drive );
-$Debug && !$ok && warn
+!$ok && print
   "# ",DRIVE_FIXED," != ",GetDriveType($drive),": ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 42
 
 $ok=  GetVolumeInformation( $drive, $vol, 64, $ser, $max, $flag, $fs, 16 );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 43
-$vol= $ser= $max= $flag= $fs= "";	# Prevent warnings.
+$vol= $ser= $max= $flag= $fs= "";	# Prevent printings.
 
 chop($drive);
 $ok= QueryDosDevice( $drive, $dev, 80 );
-$Debug && !$ok && warn "# $drive: ",fileLastError(),"\n";
-if(  $Debug  &&  $ok  ) {
+!$ok && print "# $drive: ",fileLastError(),"\n";
+if(   $ok  ) {
     ( $text= $dev ) =~ s/\0/\\0/g;
-    warn "# $drive => $text\n";
+    print "# $drive => $text\n";
 }
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 44
 
@@ -281,41 +285,41 @@
     $bit >>= 1;
 }
 $let= pack( "C", $let + unpack("C","A") ) . ":";
-$Debug && warn "# Querying undefined $let.\n";
+print "# Querying undefined $let.\n";
 
-$ok= DefineDosDevice( 0, $let, $ENV{windir} );
-$Debug && !$ok && warn "# $let,$ENV{windir}: ",fileLastError(),"\n";
+$ok= DefineDosDevice( 0, $let, $ENV{WINDIR} );
+!$ok && print "# $let,$ENV{WINDIR}: ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 45
 
-$ok=  -s $let."/Win.ini"  ==  -s $ENV{windir}."/Win.ini";
-$Debug && !$ok && warn "# ", -s $let."/Win.ini", " vs. ",
-  -s $ENV{windir}."/Win.ini", ": ",fileLastError(),"\n";
+$ok=  -s $let."/Win.ini"  ==  -s $ENV{WINDIR}."/Win.ini";
+!$ok && print "# ", -s $let."/Win.ini", " vs. ",
+  -s $ENV{WINDIR}."/Win.ini", ": ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 46
 
 $ok= DefineDosDevice( DDD_REMOVE_DEFINITION|DDD_EXACT_MATCH_ON_REMOVE,
-		      $let, $ENV{windir} );
-$Debug && !$ok && warn "# $let,$ENV{windir}: ",fileLastError(),"\n";
+		      $let, $ENV{WINDIR} );
+!$ok && print "# $let,$ENV{WINDIR}: ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 47
 
 $ok= ! -f $let."/Win.ini"
   &&  $! =~ /no such file/i;
-$Debug && !$ok && warn "# $!\n";
+!$ok && print "# $!\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 48
 
 $ok= DefineDosDevice( DDD_RAW_TARGET_PATH, $let, $dev );
-if(  $Debug  &&  !$ok  ) {
+if(   !$ok  ) {
     ( $text= $dev ) =~ s/\0/\\0/g;
-    warn "# $let,$text: ",fileLastError(),"\n";
+    print "# $let,$text: ",fileLastError(),"\n";
 }
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 49
 
-$ok= -f $let.substr($ENV{windir},3)."/win.ini";
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+$ok= -f $let.substr($ENV{WINDIR},3)."/win.ini";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 50
 
 $ok= DefineDosDevice( DDD_REMOVE_DEFINITION|DDD_EXACT_MATCH_ON_REMOVE
 		     |DDD_RAW_TARGET_PATH, $let, $dev );
-$Debug && !$ok && warn "# $let,$dev: ",fileLastError(),"\n";
+!$ok && print "# $let,$dev: ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 51
 
 #	DefineDosDevice
@@ -345,7 +349,7 @@
     } else {
 	$ok=  ! eval("$func()")  &&  $@ =~ /(::|\s)_?${func}A?[(:\s]/;
     }
-    $Debug && !$ok && warn "# $func: $@\n";
+    !$ok && print "# $func: $@\n";
     print $ok ? "" : "not ", "ok ", ++$test, "\n";
 }
 
@@ -353,19 +357,22 @@
                 @{$Win32API::File::EXPORT_TAGS{FuncW}} ) {
     $ok=  ! eval("$func()")  &&  $@ =~ /::_?${func}\(/;
     delete $consts{$func};
-    $Debug && !$ok && warn "# $func: $@\n";
+    !$ok && print "# $func: $@\n";
     print $ok ? "" : "not ", "ok ", ++$test, "\n";
 }
 
 foreach $const ( keys(%consts) ) {
     $ok= eval("my \$x= $const(); 1");
-    $Debug && !$ok && warn "# Constant $const: $@\n";
+    !$ok && print "# Constant $const: $@\n";
     print $ok ? "" : "not ", "ok ", ++$test, "\n";
 }
 
 chdir( $temp );
-system( "attrib -r $dir\\ReadOnly.txt" );
-unlink "$dir/CanWrite.txt", "$dir/ReadOnly.txt";
-system( "rd $dir" );
+if (-e "$dir/ReadOnly.txt") {
+    chmod 0777, "$dir/ReadOnly.txt";
+    unlink "$dir/ReadOnly.txt";
+}
+unlink "$dir/CanWrite.txt" if -e "$dir/CanWrite.txt";
+rmdir $dir;
 
 __END__
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/APIFile/typemap perl-libwin32-0.24/APIFile/typemap
--- libwin32-0.24-orig/APIFile/typemap	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/APIFile/typemap	2004-12-01 23:55:52.000000000 +0000
@@ -15,8 +15,10 @@
 ValEntW *		T_BUF
 SECURITY_DESCRIPTOR *	T_BUF
 SECURITY_ATTRIBUTES *	T_BUF
+LPOVERLAPPED		T_BUF
 LONG *			T_IVBUF
 DWORD *			T_UVBUF
+LPDWORD		T_UVBUF
 oDWORD *		O_UVBUF
 HKEY *			T_UVBUFP
 oHKEY *			O_UVBUFP
@@ -36,7 +38,7 @@
 T_IV
 	$var= null_arg($arg) ? ($type)0 : ($type)SvIV($arg)
 T_UV
-	$var= null_arg($arg) ? ($type)0 : ($type)SvUV($arg)
+	$var= null_arg($arg) ? ($type)0 : ($type)(DWORD)SvUV($arg)
 O_IV
 	$var= optIV($arg)
 O_UV
@@ -105,7 +107,7 @@
 	    sv_setiv( $arg, (IV)$var );
 T_UV
 	if(  ! null_arg($arg)  &&  ! SvREADONLY($arg)  )
-	    sv_setuv( $arg, (UV)$var );
+	    sv_setuv( $arg, (UV)(DWORD)$var );
 O_IV
 	if(  ! null_arg($arg)  )
 	    sv_setiv( $arg, (IV)$var );
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/APINet/Net.xs perl-libwin32-0.24/APINet/Net.xs
--- libwin32-0.24-orig/APINet/Net.xs	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/APINet/Net.xs	2004-12-01 23:55:52.000000000 +0000
@@ -1,22 +1,20 @@
-#include <windows.h>
-#include <winsock.h>
+#include "../win32perl.h"
+
+#ifndef __CYGWIN__
+#  include <winsock.h>
+#endif
+
 #include <lmcons.h>    /* LAN Manager common definitions */
 #include <lmerr.h>    /* LAN Manager network error definitions */
-#include <lmUseFlg.h>
-#include <lmAccess.h>
-#include <lmAPIBuf.h>
+#include <lmuseflg.h>
+#include <lmaccess.h>
+#include <lmapibuf.h>
 #include <lmwksta.h>
 #undef LPTSTR
 #define LPTSTR LPWSTR
-#include <lmServer.h>
+#include <lmserver.h>
 #undef LPTSTR
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
-
 static int
 not_here(char *s)
 {
@@ -485,7 +483,7 @@
     if (name != NULL) { // && *name != '\0') {
 	length = strlen(name)+1;
 	Newz(0, lpPtr, length, WCHAR);
-	MultiByteToWideChar(CP_ACP, NULL, name, -1, lpPtr,
+	MultiByteToWideChar(CP_ACP, 0, name, -1, lpPtr,
 				length * sizeof(WCHAR));
     }
     return lpPtr;
@@ -530,7 +528,7 @@
 	    croak("Value in logonHours should be an array reference,");	\
 	while (i < n) {							\
 	    if ((svTmp = av_fetch((AV*)svPtrIndirect, i, 0)) != NULL)	\
-		(BYTE)(((CAST)uiX)->field)[i] = SvIV(*svTmp);		\
+		(BYTE)(((CAST)uiX)->field)[i] = (BYTE)SvIV(*svTmp);	\
 	    else							\
 		(BYTE)(((CAST)uiX)->field)[i] = 0;			\
 	    i++;							\
@@ -893,7 +891,7 @@
 WCTMB(LPWSTR lpwStr, LPSTR lpStr, int size)
 {
     *lpStr = '\0';
-    return WideCharToMultiByte(CP_ACP, NULL, lpwStr, -1, lpStr, size,
+    return WideCharToMultiByte(CP_ACP, 0, lpwStr, -1, lpStr, size,
 			       NULL, NULL);
 }
 
@@ -1224,8 +1222,7 @@
     {
 	LPWSTR lpwServer = MBTWC(server);
 	PUSER_INFO_0 pwzUsers = NULL;
-	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0;
-	int index;
+	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0, index;
 	DWORD lastError = 0;
 	char tmpBuf[UNLEN+1];
 
@@ -1273,8 +1270,7 @@
 	LPWSTR lpwServer = MBTWC(server);
 	LPWSTR lpwUser = MBTWC(user);
 	PGROUP_INFO_0 pwzGroups;
-	DWORD entriesRead = 0, totalEntries = 0;
-	int index, len = PREFLEN;
+	DWORD entriesRead = 0, totalEntries = 0, index, len = PREFLEN;
 	DWORD lastError = 0;
 	char tmpBuf[UNLEN+1];
 
@@ -1366,8 +1362,7 @@
 	LPWSTR lpwServer = MBTWC(server);
 	LPWSTR lpwUser = MBTWC(user);
 	LPLOCALGROUP_USERS_INFO_0 pwzLocalGroupUsers=NULL;
-	DWORD entriesRead = 0, totalEntries = 0;
-	int index, len = PREFLEN;
+	DWORD entriesRead = 0, totalEntries = 0, index, len = PREFLEN;
 	char tmpBuf[UNLEN+1];
 	DWORD lastError = 0;
 
@@ -1457,7 +1452,6 @@
 	LPWSTR lpwServer = MBTWC(server);
 	LPWSTR lpwUser = MBTWC(user);
 	LPBYTE *uiX = NULL;
-	SV        **svPtr;
 	DWORD lastError = 0;
 
 	if (!(hash && SvROK(hash) &&
@@ -1590,8 +1584,7 @@
     {
 	LPWSTR lpwServer = MBTWC(server);
 	PGROUP_INFO_0 pwzGroups;
-	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0;
-	int index, len;
+	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0, index;
 	DWORD lastError = 0;
 	char tmpBuf[UNLEN+1];
 	
@@ -1667,8 +1660,7 @@
 	LPWSTR lpwServer = MBTWC(server);
 	LPWSTR lpwGroup = MBTWC(group);
 	PGROUP_USERS_INFO_0 pwzGroupUsers;
-	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0;
-	int index, len;
+	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0, index;
 	DWORD lastError = 0;
 	char tmpBuf[UNLEN+1];
 	
@@ -1912,7 +1904,7 @@
 	lastError = NetLocalGroupDelMembers(lpwServer, lpwGroup, 3,
 					    (LPBYTE)members, totalEntries);
 
-	for (i; i<len; i++) freeWideName(members[i].lgrmi3_domainandname);
+	for (; i<len; i++) freeWideName(members[i].lgrmi3_domainandname);
 	freeWideName(lpwGroup);
 	freeWideName(lpwServer);
 	Safefree(members);
@@ -1931,8 +1923,7 @@
     {
 	LPWSTR lpwServer = MBTWC(server);
 	PLOCALGROUP_INFO_0 pwzLocalGroups;
-	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0;
-	int index;
+	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0, index;
 	DWORD lastError = 0;
 	char tmpBuf[UNLEN+1];
 
@@ -2013,8 +2004,7 @@
 	LPWSTR lpwServer = MBTWC(server);
 	LPWSTR lpwGroup = MBTWC(group);
 	PLOCALGROUP_MEMBERS_INFO_1 pwzMembersInfo;
-	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0;
-	int index;
+	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0, index;
 	DWORD lastError = 0;
 	char tmpBuf[UNLEN+1];
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/APINet/mingw32.exc perl-libwin32-0.24/APINet/mingw32.exc
--- libwin32-0.24-orig/APINet/mingw32.exc	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/APINet/mingw32.exc	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/APINet/t/test.t perl-libwin32-0.24/APINet/t/test.t
--- libwin32-0.24-orig/APINet/t/test.t	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/APINet/t/test.t	2005-02-06 16:26:52.000000000 +0000
@@ -8,6 +8,7 @@
 
 BEGIN { $| = 1; print "1..18\n"; }
 END {print "not ok 1\n" unless $loaded;}
+use Win32;
 use Win32API::Net qw/ :ALL /;
 $loaded = 1;
 print "ok 1\n";
@@ -114,26 +115,33 @@
 print "not " unless UserEnum($dc, \@users, FILTER_NORMAL_ACCOUNT());
 print "ok 10\n";
 
-print "not " unless LocalGroupGetInfo($dc, "Administrators", 1,
-				      \%localGroupInfo);
+print "not " unless LocalGroupEnum("", \@localGroups);
 print "ok 11\n";
+# pick out out the administrator and guest group names for further tests
+$Administrators = $localGroups[0];
+$Guest = $localGroups[2];
+
+print "not " unless LocalGroupGetInfo($dc, $Administrators, 1,
+				      \%localGroupInfo);
+print "ok 12\n";
 undef %localGroupInfo;
 
 # LocalGroupAdd()
 $localGroupName="##Freds";
+if (grep /^##Freds$/,@localGroups) {
+  $localGroupName = $localGroups[1] . $localGroupName;
+}
+undef @localGroups;
 %localGroup=('name' => $localGroupName, 'comment' => 'All the freds');
 
 print "not " unless LocalGroupAdd("", 1, \%localGroup, $fie);
-print "ok 12\n";
+print "ok 13\n";
 
-@localGroupMembers=($testUserName, "Guest");
+# This will work only for english Windows
+@localGroupMembers=($testUserName, $Guest);
 print "not " unless LocalGroupAddMembers("", $localGroupName,
 					 \@localGroupMembers);
-print "ok 13\n";
-
-print "not " unless LocalGroupEnum("", \@localGroups);
 print "ok 14\n";
-undef @localGroups;
 
 print "not " unless LocalGroupGetInfo("", $localGroupName, 1, \%lgInfo);
 print "ok 15\n";
@@ -142,7 +150,7 @@
 print "ok 16\n";
 undef %lgMembers;
 
-@localGroupDelMembers=("Guest");
+@localGroupDelMembers=($Guest);
 print "not " unless LocalGroupDelMembers("", $localGroupName,
 					 \@localGroupDelMembers);
 print "ok 17\n";
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/APIRegistry/MANIFEST perl-libwin32-0.24/APIRegistry/MANIFEST
--- libwin32-0.24-orig/APIRegistry/MANIFEST	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/APIRegistry/MANIFEST	2004-12-01 23:55:52.000000000 +0000
@@ -8,7 +8,6 @@
 const2perl.h
 cRegistry.h
 cRegistry.pc
-ppport.h
 test.pl
 typemap
 ExtUtils/Myconst2perl.pm
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/APIRegistry/Makefile.PL perl-libwin32-0.24/APIRegistry/Makefile.PL
--- libwin32-0.24-orig/APIRegistry/Makefile.PL	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/APIRegistry/Makefile.PL	2005-02-14 21:38:59.750000000 +0000
@@ -96,14 +96,13 @@
 	    ##  join("/",@path,$final), qq{">.\n};
 	    # Install F<$final> whenever regular pm_to_blib target is built:
 	    push @m, "
-pm_to_blib: ${_final}_to_blib
+pm_to_blib.ts :: ${_final}_to_blib
 
-${_final}_to_blib: $final
-	" . '@$(PERL) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)" \\
-	"-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -MExtUtils::Install \\
-        -e "pm_to_blib({ ',neatvalue($final),',',
-	neatvalue($self->catfile('$(INST_ARCHLIB)',@path,$final)), ' },',
-	neatvalue($self->catfile(qw[$(INST_LIB) auto])), ')"
+${_final}_to_blib : $final
+	" . '$(NOECHO) $(ABSPERLRUN) -MExtUtils::Install \\
+          -e "pm_to_blib({ ',neatvalue($final),',',
+	  neatvalue($self->catfile('$(INST_ARCHLIB)',@path,$final)), ' },',
+	  neatvalue($self->catfile(qw[$(INST_LIB) auto])), ')"
 	@$(TOUCH) ', $_final, "_to_blib\n";
 
 	    push( @clean, $outfile, $bin, $obj, $_final . "_to_blib" );
@@ -119,9 +118,19 @@
 
     push @m, "
 clean ::
-    $self->{RM_F} @clean\n"   if  @clean;
-    push @m, "
+	$self->{RM_F} @clean\n"   if  @clean;
+	push @m, "
 realclean ::
-    $self->{RM_F} @realclean\n"   if  @realclean;
-    return join('',@m);
+	$self->{RM_F} @realclean\n"   if  @realclean;
+	return join('',@m);
+}
+
+# Allow adding ${_final}_to_blib to pm_to_blib.ts targets
+sub ExtUtils::MM_Cygwin::pm_to_blib {
+  my $self = shift;
+  package ExtUtils::MM_Cygwin; # the only way to override this piece
+  my $inherited = $self->SUPER::pm_to_blib(); 
+  $inherited =~ s/pm_to_blib: /pm_to_blib :: /;
+  $inherited =~ s/pm_to_blib.ts: /pm_to_blib.ts :: /;
+  $inherited;
 }
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/APIRegistry/Registry.pm perl-libwin32-0.24/APIRegistry/Registry.pm
--- libwin32-0.24-orig/APIRegistry/Registry.pm	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/APIRegistry/Registry.pm	2004-12-01 23:55:52.000000000 +0000
@@ -138,18 +138,30 @@
     return 0;
 }
 
-BEGIN {
-    my $code= 'return _regLastError(@_)';
-    local( $!, $^E )= ( 1, 1 );
-    if(  $! ne $^E  ) {
-	$code= '
-	    local( $^E )= _regLastError(@_);
-	    my $ret= $^E;
-	    return $ret;
-	';
-    }
-    eval "sub regLastError { $code }";
-    die "$@"   if  $@;
+package Win32API::Registry::_error;
+
+use overload
+  '""' => sub {
+	use Win32;
+	$_ = Win32::FormatMessage(Win32API::Registry::_regLastError());
+	tr/\r\n//d; return $_;
+  },
+  '0+' => sub { Win32API::Registry::_regLastError() },
+  'fallback' => 1;
+
+sub new { return bless {}, shift }
+sub set { Win32API::Registry::_regLastError($_[1]); return $_[0] }
+
+package Win32API::Registry;
+
+my $_error = new Win32API::Registry::_error;
+
+sub regLastError {
+	require Carp;
+	Carp::croak 'Usage: ',__PACKAGE__,'::regLastError( [$setWin32ErrCode] )'
+		if @_ > 1;
+	$_error->set($_[0]) if defined $_[0];
+	return $_error;
 }
 
 # Since we ISA DynaLoader which ISA AutoLoader, we ISA AutoLoader so we
@@ -1452,7 +1464,7 @@
 can be passed.  For parameter that are pointers to buffer sizes,
 you can also pass in C<NULL> by specifying an empty list reference,
 C<[]>.  Both of these cases will ensure that the variable has
-E<some> buffer space allocated to it and pass in that buffer's
+I<some> buffer space allocated to it and pass in that buffer's
 allocated size.  Many of the calls indicate, via C<ERROR_MORE_DATA>,
 that the buffer size was not sufficient and the F<Registry.xs>
 code will automatically enlarge the buffer to the required size
@@ -1482,7 +1494,7 @@
 Some Reg*() calls may not currently set the buffer size when they
 return C<ERROR_MORE_DATA>.  But some that are not documented as
 doing so, currently do so anyway.  So the code assumes that any
-routine E<might> do this and resizes any buffers and repeats the
+routine I<might> do this and resizes any buffers and repeats the
 call.   We hope that eventually all routines will provide this
 feature.
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/APIRegistry/Registry.xs perl-libwin32-0.24/APIRegistry/Registry.xs
--- libwin32-0.24-orig/APIRegistry/Registry.xs	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/APIRegistry/Registry.xs	2004-12-01 23:55:52.000000000 +0000
@@ -1,24 +1,8 @@
 /* Win32API/Registry.xs */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-/*#include "patchlevel.h"*/
+#include "../win32perl.h"
 
 /* Uncomment the next line unless set "WRITE_PERL=>1" in Makefile.PL: */
 #define NEED_newCONSTSUB
-#include "ppport.h"
-
-#define  WIN32_LEAN_AND_MEAN	/* Tell windows.h to skip much */
-#include <windows.h>
-
-#ifdef __cplusplus
-}
-#endif
 
 /*CONSTS_DEFINED*/
 
@@ -140,7 +124,7 @@
 	) {
 	    SetLastError( ERROR_SUCCESS );
 	    AdjustTokenPrivileges( hToken, FALSE, &tokPrivNew,
-	      NULL, NULL, NULL );
+	      0, NULL, NULL );
 	    if(  ERROR_SUCCESS == GetLastError()  ) {
 		RETVAL= TRUE;
 	    }
@@ -350,7 +334,10 @@
 RegDeleteValueW( hKey, swValueName )
 	HKEY	hKey
 	WCHAR *	swValueName
-
+    CODE:
+	RETVAL= ErrorRet(  RegDeleteValueW( hKey, swValueName )  );
+    OUTPUT:
+	RETVAL
 
 bool
 _RegEnumKeyA( hKey, uIndex, osName, ilNameSize )
@@ -841,10 +828,10 @@
 	DWORD	uErr;
     CODE:
 	init_buf_pl( iolValueData,ST(3),LONG * );
-	grow_buf_pl( osValueData,ST(2),char *, iolValueData,ST(3),LONG * );
+	grow_buf_pl( osValueData,ST(2),char *, (ULONG *)iolValueData,ST(3),ULONG * );
 	uErr= RegQueryValueA( hKey, sSubKey, osValueData, iolValueData );
 	if(  ERROR_MORE_DATA == uErr  &&  autosize(ST(3))  ) {
-	    grow_buf_pl( osValueData,ST(2),char *, iolValueData,ST(3),LONG * );
+	    grow_buf_pl( osValueData,ST(2),char *, (ULONG *)iolValueData,ST(3),ULONG * );
 	    uErr= RegQueryValueA( hKey, sSubKey, osValueData, iolValueData );
 	}
 	RETVAL= ErrorRet( uErr );
@@ -864,11 +851,11 @@
 	DWORD	uErr;
     CODE:
 	init_buf_pl( iolValueData,ST(3),LONG * );
-	grow_buf_pl( oswValueData,ST(2),WCHAR *, iolValueData,ST(3),LONG * );
+	grow_buf_pl( oswValueData,ST(2),WCHAR *, (ULONG *)iolValueData,ST(3),ULONG * );
 	uErr= RegQueryValueW( hKey, swSubKey, oswValueData, iolValueData );
 	if(  ERROR_MORE_DATA == uErr  &&  autosize(ST(3))  ) {
 	    grow_buf_pl( oswValueData,ST(2),WCHAR *,
-	      iolValueData,ST(3),LONG * );
+	      (ULONG *)iolValueData,ST(3),ULONG * );
 	    uErr= RegQueryValueW( hKey, swSubKey, oswValueData, iolValueData );
 	}
 	RETVAL= ErrorRet( uErr );
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/APIRegistry/ppport.h perl-libwin32-0.24/APIRegistry/ppport.h
--- libwin32-0.24-orig/APIRegistry/ppport.h	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/APIRegistry/ppport.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,283 +0,0 @@
-
-#ifndef _P_P_PORTABILITY_H_
-#define _P_P_PORTABILITY_H_
-
-/* Perl/Pollution/Portability Version 1.0007etm */
-
-/* Copyright (C) 1999, Kenneth Albanowski. This code may be used and
-   distributed under the same license as any version of Perl. */
-   
-/* For the latest version of this code, please retreive the Devel::PPPort
-   module from CPAN, contact the author at <kjahds@kjahds.com>, or check
-   with the Perl maintainers. */
-   
-/* If you needed to customize this file for your project, please mention
-   your changes, and visible alter the version number. */
-
-
-/*
-   In order for a Perl extension module to be as portable as possible
-   across differing versions of Perl itself, certain steps need to be taken.
-   Including this header is the first major one, then using dTHR is all the
-   appropriate places and using a PL_ prefix to refer to global Perl
-   variables is the second.
-*/
-
-
-/* If you use one of a few functions that were not present in earlier
-   versions of Perl, please add a define before the inclusion of ppport.h
-   for a static include, or use the GLOBAL request in a single module to
-   produce a global definition that can be referenced from the other
-   modules.
-   
-   Function:            Static define:           Extern define:
-   newCONSTSUB()        NEED_newCONSTSUB         NEED_newCONSTSUB_GLOBAL
-
-*/
- 
-
-/* To verify whether ppport.h is needed for your module, and whether any
-   special defines should be used, ppport.h can be run through Perl to check
-   your source code. Simply say:
-   
-   	perl -x ppport.h *.c *.h *.xs foo/*.c [etc]
-   
-   The result will be a list of patches suggesting changes that should at
-   least be acceptable, if not necessarily the most efficient solution, or a
-   fix for all possible problems. It won't catch where dTHR is needed, and
-   doesn't attempt to account for global macro or function definitions,
-   nested includes, typemaps, etc.
-   
-   In order to test for the need of dTHR, please try your module under a
-   recent version of Perl that has threading compiled-in.
- 
-*/ 
-
-
-/*
-#!/usr/bin/perl
-@ARGV = ("*.xs") if !@ARGV;
-%badmacros = %funcs = %macros = (); $replace = 0;
-foreach (<DATA>) {
-	$funcs{$1} = 1 if /Provide:\s+(\S+)/;
-	$macros{$1} = 1 if /^#\s*define\s+([a-zA-Z0-9_]+)/;
-	$replace = $1 if /Replace:\s+(\d+)/;
-	$badmacros{$2}=$1 if $replace and /^#\s*define\s+([a-zA-Z0-9_]+).*?\s+([a-zA-Z0-9_]+)/;
-	$badmacros{$1}=$2 if /Replace (\S+) with (\S+)/;
-}
-foreach $filename (map(glob($_),@ARGV)) {
-	unless (open(IN, "<$filename")) {
-		warn "Unable to read from $file: $!\n";
-		next;
-	}
-	print "Scanning $filename...\n";
-	$c = ""; while (<IN>) { $c .= $_; } close(IN);
-	$need_include = 0; %add_func = (); $changes = 0;
-	$has_include = ($c =~ /#.*include.*ppport/m);
-
-	foreach $func (keys %funcs) {
-		if ($c =~ /#.*define.*\bNEED_$func(_GLOBAL)?\b/m) {
-			if ($c !~ /\b$func\b/m) {
-				print "If $func isn't needed, you don't need to request it.\n" if
-				$changes += ($c =~ s/^.*#.*define.*\bNEED_$func\b.*\n//m);
-			} else {
-				print "Uses $func\n";
-				$need_include = 1;
-			}
-		} else {
-			if ($c =~ /\b$func\b/m) {
-				$add_func{$func} =1 ;
-				print "Uses $func\n";
-				$need_include = 1;
-			}
-		}
-	}
-
-	if (not $need_include) {
-		foreach $macro (keys %macros) {
-			if ($c =~ /\b$macro\b/m) {
-				print "Uses $macro\n";
-				$need_include = 1;
-			}
-		}
-	}
-
-	foreach $badmacro (keys %badmacros) {
-		if ($c =~ /\b$badmacro\b/m) {
-			$changes += ($c =~ s/\b$badmacro\b/$badmacros{$badmacro}/gm);
-			print "Uses $badmacros{$badmacro} (instead of $badmacro)\n";
-			$need_include = 1;
-		}
-	}
-	
-	if (scalar(keys %add_func) or $need_include != $has_include) {
-		if (!$has_include) {
-			$inc = join('',map("#define NEED_$_\n", sort keys %add_func)).
-			       "#include \"ppport.h\"\n";
-			$c = "$inc$c" unless $c =~ s/#.*include.*XSUB.*\n/$&$inc/m;
-		} elsif (keys %add_func) {
-			$inc = join('',map("#define NEED_$_\n", sort keys %add_func));
-			$c = "$inc$c" unless $c =~ s/^.*#.*include.*ppport.*$/$inc$&/m;
-		}
-		if (!$need_include) {
-			print "Doesn't seem to need ppport.h.\n";
-			$c =~ s/^.*#.*include.*ppport.*\n//m;
-		}
-		$changes++;
-	}
-	
-	if ($changes) {
-		open(OUT,">/tmp/ppport.h.$$");
-		print OUT $c;
-		close(OUT);
-		open(DIFF, "diff -u $filename /tmp/ppport.h.$$|");
-		while (<DIFF>) { s!/tmp/ppport\.h\.$$!$filename.patched!; print STDOUT; }
-		close(DIFF);
-		unlink("/tmp/ppport.h.$$");
-	} else {
-		print "Looks OK\n";
-	}
-}
-__DATA__
-*/
-
-#ifndef PERL_REVISION
-#   ifndef __PATCHLEVEL_H_INCLUDED__
-#       include "patchlevel.h"
-#   endif
-#   ifndef PERL_REVISION
-#	define PERL_REVISION	(5)
-        /* Replace: 1 */
-#       define PERL_VERSION	PATCHLEVEL
-#       define PERL_SUBVERSION	SUBVERSION
-        /* Replace PERL_PATCHLEVEL with PERL_VERSION */
-        /* Replace: 0 */
-#   endif
-#endif
-
-#define PERL_BCDVERSION ((PERL_REVISION * 0x1000000L) + (PERL_VERSION * 0x1000L) + PERL_SUBVERSION)
-
-#ifndef ERRSV
-#	define ERRSV perl_get_sv("@",FALSE)
-#endif
-
-#if (PERL_VERSION < 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION <= 5))
-/* Replace: 1 */
-#	define PL_sv_undef	sv_undef
-#	define PL_sv_yes	sv_yes
-#	define PL_sv_no		sv_no
-#	define PL_na		na
-#	define PL_stdingv	stdingv
-#	define PL_hints		hints
-#	define PL_curcop	curcop
-#	define PL_curstash	curstash
-#	define PL_copline	copline
-#	define PL_Sv		Sv
-/* Replace: 0 */
-#endif
-
-#ifndef dTHR
-#  ifdef WIN32
-#	define dTHR extern int Perl___notused
-#  else
-#	define dTHR extern int errno
-#  endif
-#endif
-
-#ifndef boolSV
-#	define boolSV(b) ((b) ? &PL_sv_yes : &PL_sv_no)
-#endif
-
-#ifndef gv_stashpvn
-#	define gv_stashpvn(str,len,flags) gv_stashpv(str,flags)
-#endif
-
-#ifndef newSVpvn
-#	define newSVpvn(data,len) ((len) ? newSVpv ((data), (len)) : newSVpv ("", 0))
-#endif
-
-#ifndef newRV_inc
-/* Replace: 1 */
-#	define newRV_inc(sv) newRV(sv)
-/* Replace: 0 */
-#endif
-
-#ifndef newRV_noinc
-#  ifdef __GNUC__
-#    define newRV_noinc(sv)               \
-      ({                                  \
-          SV *nsv = (SV*)newRV(sv);       \
-          SvREFCNT_dec(sv);               \
-          nsv;                            \
-      })
-#  else
-#    if defined(CRIPPLED_CC) || defined(USE_THREADS)
-static SV * newRV_noinc (SV * sv)
-{
-          SV *nsv = (SV*)newRV(sv);       
-          SvREFCNT_dec(sv);               
-          return nsv;                     
-}
-#    else
-#      define newRV_noinc(sv)    \
-        ((PL_Sv=(SV*)newRV(sv), SvREFCNT_dec(sv), (SV*)PL_Sv)
-#    endif
-#  endif
-#endif
-
-/* Provide: newCONSTSUB */
-
-/* newCONSTSUB from IO.xs is in the core starting with 5.004_63 */
-#if (PERL_VERSION < 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION < 63))
-
-#if defined(NEED_newCONSTSUB)
-static
-#else
-extern void newCONSTSUB _((HV * stash, char * name, SV *sv));
-#endif
-
-#if defined(NEED_newCONSTSUB) || defined(NEED_newCONSTSUB_GLOBAL)
-void
-newCONSTSUB( HV *stash, char *name, SV *sv )
-{
-	U32 oldhints = PL_hints;
-	HV *old_cop_stash = PL_curcop->cop_stash;
-	HV *old_curstash = PL_curstash;
-	line_t oldline = PL_curcop->cop_line;
-	PL_curcop->cop_line = PL_copline;
-
-	PL_hints &= ~HINT_BLOCK_SCOPE;
-	if (stash)
-		PL_curstash = PL_curcop->cop_stash = stash;
-
-	newSUB(
-
-#if (PERL_VERSION < 3) || ((PERL_VERSION == 3) && (PERL_SUBVERSION < 22))
-     /* before 5.003_22 */
-		start_subparse(),
-#else
-#  if (PERL_VERSION == 3) && (PERL_SUBVERSION == 22)
-     /* 5.003_22 */
-     		start_subparse(0),
-#  else
-     /* 5.003_23  onwards */
-     		start_subparse(FALSE, 0),
-#  endif
-#endif
-
-		newSVOP(OP_CONST, 0, newSVpv(name,0)),
-		newSVOP(OP_CONST, 0, &PL_sv_no),   /* SvPV(&PL_sv_no) == "" -- GMB */
-		newSTATEOP(0, Nullch, newSVOP(OP_CONST, 0, sv))
-	);
-
-	PL_hints = oldhints;
-	PL_curcop->cop_stash = old_cop_stash;
-	PL_curstash = old_curstash;
-	PL_curcop->cop_line = oldline;
-}
-#endif
-
-#endif /* newCONSTSUB */
-
-
-#endif /* _P_P_PORTABILITY_H_ */
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/APIRegistry/test.pl perl-libwin32-0.24/APIRegistry/test.pl
--- libwin32-0.24-orig/APIRegistry/test.pl	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/APIRegistry/test.pl	2004-12-01 23:55:52.000000000 +0000
@@ -1,6 +1,5 @@
-#!/usr/bin/perl -w
-# Before `make install' is performed this script should be runnable with
-# `make test'. After `make install' it should work as `perl test.pl'
+#!perl
+# vim:syntax=perl:
 
 ######################### We start with some black magic to print on failure.
 
@@ -17,7 +16,7 @@
 
 BEGIN { eval "use Win32API::Registry qw(:SE_);" }
 
-$|= 1   if  $Debug= ( -t STDIN ) != ( -t STDOUT );
+$Debug= $ENV{TEST_VERBOSE};
 
 $zero= 0;	# Change to 0 when RegEnumKeyExA() and RegEnumValueA()
 		# handle ERROR_MORE_DATA better!
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/APIRegistry/typemap perl-libwin32-0.24/APIRegistry/typemap
--- libwin32-0.24-orig/APIRegistry/typemap	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/APIRegistry/typemap	2004-12-01 23:55:52.000000000 +0000
@@ -16,7 +16,8 @@
 SECURITY_DESCRIPTOR *	T_BUF
 SECURITY_ATTRIBUTES *	T_BUF
 LONG *			T_IVBUF
-DWORD *			T_UVBUF
+ULONG *		T_UVBUF
+DWORD *		T_UVBUF
 oDWORD *		O_UVBUF
 HKEY *			T_UVBUFP
 oHKEY *			O_UVBUFP
@@ -37,7 +38,7 @@
 T_IV
 	$var= null_arg($arg) ? ($type)0 : ($type)SvIV($arg)
 T_UV
-	$var= null_arg($arg) ? ($type)0 : ($type)SvUV($arg)
+	$var= null_arg($arg) ? ($type)0 : ($type)(DWORD)SvUV($arg)
 O_IV
 	$var= optIV($arg)
 O_UV
@@ -73,7 +74,7 @@
 	if(  null_arg($arg)  )
 	    $var= NULL;
 	else
-	    *( $var= ($type) TempAlloc( sizeof(*($var)) ) )= (void *)SvUV($arg)
+	    *( $var= ($type) TempAlloc( sizeof(*($var)) ) )= (void *)(DWORD)SvUV($arg)
 O_IVBUFP
 	if(  null_arg($arg)  )
 	    $var= NULL;
@@ -85,7 +86,7 @@
 	    $var= NULL;
 	else
 	    *( $var= ($type) TempAlloc( sizeof(*($var)) ) )=
-	      SvOK($arg) ? (void *)SvUV($arg) : 0;
+	      SvOK($arg) ? (void *)(DWORD)SvUV($arg) : 0;
 
 #############################################################################
 OUTPUT
@@ -130,10 +131,10 @@
 	    sv_setiv( $arg, (IV)*($var) );
 T_UVBUFP
 	if(  ! null_arg($arg)  &&  ! SvREADONLY($arg)  )
-	    sv_setuv( $arg, (UV)*($var) );
+	    sv_setuv( $arg, (UV)(DWORD)*($var) );
 O_IVBUFP
 	if(  ! null_arg($arg)  )
 	    sv_setiv( $arg, (IV)*($var) );
 O_UVBUFP
 	if(  ! null_arg($arg)  )
-	    sv_setuv( $arg, (UV)*($var) );
+	    sv_setuv( $arg, (UV)(DWORD)*($var) );
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/CYGWIN-PATCHES/README perl-libwin32-0.24/CYGWIN-PATCHES/README
--- libwin32-0.24-orig/CYGWIN-PATCHES/README	1970-01-01 00:00:00.000000000 +0000
+++ perl-libwin32-0.24/CYGWIN-PATCHES/README	2005-02-27 20:29:24.843750000 +0000
@@ -0,0 +1,108 @@
+perl-libwin32
+------------------------------------------
+Perl extensions for using the Win32 API.
+Included modules: Win32API::File, Win32API::Net, Win32API::Registry,
+ChangeNotify, Clipboard, Console, Event, EventLog, File, FileSecurity,
+IPC, Internet, Job, Mutex, NetAdmin, NetResource, ODBC, OLE, PerfLib, Pipe,
+Process, Registry, Semaphore, Service, Shortcut, Sound, TieRegistry and
+WinError.
+
+Runtime requirements:
+  cygwin
+  perl-5.8.6
+  crypt-1.1-1
+
+Build requirements:
+  cygwin
+  crypt-1.1-1
+  cygutils
+  perl-5.8.6
+  gcc
+  make
+  w32api-2.2-1 (at least)
+  gzip
+
+Project Homepages:
+  http://search.cpan.org/search?query=libwin32&mode=Distributions
+  http://sourceforge.net/projects/libwin32-exp/
+
+------------------------------------
+
+Build instructions:
+  unpack perl-libwin32-0.24-<REL>-src.tar.bz2
+    if you use setup to install this src package, it will be
+	 unpacked under /usr/src automatically
+  cd /usr/src
+  ./perl-libwin32-0.24-<REL>.sh all
+
+This will create:
+  /usr/src/perl-libwin32-0.24-<REL>.tar.bz2
+  /usr/src/perl-libwin32-0.24-<REL>-src.tar.bz2
+
+------------------
+
+Port Notes:
+
+Requirements:
+
+The dll's must probably be rebased. If a remap error occurs run rebaseall from 
+the rebase package. The packaged version is already rebased to my personal settings.
+
+Certain tests require esoteric apps, which probably will fail for you. 
+Win32::OLE requires Excel.Application
+
+To Cygwin Developers:
+
+If something breaks and I'm (Rafael Kitover) not around for any
+reason, please feel free to either fix it and do a Non Maintainer
+Upload (I won't mind, honestly) or drop it from the distribution.
+
+Port TODO:
+
+* Alot of stuff needs to be fed back upstream, will add details later to this
+  file or the sourceforge project, including some references to previous
+  discussions on p5p.
+  http://rt.cpan.org/NoAuth/Bugs.html?Dist=libwin32
+* Need to make a cleaner package script and/or add some support to
+  ExtUtils::MakeMaker and Module::Build for Cygwin packages. At the very least
+  need to make a template package script for making other Perl modules, as the
+  sample setup script requires a good deal of modification.
+* Some of the hints stuff might be nicer reworked using something like:
+  http://search.cpan.org/~jstowe/TermReadKey-2.21/Configure.pm
+* Put these and other issues, in detail, into the sourceforge BTS.
+
+----- version 0.191-4 -----
+* fixed src patch
+
+----- version 0.191-3 ----- (NOT RELEASED)
+
+* make install_vendor (into vendor_perl)
+* keep Win32::Process::GetCurrentProcessID(),
+* remove Win32::Process::CygwinToWin32ProcessID() and
+  Win32::Process::Win32ToCygwinProcessID(pid) from Process.xs
+  (now in core)
+* fix pm_to_blib MM targets (APIFile, APIRegistry).
+  better than the cRegistry_pc_to_blib hack in -2
+* cleaned the build script, hints and patch. fixed rebaseall step
+
+----- version 0.191-2 ----- (NOT RELEASED)
+
+* added Win32::Process::GetCurrentProcessID(), 
+  Win32::Process::CygwinToWin32ProcessID() and
+  Win32::Process::Win32ToCygwinProcessID(pid) to Process.xs
+* Removed Win32::GUI. Seperate perl-win32-gui package
+* Win32CORE is now in perl-5.8.6 core statically.
+* Win32API::Net test patches (locale independency)
+* fixed APIRegistry cRegistry_pc_to_blib
+* all DLL's rebased, but a rebaseall might be required nevertheless.
+
+Maintainership taken over by Reini Urban (rurban@x-ray.at)
+
+----- version 0.191-1 -----
+
+Initial Cygwin package.
+
+Cygwin port maintained by: Rafael Kitover  (caelum@debian.org)
+Please address all cygwin related questions to the Cygwin mailing 
+list at <cygwin@cygwin.com>. 
+The new libwin32 mailinglist is <libwin32@lists.perl.org>.
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/ChangeNotify/ChangeNotify.xs perl-libwin32-0.24/ChangeNotify/ChangeNotify.xs
--- libwin32-0.24-orig/ChangeNotify/ChangeNotify.xs	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/ChangeNotify/ChangeNotify.xs	2004-12-01 23:55:52.000000000 +0000
@@ -1,5 +1,5 @@
 //--------------------------------------------------------------------
-// $Id$
+// $Id: ChangeNotify.xs,v 1.1.1.1 2003/01/28 18:59:17 caelum Exp $
 //--------------------------------------------------------------------
 //
 //   Win32::ChangeNotify
@@ -9,14 +9,7 @@
 //
 //--------------------------------------------------------------------
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
-
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
+#include "../win32perl.h"
 
 static DWORD
 constant(char* name)
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/ChangeNotify/test.pl perl-libwin32-0.24/ChangeNotify/test.pl
--- libwin32-0.24-orig/ChangeNotify/test.pl	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/ChangeNotify/test.pl	2004-12-01 23:55:52.000000000 +0000
@@ -1,10 +1,5 @@
-# Before `make install' is performed this script should be runnable with
-# `make test'. After `make install' it should work as `perl test.pl'
-
-######################### We start with some black magic to print on failure.
-
-# Change 1..1 below to 1..last_test_to_print .
-# (It may become useful if the test is moved to ./t subdirectory.)
+#!perl
+# vim:syntax=perl:
 
 BEGIN { $| = 1; print "1..3\n"; }
 END {print "not ok 1\n" unless $loaded;}
@@ -12,12 +7,6 @@
 $loaded = 1;
 print "ok 1\n";
 
-######################### End of black magic.
-
-# Insert your test code below (better if it prints "ok 13"
-# (correspondingly "not ok 13") depending on the success of chunk 13
-# of the test code):
-
 print 'not ' if FILE_NOTIFY_CHANGE_FILE_NAME == 0;
 print "ok 2\n";
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/ChangeNotify/typemap perl-libwin32-0.24/ChangeNotify/typemap
--- libwin32-0.24-orig/ChangeNotify/typemap	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/ChangeNotify/typemap	2004-12-01 23:55:52.000000000 +0000
@@ -8,7 +8,7 @@
 T_PTROBJ
 	if (sv_derived_from($arg, \"${Package}\")) {
 	    IV tmp = SvIV((SV*)SvRV($arg));
-	    $var = ($type) tmp;
+	    $var = ($type)(DWORD) tmp;
 	}
 	else
 	    croak(\"$var is not of type ${Package}\")
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Clipboard/Clipboard.xs perl-libwin32-0.24/Clipboard/Clipboard.xs
--- libwin32-0.24-orig/Clipboard/Clipboard.xs	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/Clipboard/Clipboard.xs	2004-12-01 23:55:52.000000000 +0000
@@ -10,35 +10,12 @@
 #######################################################################
  */
 
-/* uncomment next line for debug messages */
-// #define WIN32__CLIPBOARD__DEBUG
-
-#define  WIN32_LEAN_AND_MEAN
-#include <windows.h>
-#include <string.h>
+#include "../win32perl.h"
 #include <winuser.h>
 #include <shellapi.h>
 
-#define __TEMP_WORD  WORD   /* perl defines a WORD, yikes! */
-
-#ifdef __cplusplus
-#include <stdlib.h>
-#include <math.h>
-extern "C" {
-#endif
-
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#ifdef __cplusplus
-}
-#endif
-
-#include "../ppport.h"
-
-#undef WORD
-#define WORD __TEMP_WORD
+/* uncomment next line for debug messages */
+// #define WIN32__CLIPBOARD__DEBUG
 
 // Section for the constant definitions.
 #define CROAK croak
@@ -52,7 +29,6 @@
 
 /* DLL entry point */
 BOOL WINAPI DllMain(HINSTANCE hDll, DWORD reason, LPVOID reserved) {
-    BOOL ccb;
 #ifdef WIN32__CLIPBOARD__DEBUG
     printf("!XS(DllMain): DLL entry point called with reason: %ld\n", reason);
     printf("!XS(DllMain): ClipboardViewer is: %ld\n", GetClipboardViewer());
@@ -443,12 +419,11 @@
     HANDLE myhandle;
 	LPTSTR filename;
 	UINT namelength;
-	int i, toreturn;
-	UINT count;
+	UINT i, toreturn, count;
     if(OpenClipboard(NULL)) {
 		if(myhandle = GetClipboardData(CF_HDROP)) {
 			count = DragQueryFile((HDROP) myhandle, 0xFFFFFFFF, NULL, 0);
-			EXTEND(SP, count);
+			EXTEND(SP, (int)count);
 			for(i=0; i<count; i++) {
 				namelength = DragQueryFile((HDROP) myhandle, i, NULL, 0);
 				filename = (LPTSTR) safemalloc(namelength+1);
@@ -539,7 +514,7 @@
     UINT namelength;
     int toret;
     UINT count;
-    int i;
+    UINT i;
 	WORD cClrBits;
 	LPBITMAPINFO bmi;
 	BITMAPFILEHEADER hdr;
@@ -550,7 +525,7 @@
 		case CF_HDROP:
 			if(myhandle = GetClipboardData(CF_HDROP)) {
 				count = DragQueryFile((HDROP) myhandle, 0xFFFFFFFF, NULL, 0);
-				EXTEND(SP, count);
+				EXTEND(SP, (int)count);
 				for(i=0; i<count; i++) {
 					namelength = DragQueryFile((HDROP) myhandle, i, NULL, 0);
 					filename = (LPTSTR) safemalloc(namelength+1);
@@ -693,7 +668,6 @@
 EnumFormats(...)
 PPCODE:
 	UINT format;
-	LPTSTR formatname[1024];
 	int count;
     if(OpenClipboard(NULL)) {
 		format = EnumClipboardFormats(0);
@@ -711,7 +685,6 @@
 IsFormatAvailable(svformat,...)
     SV *svformat
 PPCODE:
-	UINT format;
     if (items > 1)
         svformat = ST(1);
 	XST_mIV(0, (long) IsClipboardFormatAvailable((UINT) SvIV(svformat)));
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Console/Console.xs perl-libwin32-0.24/Console/Console.xs
--- libwin32-0.24-orig/Console/Console.xs	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/Console/Console.xs	2004-12-01 23:55:52.000000000 +0000
@@ -9,21 +9,7 @@
  *
  */
 
-#define  WIN32_LEAN_AND_MEAN
-#include <windows.h>
-
-#define __TEMP_WORD  WORD	/* perl defines a WORD, yikes! */
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#undef Top			/* some devel version pollutes */
-#undef WORD
-#define WORD __TEMP_WORD
-
-// Section for the constant definitions.
-#define CROAK croak
-
+#include "../win32perl.h"
 
 DWORD
 constant(char *name, int arg)
@@ -423,7 +409,7 @@
     SHORT x
     SHORT y
 PPCODE:
-    int i;
+    DWORD i;
     COORD coords;
     DWORD written;
     unsigned short buffer[80*999*sizeof(unsigned short)];
@@ -490,7 +476,7 @@
     SHORT x
     SHORT y
 PPCODE:
-    int i;
+    unsigned int i;
     COORD coords;
     DWORD nofread;
     unsigned short abuffer[80*999*sizeof(unsigned short)];
@@ -755,19 +741,19 @@
     case KEY_EVENT:
 	kevent=(KEY_EVENT_RECORD *)&(event.Event);
 	kevent->bKeyDown=(BOOL)SvIV(ST(2));
-	kevent->wRepeatCount=SvIV(ST(3));
-	kevent->wVirtualKeyCode=SvIV(ST(4));
-	kevent->wVirtualScanCode=SvIV(ST(5));
+	kevent->wRepeatCount=(WORD)SvIV(ST(3));
+	kevent->wVirtualKeyCode=(WORD)SvIV(ST(4));
+	kevent->wVirtualScanCode=(WORD)SvIV(ST(5));
 #ifdef UNICODE
 	kevent->uChar.UnicodeChar=SvIV(ST(6));
 #else
-	kevent->uChar.AsciiChar=SvIV(ST(7));
+	kevent->uChar.AsciiChar=(CHAR)SvIV(ST(7));
 #endif
 	break;
     case MOUSE_EVENT:
 	mevent=(MOUSE_EVENT_RECORD *)&(event.Event);
-	mevent->dwMousePosition.X=SvIV(ST(2));
-	mevent->dwMousePosition.Y=SvIV(ST(3));
+	mevent->dwMousePosition.X=(SHORT)SvIV(ST(2));
+	mevent->dwMousePosition.Y=(SHORT)SvIV(ST(3));
 	mevent->dwButtonState=SvIV(ST(4));
 	mevent->dwControlKeyState=SvIV(ST(5));
 	mevent->dwEventFlags=SvIV(ST(6));
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Console/test.pl perl-libwin32-0.24/Console/test.pl
--- libwin32-0.24-orig/Console/test.pl	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/Console/test.pl	2004-12-01 23:55:52.000000000 +0000
@@ -1,6 +1,7 @@
 #these tests are useless in the automated build process
-exit if $ENV{ACTIVEPERL_SKIP_INTERACTIVE_TESTS};
+exit if $ENV{ACTIVEPERL_SKIP_INTERACTIVE_TESTS} || !$ENV{TEST_VERBOSE};
 
+use Win32;
 use Win32::Console;
 
 $^W = 0;  # we get about a trillion warn_undef-s
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Event/Event.xs perl-libwin32-0.24/Event/Event.xs
--- libwin32-0.24-orig/Event/Event.xs	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/Event/Event.xs	2004-12-01 23:55:52.000000000 +0000
@@ -1,5 +1,5 @@
 //--------------------------------------------------------------------
-// $Id$
+// $Id: Event.xs,v 1.1.1.1 2003/01/28 18:59:21 caelum Exp $
 //--------------------------------------------------------------------
 //
 //   Win32::Event
@@ -9,15 +9,7 @@
 //
 //--------------------------------------------------------------------
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
-
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-
+#include "../win32perl.h"
 
 MODULE = Win32::Event		PACKAGE = Win32::Event
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Event/typemap perl-libwin32-0.24/Event/typemap
--- libwin32-0.24-orig/Event/typemap	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/Event/typemap	2004-12-01 23:55:52.000000000 +0000
@@ -7,7 +7,7 @@
 T_PTROBJ
 	if (sv_derived_from($arg, \"${Package}\")) {
 	    IV tmp = SvIV((SV*)SvRV($arg));
-	    $var = ($type) tmp;
+	    $var = ($type)(DWORD) tmp;
 	}
 	else
 	    croak(\"$var is not of type ${Package}\")
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/EventLog/EventLog.pm perl-libwin32-0.24/EventLog/EventLog.pm
--- libwin32-0.24-orig/EventLog/EventLog.pm	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/EventLog/EventLog.pm	2004-12-01 23:55:52.000000000 +0000
@@ -13,6 +13,7 @@
 
 require Exporter;
 require DynaLoader;
+require Win32;
 
 die "The Win32::Eventlog module works only on Windows NT"
 	unless Win32::IsWinNT();
@@ -119,10 +120,16 @@
     die "usage: OBJECT->Read(FLAGS, RECORDOFFSET, HASHREF)\n" unless @_ == 3;
 
     my ($readflags,$recordoffset) = @_;
+
+    # This is to get rid of a weird "Use of uninitialized value in subroutine
+    # entry" warning in Perl 5.6.
+    my ($header, $source, $computer, $sid, $data, $strings) =
+	    map { "" } (1..6);
+
     # The following is stolen shamelessly from Wyt's tests for the registry.
     my $result = ReadEventLog($self->{handle}, $readflags, $recordoffset,
-			      my $header, my $source, my $computer, my $sid,
-			      my $data, my $strings);
+			      $header, $source, $computer, $sid, $data,
+			      $strings);
     my ($length,
 	$reserved,
 	$recordnumber,
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/EventLog/EventLog.xs perl-libwin32-0.24/EventLog/EventLog.xs
--- libwin32-0.24-orig/EventLog/EventLog.xs	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/EventLog/EventLog.xs	2004-12-01 23:55:52.000000000 +0000
@@ -3,13 +3,7 @@
  * Written by Jesse Dougherty for hip communications
  */
 
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
+#include "../win32perl.h"
 
 #define SETIV(index,value) sv_setiv(ST(index),value)
 #define SETPV(index,string) sv_setpv(ST(index),string)
@@ -204,7 +198,7 @@
     DWORD eventType
     DWORD category
     DWORD eventID
-    DWORD reserved = NO_INIT
+    DWORD reserved
     char *data = NO_INIT
 CODE:
 {
@@ -240,7 +234,7 @@
 	data = SvPV(ST(6), dataLength);
 	if (USING_WIDE()) {
 	    New(3101, warray, items - 7, LPWSTR);
-	    for (index = 0; index < items - 7; ++index) {
+	    for (index = 0; index < (unsigned)items - 7; ++index) {
 		buffer = SvPV(ST(index+7), bufLength);
 		New(0, pwChar, bufLength+1, WCHAR);
 		A2WHELPER(buffer, pwChar, (bufLength+1)*sizeof(WCHAR));
@@ -248,33 +242,33 @@
 	    }
 	    RETVAL = ReportEventW(
                 hLog,                  /* handle returned by RegisterEventSource */
-                SvIV(ST(2)),           /* event type to log */
-                SvIV(ST(3)),           /* event category */
+                (WORD)SvIV(ST(2)),     /* event type to log */
+                (WORD)SvIV(ST(3)),     /* event category */
                 SvIV(ST(4)),           /* event identifier */
                 NULL,                  /* user security identifier (optional) */
-                items - 7,             /* number of strings to merge with message */
+                (WORD)(items - 7),     /* number of strings to merge with message */
                 dataLength,            /* size of raw (binary) data (in bytes) */
                 (const WCHAR**)warray, /* array of strings to merge with message */
                 data                   /* address of binary data */
 		);
-	    for (index = 0; index < items - 7; ++index) {
+	    for (index = 0; index < (unsigned)items - 7; ++index) {
 		Safefree(warray[index]);
 	    }
 	    Safefree(warray);
 	}
 	else {
 	    New(3101, array, items - 7, char*);
-	    for (index = 0; index < items - 7; ++index) {
+	    for (index = 0; index < (unsigned)items - 7; ++index) {
 		buffer = SvPV(ST(index+7), bufLength);
 		array[index] = buffer;
 	    }
 	    RETVAL = ReportEventA(
                 hLog,                /* handle returned by RegisterEventSource */
-                SvIV(ST(2)),         /* event type to log */
-                SvIV(ST(3)),         /* event category */
+                (WORD)SvIV(ST(2)),   /* event type to log */
+                (WORD)SvIV(ST(3)),   /* event category */
                 SvIV(ST(4)),         /* event identifier */
                 NULL,                /* user security identifier (optional) */
-                items - 7,           /* number of strings to merge with message */
+                (WORD)items - 7,     /* number of strings to merge with message */
                 dataLength,          /* size of raw (binary) data (in bytes) */
                 (const char**)array, /* array of strings to merge with message */
                 data                 /* address of binary data */
@@ -292,12 +286,12 @@
     size_t handle
     DWORD Flags
     DWORD Record
-    char *evtHeader = NO_INIT
-    char *sourceName = NO_INIT
-    char *computerName = NO_INIT
-    char *sid = NO_INIT
-    char *data = NO_INIT
-    char *strings = NO_INIT
+    char *evtHeader
+    char *sourceName
+    char *computerName
+    char *sid
+    char *data
+    char *strings
 CODE:
 {
     int length;
@@ -308,7 +302,6 @@
     lpEvtLog = SVE(handle);
     if ((lpEvtLog != NULL) && (lpEvtLog->dwID == EVTLOGID)) {
 	DWORD NumRead, Required;
-	long retval;
 	if (Flags != lpEvtLog->Flags) {
 	    /* Reset to new read mode & force a re-read call */
 	    lpEvtLog->Flags      = Flags;
@@ -407,7 +400,7 @@
     DWORD id
     char *longstring
     int numstrings
-    char *message = NO_INIT
+    char *message
 CODE:
 {
     HINSTANCE dll = NULL;
@@ -468,7 +461,7 @@
         /* Try to retrieve message *without* expanding the inserts yet */
         ptr = wmsgfile;
         while (ptr && !wmessage) {
-            WCHAR *semi = wcschr(ptr, L';');
+            WCHAR *semi = (WCHAR *)wcschr(ptr, L';');
             if (semi)
                 *semi++ = '\0';
             dll = LoadLibraryExW(ptr, 0, LOAD_LIBRARY_AS_DATAFILE);
@@ -489,7 +482,7 @@
         /* Determine higest %n insert number */
         maxinsert = numstrings;
         ptr = wmessage;
-        while ((percent=wcschr(ptr, L'%'))
+        while ((percent=(WCHAR *)wcschr(ptr, L'%'))
                && swscanf(percent, L"%%%d", &id2) == 1)
         {
             if (id2 > maxinsert)
@@ -519,7 +512,7 @@
 	    wstrings[j] = ptr;
 
 	    ptr += wcslen(ptr)+1;
-	    while ((percent = wcschr(wstrings[j], L'%'))
+	    while ((percent = (WCHAR *)wcschr(wstrings[j], L'%'))
 		   && swscanf(percent, L"%%%%%d", &id2) == 1)
 	    {
 		if (!dll) {		/* first time round - load dll */
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/EventLog/t/eventlog.t perl-libwin32-0.24/EventLog/t/eventlog.t
--- libwin32-0.24-orig/EventLog/t/eventlog.t	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/EventLog/t/eventlog.t	2004-12-01 23:55:52.000000000 +0000
@@ -1,23 +1,27 @@
+#!perl
+# vim:syntax=perl:
+#
 # (c) 1995 Microsoft Corporation. All rights reserved.
 #	Developed by ActiveWare Internet Corp., http://www.ActiveWare.com
 
 # eventlog.t - Event Logging tests
 
-BEGIN {
-    if (Win32::IsWin95()) {
-        print"1..0\n";
-        print STDERR "# EventLog is not supported on Windows 95 or Win32s\n";
-    }
-}
-
 use strict;
+use Win32;
 use Win32::EventLog;
 
+if (not Win32::IsWinNT()) {
+    print "1..0\n";
+    print "# EventLog is not supported on Windows 95 or Win32s\n";
+    exit;
+}
+
 my $bug = 1;
 
 # accounting for the test harness
+
 open ME, $0 or die $!;
-my $bugs = grep /^\$bug\+\+;\n$/, <ME>;
+my $bugs = grep /^\$bug\+\+;/, <ME>;
 close ME;
 
 print "1..$bugs\n";
@@ -75,6 +79,3 @@
 $EventInfo->{Data} eq 'unix' or print "not ";
 print "ok $bug\n";
 $bug++;
-
-
-
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/File/File.xs perl-libwin32-0.24/File/File.xs
--- libwin32-0.24-orig/File/File.xs	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/File/File.xs	2004-12-01 23:55:52.000000000 +0000
@@ -2,14 +2,7 @@
  *
  */
 
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
-
+#include "../win32perl.h"
 
 /* constant function for exporting NT definitions. */
 static long constant(char *name)
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/FileSecurity/FileSecurity.pm perl-libwin32-0.24/FileSecurity/FileSecurity.pm
--- libwin32-0.24-orig/FileSecurity/FileSecurity.pm	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/FileSecurity/FileSecurity.pm	2004-12-01 23:55:52.000000000 +0000
@@ -12,10 +12,11 @@
 require Exporter;
 require DynaLoader;
 use Carp ;
+use Win32;
 
 $VERSION = '1.04';
 
-croak "The Win32::FileSecurity module works only on Windows NT" if (!Win32::IsWinNT()) ;
+croak "The Win32::FileSecurity module works only on Windows NT" if not Win32::IsWinNT();
 
 @ISA= qw( Exporter DynaLoader );
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/FileSecurity/FileSecurity.xs perl-libwin32-0.24/FileSecurity/FileSecurity.xs
--- libwin32-0.24-orig/FileSecurity/FileSecurity.xs	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/FileSecurity/FileSecurity.xs	2004-12-01 23:55:52.000000000 +0000
@@ -9,15 +9,8 @@
  *
  */
 
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
+#include "../win32perl.h"
 #include <winbase.h>
-#include <string.h>
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
 
 #undef New
 #undef Newc
@@ -149,7 +142,7 @@
 	char *name ;
 	I32 Mask = 0 ;
 	
-	for( i = 0 ; i < items ; i++ ) {
+	for( i = 0 ; i < (unsigned)items ; i++ ) {
 	    if ( ! SvPOK( ST(i) ) ) continue ;
 	    name = SvPV( ST(i), len ) ;
 	    
@@ -172,7 +165,7 @@
 	SV *av
     CODE:
 	{
-	    int j, Ok ;
+	    int j;
 	    if (!(av && SvROK(av) && (av = SvRV(av)) && SvTYPE(av) == SVt_PVAV))
     		croak( "second arg must be ARRAYREF" ) ;
 
@@ -201,7 +194,6 @@
 	{
 	    SV*  sv;
 	    SV** psv;
-	    AV*  av;
 	    PSECURITY_DESCRIPTOR pSecDesc = NULL;
 	    SECURITY_DESCRIPTOR_CONTROL Control = 0;
 	    BOOL bDaclPresent, bDaclDefaulted ;
@@ -213,7 +205,7 @@
 		bName = MAXIMUM_NAME_LENGTH, bDName = MAXIMUM_NAME_LENGTH;
 	    SID_NAME_USE eUse ;
 	    DWORD nLength = 0, nLengthNeeded = 1, tries = 2, Revision = 0 ;
-	    DWORD error, i, j ;
+	    DWORD error, i;
 	    BOOL bResult;
 
 	    RETVAL = FALSE;
@@ -422,7 +414,7 @@
 	    /* Initialize a new security descriptor. */
  
 	    /* SECURITY_DESCRIPTOR_MIN_LENGTH defined in WINNT.H */
-	    Newc( 4, pSD, SECURITY_DESCRIPTOR_MIN_LENGTH, char, PSECURITY_DESCRIPTOR );
+	    Newc( 4, pSD, SECURITY_DESCRIPTOR_MIN_LENGTH, char, SECURITY_DESCRIPTOR );
 	    if (pSD == NULL) { 
 		ErrorHandler( "Newc SECURITY_DESCRIPTOR"); 
 		goto SetCleanup ;
@@ -561,7 +553,7 @@
 		while (tries--) {
 		    /* Add Ace */
 		    if ( AccountRights ) {
-			pAllAce->Header.AceSize = sizeof( ACCESS_ALLOWED_ACE ) - sizeof( DWORD ) + GetLengthSid( (PSID) pSID  ) ;
+			pAllAce->Header.AceSize = (WORD)(sizeof( ACCESS_ALLOWED_ACE ) - sizeof( DWORD ) + GetLengthSid( (PSID) pSID  )) ;
 			pAllAce->Mask = (ACCESS_MASK) AccountRights ;
 			
 			if (!AddAce(
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/FileSecurity/mingw32.exc perl-libwin32-0.24/FileSecurity/mingw32.exc
--- libwin32-0.24-orig/FileSecurity/mingw32.exc	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/FileSecurity/mingw32.exc	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/FileSecurity/test.pl perl-libwin32-0.24/FileSecurity/test.pl
--- libwin32-0.24-orig/FileSecurity/test.pl	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/FileSecurity/test.pl	2004-12-01 23:55:52.000000000 +0000
@@ -12,7 +12,7 @@
 foreach (<*>) {
     next unless -e $_;
     my(%hash) = ();
-    if ( Get( $_, \%hash ) ) {
+    if ( eval { Get( $_, \%hash ) } ) {
         print STDERR "----- File: $_ -----\n";
 	while( ($name, $mask) = each %hash ) {
 	    print STDERR "$name:\n\t"; 
@@ -20,8 +20,8 @@
 	    print STDERR join( "\n\t", @happy ), "\n";
 	}
     } else {
-	print( "Error #", int( $! ), ": $!" ) ;
+	my $error = Win32::GetLastError();
+	print( "Error #", $error, ": ", Win32::FormatMessage($error), "\n" ) ;
+	print "$@\n";
     }
 }
-
-
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/IPC/IPC.xs perl-libwin32-0.24/IPC/IPC.xs
--- libwin32-0.24-orig/IPC/IPC.xs	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/IPC/IPC.xs	2004-12-01 23:55:58.000000000 +0000
@@ -1,5 +1,5 @@
 //--------------------------------------------------------------------
-// $Id$
+// $Id: IPC.xs,v 1.1.1.1 2003/01/28 18:59:31 caelum Exp $
 //--------------------------------------------------------------------
 //
 //   Win32::IPC
@@ -9,15 +9,9 @@
 //
 //--------------------------------------------------------------------
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
-
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-
+#include "../win32perl.h"
+#include <wininet.h>
+#include <winver.h>
 
 static IV
 WaitForMultiple(AV* hArray, BOOL fWaitAll, DWORD dwTimeOut)
@@ -59,12 +53,12 @@
       PUTBACK;
       result = perl_call_method("get_process_handle", G_SCALAR|G_EVAL);
       SPAGAIN;
-      if ((result == 1) && SvIOKp(TOPs)) handle = (HANDLE)POPi;
+      if ((result == 1) && SvIOKp(TOPs)) handle = (HANDLE)(DWORD)POPi;
       PUTBACK;
       FREETMPS;
       LEAVE;
     } else if (sv_derived_from(*svpp,"Win32::IPC")) {
-      handle = (HANDLE)(SvIV(SvRV(*svpp)));
+      handle = (HANDLE)(DWORD)(SvIV(SvRV(*svpp)));
     } else {
       croak("Don't know how to wait on $objects[%d]",i);
       return IV_MAX;
@@ -111,14 +105,12 @@
 IV
 wait_any(objects,timeout=INFINITE)
 	SV *  objects
-	BOOL  waitall
 	DWORD timeout
 ALIAS:
 	wait_all = 1
 PROTOTYPE: \@;$
 PREINIT:
 	AV *	av;
-	DWORD 	ret;
 CODE:
 	if (!(SvROK(objects)
 	      && (av = (AV*)SvRV(objects))
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/IPC/typemap perl-libwin32-0.24/IPC/typemap
--- libwin32-0.24-orig/IPC/typemap	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/IPC/typemap	2004-12-01 23:55:58.000000000 +0000
@@ -7,7 +7,7 @@
 T_PTROBJ
 	if (sv_derived_from($arg, \"${Package}\")) {
 	    IV tmp = SvIV((SV*)SvRV($arg));
-	    $var = ($type) tmp;
+	    $var = ($type)(DWORD) tmp;
 	}
 	else
 	    croak(\"$var is not of type ${Package}\")
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Internet/Internet.pm perl-libwin32-0.24/Internet/Internet.pm
--- libwin32-0.24-orig/Internet/Internet.pm	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/Internet/Internet.pm	2004-12-01 23:55:58.000000000 +0000
@@ -20,6 +20,7 @@
 require Exporter;       # to export the constants to the main:: space
 require DynaLoader;     # to dynuhlode the module.
 
+use Win32;
 # use Win32::WinError;    # for windows constants.
 
 @ISA= qw( Exporter DynaLoader );
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Internet/Internet.xs perl-libwin32-0.24/Internet/Internet.xs
--- libwin32-0.24-orig/Internet/Internet.xs	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/Internet/Internet.xs	2004-12-01 23:55:58.000000000 +0000
@@ -9,46 +9,8 @@
  *
  */
 
-// Basic includes
-#define  WIN32_LEAN_AND_MEAN
-// #include <math.h>
-#include <windows.h>
-
-// Extension specific includes
+#include "../win32perl.h"
 #include <wininet.h>
-#include <winver.h>
-
-#define __TEMP_WORD  WORD	/* perl defines a WORD, yikes! */
-
-// Perl includes
-#if (defined(__cplusplus) && !defined(PERL_OBJECT))
-extern "C" {
-#endif
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-#if (defined(__cplusplus) && !defined(PERL_OBJECT))
-}
-#endif
-
-#undef WORD
-#define WORD __TEMP_WORD
-
-#ifndef PERL_VERSION
-#  include "patchlevel.h"
-#  define PERL_REVISION		5
-#  define PERL_VERSION		PATCHLEVEL
-#  define PERL_SUBVERSION	SUBVERSION
-#endif
-
-#if PERL_REVISION == 5 && (PERL_VERSION < 4 || \
-			   (PERL_VERSION == 4 && PERL_SUBVERSION <= 75))
-#  define PL_sv_undef		sv_undef
-#  define PL_sv_yes		sv_yes
-#  define PL_sv_no		sv_no
-#  define PL_na			na
-#  define PL_dowarn		dowarn
-#endif
 
 // Section for the constant definitions.
 #define CROAK croak
@@ -973,7 +935,6 @@
     HINTERNET handle
     DWORD option
 PPCODE:
-    DWORD mysize;
     char *mybuf;
     long mybufsz = 16000;
     DWORD mynum;
@@ -1036,7 +997,6 @@
     DWORD mysize;
     void *mybuf;
     long mybufsz = 16000;
-    BOOL myquerystatus;
     DWORD mynum;
     BOOL myretval;
     STRLEN len;
@@ -1096,7 +1056,7 @@
     // printf("ITFST %d:%d:%d %d/%d/%d %d %d\n",st.wHour,st.wMinute,st.wSecond,
     //		st.wDay, st.wMonth, st.wYear, st.wDayOfWeek,RFC;
 
-    if (InternetTimeFromSystemTime((CONST SYSTEMTIME *)&st,
+    if (InternetTimeFromSystemTime((SYSTEMTIME *)&st,
 				  RFC,
 				  (LPSTR)&mybuffer,
 				  (DWORD)sizeof(mybuffer)))
@@ -1145,7 +1105,7 @@
     myURL.dwSchemeLength=mysize;
     myURL.lpszHostName=(char *)safemalloc(mysize);
     myURL.dwHostNameLength=mysize;
-    myURL.nPort=mysize;
+    myURL.nPort=(INTERNET_PORT)mysize;
     myURL.lpszUserName=(char *)safemalloc(mysize);
     myURL.dwUserNameLength=mysize;
     myURL.lpszPassword=(char *)safemalloc(mysize);
@@ -1190,7 +1150,7 @@
     myURL.dwStructSize=sizeof(myURL);
     myURL.lpszScheme	= SvPV(scheme, len); myURL.dwSchemeLength = len;
     myURL.lpszHostName	= SvPV(hostname, len); myURL.dwHostNameLength = len;
-    myURL.nPort		= port;
+    myURL.nPort		= (INTERNET_PORT)port;
     myURL.lpszUserName	= SvPV(username, len); myURL.dwUserNameLength = len;
     myURL.lpszPassword	= SvPV(password, len); myURL.dwPasswordLength = len;
     myURL.lpszUrlPath	= SvPV(path, len); myURL.dwUrlPathLength = len;
@@ -1336,7 +1296,6 @@
     HINTERNET myhandle;
     WIN32_FIND_DATA myfile;
     SYSTEMTIME mytime;
-    unsigned long myCreationTime, myLastAccessTime, myLastWriteTime;
     unsigned long myFileSize;	
 
     if (myhandle = FtpFindFirstFile(handle, pattern,
@@ -1387,7 +1346,6 @@
 PPCODE:
     WIN32_FIND_DATA myfile;
     SYSTEMTIME mytime;
-    unsigned long myCreationTime, myLastAccessTime, myLastWriteTime;
     unsigned long myFileSize;	
 
     if (InternetFindNextFile(handle, &myfile)) {
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Internet/Makefile.PL perl-libwin32-0.24/Internet/Makefile.PL
--- libwin32-0.24-orig/Internet/Makefile.PL	2002-07-09 00:15:51.000000000 +0000
+++ perl-libwin32-0.24/Internet/Makefile.PL	2004-12-01 23:55:58.000000000 +0000
@@ -1,13 +1,12 @@
 use ExtUtils::MakeMaker;
 use Config;
-my $inetlib = 'wininet';
-$inetlib = 'inet' if $Config{'cc'} =~ /^bcc32/i;
+
 WriteMakefile(
     'NAME'		=> 'Win32::Internet',
     'VERSION_FROM'	=> 'Internet.pm', # finds $VERSION
+    'PM'		=> { 'Internet.pm' => '$(INST_LIBDIR)/Internet.pm' },
     'dist'		=> {COMPRESS => 'gzip -9f', SUFFIX => 'gz'},
-    'LIBS'		=> [ ":nosearch ${inetlib}.lib" ],
-    'INC'	=> '-I.',
+    'INC'		=> '-I.',
     ($] < 5.005 ? () :
       (
 	'AUTHOR'	=> 'Aldo Calpini <dada@divinf.it>',
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Internet/mingw32.exc perl-libwin32-0.24/Internet/mingw32.exc
--- libwin32-0.24-orig/Internet/mingw32.exc	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/Internet/mingw32.exc	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Internet/typemap perl-libwin32-0.24/Internet/typemap
--- libwin32-0.24-orig/Internet/typemap	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/Internet/typemap	2004-12-01 23:55:58.000000000 +0000
@@ -5,3 +5,15 @@
 BOOL                    T_IV
 LPTSTR                  T_PV
 HINTERNET               T_IV
+
+#############################################################################
+INPUT
+
+T_IV
+	$var = ($type)(DWORD)SvIV($arg)
+
+#############################################################################
+OUTPUT
+
+T_IV
+	sv_setiv($arg, (IV)(DWORD)$var);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Job/Job.pm perl-libwin32-0.24/Job/Job.pm
--- libwin32-0.24-orig/Job/Job.pm	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/Job/Job.pm	2004-12-01 23:55:58.000000000 +0000
@@ -3,6 +3,7 @@
 use strict;
 use base qw(DynaLoader);
 use vars qw($VERSION);
+use Win32;
 
 $VERSION = '0.01';
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Job/Job.xs perl-libwin32-0.24/Job/Job.xs
--- libwin32-0.24-orig/Job/Job.xs	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/Job/Job.xs	2004-12-01 23:55:58.000000000 +0000
@@ -1,9 +1,7 @@
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x0500
-#include <windows.h>
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
+#include "../win32perl.h"
 
 #define NEWZ_CONST_INT 413
 #define KILL_EXITCODE  293
@@ -19,14 +17,6 @@
 #define JOB_OBJECT_LIMIT_BREAKAWAY_OK 0x00000800
 #endif
 
-/* For non-threaded Perl */
-#ifndef pTHX
-#define pTHX	/* empty */
-#define aTHX	/* empty */
-#define pTHX_	/* empty */
-#define aTHX_	/* empty */
-#endif
-
 /* This structure contains the HANDLE for the job object, plus an
  * array of pointers to PROCESS_INFORMATION structures (one for each
  * process spawn()ed). We remember these so we can call CloseHandle()
@@ -73,7 +63,7 @@
 new_handle(pTHX_ HANDLE file)
 {
 	SV* rv = newSViv(0); /* blank SV */
-	sv_setref_iv(rv, "Win32::Job::_handle", (IV)file);
+	sv_setref_iv(rv, "Win32::Job::_handle", (IV)(DWORD)file);
 	return rv;
 }
 
@@ -208,7 +198,7 @@
 	HANDLE h;
     CODE:
 	iv = SvIV(SvRV(self));
-	h  = (HANDLE)iv;
+	h  = (HANDLE)(DWORD)iv;
 	if (h) CloseHandle(h);
 
 MODULE = Win32::Job	PACKAGE = Win32::Job
@@ -222,7 +212,7 @@
 	JOB_T	job;
     CODE:
 	Newz(NEWZ_CONST_INT, job, 1, job_t);
-	job->hJob  = CreateJobObject(NULL, NULL); /* unnamed job */
+	job->hJob  = (HANDLE)CreateJobObject(NULL, NULL); /* unnamed job */
 	job->procs = newAV();
 	job->info  = newHV();
 	RETVAL = job;
@@ -303,7 +293,7 @@
 	    char *curr = path;
 	    char *endp = strchr(curr, ';');
 	    int len;
-	    struct stat sbuf;
+	    struct stat     sbuf;
 	    while (endp) {
 		len = (int)(endp - curr);
 		strncpy(pbuf, curr, len);
@@ -527,7 +517,7 @@
 	    which = 0;     /* wait for ANY process to complete */
 	if (!interval)
 	    XSRETURN_UNDEF; /* you suck, programmer! */
-	dwInterval = interval * 1000;
+	dwInterval = (DWORD)(interval * 1000);
 	for (i = 0; i < imax; i++) {
 	    STRLEN l;
 	    SV *tmp = *av_fetch(self->procs, i, 0);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Job/test.pl perl-libwin32-0.24/Job/test.pl
--- libwin32-0.24-orig/Job/test.pl	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/Job/test.pl	2004-12-01 23:55:58.000000000 +0000
@@ -1,8 +1,14 @@
 use Config;
 use Data::Dumper;
+use Win32;
 use Win32::Job;
 
 my $job;
+my $perlpath = $Config{perlpath};
+if ($^O eq 'cygwin') {
+	chomp($perlpath = `cygpath -w $perlpath`);
+	$perlpath .= '.exe' if $perlpath !~ /\.exe$/;
+}
 
 # Processes you spawn in the job are initially suspended. You can activate
 # them by using one of the following functions. This allows you to run several 
@@ -12,12 +18,12 @@
 # is one way to implement your own timeout, for example. The watchdog is passed
 # the $job object.
 $job = Win32::Job->new;
-$job->spawn($Config{perlpath}, "perl child.t", {
+$job->spawn($perlpath, "perl child.t", {
 	stdin => 'NUL',
 	stdout => 'stdout.txt',
 	stderr => 'stdout.txt',
 });
-$job->spawn($Config{perlpath}, "perl -le \"print \$\$\"");
+$job->spawn($perlpath, "perl -le \"print \$\$\"");
 $job->spawn("cmd", q{cmd /C "echo %PATH%"});
 $i = 0;
 $job->watch(sub {
@@ -32,7 +38,7 @@
 # you're letting it run with no timeout at all (and you might as well use a 
 # simpler module).
 $job = Win32::Job->new;
-$job->spawn($Config{perlpath}, "perl child.t"); #, {new_console => 1});
+$job->spawn($perlpath, "perl child.t"); #, {new_console => 1});
 $job->run(10);
 print Dumper $job->status;
 print "$^E\n";
@@ -40,7 +46,7 @@
 # You can call kill() explicitly to kill the job and all of its subprocesses.
 # You could do this from a watchdog timer, for example.
 $job = Win32::Job->new;
-$job->spawn($Config{perlpath}, "perl child.t");
+$job->spawn($perlpath, "perl child.t");
 $job->run(1);
 print Dumper $job->status;
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Job/test1.pl perl-libwin32-0.24/Job/test1.pl
--- libwin32-0.24-orig/Job/test1.pl	1970-01-01 00:00:00.000000000 +0000
+++ perl-libwin32-0.24/Job/test1.pl	2005-02-06 16:53:08.000000000 +0000
@@ -0,0 +1,40 @@
+use strict;
+use Win32::Job;
+use Sys::Hostname;
+use Data::Dumper;
+
+my $job;
+my $args;
+my $pid;
+my $prog;
+my $host;
+my $ok;
+my $rc;
+my %stat;
+my $timeout = 24*60*60; #seconds
+
+   $host = hostname;
+   $args = join(' ',@ARGV); #note: these are args that ri.bat would have
+   $prog  = 'I:\PerlProjects\no_ctl_c\my_ri.bat'; # TODO: pick right ri.bat
+   $job = Win32::Job->new;
+
+   $pid = $job->spawn($prog,$args,{no_window => 2});
+
+   print STDERR "\n";
+   print STDERR "host = $host\n";
+   print STDERR "prog = $prog\n";
+   print STDERR "args = $args\n";
+   print STDERR "pid  = $pid\n";
+
+   $ok = $job->run($timeout);
+   unless($ok){
+     print STDERR "timed out!\n";
+   }
+
+   %stat = $job->status();
+
+   $Data::Dumper::Indent   = 1;
+   $Data::Dumper::Purity   = 1;
+   $Data::Dumper::Deepcopy = 1;
+   print STDERR Data::Dumper->Dump( [ \%stat ], [ '*stat' ] );
+   print STDERR "\n";
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Job/typemap perl-libwin32-0.24/Job/typemap
--- libwin32-0.24-orig/Job/typemap	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/Job/typemap	2004-12-01 23:55:58.000000000 +0000
@@ -4,7 +4,7 @@
 T_JOB
         if (sv_derived_from($arg, \"Win32::Job\")) {
             IV tmp = SvIV((SV*)SvRV($arg));
-            $var = ($type) tmp;
+            $var = ($type)(DWORD) tmp;
         }
         else
             croak(\"$var is not of type Win32::Job\")
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/MANIFEST perl-libwin32-0.24/MANIFEST
--- libwin32-0.24-orig/MANIFEST	2002-07-09 00:28:22.000000000 +0000
+++ perl-libwin32-0.24/MANIFEST	2005-02-13 11:28:54.234375000 +0000
@@ -13,8 +13,8 @@
 APIFile/ex/DiskGeom.plx
 APIFile/ex/FormatFloppy.plx
 APIFile/ex/ListDevs.plx
-APIFile/ppport.h
 APIFile/test.pl
+APIFile/t/tie.t
 APIFile/typemap
 APINet/Changes
 APINet/MANIFEST
@@ -22,7 +22,6 @@
 APINet/Net.html
 APINet/Net.pm
 APINet/Net.xs
-APINet/mingw32.exc
 APINet/t/test.t
 APIRegistry/Changes
 APIRegistry/ExtUtils/Myconst2perl.pm
@@ -35,7 +34,6 @@
 APIRegistry/cRegistry.h
 APIRegistry/cRegistry.pc
 APIRegistry/const2perl.h
-APIRegistry/ppport.h
 APIRegistry/test.pl
 APIRegistry/typemap
 ChangeNotify/ChangeNotify.pm
@@ -94,7 +92,6 @@
 FileSecurity/FileSecurity.xs
 FileSecurity/MANIFEST
 FileSecurity/Makefile.PL
-FileSecurity/mingw32.exc
 FileSecurity/test.pl
 IPC/Changes
 IPC/IPC.pm
@@ -115,7 +112,6 @@
 Internet/docs/license.html
 Internet/docs/reference.html
 Internet/docs/toc.html
-Internet/mingw32.exc
 Internet/test-async.pl
 Internet/test.pl
 Internet/typemap
@@ -140,14 +136,12 @@
 NetAdmin/Makefile.PL
 NetAdmin/NetAdmin.pm
 NetAdmin/NetAdmin.xs
-NetAdmin/mingw32.exc
 NetAdmin/t/netadmin.t
 NetResource/Changes
 NetResource/MANIFEST
 NetResource/Makefile.PL
 NetResource/NetResource.pm
 NetResource/NetResource.xs
-NetResource/mingw32.exc
 NetResource/t/netresource.t
 NetResource/typemap
 ODBC/CMom.cpp
@@ -157,7 +151,7 @@
 ODBC/Constant.cpp
 ODBC/Constant.h
 ODBC/HISTORY.TXT
-ODBC/Icon2.ico
+ODBC/ODBC.ico
 ODBC/MANIFEST
 ODBC/Makefile.PL
 ODBC/ODBC.h
@@ -171,7 +165,6 @@
 ODBC/Test.pl
 ODBC/docs/object.html
 ODBC/docs/odbc.html
-ODBC/mingw32.exc
 ODBC/resource.h
 OLE/Changes			Lowlevel changelog
 OLE/MANIFEST
@@ -180,7 +173,6 @@
 OLE/OLE.xs
 OLE/README
 OLE/ToDo
-OLE/hints/cygwin.pl
 OLE/lib/OLE.pm			Compatibility layer: old toplevel OLE.pm
 OLE/lib/Win32/OLE/Const.pm	Win32::OLE::Const module: TypeLib constants
 OLE/lib/Win32/OLE/Enum.pm	Win32::OLE::Enum module: Collection objects
@@ -226,7 +218,6 @@
 PerfLib/PerfLib.pm
 PerfLib/PerfLib.xs
 PerfLib/calc.html
-PerfLib/mingw32.exc
 PerfLib/test.pl
 PerfLib/typemap
 Pipe/Client.pl
@@ -239,7 +230,6 @@
 Pipe/Pipe.xs
 Pipe/README
 Pipe/Server.pl
-Pipe/mingw32.exc
 Pipe/test.bat
 Process/Changes
 Process/MANIFEST
@@ -247,7 +237,6 @@
 Process/Process.hpp
 Process/Process.pm
 Process/Process.xs
-Process/mingw32.exc
 Process/test.pl
 Process/typemap
 README
@@ -284,7 +273,6 @@
 Shortcut/docs/reference.html
 Shortcut/docs/toc.html
 Shortcut/ln32.bat
-Shortcut/mingw32.exc
 Shortcut/test.pl
 Shortcut/typemap
 Sound/MANIFEST
@@ -292,7 +280,6 @@
 Sound/README
 Sound/Sound.pm
 Sound/Sound.xs
-Sound/mingw32.exc
 Sound/test.pl
 Sound/samples/welcome.wav
 Sound/samples/devices.pl
@@ -314,4 +301,9 @@
 WinError/Makefile.PL
 WinError/WinError.pm
 WinError/WinError.xs
+WinError/t/winerror.t
 ppport.h
+win32perl.h
+hints/cygwin.pl
+hints/MSWin32.pl
+CYGWIN-PATCHES/README
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Makefile.PL perl-libwin32-0.24/Makefile.PL
--- libwin32-0.24-orig/Makefile.PL	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/Makefile.PL	2005-02-13 11:27:40.781250000 +0000
@@ -1,10 +1,67 @@
 use ExtUtils::MakeMaker;
+use ExtUtils::MM;
+
+my @extensions = qw(
+	APIFile APINet APIRegistry ChangeNotify Clipboard Console
+	Event EventLog File FileSecurity Internet IPC Job Mutex NetAdmin
+	NetResource ODBC OLE PerfLib Pipe Process Registry Semaphore Service
+	Shortcut Sound TieRegistry WinError 
+);
+#OLE GUI
+
+LinkHints();
+
+# Man pages don't get generated, so I just built a list manually for now.
+my %MAN3PODS = (
+	'APIFile/File.pm'			=> 	'Win32API/File',
+	'APINet/Net.pm'				=>	'Win32API/Net',
+	'APIRegistry/Registry.pm'		=>	'Win32API/Registry',
+	'ChangeNotify/ChangeNotify.pm'		=>	'Win32/ChangeNotify',
+	'Clipboard/Clipboard.pm'		=>	'Win32/Clipboard',
+	'Console/Console.pm'			=>	'Win32/Console',
+	'Event/Event.pm'			=>	'Win32/Event',
+	'EventLog/EventLog.pm'			=>	'Win32/EventLog',
+	'File/File.pm'				=>	'Win32/File',
+	'FileSecurity/FileSecurity.pm'		=>	'Win32/FileSecurity',
+	'Internet/Internet.pm'			=>	'Win32/Internet',
+	'IPC/IPC.pm'				=>	'Win32/IPC',
+	'Job/Job.pm'				=>	'Win32/Job',
+	'Mutex/Mutex.pm'			=>	'Win32/Mutex',
+	'NetAdmin/NetAdmin.pm'			=>	'Win32/NetAdmin',
+	'NetResource/NetResource.pm'		=>	'Win32/NetResource',
+	'ODBC/ODBC.pm'				=>	'Win32/ODBC',
+	'OLE/lib/Win32/OLE/Const.pm'		=>	'Win32/OLE/Const',
+	'OLE/lib/Win32/OLE/Enum.pm'		=>	'Win32/OLE/Enum',
+	'OLE/lib/Win32/OLE/NEWS.pod'		=>	'Win32/OLE/NEWS',
+	'OLE/lib/Win32/OLE/NLS.pm'		=>	'Win32/OLE/NLS',
+	'OLE/lib/Win32/OLE/TPJ.pod'		=>	'Win32/OLE/TPJ',
+	'OLE/lib/Win32/OLE/Variant.pm'		=>	'Win32/OLE/Variant',
+	'OLE/lib/Win32/OLE.pm'			=>	'Win32/OLE',
+	'PerfLib/PerfLib.pm'			=>	'Win32/PerfLib',
+	'Pipe/Pipe.pm'				=>	'Win32/Pipe',
+	'Process/Process.pm'			=>	'Win32/Process',
+	'Registry/Registry.pm'			=>	'Win32/Registry',
+	'Semaphore/Semaphore.pm'		=>	'Win32/Semaphore',
+	'Service/Service.pm'			=>	'Win32/Service',
+	'Sound/Sound.pm'			=>	'Win32/Sound',
+	'TieRegistry/TieRegistry.pm'		=>	'Win32/TieRegistry',
+);
+
+for (values %MAN3PODS) {
+  $_ = '$(INST_MAN3DIR)/'.MM->replace_manpage_separator($_).'.$(MAN3EXT)';
+}
 
 WriteMakefile(
     NAME		=> 'Win32',
     DISTNAME		=> 'libwin32',
     VERSION_FROM	=> 'Win32.pm',
+    XS			=> { 'Win32.xs' => 'Win32.cpp' },
+    DIR			=> [@extensions],
+    MAN3PODS		=> { %MAN3PODS },
     'dist'		=> {COMPRESS => 'gzip -9f', SUFFIX => 'gz'},
+    clean		=> {FILES =>
+    	join ' ', map { "$_/hints" } @extensions
+    },
     ($] < 5.005 ? () :
       (
 	ABSTRACT	=> 'A collection of extensions that aims to provide '
@@ -13,22 +70,27 @@
       )),
 );
 
+sub MY::xs_c {
+    '
+.xs.cpp:
+	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs >xstmp.c && $(MV) xstmp.c $*.cpp
+';
+}
+
+sub LinkHints {
+  use IO::File;
+  use File::Basename;
+
+  print "Creating hints files...\n";
+
+  my @hints = map { basename $_ } <hints/*.pl>;
 
-package MY;
-use Config;
-sub post_initialize {
-    my $self = shift;
-    my @keep;
-    my $mingw32 = ($^O eq 'MSWin32') && ($Config{'cc'} =~ /^gcc/i);
-    warn "Not all subdirs build with Mingw32\n" if $mingw32;
-    foreach my $dir (@{$self->{'DIR'}}) {
-	if ($mingw32 && -f "$dir/mingw32.exc") {
-	    warn "Skipping $dir on Mingw32\n";
-	}
-	else {
-	    push(@keep,$dir);
-	}
+  for my $dir (@extensions) {
+    mkdir "$dir/hints";
+    for my $hint (@hints) {
+      my $file = new IO::File "> $dir/hints/$hint";
+      print $file
+	qq{local \$/; open H, "../hints/$hint"; eval <H>; close H;\n} if $file;
     }
-    $self->{DIR} = \@keep;
-    return $self->SUPER::post_initialize;
+  }
 }
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Mutex/Mutex.xs perl-libwin32-0.24/Mutex/Mutex.xs
--- libwin32-0.24-orig/Mutex/Mutex.xs	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/Mutex/Mutex.xs	2004-12-01 23:55:58.000000000 +0000
@@ -1,5 +1,5 @@
 //--------------------------------------------------------------------
-// $Id$
+// $Id: Mutex.xs,v 1.1.1.1 2003/01/28 18:59:32 caelum Exp $
 //--------------------------------------------------------------------
 //
 //   Win32::Mutex
@@ -9,15 +9,7 @@
 //
 //--------------------------------------------------------------------
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
-
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-
+#include "../win32perl.h"
 
 MODULE = Win32::Mutex		PACKAGE = Win32::Mutex
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Mutex/typemap perl-libwin32-0.24/Mutex/typemap
--- libwin32-0.24-orig/Mutex/typemap	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/Mutex/typemap	2004-12-01 23:55:58.000000000 +0000
@@ -7,7 +7,7 @@
 T_PTROBJ
 	if (sv_derived_from($arg, \"${Package}\")) {
 	    IV tmp = SvIV((SV*)SvRV($arg));
-	    $var = ($type) tmp;
+	    $var = ($type)(DWORD) tmp;
 	}
 	else
 	    croak(\"$var is not of type ${Package}\")
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/NetAdmin/NetAdmin.pm perl-libwin32-0.24/NetAdmin/NetAdmin.pm
--- libwin32-0.24-orig/NetAdmin/NetAdmin.pm	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/NetAdmin/NetAdmin.pm	2004-12-01 23:55:58.000000000 +0000
@@ -9,6 +9,7 @@
 
 require Exporter;
 require DynaLoader;
+use Win32;
 
 die "The Win32::NetAdmin module works only on Windows NT" if(!Win32::IsWinNT() );
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/NetAdmin/NetAdmin.xs perl-libwin32-0.24/NetAdmin/NetAdmin.xs
--- libwin32-0.24-orig/NetAdmin/NetAdmin.xs	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/NetAdmin/NetAdmin.xs	2004-12-01 23:55:58.000000000 +0000
@@ -16,24 +16,21 @@
  *    98.02.13 david.gardiner@unisa.edu.au
  */
 
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
+#include "../win32perl.h"
+
+#define FORCE_UNICODE	/* Avoid spurious warnings due to broken headers */
+
 #include <lmcons.h>     /* LAN Manager common definitions */
 #include <lmerr.h>      /* LAN Manager network error definitions */
-#include <lmUseFlg.h>
-#include <lmAccess.h>
-#include <lmAPIBuf.h>
+#include <lmuseflg.h>
+#include <lmaccess.h>
+#include <lmapibuf.h>
 #undef LPTSTR
 #define LPTSTR LPWSTR
-#include <lmServer.h>
+#include <lmserver.h>
 #include <lmwksta.h>
 #undef LPTSTR
 #define LPTSTR LPSTR
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
 
 #define RETURNRESULT(x)		if ((x)){ XST_mYES(0); }\
                      		else { XST_mNO(0); }\
@@ -556,7 +553,7 @@
 	length = (strlen(name)+1) * sizeof(WCHAR);
 	lpPtr = (LPWSTR)malloc(length);
 	if (lpPtr != NULL)
-	    MultiByteToWideChar(CP_ACP, NULL, name, -1, lpPtr, length);
+	    MultiByteToWideChar(CP_ACP, 0, name, -1, lpPtr, length);
     }
     return lpPtr;
 }
@@ -570,14 +567,15 @@
 	free(lpPtr);
 }
 
+/*
+
 int
 WCTMB(LPWSTR lpwStr, LPSTR lpStr, int size)
 {
     *lpStr = '\0';
-    return WideCharToMultiByte(CP_ACP,NULL,lpwStr,-1,lpStr,size,NULL,NULL);
+    return WideCharToMultiByte(CP_ACP,0,lpwStr,-1,lpStr,size,NULL,NULL);
 }
 
-/*
 void AddStringToHV(HV *hv, char *key, char *value)
 {
     char buffer[256];
@@ -902,7 +900,6 @@
 XS(XS_NT__NetAdmin_UsersExist)
 {
     dXSARGS;
-    char buffer[UNLEN+1];
     LPWSTR lpwServer, lpwUser;
     PUSER_INFO_0 puiUser;
     BOOL bReturn = FALSE;
@@ -937,8 +934,7 @@
     PUSER_INFO_10 pwzUsers10;
     DWORD filter, entriesRead, totalEntries, resumeHandle = 0;
     int index;
-    SV *sv, *nSv;
-    SV *user;
+    SV *sv;
     DWORD lastError = 0;
 
     if (items != 3) {
@@ -961,7 +957,7 @@
 					&resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzUsers[index].usri0_name, buffer, sizeof(buffer));
 		    av_push((AV*)sv, newSVpv(buffer, 0));
 		}
@@ -979,7 +975,7 @@
 					&resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzUsers10[index].usri10_name, buffer, sizeof(buffer));
 		    W2AHELPER(pwzUsers10[index].usri10_full_name, buffer1,
 			  sizeof(buffer1));
@@ -1031,7 +1027,7 @@
 					  &totalEntries, &resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pws[index].wkti0_transport_name, buffer,
 			  sizeof(buffer));
 		    av_push((AV*)sv, newSVpv(buffer, 0));
@@ -1050,7 +1046,7 @@
 						  &totalEntries, &resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    hvTemp = newHV();
 		    hv_store(hvTemp,
 			     "quality_of_service",
@@ -1101,8 +1097,7 @@
     PWKSTA_USER_INFO_1 pwzUser1;
     DWORD entriesRead, totalEntries, resumeHandle = 0;
     int index;
-    SV *sv, *nSv;
-    SV *user;
+    SV *sv;
     DWORD lastError = 0;
 
     if (items != 2) {
@@ -1124,7 +1119,7 @@
 					&resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzUser0[index].wkui0_username, buffer, sizeof(buffer));
 		    av_push((AV*)sv, newSVpv(buffer, 0));
 		}
@@ -1142,7 +1137,7 @@
 					     &resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzUser1[index].wkui1_username, buffer, sizeof(buffer));
 		    W2AHELPER(pwzUser1[index].wkui1_logon_domain, logon_domain,
 			  sizeof(logon_domain));
@@ -1295,7 +1290,7 @@
 	    for (index = 0; index <= count; ++index) {
 		psv = av_fetch((AV*)sv, index, 0);
 		if (psv != NULL) {
-		    MultiByteToWideChar(CP_ACP, NULL, (char*)SvPV(*psv,n_a),
+		    MultiByteToWideChar(CP_ACP, 0, (char*)SvPV(*psv,n_a),
 					-1, wzUser, sizeof(wzUser));
 		    lastError = NetGroupAddUser(lpwServer, lpwGroup, wzUser);
 		    if (lastError != 0)
@@ -1304,7 +1299,7 @@
 	    }
 	    break;
 	default:
-	    MultiByteToWideChar(CP_ACP, NULL, (char*)SvPV(sv,n_a),
+	    MultiByteToWideChar(CP_ACP, 0, (char*)SvPV(sv,n_a),
 				-1, wzUser, sizeof(wzUser));
 	    lastError = NetGroupAddUser(lpwServer, lpwGroup, wzUser);
 	    break;
@@ -1342,7 +1337,7 @@
 	    for (index = 0; index <= count; ++index) {
 		psv = av_fetch((AV*)sv, index, 0);
 		if (psv != NULL) {
-		    MultiByteToWideChar(CP_ACP, NULL, (char*)SvPV(*psv,n_a),
+		    MultiByteToWideChar(CP_ACP, 0, (char*)SvPV(*psv,n_a),
 					-1, wzUser, sizeof(wzUser));
 		    lastError = NetGroupDelUser(lpwServer, lpwGroup, wzUser);
 		    if (lastError != 0)
@@ -1351,7 +1346,7 @@
 	    }
 	    break;
 	default:
-	    MultiByteToWideChar(CP_ACP, NULL, (char*)SvPV(sv,n_a),
+	    MultiByteToWideChar(CP_ACP, 0, (char*)SvPV(sv,n_a),
 				-1, wzUser, sizeof(wzUser));
 	    lastError = NetGroupDelUser(lpwServer, lpwGroup, wzUser);
 	    break;
@@ -1389,7 +1384,7 @@
 					 &totalEntries, &resumeHandle);
 	    if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		break;
-	    for (index = 0; index < entriesRead; ++index)
+	    for (index = 0; index < (int)entriesRead; ++index)
 		if (lstrcmpiW(lpwUser, pwzGroupUsers[index].grui0_name) == 0) {
 		    bReturn = TRUE;
 		    break;
@@ -1405,7 +1400,7 @@
 	    // should check that entriesRead == totalEntries and redo if not
 	    // but 'this should not happen' if PREFLEN is sufficiently large...
 	    PGROUP_USERS_INFO_0 lpGroupInfo = pwzGroupUsers;
-	    for (index = 0; index < entriesRead; index++, lpGroupInfo++) {
+	    for (index = 0; index < (int)entriesRead; index++, lpGroupInfo++) {
 		if (lstrcmpiW(lpwGroup, lpGroupInfo->grui0_name) == 0) {
 		    bReturn = TRUE;
 		    break;
@@ -1429,9 +1424,9 @@
     char buffer[UNLEN+1];
     PGROUP_USERS_INFO_0 pwzGroupUsers;
     DWORD entriesRead, totalEntries;
-    size_t resumeHandle = 0;
+    DWORD resumeHandle = 0;
     int index;
-    SV *sv, *nSv;
+    SV *sv;
     DWORD lastError = 0;
 
     if (items != 3) {
@@ -1454,7 +1449,7 @@
 					     &resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzGroupUsers[index].grui0_name,
 			  buffer, sizeof(buffer));
 		    av_push((AV*)sv, newSVpv(buffer, 0));
@@ -1598,7 +1593,7 @@
 	    for (index = 0; index <= count; ++index) {
 		psv = av_fetch((AV*)sv, index, 0);
 		if (psv != NULL) {
-		    MultiByteToWideChar(CP_ACP, NULL, (char*)SvPV(*psv,n_a),
+		    MultiByteToWideChar(CP_ACP, 0, (char*)SvPV(*psv,n_a),
 					-1, wzUser, sizeof(wzUser));
 		    lastError = NetLocalGroupAddMembers(lpwServer, lpwGroup, 3,
 							(LPBYTE)&lgmi3MembersInfo, 1);
@@ -1608,7 +1603,7 @@
 	    }
 	    break;
 	default:
-	    MultiByteToWideChar(CP_ACP, NULL, (char*)SvPV(sv,n_a), -1,
+	    MultiByteToWideChar(CP_ACP, 0, (char*)SvPV(sv,n_a), -1,
 				wzUser, sizeof(wzUser));
 	    lastError = NetLocalGroupAddMembers(lpwServer, lpwGroup, 3,
 						(LPBYTE)&lgmi3MembersInfo, 1);
@@ -1649,7 +1644,7 @@
 	    for (index = 0; index <= count; ++index) {
 		psv = av_fetch((AV*)sv, index, 0);
 		if (psv != NULL) {
-		    MultiByteToWideChar(CP_ACP, NULL, (char*)SvPV(*psv,n_a),
+		    MultiByteToWideChar(CP_ACP, 0, (char*)SvPV(*psv,n_a),
 					-1, wzUser, sizeof(wzUser));
 		    lastError = NetLocalGroupDelMembers(lpwServer, lpwGroup, 3,
 							(LPBYTE)&lgmi3MembersInfo, 1);
@@ -1659,7 +1654,7 @@
 	    }
 	    break;
 	default:
-	    MultiByteToWideChar(CP_ACP, NULL, (char*)SvPV(sv,n_a), -1,
+	    MultiByteToWideChar(CP_ACP, 0, (char*)SvPV(sv,n_a), -1,
 				wzUser, sizeof(wzUser));
 	    lastError = NetLocalGroupDelMembers(lpwServer, lpwGroup, 3,
 						(LPBYTE)&lgmi3MembersInfo, 1);
@@ -1675,9 +1670,9 @@
 XS(XS_NT__NetAdmin_LocalGroupIsMember)
 {
     dXSARGS;
-    LPWSTR lpwServer, lpwGroup, lpwUser;
+    LPWSTR lpwServer, lpwGroup;
     DWORD entriesRead, totalEntries;
-    size_t resumeHandle = 0;
+    DWORD resumeHandle = 0;
     int index;
     BOOL bReturn = FALSE;
     DWORD lastError = 0;
@@ -1715,7 +1710,7 @@
 						&totalEntries, &resumeHandle);
 	    if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		break;
-	    for (index = 0; index < entriesRead; ++index)
+	    for (index = 0; index < (int)entriesRead; ++index)
 		if (EqualSid(pSid, pwzMembersInfo[index].lgrmi0_sid) != 0){
 		    bReturn = TRUE;
 		    break;
@@ -1742,7 +1737,7 @@
 		// should check that entriesRead == totalEntries and redo if not
 		// but 'this should not happen' if PREFLEN is sufficiently large
 		lpGroupInfo = pwzGroupUsers;
-		for (index = 0; index < entriesRead; index++, lpGroupInfo++) {
+		for (index = 0; index < (int)entriesRead; index++, lpGroupInfo++) {
 		    if (lstrcmpiW(lpwGroup, lpGroupInfo->lgrui0_name) == 0) {
 			bReturn = TRUE;
 			break;
@@ -1767,9 +1762,9 @@
     char buffer[UNLEN+1];
     PLOCALGROUP_MEMBERS_INFO_1 pwzMembersInfo;
     DWORD entriesRead, totalEntries;
-    size_t resumeHandle = 0;
+    DWORD resumeHandle = 0;
     int index;
-    SV *sv, *nSv;
+    SV *sv;
     DWORD lastError = 0;
 
     if (items != 3) {
@@ -1793,7 +1788,7 @@
 						    &resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzMembersInfo[index].lgrmi1_name, buffer,
 			  sizeof(buffer));
 		    av_push((AV*)sv, newSVpv(buffer, 0));
@@ -1821,9 +1816,9 @@
     char buffer1[UNLEN+1];
     PLOCALGROUP_MEMBERS_INFO_2 pwzMembersInfo;
     DWORD entriesRead, totalEntries;
-    size_t resumeHandle = 0;
+    DWORD resumeHandle = 0;
     int index;
-    SV *sv, *nSv;
+    SV *sv;
     DWORD lastError = 0;
 
     if (items != 3) {
@@ -1847,7 +1842,7 @@
 						    &resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzMembersInfo[index].lgrmi2_domainandname, buffer,
 			  sizeof(buffer));
 		    av_push((AV*)sv, newSVpv(buffer, 0));
@@ -1869,7 +1864,7 @@
 						    &resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzMembersInfo[index].lgrmi2_domainandname, buffer,
 			  sizeof(buffer));
 		    sprintf(buffer1, "%d", pwzMembersInfo[index].lgrmi2_sidusage );
@@ -1900,7 +1895,7 @@
     PSERVER_INFO_101 pwzServerInfo101;
     DWORD entriesRead, totalEntries, resumeHandle = 0;
     int index;
-    SV *sv, *nSv;
+    SV *sv;
     DWORD lastError = 0;
 
     if (items != 4) {
@@ -1925,7 +1920,7 @@
 					  lpwDomain, &resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzServerInfo[index].sv100_name, buffer,
 			  sizeof(buffer));
 		    av_push((AV*)sv, newSVpv(buffer, 0));
@@ -1947,7 +1942,7 @@
 					  lpwDomain, &resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzServerInfo101[index].sv101_name, buffer,
 			  sizeof(buffer));
 		    W2AHELPER(pwzServerInfo101[index].sv101_comment, buffer1,
@@ -1978,7 +1973,7 @@
     LPWSTR p;
     DWORD entriesRead, totalEntries, resumeHandle = 0;
     int index;
-    SV *sv, *nSv;
+    SV *sv;
     DWORD lastError = 0;
 
     if (items != 2) {
@@ -2002,7 +1997,7 @@
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
 		p = disks;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(p, buffer, sizeof(buffer));
 		    av_push((AV*)sv, newSVpv(buffer, strlen(buffer)));
 		    p += 3;
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/NetAdmin/mingw32.exc perl-libwin32-0.24/NetAdmin/mingw32.exc
--- libwin32-0.24-orig/NetAdmin/mingw32.exc	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/NetAdmin/mingw32.exc	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/NetAdmin/t/netadmin.t perl-libwin32-0.24/NetAdmin/t/netadmin.t
--- libwin32-0.24-orig/NetAdmin/t/netadmin.t	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/NetAdmin/t/netadmin.t	2004-12-01 23:55:58.000000000 +0000
@@ -1,6 +1,8 @@
 #test for Perl NetAdmin Module Extension.
 #Written by Douglas_Lankshear@ActiveWare.com
 
+use Win32;
+
 BEGIN{
 	if( Win32::IsWin95() ){
 		print"1..1\nok 1\n";
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/NetResource/NetResource.xs perl-libwin32-0.24/NetResource/NetResource.xs
--- libwin32-0.24-orig/NetResource/NetResource.xs	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/NetResource/NetResource.xs	2004-12-01 23:55:58.000000000 +0000
@@ -5,13 +5,11 @@
  * Heavily cleaned up and bugfixed by Gurusamy Sarathy <gsar@activestate.com>
  */
 
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-#include <malloc.h>
-#include <string.h>
+#include "../win32perl.h"
 
 #define UNICODE
 #define _UNICODE
+#define FORCE_UNICODE
 
 #undef LPTSTR        /* This is a band-aid to allow the NetShare* functions to use */
 #define LPTSTR LPWSTR    /* UNICODE strings while allowing the other functions to use
@@ -26,11 +24,6 @@
 #undef UNICODE
 #undef _UNICODE
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-/*#include "NTXSUB.h"*/
-
 static DWORD dwLastError = NO_ERROR;
 
 /*
@@ -317,7 +310,6 @@
     DWORD cEntries = 0xFFFFFFFF; /* enumerate all possible entries    */
     LPNETRESOURCEA lpnrLocal;     /* pointer to enumerated structures  */
     DWORD i;
-    HV*     phvNet;
     SV*        svNetRes;
     AV*	av;
 
@@ -428,7 +420,7 @@
         length = (strlen(name)+1)*2;
         lpPtr = (LPWSTR)safemalloc(length);
         if(lpPtr != NULL)
-            MultiByteToWideChar(CP_ACP, NULL, name, -1, lpPtr, length);
+            MultiByteToWideChar(CP_ACP, 0, name, -1, lpPtr, length);
     }
     return lpPtr;
 }
@@ -445,7 +437,7 @@
 int
 WCTMB(LPWSTR lpwStr, LPSTR lpStr, int size)
 {
-    return WideCharToMultiByte(CP_ACP, NULL, lpwStr, -1, lpStr, size, NULL, NULL);
+    return WideCharToMultiByte(CP_ACP, 0, lpwStr, -1, lpStr, size, NULL, NULL);
 }    
 
 
@@ -609,8 +601,6 @@
     PTSHARE_INFO    tshare
     DWORD parm_err = NO_INIT
     LPSTR servername
-PREINIT:
-    DWORD    parm;
 CODE:
     {
         SHARE_INFO_502     Share_502;
@@ -664,7 +654,7 @@
 	if (*device >= 'a' && *device <= 'z' && device[1] == ':')
 	    lpwDevice[0] = (WCHAR)(*device - 'a' + 'A');
 	else if (!strchr(device, '\\') && !strchr(device, '/'))
-	    lpwDevice = _wcsupr(lpwDevice);
+	    lpwDevice = (LPWSTR)_wcsupr(lpwDevice);
 
         dwLastError = NetShareCheck(lpwServer,lpwDevice,&type);
         FreeWideName( lpwServer );
@@ -706,7 +696,6 @@
     TSHARE_INFO    tRet;    
 CODE:
     {
-        BOOL bRet;
         PSHARE_INFO_502    pShareInfo;
         LPWSTR    lpwServer,lpwNetname;
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/NetResource/mingw32.exc perl-libwin32-0.24/NetResource/mingw32.exc
--- libwin32-0.24-orig/NetResource/mingw32.exc	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/NetResource/mingw32.exc	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/NetResource/t/netresource.t perl-libwin32-0.24/NetResource/t/netresource.t
--- libwin32-0.24-orig/NetResource/t/netresource.t	2002-07-09 00:50:34.000000000 +0000
+++ perl-libwin32-0.24/NetResource/t/netresource.t	2004-12-01 23:55:58.000000000 +0000
@@ -11,7 +11,7 @@
 
 use Win32::NetResource;
 #use Data::Dumper;
-#use Win32;
+use Win32;
 $debug = 2;
 
 sub deb {
@@ -20,16 +20,21 @@
     }
 }
 
-sub err {
-    my $err;
-    Win32::NetResource::GetError($err);
-    deb("|$err| => ", Win32::FormatMessage($err));
+sub err_ {
+    my $err_;
+    Win32::NetResource::GetError($err_);
+    deb("|$err_| => ", Win32::FormatMessage($err_));
 }
 
 print "1..7\n";
 
+my $tmp_dir = "c:\\perl_tmp_$$";
+mkdir $tmp_dir;
+
+sub END { rmdir $tmp_dir; }
+
 $ShareInfo = {
-		'path' => 'c:\\',
+		'path' => $tmp_dir,
 		'netname' => "myshare",
 		'remark' => "This mine, leave it alone",
 		'passwd' => "soundgarden",
@@ -55,13 +60,13 @@
 }
 print "ok 1\n";
 
-err();
+err_();
 
 #
 # Make a share of the current directory.
 
 $ShareInfo = {
-		'path' => "c:\\",
+		'path' => $tmp_dir,
 		'netname' => "PerlTempShare",
 		'remark' => "This mine, leave it alone",
 		'passwd' => "",
@@ -71,20 +76,21 @@
 		'type'  => 0,
 	     };
 
-
+# Try deleting it first, just in case.
+Win32::NetResource::NetShareDel("PerlTempShare");
 
 deb("Testing NetShareAdd");
 $parm = "";
 Win32::NetResource::NetShareAdd( $ShareInfo,$parm ) or print "not ";
 print "ok 2\n";
 
-err();
+err_();
 
 deb("testing NetShareGetInfo");
 $NewShare = {};
 Win32::NetResource::NetShareGetInfo("PerlTempShare", $NewShare) or print "not ";
 print "ok 3\n";
-err();
+err_();
 
 foreach (keys %$NewShare) {
     deb("# $_ => $NewShare->{ $_ }");
@@ -110,7 +116,7 @@
 
 Win32::NetResource::GetSharedResources($Aref,0,$host) or print "not ";
 print "ok 4\n";
-err();
+err_();
 
 deb("-----");
 foreach $href (@$Aref){
@@ -136,20 +142,22 @@
     $myRef->{'LocalName'} = $drive;
     #print STDERR "mapping to |$drive|\n", Dumper($myRef), "\n";
     Win32::NetResource::AddConnection($myRef,$passwd,$user,0);
-    err();
+    err_();
 
     Win32::NetResource::GetUNCName( $UNCName, $drive ) or print "not ";
     print "ok 5\n";
-    err();
+    err_();
     deb("uncname is $UNCName");
 
     Win32::NetResource::CancelConnection($drive,0,1) or print "not ";
     print "ok 6\n";
-    err();
+    err_();
 }
 else {
     print "ok $_ # skipped: share not found\n" for 5..6;
 }
 Win32::NetResource::NetShareDel("PerlTempShare") or print "not ";
 print "ok 7\n";
-err();
+err_();
+
+rmdir $tmp_dir;
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/NetResource/typemap perl-libwin32-0.24/NetResource/typemap
--- libwin32-0.24-orig/NetResource/typemap	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/NetResource/typemap	2004-12-01 23:55:58.000000000 +0000
@@ -1,4 +1,4 @@
-# $Header$ 
+# $Header: /cvsroot/libwin32-exp/libwin32-exp/NetResource/typemap,v 1.1.1.1 2003/01/28 18:59:35 caelum Exp $ 
 # basic C types
 WORD			T_IV
 LONG                    T_IV
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/ODBC/CMom.cpp perl-libwin32-0.24/ODBC/CMom.cpp
--- libwin32-0.24-orig/ODBC/CMom.cpp	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/ODBC/CMom.cpp	2004-12-01 23:55:58.000000000 +0000
@@ -20,34 +20,17 @@
    Use under GNU General Public License or Larry Wall's "Artistic License"
 */
 
-
-#define WIN32_LEAN_AND_MEAN
-#include <stdlib.h>
-#include <math.h>
-#include <windows.h>
-
-#include <stdio.h>
-
-#include <SQL.H>
-#include <SQLEXT.H>
-#include <ODBCINST.H>
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-#include "EXTERN.h"
-#include "perl.h"
-
 #define NO_XSLOCKS
-#include "XSub.h"
-#if defined(__cplusplus)
-}
-#endif
+#include "../win32perl.h"
+
+#include <sql.h>
+#include <sqlext.h>
+#include <odbcinst.h>
 
 #define	_CMOM_
-#include "odbc.h"	
-#include "cmom.hpp"
 
+#include "ODBC.h"
+#include "CMom.hpp"
 
 int	CMom::iTotalHistory = 0;
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/ODBC/CResults.cpp perl-libwin32-0.24/ODBC/CResults.cpp
--- libwin32-0.24-orig/ODBC/CResults.cpp	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/ODBC/CResults.cpp	2004-12-01 23:55:58.000000000 +0000
@@ -20,33 +20,16 @@
    Use under GNU General Public License or Larry Wall's "Artistic License"
 */
 
-
-#define WIN32_LEAN_AND_MEAN
-#include <stdlib.h>
-#include <math.h>
-#include <windows.h>
-
-#include <stdio.h>
-
-#include <SQL.H>
-#include <SQLEXT.H>
-#include <ODBCINST.H>
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-#include <EXTERN.h>
-#include "perl.h"
-
 #define NO_XSLOCKS
-#include "XSub.h"
-#if defined(__cplusplus)
-}
-#endif
+#include "../win32perl.h"
+
+#include <sql.h>
+#include <sqlext.h>
+#include <odbcinst.h>
 
 #include "ODBCbuild.h"
-#include "odbc.h"	
-#include "cresults.hpp"
+#include "ODBC.h"	
+#include "CResults.hpp"
 
 CResults::CResults(ODBC_TYPE *h){
 	char szBuff[100];
@@ -82,7 +65,8 @@
 			SWORD	dColType;
 
 			for(iTemp = 1; iTemp <= sNumOfCols; iTemp++){
-				if (SQLColAttributes(h->hstmt, iTemp, SQL_COLUMN_DISPLAY_SIZE, NULL, NULL, NULL, &dSize[iTemp]) == SQL_SUCCESS){
+				if (SQLColAttributes(h->hstmt, iTemp,
+				  SQL_COLUMN_DISPLAY_SIZE, NULL, 0, NULL, &dSize[iTemp]) == SQL_SUCCESS){
 						//	If we cant resolve the size define it as the MAX Buffer
 						//	size. Later we can change this if needed.
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/ODBC/CResults.hpp perl-libwin32-0.24/ODBC/CResults.hpp
--- libwin32-0.24-orig/ODBC/CResults.hpp	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/ODBC/CResults.hpp	2004-12-01 23:55:58.000000000 +0000
@@ -1,7 +1,9 @@
 #define	NULL_VALUE	""
 
-#ifndef _WIN64
+#ifndef SQLLEN
 #  define	SQLLEN	SDWORD
+#endif
+#ifndef SQLULEN
 #  define	SQLULEN	UDWORD
 #endif
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/ODBC/Constant.cpp perl-libwin32-0.24/ODBC/Constant.cpp
--- libwin32-0.24-orig/ODBC/Constant.cpp	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/ODBC/Constant.cpp	2004-12-01 23:55:58.000000000 +0000
@@ -20,30 +20,14 @@
    Use under GNU General Public License or Larry Wall's "Artistic License"
 */
 
-
-#define WIN32_LEAN_AND_MEAN
-#include <stdlib.h>
-#include <math.h>		// VC-5.0 brain melt
-#include <windows.h>
-
-#include <stdio.h>
-#include <SQL.H>
-#include <SQLEXT.H>
-#include <ODBCINST.H>
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-#include <EXTERN.h>
-#include "perl.h"
-
 #define NO_XSLOCKS
-#include "XSub.h"
-#if defined(__cplusplus)
-}
-#endif
+#include "../win32perl.h"
+
+#include <sql.h>
+#include <sqlext.h>
+#include <odbcinst.h>
 
-#include "constant.h"		   
+#include "Constant.h"		   
 
 // constant function for exporting NT definitions.
 long
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/ODBC/Icon2.ico perl-libwin32-0.24/ODBC/Icon2.ico
--- libwin32-0.24-orig/ODBC/Icon2.ico	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/ODBC/Icon2.ico	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-                (       @                                                                                                                                                                                                                               ww         ww{         w{                                                ;????=C           ` H G +PNu?<,?Q
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/ODBC/MANIFEST perl-libwin32-0.24/ODBC/MANIFEST
--- libwin32-0.24-orig/ODBC/MANIFEST	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/ODBC/MANIFEST	2004-12-01 23:55:58.000000000 +0000
@@ -5,7 +5,7 @@
 Constant.cpp
 Constant.h
 HISTORY.TXT
-Icon2.ico
+ODBC.ico
 MANIFEST
 Makefile.PL
 ODBC.h
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/ODBC/Makefile.PL perl-libwin32-0.24/ODBC/Makefile.PL
--- libwin32-0.24-orig/ODBC/Makefile.PL	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/ODBC/Makefile.PL	2004-12-01 23:55:58.000000000 +0000
@@ -1,11 +1,9 @@
 use ExtUtils::MakeMaker;
-use Config;
-$BORLAND = 1 if $Config{'cc'} =~ /^bcc32/i;
-my $incpath = $Config{incpath};
+
 WriteMakefile(
-    'INC'		=> ($BORLAND ? "-I$incpath\\mfc" : '-GX'),
     'OBJECT'		=> 'CMom$(OBJ_EXT) Constant$(OBJ_EXT) CResults$(OBJ_EXT) ODBC$(OBJ_EXT)',
     'NAME'		=> 'Win32::ODBC',
+    'PM'		=> { 'ODBC.pm' => '$(INST_LIBDIR)/ODBC.pm' },
     'VERSION_FROM'	=> 'ODBC.pm',
     'XS'	=> { 'ODBC.xs' => 'ODBC.cpp' },
     'dist'	=> { COMPRESS => 'gzip -9f', SUFFIX => 'gz' },
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/ODBC/ODBC.h perl-libwin32-0.24/ODBC/ODBC.h
--- libwin32-0.24-orig/ODBC/ODBC.h	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/ODBC/ODBC.h	2004-12-01 23:55:58.000000000 +0000
@@ -1,37 +1,27 @@
-
 #define	SYNTAX_ERROR	999
-#define CROAK(xxxx)													\
-				PUSHMARK(sp);										\
-				XPUSHs(sv_2mortal(newSVnv((double)SYNTAX_ERROR)));	\
-				XPUSHs(sv_2mortal(newSVpv(xxxx, strlen(xxxx))));	\
-				PUTBACK;											\
-				return;												\
-																				\
-																				\
-
-#define	DEBUG_DUMP(xxx);		\
-/*
-								{																	\
-								 char szBuff[512]; 													\
-								 sprintf(szBuff, "=== %s (Thread: %04i)\n", xxx, GetCurrentThreadId());	\
-								 DebugPrint(szBuff);												\
-								}
- */
 
-/*
+#define CROAK(xxxx) \
+	PUSHMARK(sp); \
+	XPUSHs(sv_2mortal(newSVnv((double)SYNTAX_ERROR))); \
+	XPUSHs(sv_2mortal(newSVpv(xxxx, strlen(xxxx)))); \
+	PUTBACK; \
+	return;
+
+#define	DEBUG_DUMP(xxx) \
+{ \
+	char szBuff[512]; \
+	sprintf(szBuff, "=== %s (Thread: %04i)\n", xxx, GetCurrentThreadId()); \
+	DebugPrint(szBuff); \
+}
+
+#define	DEFAULT_DEBUG_FILE		"c:\\temp\\perlodbc.out"
+
 #ifndef _DEBUG
-	//	Define the Debug Macros...
 	#define	DebugDumpError(h)	
 	#define	DebugConnection(szString, h)
 	#define	DebugDump(szString)
 	#define	DebugPrint(szString)
 #endif
-*/
-
-#define TMPBUFSZ 512
-
-#define SUCCESSRETURNED(x)	(x == ERROR_SUCCESS)
-#define REGRETURN(x) XSRETURN_IV(SUCCESSRETURNED(x))
 
 #define MAX_DATA_BUF_SIZE		0x7FFFFFFE	//	Largest value for a SDWORD ( -1 for a string terminating null)	
 #define	MAX_DATA_ASSUME_SIZE	0x20000000	//	Largest size a field can specify before we assume that it is not accurate
@@ -40,8 +30,8 @@
 
 
 #define	COMMAND_LENGTH			1024
-#define	DSN_LENGTH				1024
-#define	DS_DESCRIPTION_LENGTH	2048
+#define	DSN_LENGTH			1024
+#define	DS_DESCRIPTION_LENGTH		2048
 
 #define ODBC_BUFF_SIZE 			1024
 #define	SQL_STATE_SIZE			10
@@ -51,13 +41,11 @@
 
 #define	TABLE_COMMAND_STRING	"%s(\"%s\", \"%s\", \"%s\", \"%s\")"
 
-#define	DEFAULT_DEBUG_FILE		"c:\\temp\\perlodbc.out"
-#define	DEFAULT_STMT_CLOSE_TYPE	SQL_DROP
+#define	DEFAULT_STMT_CLOSE_TYPE		SQL_DROP
 
 	//	Define ODBCList as a Macro for backward compatiblility.
 #define	THREAD_MOM	( (CMom *) ::cMom->operator[](GetCurrentThreadId()))
 #define	ODBCLIST	( (ODBC_TYPE *) (THREAD_MOM)->operator[]((DWORD)0))
-						
 
 class CResults;
 
@@ -165,11 +153,7 @@
 char *MapCloseType(UWORD uCloseType);
 void CleanError(ODBC_ERROR *h);
 int	ColNameToNum(ODBC_TYPE *h, char *szName);
-#ifdef __BORLANDC__
-BOOL WINAPI DllEntryPoint(HINSTANCE  hinstDLL, DWORD fdwReason, LPVOID  lpvReserved);
-#else
 BOOL WINAPI DllMain(HINSTANCE  hinstDLL, DWORD fdwReason, LPVOID  lpvReserved);
-#endif
 // void ReturnError(ODBC_TYPE *h);
 void AddDebug(ODBC_TYPE *h);
 void RemoveDebug(ODBC_TYPE *h);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/ODBC/ODBC.ico perl-libwin32-0.24/ODBC/ODBC.ico
--- libwin32-0.24-orig/ODBC/ODBC.ico	1970-01-01 00:00:00.000000000 +0000
+++ perl-libwin32-0.24/ODBC/ODBC.ico	2004-12-01 23:55:58.000000000 +0000
@@ -0,0 +1 @@
+                (       @                                                                                                                                                                                                                               ww         ww{         w{                                                ;????=C           ` H G +PNu?<,?Q
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/ODBC/ODBC.xs perl-libwin32-0.24/ODBC/ODBC.xs
--- libwin32-0.24-orig/ODBC/ODBC.xs	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/ODBC/ODBC.xs	2004-12-01 23:55:58.000000000 +0000
@@ -23,38 +23,19 @@
 #define PERL_POLLUTE
 #define __WIN32_ODBC__
 
-#define WIN32_LEAN_AND_MEAN
-#include <stdlib.h>
-#include <math.h>   // VC-5.0 brainmelt
-#include <windows.h>
-#include <stdio.h>
+#include "../win32perl.h"
     
     //  ODBC Stuff
-#include <SQL.H>
-#include <SQLEXT.H>
-#include <ODBCINST.H>
-
-    //  Win32 Perl Stuff
-#if defined(__cplusplus)
-extern "C" {
-#endif
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSub.h"
-
-#include "../ppport.h"
-
-#if defined(__cplusplus)
-}   
-#endif
-
+#include <sql.h>
+#include <sqlext.h>
+#include <odbcinst.h>
 
     //  Win32::ODBC Stuff                       
-#include "ODBCBuild.h"
+#include "ODBCbuild.h"
 #include "CResults.hpp" 
 #include "CMom.hpp"
-#include "odbc.h"
-#include "constant.h"
+#include "ODBC.h"
+#include "Constant.h"
 
 #undef  __WIN32_ODBC__
 
@@ -91,7 +72,6 @@
     ODBC_TYPE *h = 0;
     int iResult = 0;
     CMom    *cmDaughter;
-    int iTemp;
 
 
 #ifdef _Debug
@@ -269,7 +249,7 @@
             AllocConsole();
             SetConsoleTitle("DEBUG: ODBC.PLL");
             ghDebug = GetStdHandle(STD_ERROR_HANDLE);
-#endif _DEBUG
+#endif /* _DEBUG */
         }
         h->iDebug = 1;
     }
@@ -608,7 +588,6 @@
 
     char      szDSN[DSN_LENGTH]; // string to hold datasource name
     ODBC_TYPE * h;
-    int         con_num; //connection #
     char        *szIn = 0;
     int         iTemp = 0;
 
@@ -669,7 +648,7 @@
                 char    szError[100];
 
                 while (iTemp > 1){
-                    uType= SvIV(ST(iTemp - 1));
+                    uType=(UWORD)SvIV(ST(iTemp - 1));
                     if (SvIOKp(ST(iTemp)) || SvNOKp(ST(iTemp))){
                         udValue = SvIV(ST(iTemp));
                     }else{
@@ -736,14 +715,11 @@
 {
     dXSARGS;
     ODBC_TYPE * h;
-    int        con_num; // Connection #
     RETCODE retcode;          //ODBC gunk
     UCHAR  buff2[ODBC_BUFF_SIZE];
     SDWORD bufflenout;
-    int lenn;
     UWORD  x;
     char * szSQL; 
-    int len;
     STRLEN n_a;
 
     if(items < 2){
@@ -803,7 +779,6 @@
 {
     dXSARGS;
     ODBC_TYPE * h;
-    int        con_num;
 
     RETCODE retcode;         // yet more ODBC garbage
     UWORD   uType = SQL_FETCH_NEXT;
@@ -811,8 +786,7 @@
     DWORD   dRowSetSize = 1;
 
     UWORD   *rgfRowStatus = 0;
-    SQLULEN  udCRow = 0;
-    int     iTemp;  
+    SQLULEN  udCRow = 0, iTemp;  
 
     if(items < 1 || items > 3){
         CROAK("usage: ($err,@col) = ODBC_Fetch($connection [, $Row [, $FetchType]])\n0die \"Oops: $col[0]\" if ($err);\n");
@@ -826,7 +800,7 @@
 //      uType = SQL_FETCH_RELATIVE;
     }
     if (items > 2){
-        uType = SvIV(ST(2));
+        uType = (UWORD)SvIV(ST(2));
     }
                      
     PUSHMARK(sp);
@@ -961,7 +935,7 @@
 RETCODE TableColList(pTHX_ int iType){
     dXSARGS;
     ODBC_TYPE * h;
-    int        con_num, iTemp;
+    int    iTemp;
     UCHAR  buff2[ODBC_BUFF_SIZE];
     SDWORD bufflenout;
     UWORD  x;
@@ -1383,7 +1357,6 @@
 {
     dXSARGS;
     ODBC_TYPE * h;
-    long    iSize;
     char    *szType;
 
     if(items != 1){
@@ -1420,7 +1393,7 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     CleanError(h->Error);
-    uType = SvIV(ST(1));
+    uType = (UWORD)SvIV(ST(1));
     PUSHMARK(sp);
 
     switch(uType){
@@ -1466,7 +1439,7 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     CleanError(h->Error);
-    uType= SvIV(ST(1));
+    uType=(UWORD)SvIV(ST(1));
     if (SvIOKp(ST(2)) || SvNOKp(ST(2))){
         udValue = SvIV(ST(2));
     }else{
@@ -1508,7 +1481,7 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     CleanError(h->Error);
-    uOption = SvIV(ST(1));
+    uOption = (UWORD)SvIV(ST(1));
     PUSHMARK(sp);
 
     if(!h->Error->ErrNum){
@@ -1557,7 +1530,6 @@
     DWORD   *dValue = (DWORD *)ucValue;
     UWORD   uOption;
     UDWORD  udValue;
-    UCHAR   uType;
     RETCODE rResult = 0;
     STRLEN  n_a;
 
@@ -1567,7 +1539,7 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     CleanError(h->Error);
-    uOption = SvIV(ST(1));
+    uOption = (UWORD)SvIV(ST(1));
     if (items > 2){
         if (SvIOKp(ST(2)) || SvNOKp(ST(2))){
             udValue = SvIV(ST(2));
@@ -1652,7 +1624,7 @@
         iTotal = 100;
         items = 1;
     }else{
-        uOption = SvIV(ST(1));
+        uOption = (UWORD)SvIV(ST(1));
     }
 
     while(items--){
@@ -1670,7 +1642,7 @@
         iTemp++;
         if (items){     //  If there are no more stack elements we will screw up
                         //  trying to access ST(1 + iTemp)
-            uOption = SvIV(ST(1 + iTemp));
+            uOption = (UWORD)SvIV(ST(1 + iTemp));
         }
     }
     if (!h->Error->ErrNum){
@@ -1704,7 +1676,7 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     CleanError(h->Error);
-    uType = SvIV(ST(1));
+    uType = (UWORD)SvIV(ST(1));
     PUSHMARK(sp);
 
     if(!h->Error->ErrNum){
@@ -1751,7 +1723,7 @@
     h = _NT_ODBC_Verify(SvIV(ST(iStack)));
     CleanError(h->Error);
     iStack++;
-    uType = SvIV(ST(iStack));
+    uType = (UWORD)SvIV(ST(iStack));
     iStack++;
     szDriver = SvPV(ST(iStack), n_a);
     if (strlen(szDriver) == 0){
@@ -1845,7 +1817,7 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     CleanError(h->Error);
-    uType = SvIV(ST(1));
+    uType = (UWORD)SvIV(ST(1));
     PUSHMARK(sp);
 
     if(!h->Error->ErrNum){
@@ -1869,8 +1841,9 @@
                 iSize = (int) swBytes + 1;
                 iFlag = 0;
                 CleanError(h->Error);
+		break;
             }
-        } while (iSize <= (int) swBytes);
+        }
     }
 
     if (!h->Error->ErrNum){
@@ -1926,7 +1899,6 @@
     ODBC_TYPE * h;
     UWORD   iCol = 0;
     UWORD   iType = 0;
-    int     iTemp;
     UCHAR   *szName = 0;
     UCHAR   szBuff[ODBC_BUFF_SIZE];
     SWORD   dBuffLen = 0;
@@ -1940,7 +1912,7 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     szName = (unsigned char *) SvPV(ST(1), n_a);
-    iType = SvIV(ST(2));
+    iType = (UWORD)SvIV(ST(2));
     
     PUSHMARK(sp);
    
@@ -1980,8 +1952,6 @@
     ODBC_TYPE * h;
     int iDebug = 0;
     char    *szFile = 0;
-    char    szBuff[286];
-    DWORD   dCount;
     STRLEN  n_a;
 
     if(items < 1 || items > 3){
@@ -2003,8 +1973,10 @@
             if (ghFile){
             
 #ifdef _Debug   
+		{ char szBuff[1000];
                 sprintf(szBuff, "Closing debug file \"%s\"", (gszFile)? gszFile:"none opened");
                 DebugConnection(szBuff, h);
+		}
 #endif
                 CloseHandle(ghFile);
                 ghFile = 0;
@@ -2028,6 +2000,7 @@
             
 #ifdef _Debug
             if(ghDebug){
+		char szBuff[1000];
                 sprintf(szBuff, "Debug mode set on by connection %i.\n", h->conn);
                 DebugConnection(szBuff, h);
             }
@@ -2036,10 +2009,11 @@
         }else{
         
 #ifdef _Debug
-            if (ghDebug){
+            if (ghDebug){{
+		char szBuff[1000];
                 sprintf(szBuff, "Debug mode set off by connection %i.\n", h->conn);
                 DebugConnection(szBuff, h);
-            }
+	    }}
 #endif
 
             RemoveDebug(h);
@@ -2075,12 +2049,12 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     CleanError(h->Error);
-    uRow    = SvIV(ST(1));
+    uRow    = (UWORD)SvIV(ST(1));
     if (items > 2){
-        uOption = SvIV(ST(2));
+        uOption = (UWORD)SvIV(ST(2));
     }
     if (items > 3){
-        uLock   = SvIV(ST(3));
+        uLock   = (UWORD)SvIV(ST(3));
     }
     PUSHMARK(sp);
 
@@ -2109,17 +2083,9 @@
 {
     dXSARGS;
     ODBC_TYPE * h;
-    RETCODE retcode;         // yet more ODBC garbage
-    UCHAR  buff2[ODBC_BUFF_SIZE];
     UCHAR   *szBuf = 0;
     SDWORD  iBuf = DEFAULTCOLSIZE;
-    SDWORD  bufflenout;
-    SWORD   sSQLType;
-    SWORD   sTemp;
-    int lenn, iTotalPushed, iTemp;
-    UWORD  x;
-    int len;
-    DWORD   dTemp;
+    int iTemp;
     
     if(items != 1){
         CROAK("usage: ($Err, $Type) = ODBC_GetData($Connection)\n");
@@ -2201,7 +2167,7 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     if (items > 1){
-        uCloseSpecified = SvIV(ST(1));  
+        uCloseSpecified = (UWORD)SvIV(ST(1));  
     }
     CleanError(h->Error);
     PUSHMARK(sp);
@@ -2462,7 +2428,7 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     CleanError(h->Error);
-    sType = SvIV(ST(1));
+    sType = (SWORD)SvIV(ST(1));
     PUSHMARK(sp);
 
     if(!h->Error->ErrNum){
@@ -2511,11 +2477,11 @@
 }
 
 void TerminateThread(){
-    char    szBuff[100];
     CMom    *cmDaughter;
 
     DEBUG_DUMP("TerminateThread(): Entering Critical Section gDCS")
 #ifdef _Debug
+    { char szBuff[1000];
     EnterCriticalSection(&gDCS);
     sprintf(szBuff, "Thread %05i (total threads: %03i) terminating.\n", GetCurrentThreadId(), giThread);
         //  Entered Debug CS so no other debug messages interrupt us...
@@ -2523,6 +2489,7 @@
     DebugPrint(szBuff);
         //  If this thread has a CMom then delete it!
     DebugPrint("\t--> Checking for a daughter on this thread...\n");
+    }
 #endif
 
     if (::cMom){
@@ -2564,6 +2531,12 @@
     ODBC_TYPE   *h = 0;
     int iRetCode = 1;
 
+#if defined(__CYGWIN__) || defined(__MINGW32__)
+//  Otherwise, this is done in DllMain
+    InitializeCriticalSection(&gDCS);
+    InitializeCriticalSection(&gCS);
+#endif
+
     if (! ::cMom){
         ::cMom = new CMom;
     }
@@ -2600,7 +2573,6 @@
 {
     dXSARGS;
     char* file = __FILE__;
-    int i;
     RETCODE iRetCode = 1;
 
 #ifdef _Debug
@@ -2666,15 +2638,11 @@
 
 }           
 
-#ifdef  WIN32
+#if !defined(__CYGWIN__) && !defined(__MINGW32__)
 
     /* ===============  DLL Specific  Functions  ===================  */
     BOOL WINAPI
-#  ifdef __BORLANDC__
-    DllEntryPoint
-#  else
     DllMain
-#  endif
     (HINSTANCE  hinstDLL, DWORD fdwReason, LPVOID  lpvReserved){
         BOOL    bResult = TRUE;
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/ODBC/ODBCTEST.ldb perl-libwin32-0.24/ODBC/ODBCTEST.ldb
--- libwin32-0.24-orig/ODBC/ODBCTEST.ldb	1970-01-01 00:00:00.000000000 +0000
+++ perl-libwin32-0.24/ODBC/ODBCTEST.ldb	2005-02-06 17:13:30.000000000 +0000
@@ -0,0 +1 @@
+REINI                           admin                           REINI                           admin                           REINI                           admin                           
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/ODBC/ODBCbuild.h perl-libwin32-0.24/ODBC/ODBCbuild.h
--- libwin32-0.24-orig/ODBC/ODBCbuild.h	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/ODBC/ODBCbuild.h	2004-12-01 23:55:58.000000000 +0000
@@ -27,6 +27,7 @@
 
 #define	VERNAME			"ODBC extension for Win32 Perl"
 #define VERSION_NUM		VERSION_HI
+#undef  VERSION
 #define	VERSION			VERSION_NUM " " VERSION_TYPE
 #define VERDATE			__DATE__
 #define VERTIME			__TIME__
@@ -35,7 +36,7 @@
 #define VERCOMMENT		"This version requires " PERLVER "."
 
 #define RC_COMMENTS		VERNAME "\r\n----\r\n" VERCOMMENT "\0"
-#define	RC_COMPANY		"Roth Consulting\r\nhttp://www.roth.net/\0"
+#define	RC_COMPANY		"Roth Consulting\r\nhttp:\057/www.roth.net/\0"
 #define	RC_FILEDESC		INTERNALNAME " (for " PERLVER ")\0"
 #define RC_FILEVER		VERSION "\0"
 #define	RC_INTNAME		INTERNALNAME " " DEBUGGING "\0"
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/ODBC/Odbc.rc perl-libwin32-0.24/ODBC/Odbc.rc
--- libwin32-0.24-orig/ODBC/Odbc.rc	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/ODBC/Odbc.rc	2004-12-01 23:55:58.000000000 +0000
@@ -1,9 +1,9 @@
 #include <windows.h>
-#include "ODBCBuild.h"
+#include "ODBCbuild.h"
 
 
 // Icon
-Win32ODBC               ICON    DISCARDABLE     "ODBC.ICO"
+Win32ODBC               ICON    DISCARDABLE     "ODBC.ico"
 
 
 // Version
@@ -29,7 +29,7 @@
         BLOCK "040904b0"
         BEGIN
             VALUE "Comments", 			RC_COMMENTS
-            VALUE "CompanyName", 		RC_COMPANY
+            VALUE "CompanyName",		RC_COMPANY
             VALUE "FileDescription", 	RC_FILEDESC 
             VALUE "FileVersion", 		RC_FILEVER
             VALUE "InternalName", 		RC_INTNAME
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/ODBC/Test.pl perl-libwin32-0.24/ODBC/Test.pl
--- libwin32-0.24-orig/ODBC/Test.pl	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/ODBC/Test.pl	2004-12-01 23:55:58.000000000 +0000
@@ -36,6 +36,7 @@
 #                           - If omitted then we use the default value.
 #####
 
+    use Win32;
     use Win32::ODBC;
 
 
@@ -49,8 +50,7 @@
 
     $DriverType = "Microsoft Access Driver (*.mdb)";
     $Desc = "Description=The Win32::ODBC Test DSN for Perl";
-    $Dir = `cd`;
-    chop $Dir;
+    $Dir = Win32::GetCwd();
     $DBase = "ODBCTest.mdb";
 
     $iWidth=60;
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/ODBC/mingw32.exc perl-libwin32-0.24/ODBC/mingw32.exc
--- libwin32-0.24-orig/ODBC/mingw32.exc	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/ODBC/mingw32.exc	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/OLE/MANIFEST perl-libwin32-0.24/OLE/MANIFEST
--- libwin32-0.24-orig/OLE/MANIFEST	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/OLE/MANIFEST	2004-12-01 23:55:58.000000000 +0000
@@ -5,7 +5,6 @@
 OLE.xs
 README
 ToDo
-hints/cygwin.pl
 lib/OLE.pm		Compatibility layer: old toplevel OLE.pm
 lib/Win32/OLE.pm
 lib/Win32/OLE/Const.pm	Win32::OLE::Const module: TypeLib constants
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/OLE/Makefile.PL perl-libwin32-0.24/OLE/Makefile.PL
--- libwin32-0.24-orig/OLE/Makefile.PL	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/OLE/Makefile.PL	2004-12-01 23:55:58.000000000 +0000
@@ -1,6 +1,8 @@
 use Config;
 use ExtUtils::MakeMaker qw(&WriteMakefile &neatvalue);
 
+my $ACTIVE_PERL = defined eval { Win32::BuildNumber() } ? 1 : 0;
+
 my @MM =
 (
  'NAME'	        => 'Win32::OLE',
@@ -66,6 +68,8 @@
 
 # Install typelib browser for ActivePerl help
 sub MY::post_constants {
+    return unless $ACTIVE_PERL;
+
     my @files = qw(Browser.dhtml Browser.html Class.png Const.png Default.png
                    Enum.png Event.png Function.png Global.png Help.png
                    Library.png Module.png Property.png Type.png);
@@ -82,6 +86,8 @@
 }
 
 sub MY::postamble {
+    return unless $ACTIVE_PERL;
+
     return q{
 all :: browser_to_blib
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/OLE/OLE.xs perl-libwin32-0.24/OLE/OLE.xs
--- libwin32-0.24-orig/OLE/OLE.xs	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/OLE/OLE.xs	2005-02-06 14:59:05.000000000 +0000
@@ -27,14 +27,17 @@
 
 // #define _DEBUG
 
-#define register /* be gone */
-
 #define MY_VERSION "Win32::OLE(" XS_VERSION ")"
 
-#include <math.h>	/* this hack gets around VC-5.0 brainmelt */
+#define register /* be gone */
 #define _WIN32_DCOM
-#include <windows.h>
+#define PERL_NO_GET_CONTEXT
+#define NO_XSLOCKS
+
+#include "../win32perl.h"
+
 #include <ocidl.h>
+#include <olectl.h>
 
 #ifdef _DEBUG
 #   include <crtdbg.h>
@@ -45,29 +48,6 @@
 
 extern "C" {
 
-#ifdef __CYGWIN__
-#   undef WIN32			/* don't use with Cygwin & Perl */
-#   include <netdb.h>
-#   include <sys/socket.h>
-#   include <unistd.h>
-#   define strrev _strrev
-    char *_strrev(char*);	/* from string.h (msvcrt40) */
-#endif
-
-#define PERL_NO_GET_CONTEXT
-#define NO_XSLOCKS
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-#include "patchlevel.h"
-
-#undef WORD
-typedef unsigned short WORD;
-
-#ifndef _WIN64
-#  define DWORD_PTR	DWORD
-#endif
-
 #if PERL_VERSION < 6
 #   error Win32::OLE requires Perl 5.6.0 or later
 #endif
@@ -174,7 +154,7 @@
                                 sizeof(MY_VERSION)-1, FALSE);          \
         if (!pinterp || !*pinterp || !SvIOK(*pinterp))		       \
             warn(MY_VERSION ": Per-interpreter data not initialized"); \
-        PERINTERP *pInterp = (PERINTERP*)SvIV(*pinterp)
+        PERINTERP *pInterp = (PERINTERP*)(DWORD)SvIV(*pinterp)
 #    define INTERP pInterp
 #else
 static PERINTERP Interp;
@@ -985,7 +965,7 @@
         DBG(("hv_fetch(%08x) returned %08x", punk, svp));
         punk->Release();
         if (svp)
-            return sv_2mortal(sv_bless(newRV((SV*)SvIV(*svp)), stash));
+            return sv_2mortal(sv_bless(newRV((SV*)(DWORD)SvIV(*svp)), stash));
     }
 
     if (!pDispatch) {
@@ -1026,7 +1006,7 @@
         pDispatch->QueryInterface(IID_IUnknown, (void**)&punk);
         /* use XIV as a weak reference */
         SV **svp = hv_store(g_hv_unique, (char*)&punk, sizeof(punk),
-                            newSViv((IV)pObj->self), 0);
+                            newSViv((IV)(DWORD)pObj->self), 0);
         DBG(("hv_store(%08x) returned %08x", punk, svp));
         punk->Release();
         pObj->flags |= OBJFLAG_UNIQUE;
@@ -1037,7 +1017,7 @@
     DBG(("CreatePerlObject=|%lx| Class=%s Tie=%s pDispatch=0x%x\n", pObj,
 	 HvNAME(stash), szTie, pDispatch));
 
-    hv_store(hvinner, PERL_OLE_ID, PERL_OLE_IDLEN, newSViv((IV)pObj), 0);
+    hv_store(hvinner, PERL_OLE_ID, PERL_OLE_IDLEN, newSViv((IV)(DWORD)pObj), 0);
     inner = sv_bless(newRV_noinc((SV*)hvinner), gv_stashpv(szTie, TRUE));
     sv_magic((SV*)pObj->self, inner, 'P', Nullch, 0);
     SvREFCNT_dec(inner);
@@ -1157,7 +1137,7 @@
 	    mg_get(*psv);
 
 	if (psv && SvIOK(*psv)) {
-	    WINOLEOBJECT *pObj = (WINOLEOBJECT*)SvIV(*psv);
+	    WINOLEOBJECT *pObj = (WINOLEOBJECT*)(DWORD)SvIV(*psv);
 
 	    DBG(("GetOleObject = |%lx|\n", pObj));
 	    if (pObj && pObj->header.lMagic == WINOLE_MAGIC)
@@ -1174,7 +1154,7 @@
 GetOleEnumObject(pTHX_ SV *sv, BOOL bDESTROY=FALSE)
 {
     if (sv_isobject(sv) && sv_derived_from(sv, szWINOLEENUM)) {
-	WINOLEENUMOBJECT *pEnumObj = (WINOLEENUMOBJECT*)SvIV(SvRV(sv));
+	WINOLEENUMOBJECT *pEnumObj = (WINOLEENUMOBJECT*)(DWORD)SvIV(SvRV(sv));
 
 	if (pEnumObj && pEnumObj->header.lMagic == WINOLEENUM_MAGIC)
 	    if (pEnumObj->pEnum || bDESTROY)
@@ -1189,7 +1169,7 @@
 GetOleVariantObject(pTHX_ SV *sv, BOOL bWarn=TRUE)
 {
     if (sv_isobject(sv) && sv_derived_from(sv, szWINOLEVARIANT)) {
-	WINOLEVARIANTOBJECT *pVarObj = (WINOLEVARIANTOBJECT*)SvIV(SvRV(sv));
+	WINOLEVARIANTOBJECT *pVarObj = (WINOLEVARIANTOBJECT*)(DWORD)SvIV(SvRV(sv));
 
 	if (pVarObj && pVarObj->header.lMagic == WINOLEVARIANT_MAGIC)
 	    return pVarObj;
@@ -1213,7 +1193,7 @@
 
     AddToObjectChain(aTHX_ (OBJECTHEADER*)pObj, WINOLETYPELIB_MAGIC);
 
-    return sv_bless(newRV_noinc(newSViv((IV)pObj)),
+    return sv_bless(newRV_noinc(newSViv((IV)(DWORD)pObj)),
 		    gv_stashpv(szWINOLETYPELIB, TRUE));
 }
 
@@ -1221,7 +1201,7 @@
 GetOleTypeLibObject(pTHX_ SV *sv)
 {
     if (sv_isobject(sv) && sv_derived_from(sv, szWINOLETYPELIB)) {
-	WINOLETYPELIBOBJECT *pObj = (WINOLETYPELIBOBJECT*)SvIV(SvRV(sv));
+	WINOLETYPELIBOBJECT *pObj = (WINOLETYPELIBOBJECT*)(DWORD)SvIV(SvRV(sv));
 
 	if (pObj && pObj->header.lMagic == WINOLETYPELIB_MAGIC)
 	    return pObj;
@@ -1242,7 +1222,7 @@
 
     AddToObjectChain(aTHX_ (OBJECTHEADER*)pObj, WINOLETYPEINFO_MAGIC);
 
-    return sv_bless(newRV_noinc(newSViv((IV)pObj)),
+    return sv_bless(newRV_noinc(newSViv((IV)(DWORD)pObj)),
 		    gv_stashpv(szWINOLETYPEINFO, TRUE));
 }
 
@@ -1250,7 +1230,7 @@
 GetOleTypeInfoObject(pTHX_ SV *sv)
 {
     if (sv_isobject(sv) && sv_derived_from(sv, szWINOLETYPEINFO)) {
-	WINOLETYPEINFOOBJECT *pObj = (WINOLETYPEINFOOBJECT*)SvIV(SvRV(sv));
+	WINOLETYPEINFOOBJECT *pObj = (WINOLETYPEINFOOBJECT*)(DWORD)SvIV(SvRV(sv));
 
 	if (pObj && pObj->header.lMagic == WINOLETYPEINFO_MAGIC)
 	    return pObj;
@@ -1409,7 +1389,7 @@
     UINT cp = QueryPkgVar(aTHX_ stash, CP_NAME, CP_LEN, cpDefault);
     int newenum = QueryPkgVar(aTHX_ stash, _NEWENUM_NAME, _NEWENUM_LEN);
 
-    while (pObj->PropIndex < pObj->cFuncs+pObj->cVars) {
+    while ((UINT)pObj->PropIndex < (UINT)(pObj->cFuncs+pObj->cVars)) {
 	ULONG index = pObj->PropIndex++;
 	/* Try all the INVOKE_PROPERTYGET functions first */
 	if (index < pObj->cFuncs) {
@@ -1756,7 +1736,7 @@
 	if ((iFlags & IMPLTYPEFLAG_FDEFAULT) &&
 	    (iFlags & IMPLTYPEFLAG_FSOURCE))
 	{
-	    HREFTYPE hRefType = NULL;
+	    HREFTYPE hRefType = 0;
 
 	    hr = pTypeInfo->GetRefTypeOfImplType(i, &hRefType);
 	    DBG(("GetRefTypeOfImplType: hr=0x%08x\n", hr));
@@ -2059,7 +2039,7 @@
 	XPUSHs(sv_2mortal(self));
 	if (pushname)
 	    XPUSHs(event);
-	for (int i=0; i < pdispparams->cArgs; ++i) {
+	for (UINT i=0; i < pdispparams->cArgs; ++i) {
 	    VARIANT *pVariant = &pdispparams->rgvarg[pdispparams->cArgs-i-1];
 	    DBG(("   Arg %d vt=0x%04x\n", i, V_VT(pVariant)));
 	    SV *sv = sv_newmortal();
@@ -2182,7 +2162,7 @@
     ENTER;
     SAVETMPS;
     PUSHMARK(sp);
-    for (int i=0; i < pdispparams->cArgs; ++i) {
+    for (UINT i=0; i < pdispparams->cArgs; ++i) {
 	VARIANT *pVariant = &pdispparams->rgvarg[pdispparams->cArgs-i-1];
 	DBG(("   Arg %d vt=0x%04x\n", i, V_VT(pVariant)));
 	SV *sv = sv_newmortal();
@@ -2270,7 +2250,7 @@
 
 	if (psv) {
 	    if (SvROK(*psv) && SvTYPE(SvRV(*psv)) == SVt_PVAV) {
-		if (++index >= cDims) {
+		if (++index >= (int)cDims) {
 		    warn(MY_VERSION ": SetSafeArrayFromAV unexpected failure");
 		    hr = E_UNEXPECTED;
 		    break;
@@ -2399,7 +2379,7 @@
 		plen[index] = av_len(pav[index])+1;
 
 		if (index < dim) {
-		    if (plen[index] > psab[index].cElements)
+		    if ((UINT)(plen[index]) > (UINT)(psab[index].cElements))
 			psab[index].cElements = plen[index];
 		}
 		else {
@@ -2475,11 +2455,11 @@
     VARTYPE vt = V_VT(pVariant);
     /* sv must NOT be Nullsv unless vt is VT_EMPTY, VT_NULL or VT_DISPATCH */
 
-#   define ASSIGN(vartype,perltype)                           \
-        if (vt & VT_BYREF) {                                  \
-            *V_##vartype##REF(pVariant) = Sv##perltype##(sv); \
-        } else {                                              \
-            V_##vartype(pVariant) = Sv##perltype##(sv);       \
+#   define ASSIGN(vartype,perltype,ctype)                           \
+        if (vt & VT_BYREF) {                                        \
+            *V_##vartype##REF(pVariant) = (ctype)Sv##perltype (sv); \
+        } else {                                                    \
+            V_##vartype(pVariant) = (ctype)Sv##perltype (sv);       \
         }
 
     /* XXX requirement to call mg_get() may change in Perl > 5.005 */
@@ -2509,7 +2489,7 @@
 	    SafeArrayGetLBound(psa, 1, &lLower);
 	    SafeArrayGetUBound(psa, 1, &lUpper);
 
-	    long lLength = 1 + lUpper-lLower;
+	    STRLEN lLength = 1 + lUpper-lLower;
 	    len = (len < lLength ? len : lLength);
 	    memcpy(pDest, pSrc, len);
 	    if (lLength > len)
@@ -2526,19 +2506,19 @@
 	break;
 
     case VT_I2:
-	ASSIGN(I2, IV);
+	ASSIGN(I2, IV, SHORT);
 	break;
 
     case VT_I4:
-	ASSIGN(I4, IV);
+	ASSIGN(I4, IV, UINT);
 	break;
 
     case VT_R4:
-	ASSIGN(R4, NV);
+	ASSIGN(R4, NV, FLOAT);
 	break;
 
     case VT_R8:
-	ASSIGN(R8, NV);
+	ASSIGN(R8, NV, DOUBLE);
 	break;
 
     case VT_CY:
@@ -2622,7 +2602,7 @@
 	break;
 
     case VT_ERROR:
-	ASSIGN(ERROR, IV);
+	ASSIGN(ERROR, IV, DWORD);
 	break;
 
     case VT_BOOL:
@@ -2689,7 +2669,7 @@
 
     case VT_UI1:
 	if (SvIOK(sv)) {
-	    ASSIGN(UI1, IV);
+	    ASSIGN(UI1, IV, BYTE);
 	}
 	else {
 	    char *ptr = SvPV_nolen(sv);
@@ -2719,9 +2699,9 @@
 
 #   define SET(perltype,vartype)                                 \
         if (vt & VT_BYREF) {                                     \
-            sv_set##perltype##(sv, *V_##vartype##REF(pVariant)); \
+            sv_set##perltype(sv, *V_##vartype##REF(pVariant)); \
         } else {                                                 \
-            sv_set##perltype##(sv, V_##vartype##(pVariant));     \
+            sv_set##perltype(sv, V_##vartype(pVariant));     \
         }
 
     sv_setsv(sv, &PL_sv_undef);
@@ -3182,7 +3162,7 @@
     if (SvOK(sv))
 	warn(MY_VERSION ": Per-interpreter data already set");
 
-    sv_setiv(sv, (IV)pInterp);
+    sv_setiv(sv, (IV)(DWORD)pInterp);
 #endif
 
     g_pObj = NULL;
@@ -3489,10 +3469,9 @@
 PPCODE:
 {
     char *buffer = "";
-    char *ptr;
     size_t length;
     unsigned int argErr;
-    int index, arrayIndex;
+    unsigned int index;
     I32 len;
     WINOLEOBJECT *pObj;
     EXCEPINFO excepinfo;
@@ -3532,7 +3511,7 @@
     if (SvROK(method) && (sv = SvRV(method)) &&	SvTYPE(sv) == SVt_PVAV &&
 	!SvOBJECT(sv) && av_len((AV*)sv) == 1)
     {
-	wFlags = SvIV(*av_fetch((AV*)sv, 0, FALSE));
+	wFlags = (USHORT)SvIV(*av_fetch((AV*)sv, 0, FALSE));
 	method = *av_fetch((AV*)sv, 1, FALSE);
     }
 
@@ -3552,7 +3531,7 @@
                 PUTBACK;
                 items = perl_call_method("All", G_ARRAY);
                 SPAGAIN;
-                for (index=0; index<items; ++index)
+                for (index=0; index<(UINT)items; ++index)
                     av_push(av, newSVsv(ST(index)));
                 sv_setsv(retval, sv_2mortal(newRV_noinc((SV*)av)));
 		XSRETURN_YES;
@@ -4025,8 +4004,6 @@
 	XSRETURN_EMPTY;
 
     IID iid;
-    ITypeInfo *pTypeInfo;
-    ITypeLib *pTypeLib;
 
     // XXX support GUIDs in addition to names too
     char *pszItf = SvPV_nolen(itf);
@@ -4199,7 +4176,7 @@
 		    if ((iFlags & IMPLTYPEFLAG_FDEFAULT) &&
 			(iFlags & IMPLTYPEFLAG_FSOURCE))
 		    {
-			HREFTYPE hRefType = NULL;
+			HREFTYPE hRefType = 0;
 			hr = pObj->pTypeInfo->GetRefTypeOfImplType(i, &hRefType);
 			DBG(("GetRefTypeOfImplType: hr=0x%08x\n", hr));
 			if (FAILED(hr))
@@ -4427,7 +4404,7 @@
     unsigned int argErr;
     STRLEN length;
     char *buffer;
-    int index;
+    UINT index;
     HRESULT hr;
     EXCEPINFO excepinfo;
     DISPID dispID = DISPID_VALUE;
@@ -4566,7 +4543,6 @@
     LCID lcid = SvIOK(locale) ? SvIV(locale) : lcidDefault;
     UINT cp = SvIOK(codepage) ? SvIV(codepage) : cpDefault;
     HV *stash = gv_stashpv(szWINOLE, TRUE);
-    unsigned int count;
 
     Initialize(aTHX_ stash);
     SetLastOleError(aTHX_ stash);
@@ -4578,7 +4554,7 @@
     if (CheckOleError(aTHX_ stash, hr))
 	XSRETURN_EMPTY;
 
-    hr = LoadRegTypeLib(clsid, major, minor, lcid, &pTypeLib);
+    hr = LoadRegTypeLib(clsid, (WORD)major, (WORD)minor, lcid, &pTypeLib);
     if (FAILED(hr) && SvPOK(typelib)) {
 	/* typelib not registerd, try to read from file "typelib" */
 	pszBuffer = SvPV_nolen(typelib);
@@ -4629,7 +4605,7 @@
 
     /* loop through all objects in type lib */
     count = pObj->pTypeLib->GetTypeInfoCount();
-    for (int index=0; index < count; ++index) {
+    for (UINT index=0; index < count; ++index) {
 	ITypeInfo *pTypeInfo;
 	TYPEATTR  *pTypeAttr;
 
@@ -4944,7 +4920,7 @@
 
     AddToObjectChain(aTHX_ (OBJECTHEADER*)pEnumObj, WINOLEENUM_MAGIC);
 
-    SV *sv = newSViv((IV)pEnumObj);
+    SV *sv = newSViv((IV)(DWORD)pEnumObj);
     ST(0) = sv_2mortal(sv_bless(newRV_noinc(sv), GetStash(aTHX_ self)));
     XSRETURN(1);
 }
@@ -5068,7 +5044,7 @@
 {
     HRESULT hr;
     WINOLEVARIANTOBJECT *pVarObj;
-    VARTYPE vt = items < 2 ? VT_EMPTY : SvIV(ST(1));
+    VARTYPE vt = items < 2 ? VT_EMPTY : (VARTYPE)SvIV(ST(1));
     SV *data = items < 3 ? Nullsv : ST(2);
 
     // XXX Initialize should be superfluous here
@@ -5111,7 +5087,7 @@
 	}
 
 	Newz(0, rgsabound, cDims, SAFEARRAYBOUND);
-	for (int iDim=0; iDim < cDims; ++iDim) {
+	for (UINT iDim=0; iDim < cDims; ++iDim) {
 	    SV *sv = ST(2+iDim);
 
 	    if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVAV) {
@@ -5178,7 +5154,7 @@
     AddToObjectChain(aTHX_ (OBJECTHEADER*)pVarObj, WINOLEVARIANT_MAGIC);
 
     HV *stash = GetStash(aTHX_ self);
-    SV *sv = newSViv((IV)pVarObj);
+    SV *sv = newSViv((IV)(DWORD)pVarObj);
     ST(0) = sv_2mortal(sv_bless(newRV_noinc(sv), stash));
     XSRETURN(1);
 }
@@ -5217,7 +5193,7 @@
     ST(0) = &PL_sv_undef;
     SetLastOleError(aTHX_ olestash);
     VariantInit(&variant);
-    hr = VariantChangeTypeEx(&variant, &pVarObj->variant, lcid, 0, type);
+    hr = VariantChangeTypeEx(&variant, &pVarObj->variant, lcid, 0, (VARTYPE)type);
     if (SUCCEEDED(hr)) {
 	ST(0) = sv_newmortal();
 	hr = SetSVFromVariantEx(aTHX_ &variant, ST(0), olestash);
@@ -5251,7 +5227,7 @@
     SetLastOleError(aTHX_ olestash);
     /* XXX: Does it work with VT_BYREF? */
     hr = VariantChangeTypeEx(&pVarObj->variant, &pVarObj->variant,
-			     lcid, 0, type);
+			     lcid, 0, (VARTYPE)type);
     CheckOleError(aTHX_ olestash, hr);
     if (FAILED(hr))
 	ST(0) = &PL_sv_undef;
@@ -5304,7 +5280,7 @@
 
 	long *rgIndices;
 	New(0, rgIndices, cDims, long);
-	for (int iDim=0; iDim < cDims; ++iDim)
+	for (UINT iDim=0; iDim < cDims; ++iDim)
             rgIndices[iDim] = SvIV(ST(1+iDim));
 
 	VARTYPE vt_base = V_VT(pSource) & VT_TYPEMASK;
@@ -5342,7 +5318,7 @@
     AddToObjectChain(aTHX_ (OBJECTHEADER*)pNewVar, WINOLEVARIANT_MAGIC);
 
     HV *stash = GetStash(aTHX_ self);
-    SV *sv = newSViv((IV)pNewVar);
+    SV *sv = newSViv((IV)(DWORD)pNewVar);
     ST(0) = sv_2mortal(sv_bless(newRV_noinc(sv), stash));
     XSRETURN(1);
 }
@@ -5554,7 +5530,7 @@
 	sign = 1;
     }
     while (u64) {
-	amount[len++] = u64%10 + '0';
+	amount[len++] = (char)(u64%10 + '0');
 	u64 /= 10;
     }
     if (len == sign)
@@ -5778,7 +5754,7 @@
 
     HRESULT hr = S_OK;
     UINT cDims = SafeArrayGetDim(psa);
-    for (int iDim=0; iDim < cDims; ++iDim) {
+    for (UINT iDim=0; iDim < cDims; ++iDim) {
 	long lLBound, lUBound;
 	hr = SafeArrayGetLBound(psa, 1+iDim, &lLBound);
 	if (FAILED(hr))
@@ -5871,7 +5847,7 @@
 
     long *rgIndices;
     New(0, rgIndices, cDims, long);
-    for (int iDim=0; iDim < cDims; ++iDim)
+    for (UINT iDim=0; iDim < cDims; ++iDim)
         rgIndices[iDim] = SvIV(ST(1+iDim));
 
     VARIANT variant, byref;
@@ -6090,7 +6066,7 @@
 	else {
 	    sv = sv_newmortal();
 	    SvUPGRADE(sv, SVt_PV);
-	    SvGROW(sv, len+1);
+	    SvGROW(sv, (UINT)len+1);
 	    SvCUR_set(sv, LCMapStringA(lcid, flags, string, length,
 				       SvPVX(sv), SvLEN(sv)));
 	    if (SvCUR(sv))
@@ -6131,7 +6107,7 @@
 	int len = GetLocaleInfoA(lcid, lctype, NULL, 0);
 	if (len > 0) {
 	    SvUPGRADE(sv, SVt_PV);
-	    SvGROW(sv, len);
+	    SvGROW(sv, (UINT)len);
 	    len = GetLocaleInfoA(lcid, lctype, SvPVX(sv), SvLEN(sv));
 	    if (len) {
 		SvCUR_set(sv, len-1);
@@ -6156,8 +6132,8 @@
 
     New(0, pCharType, len, unsigned short);
     if (GetStringTypeA(lcid, type, string, len, pCharType)) {
-	EXTEND(SP, len);
-	for (int i=0; i < len; ++i)
+	EXTEND(SP, (int)len);
+	for (STRLEN i=0; i < len; ++i)
 	    PUSHs(sv_2mortal(newSViv(pCharType[i])));
     }
     Safefree(pCharType);
@@ -6213,7 +6189,7 @@
 {
     DWORD_PTR dwResult;
 
-    SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0, NULL,
+    SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0, 0,
 		       SMTO_NORMAL, 5000, &dwResult);
     XSRETURN_EMPTY;
 }
@@ -6690,7 +6666,7 @@
 
     AddToObjectChain(aTHX_ (OBJECTHEADER*)pObj, WINOLETYPEINFO_MAGIC);
 
-    SV *sv = newSViv((IV)pObj);
+    SV *sv = newSViv((IV)(DWORD)pObj);
     ST(0) = sv_2mortal(sv_bless(newRV_noinc(sv), GetStash(aTHX_ self)));
     XSRETURN(1);
 }
@@ -6715,7 +6691,7 @@
 	XSRETURN_EMPTY;
 
     AV *av = newAV();
-    for (int i = 0; i < cNames; ++i) {
+    for (unsigned int i = 0; i < cNames; ++i) {
 	char szName[32];
 	// XXX use correct codepage ???
 	char *pszName = GetMultiByte(aTHX_ rgbstr[i],
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/OLE/hints/cygwin.pl perl-libwin32-0.24/OLE/hints/cygwin.pl
--- libwin32-0.24-orig/OLE/hints/cygwin.pl	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/OLE/hints/cygwin.pl	1970-01-01 00:00:00.000000000 +0000
@@ -1,8 +0,0 @@
-$self->{CC} = 'g++';
-$self->{LIBS} = ['-lole32 -loleaut32 -luuid -lmsvcrt40'];
-$self->{CCFLAGS} .= '-fvtable-thunks ' . $Config{ccflags};
-
-# NOTE: These two functions are used for a typelib browser
-#       that requires the ActiveState PerlScript wrapper.
-sub MY::post_constants {}
-sub MY::postamble {}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/OLE/t/3_ole.t perl-libwin32-0.24/OLE/t/3_ole.t
--- libwin32-0.24-orig/OLE/t/3_ole.t	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/OLE/t/3_ole.t	2004-12-01 23:55:58.000000000 +0000
@@ -41,6 +41,7 @@
 use Cwd;
 use FileHandle;
 use Sys::Hostname;
+use Win32;
 
 use Win32::OLE qw(CP_ACP CP_OEMCP HRESULT in valof with);
 use Win32::OLE::NLS qw(:DEFAULT :LANG :SUBLANG);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/PerfLib/Makefile.PL perl-libwin32-0.24/PerfLib/Makefile.PL
--- libwin32-0.24-orig/PerfLib/Makefile.PL	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/PerfLib/Makefile.PL	2004-12-01 23:55:58.000000000 +0000
@@ -5,9 +5,6 @@
     'NAME'		=> 'Win32::PerfLib',
     'VERSION_FROM'	=> 'PerfLib.pm', # finds $VERSION
     'dist'		=> {COMPRESS => 'gzip -9f', SUFFIX => 'gz'},
-    'LIBS'		=> [''],   # e.g., '-lm' 
-    'DEFINE'		=> '',     # e.g., '-DHAVE_SOMETHING' 
-    'INC'		=> '',     # e.g., '-I/usr/include/other'
     ($] < 5.005 ? () :
       (
 	'AUTHOR'	=> 'Jutta M. Klebe <jmk@bybyte.de>',
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/PerfLib/PerfLib.xs perl-libwin32-0.24/PerfLib/PerfLib.xs
--- libwin32-0.24-orig/PerfLib/PerfLib.xs	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/PerfLib/PerfLib.xs	2004-12-01 23:55:58.000000000 +0000
@@ -1,14 +1,7 @@
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
+#include "../win32perl.h"
 #include <winreg.h>
 #include <winperf.h>
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
-
 #if !defined(PERL_OBJECT)
 #  ifndef CPERLarg_
 #    define CPERLarg_
@@ -536,7 +529,7 @@
 int WCTMB(LPWSTR lpwStr, LPSTR lpStr, int size)
 {
     *lpStr = '\0';
-    return WideCharToMultiByte(CP_ACP,NULL,lpwStr,-1,lpStr,size,NULL,NULL);
+    return WideCharToMultiByte(CP_ACP,0,lpwStr,-1,lpStr,size,NULL,NULL);
 }
 
 
@@ -587,8 +580,6 @@
 		PPERF_INSTANCE_DEFINITION PerfInst)
 {
     PPERF_COUNTER_DEFINITION PerfCntr, CurCntr;
-    PPERF_COUNTER_BLOCK PtrToCntr;
-    PPERF_COUNTER_BLOCK PerfCntrBlk;
     BYTE *lpCounterData;
     LARGE_INTEGER *lpLargeInt;
     DWORD *lpDWord;
@@ -824,10 +815,8 @@
 	char akey[256] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009";
 	WCHAR wkey[256] = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009";
 	BYTE *nameArray;
-	BYTE *p;
 	DWORD value_len;
 	DWORD type;
-	DWORD value;
 
 	if (USING_WIDE()) {
 	    WCHAR wmachine[MAX_PATH+1];
@@ -917,7 +906,7 @@
 	RETVAL
 	counter		if (RETVAL) { SETPVN(1, nameArray, value_len); } Safefree(nameArray);
 
-bool
+DWORD
 PerfLibGetHelp(machine,help)
 	char *machine
 	SV *help
@@ -927,10 +916,8 @@
 	char akey[256] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009";
 	WCHAR wkey[256] = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009";
 	BYTE *helpArray;
-	BYTE *p;
 	DWORD value_len;
 	DWORD type;
-	DWORD value;
 
 	if (USING_WIDE()) {
 	    WCHAR wmachine[MAX_PATH+1];
@@ -1037,21 +1024,14 @@
 	PPERF_OBJECT_TYPE PerfObj;
 	PPERF_INSTANCE_DEFINITION PerfInst;
 	PPERF_COUNTER_DEFINITION PerfCntr, CurCntr;
-	PPERF_COUNTER_BLOCK PtrToCntr;
-	PPERF_COUNTER_BLOCK PerfCntrBlk;
 	BYTE *lpCounterData;
-	LARGE_INTEGER *lpLargeInt;
-	DWORD *lpDWord;
-	DWORD i,k,j,size,type,subtype, display, calc_mod, time_base;
+	DWORD i,j,type;
 	char buffer[TEMPBUFSZ];
-	HV *hvCounter;
 	HV *hvInstance;
 	HV *hvObject;
 	HV *hvCounterNum;
 	HV *hvInstanceNum;
 	HV *hvObjectNum;
-	struct tm t;
-	time_t stime;
 	FILETIME ft;
 	LARGE_INTEGER lft;
 	DWORD PerfLib_debug = 0;
@@ -1099,16 +1079,14 @@
 	lft.u.LowPart = (DWORD)ft.dwLowDateTime;
 	lft.u.HighPart = (LONG)ft.dwHighDateTime;
 	sprintf(buffer, "%I64d", lft.QuadPart);
-#//	hv_store((HV*)data, "SystemTime", strlen("SystemTime"),
-#//		 newSVpv(buffer, strlen(buffer)), 0);
 	hv_store((HV*)data, "SystemTime", strlen("SystemTime"),
-		 newSVnv(lft.QuadPart), 0);
+		 newSVnv((NV)lft.QuadPart), 0);
 	hv_store((HV*)data, "PerfTime", strlen("PerfTime"),
-		 newSVnv(PerfData->PerfTime.QuadPart),0);
+		 newSVnv((NV)PerfData->PerfTime.QuadPart),0);
 	hv_store((HV*)data, "PerfFreq", strlen("PerfFreq"),
-		 newSVnv(PerfData->PerfFreq.QuadPart),0);
+		 newSVnv((NV)PerfData->PerfFreq.QuadPart),0);
 	hv_store((HV*)data, "PerfTime100nSec", strlen("PerfTime100nSec"),
-		 newSVnv(PerfData->PerfTime100nSec.QuadPart),0);
+		 newSVnv((NV)PerfData->PerfTime100nSec.QuadPart),0);
 	WCTMB((LPWSTR)((PBYTE)PerfData + PerfData->SystemNameOffset), buffer,
 	      PerfData->SystemNameLength);
 	hv_store((HV*)data, "SystemName", strlen("SystemName"),
@@ -1145,7 +1123,7 @@
 	    if (PerfObj->NumInstances > 0 )
 	    {
 		hvInstanceNum = newHV();
-		for (j=1;j<=PerfObj->NumInstances;j++)
+		for (j=1;j<=(DWORD)(PerfObj->NumInstances);j++)
 		{
 		    if (PerfLib_debug)
 			printf("Instance %S\n",
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/PerfLib/mingw32.exc perl-libwin32-0.24/PerfLib/mingw32.exc
--- libwin32-0.24-orig/PerfLib/mingw32.exc	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/PerfLib/mingw32.exc	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/PerfLib/typemap perl-libwin32-0.24/PerfLib/typemap
--- libwin32-0.24-orig/PerfLib/typemap	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/PerfLib/typemap	2004-12-01 23:55:58.000000000 +0000
@@ -7,3 +7,13 @@
 PPERF_INSTANCE_DEFINITION	T_PTROBJ
 PPERF_COUNTER_DEFINITION	T_PTROBJ
 PPERF_COUNTER_BLOCK		T_PTROBJ
+
+INPUT
+
+T_IV
+	$var = ($type)(DWORD)SvIV($arg)
+
+OUTPUT
+
+T_IV
+	sv_setiv($arg, (IV)(DWORD)$var);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Pipe/Cpipe.cpp perl-libwin32-0.24/Pipe/Cpipe.cpp
--- libwin32-0.24-orig/Pipe/Cpipe.cpp	2002-07-09 00:15:52.000000000 +0000
+++ perl-libwin32-0.24/Pipe/Cpipe.cpp	2004-12-01 23:55:58.000000000 +0000
@@ -1,25 +1,6 @@
-
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-
-#if defined(__cplusplus)
-#include <stdlib.h>
-#include <math.h>
-extern "C" {
-#endif
-
-#include <EXTERN.h>
-#include "perl.h"
-#include "XSub.h"
-
-#if defined(__cplusplus)
-}
-#endif
-
-#include "../ppport.h"
-
-#include "CPipe.hpp"
-#include "pipe.h"
+#include "../win32perl.h"
+#include "Cpipe.hpp"
+#include "Pipe.h"
 
 CPipe::CPipe(char *szName, DWORD dWait){
 	int	iTemp;
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Pipe/Makefile.PL perl-libwin32-0.24/Pipe/Makefile.PL
--- libwin32-0.24-orig/Pipe/Makefile.PL	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Pipe/Makefile.PL	2004-12-01 23:55:58.000000000 +0000
@@ -1,10 +1,10 @@
 use ExtUtils::MakeMaker;
 use Config;
-$BORLAND = 1 if $Config{'cc'} =~ /^bcc32/i;
+
 WriteMakefile(
-    'INC'		=> ($BORLAND ? '' : '-GX'),
     'OBJECT'		=> 'Cpipe$(OBJ_EXT) Pipe$(OBJ_EXT)',
     'NAME'		=> 'Win32::Pipe',
+    'PM'		=> { 'Pipe.pm' => '$(INST_LIBDIR)/Pipe.pm' },
     'VERSION_FROM'	=> 'Pipe.pm',
     'XS'		=> { 'Pipe.xs' => 'Pipe.cpp' },
     'dist'		=> { COMPRESS => 'gzip -9f', SUFFIX => 'gz' },
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Pipe/Pipe.xs perl-libwin32-0.24/Pipe/Pipe.xs
--- libwin32-0.24-orig/Pipe/Pipe.xs	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Pipe/Pipe.xs	2004-12-01 23:55:58.000000000 +0000
@@ -20,30 +20,9 @@
    Use under GNU General Public License or Larry Wall's "Artistic License"
 */
 
-#define WIN32_LEAN_AND_MEAN
-#include <stdlib.h>
-#include <math.h>
-#include <windows.h>
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-
-#include <EXTERN.h>
-#include "perl.h"
-#include "XSub.h"
-#include "patchlevel.h"
-
-#if (PATCHLEVEL < 5) && !defined(PL_sv_undef)
-# define PL_sv_undef sv_undef
-#endif
-
-#if defined(__cplusplus)
-}
-#endif
-
-#include "cpipe.hpp"
-#include "pipe.h"
+#include "../win32perl.h"
+#include "Cpipe.hpp"
+#include "Pipe.h"
 
 char gszError[ERROR_TEXT_SIZE];
 int	giError = 0;
@@ -193,7 +172,7 @@
 	if(items != 1){
 		CROAK("usage: Close($PipeHandle);\n");
 	}
-	Pipe = (class CPipe *)SvIV(ST(0));
+	Pipe = (class CPipe *)(DWORD)SvIV(ST(0));
 
 	PUSHMARK(sp);
 	
@@ -216,7 +195,7 @@
 	if(items != 2){
 		CROAK("usage: Write($PipeHandle, $Data);\n");
 	}
-	Pipe = (class CPipe *)SvIV(ST(0));
+	Pipe = (class CPipe *)(DWORD)SvIV(ST(0));
 	vpData = (void *)SvPV(ST(1), dDataLen);
 
 	PUSHMARK(sp);
@@ -240,7 +219,7 @@
 	if(items != 1){
 		CROAK("usage: Read($PipeHandle);\n");
 	}
-	Pipe = (class CPipe *)SvIV(ST(0));
+	Pipe = (class CPipe *)(DWORD)SvIV(ST(0));
 
 	PUSHMARK(sp);
 	
@@ -275,7 +254,7 @@
 	if(items != 1){
 		CROAK("usage: Connect($PipeHandle);\n");
 	}
-	Pipe = (class CPipe *)SvIV(ST(0));
+	Pipe = (class CPipe *)(DWORD)SvIV(ST(0));
 
 	PUSHMARK(sp);
 	
@@ -297,7 +276,7 @@
 	if(items > 0 && items < 3){
 		CROAK("usage: Disconnect($PipeHandle [, $iPurge]);\n");
 	}
-	Pipe = (class CPipe *)SvIV(ST(0));
+	Pipe = (class CPipe *)(DWORD)SvIV(ST(0));
 	if (items == 2){
 		iPurge = (int) SvIV(ST(1));
 	}
@@ -322,7 +301,7 @@
 	if(items != 2){
 		CROAK("usage: ResizeBuffer($PipeHandle, $Size);\n");
 	}
-	Pipe = (class CPipe *)SvIV(ST(0));
+	Pipe = (class CPipe *)(DWORD)SvIV(ST(0));
 	dSize = (DWORD)SvIV(ST(1));
 
 	PUSHMARK(sp);
@@ -344,7 +323,7 @@
 	if(items != 1){
 		CROAK("usage: BufferSize($PipeHandle);\n");
 	}
-	Pipe = (class CPipe *)SvIV(ST(0));
+	Pipe = (class CPipe *)(DWORD)SvIV(ST(0));
 
 	PUSHMARK(sp);
 	
@@ -369,7 +348,7 @@
 		CROAK("usage: Error([$PipeHandle]);\n");
 	}
 	if (items == 1){
-		Pipe = (class CPipe *)SvIV(ST(0));
+		Pipe = (class CPipe *)(DWORD)SvIV(ST(0));
 	}
 
 	PUSHMARK(sp);
@@ -417,7 +396,6 @@
 {
 	dXSARGS;
 	char* file = __FILE__;
-	int i;
 
 	giError = 0;
 	memset((void *)gszError, 0, ERROR_TEXT_SIZE);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Pipe/mingw32.exc perl-libwin32-0.24/Pipe/mingw32.exc
--- libwin32-0.24-orig/Pipe/mingw32.exc	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Pipe/mingw32.exc	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Process/Changes perl-libwin32-0.24/Process/Changes
--- libwin32-0.24-orig/Process/Changes	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Process/Changes	2005-02-06 17:51:35.000000000 +0000
@@ -1,5 +1,8 @@
 Revision history for Perl extension Win32::Process.
 
+0.10  Sun Feb 6 18:50:44 2005
+	- add GetCurrentProcessID() for cygwin (by Reini Urban <rurban@x-ray.at>)
+
 0.09  Fri Aug 17 16:11:58 2001
 	- allow opening an existing pid, like OpenProcess() (thanks to
 	  Blair Zajac <blair@orcaware.com>)
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Process/Makefile.PL perl-libwin32-0.24/Process/Makefile.PL
--- libwin32-0.24-orig/Process/Makefile.PL	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Process/Makefile.PL	2004-12-01 23:55:58.000000000 +0000
@@ -1,9 +1,10 @@
 use ExtUtils::MakeMaker;
 use Config;
-$BORLAND = 1 if $Config{'cc'} =~ /^bcc32/i;
+
+$WINNT = $^O ne 'cygwin' ? Win32::IsWinNT() : (`uname -a`)[0] =~ /CYGWIN_NT/i;
+
 WriteMakefile(
-    'INC'		=> ($BORLAND ? '' : '-GX'),
-    'DEFINE'		=> (Win32::IsWinNT() ? '' : '-DSTRICTLY_WINDOWS95'),
+    'DEFINE'		=> ($WINNT   ? '' : '-DSTRICTLY_WINDOWS95'),
     'NAME'		=> 'Win32::Process',
     'VERSION_FROM'	=> 'Process.pm',
     'XS'		=> { 'Process.xs' => 'Process.cpp' },
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Process/Process.hpp perl-libwin32-0.24/Process/Process.hpp
--- libwin32-0.24-orig/Process/Process.hpp	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Process/Process.hpp	2004-12-01 23:55:58.000000000 +0000
@@ -1,13 +1,8 @@
 /*
     cProcess class definition for the Win32::Process module extension
 */
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
 
-#ifndef _WIN64
-#  define DWORD_PTR	DWORD
-#  define PDWORD_PTR	DWORD*
-#endif
+#include "../win32perl.h"
 
 typedef BOOL (*LPSetProcessAffinityMask)(HANDLE, DWORD);
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Process/Process.pm perl-libwin32-0.24/Process/Process.pm
--- libwin32-0.24-orig/Process/Process.pm	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Process/Process.pm	2005-02-06 17:46:22.000000000 +0000
@@ -4,7 +4,7 @@
 require DynaLoader;
 @ISA = qw(Exporter DynaLoader);
 
-$VERSION = '0.09';
+$VERSION = '0.10';
 
 # Items to export into callers namespace by default. Note: do not export
 # names by default without a very good reason. Use EXPORT_OK instead.
@@ -159,6 +159,13 @@
 
 Returns the Process ID.
 
+=item Win32::Process::GetCurrentProcessID()
+
+Returns the current process ID, which is the same as $$. But not on cygwin, 
+where $$ is the cygwin-internal PID and not the windows PID.
+On cygwin GetCurrentProcessID() returns the windows PID as needed for all 
+the Win32::Process functions.
+
 =back
 
 =head1 EXPORTS
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Process/Process.xs perl-libwin32-0.24/Process/Process.xs
--- libwin32-0.24-orig/Process/Process.xs	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Process/Process.xs	2005-02-06 17:42:35.000000000 +0000
@@ -1,27 +1,17 @@
-#include <stdlib.h>		// avoid BCC-5.0 brainmelt
-#include <math.h>		// avoid VC-5.0 brainmelt
+#include "../win32perl.h"
 #include "Process.hpp"
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
 
 #if defined(__cplusplus)
-#include <stdlib.h>
 extern "C" {
 #endif
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.H"
-
-#include "../ppport.h"
-
 static BOOL
 Create(cProcess* &cP, char* szAppName, char* szCommLine, DWORD Inherit,
        DWORD CreateFlags, char* szCurrDir)
 {
     BOOL bRetVal;
     void *env = NULL;
-#if PERL_VERSION > 5
+#if PERL_VERSION > 5 && defined(get_childenv)
     env = PerlEnv_get_childenv();
 #endif
     cP = NULL;
@@ -33,7 +23,7 @@
     catch (...) {
         bRetVal = FALSE;
     }
-#if PERL_VERSION > 5
+#if PERL_VERSION > 5 && defined(get_childenv)
     PerlEnv_free_childenv(env);
 #endif
     return bRetVal;
@@ -455,3 +445,11 @@
     }
 OUTPUT:
     RETVAL
+
+DWORD
+GetCurrentProcessID()
+CODE:
+    RETVAL = GetCurrentProcessId();
+OUTPUT:
+    RETVAL
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Process/mingw32.exc perl-libwin32-0.24/Process/mingw32.exc
--- libwin32-0.24-orig/Process/mingw32.exc	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Process/mingw32.exc	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Process/test.pl perl-libwin32-0.24/Process/test.pl
--- libwin32-0.24-orig/Process/test.pl	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Process/test.pl	2005-02-06 17:43:26.000000000 +0000
@@ -30,7 +30,8 @@
 # of the test code):
 
 my $p;
-if (Win32::Process::Open($p, $$, 0)) {
+my $pid = $^O eq 'cygwin' ? Win32::Process::GetCurrentProcessID() : $$;
+if (Win32::Process::Open($p, $pid, 0)) {
   ok(1);
   ok($p->SetPriorityClass(HIGH_PRIORITY_CLASS))
 } else {
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Process/typemap perl-libwin32-0.24/Process/typemap
--- libwin32-0.24-orig/Process/typemap	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Process/typemap	2004-12-01 23:55:58.000000000 +0000
@@ -12,7 +12,7 @@
 T_PTROBJ
 	if (sv_derived_from($arg, \"${Package}\")) {
 	    IV tmp = SvIV((SV*)SvRV($arg));
-	    $var = ($type) tmp;
+	    $var = ($type)(DWORD) tmp;
 	}
 	else
 	    croak(\"$var is not of type ${Package}\")
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Registry/Registry.xs perl-libwin32-0.24/Registry/Registry.xs
--- libwin32-0.24-orig/Registry/Registry.xs	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Registry/Registry.xs	2004-12-01 23:55:58.000000000 +0000
@@ -1,20 +1,7 @@
-/*
- * This file was generated automatically by xsubpp version 1.9 from the 
- * contents of registry.xs. This file has been edited. Don't attempt to rebuild this
- * file with the XS file.
- *
- *    			 
- *
- */
-
 /* XS interface to the Windows NT Registry
  * Written by Jesse Dougherty for Hip Communications 
  */
-#define  WIN32_LEAN_AND_MEAN
-#include <windows.h>
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
+#include "../win32perl.h"
 
 /* Section for the constant definitions. */
 #define MAX_LENGTH 2048
@@ -469,7 +456,7 @@
 RegCreateKeyEx(hkey,subkey,res,kclass,options,sam,security,ohandle,disposition)
 	HKEY hkey
 	char *subkey
-	SV *res = NO_INIT
+	SV *res
 	char *kclass
 	DWORD options
 	REGSAM sam
@@ -524,7 +511,7 @@
 RegEnumKey(hkey,idx,subkey)
 	HKEY hkey
 	DWORD idx
-	char *subkey = NO_INIT
+	char *subkey
     CODE:
 	char keybuffer[TMPBUFSZ];
 	LONG result = RegEnumKey(hkey, idx, keybuffer, sizeof(keybuffer));
@@ -539,9 +526,9 @@
 RegEnumKeyEx(hkey,idx,subkey,classname,lastwritetime)
 	HKEY hkey
 	DWORD idx
-	char *subkey = NO_INIT
-	char *classname = NO_INIT
-	FILETIME lastwritetime = NO_INIT
+	char *subkey
+	char *classname
+	IV lastwritetime
     CODE:
 	char keybuffer[TMPBUFSZ];
 	DWORD keybuffersz = TMPBUFSZ;
@@ -563,10 +550,10 @@
 RegEnumValue(hkey,idx,name,reserved,type,value)
 	HKEY hkey
 	DWORD idx
-	char *name = NO_INIT
-	DWORD reserved = NO_INIT
+	char *name
+	DWORD reserved
 	DWORD type = NO_INIT
-	char *value = NO_INIT
+	char *value
     CODE:
 	static HKEY last_hkey;
 	char  myvalbuf[MAX_LENGTH];
@@ -669,7 +656,7 @@
 RegGetKeySecurity(hkey,sec_info,sec_desc)
 	HKEY hkey
 	DWORD sec_info
-	char *sec_desc = NO_INIT
+	char *sec_desc
     CODE:
 	SECURITY_DESCRIPTOR sd;
 	DWORD sdsz;
@@ -733,7 +720,7 @@
 RegOpenKeyEx(hkey,subkey,res,sam,ohandle)
 	HKEY hkey
 	char *subkey
-	SV *res = NO_INIT
+	SV *res
 	REGSAM sam
 	HKEY ohandle = NO_INIT
     CODE:
@@ -748,9 +735,9 @@
 bool
 RegQueryInfoKey(hkey,kclass,classsz,reserved,numsubkeys,maxsubkeylen,maxclasslen,numvalues,maxvalnamelen,maxvaldatalen,secdesclen,lastwritetime)
 	HKEY hkey
-	char *kclass = NO_INIT
+	char *kclass
 	DWORD classsz = NO_INIT
-	DWORD reserved = NO_INIT
+	DWORD reserved
 	DWORD numsubkeys = NO_INIT
 	DWORD maxsubkeylen = NO_INIT
 	DWORD maxclasslen = NO_INIT
@@ -758,7 +745,7 @@
 	DWORD maxvalnamelen = NO_INIT
 	DWORD maxvaldatalen = NO_INIT
 	DWORD secdesclen = NO_INIT
-	FILETIME lastwritetime = NO_INIT
+	IV lastwritetime
     CODE:
 	char keyclass[TMPBUFSZ];
 	FILETIME ft;
@@ -808,7 +795,7 @@
 RegQueryValueEx(hkey,valuename,reserved,type,data)
 	HKEY hkey
 	char *valuename
-	SV *reserved = NO_INIT
+	SV *reserved
 	DWORD type = NO_INIT
 	SV *data
     CODE:
@@ -960,7 +947,7 @@
 RegSetValueEx(hkey,valname,reserved,type,data)
 	HKEY hkey
 	char *valname
-	DWORD reserved = NO_INIT
+	DWORD reserved
 	DWORD type
 	SV *data
     CODE:
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Registry/t/registry.t perl-libwin32-0.24/Registry/t/registry.t
--- libwin32-0.24-orig/Registry/t/registry.t	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Registry/t/registry.t	2004-12-01 23:55:58.000000000 +0000
@@ -5,12 +5,13 @@
 # Tests for NT Extensions - Registry Manipulation Routines
 # changed to test new registry extension modules.
 
+use Win32;
 use Win32::Registry;
 
 $bug = 1;
 
 open( ME, $0 ) || die $!;
-$bugs = grep( /^\$bug\+\+;\n$/, <ME> );
+$bugs = grep( /^\$bug\+\+;/, <ME> );
 close( ME );
 
 print "1..$bugs\n";
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Registry/typemap perl-libwin32-0.24/Registry/typemap
--- libwin32-0.24-orig/Registry/typemap	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Registry/typemap	2004-12-01 23:55:58.000000000 +0000
@@ -2,3 +2,13 @@
 REGSAM                  T_IV
 HKEY                    T_IV
 HANDLE                  T_IV
+
+INPUT
+
+T_IV
+	$var = ($type)(DWORD)SvIV($arg)
+
+OUTPUT
+
+T_IV
+	sv_setiv($arg, (IV)(DWORD)$var);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Semaphore/Semaphore.xs perl-libwin32-0.24/Semaphore/Semaphore.xs
--- libwin32-0.24-orig/Semaphore/Semaphore.xs	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Semaphore/Semaphore.xs	2004-12-01 23:55:58.000000000 +0000
@@ -1,5 +1,5 @@
 //--------------------------------------------------------------------
-// $Id$
+// $Id: Semaphore.xs,v 1.1.1.1 2003/01/28 19:00:03 caelum Exp $
 //--------------------------------------------------------------------
 //
 //   Win32::Semaphore
@@ -9,15 +9,7 @@
 //
 //--------------------------------------------------------------------
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
-
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-
+#include "../win32perl.h"
 
 MODULE = Win32::Semaphore	PACKAGE = Win32::Semaphore
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Semaphore/typemap perl-libwin32-0.24/Semaphore/typemap
--- libwin32-0.24-orig/Semaphore/typemap	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Semaphore/typemap	2004-12-01 23:55:58.000000000 +0000
@@ -8,7 +8,7 @@
 T_PTROBJ
 	if (sv_derived_from($arg, \"${Package}\")) {
 	    IV tmp = SvIV((SV*)SvRV($arg));
-	    $var = ($type) tmp;
+	    $var = ($type)(DWORD) tmp;
 	}
 	else
 	    croak(\"$var is not of type ${Package}\")
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Service/Service.pm perl-libwin32-0.24/Service/Service.pm
--- libwin32-0.24-orig/Service/Service.pm	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Service/Service.pm	2004-12-01 23:55:58.000000000 +0000
@@ -11,6 +11,7 @@
 
 require Exporter;
 require DynaLoader;
+use Win32;
 
 die "The Win32::Service module works only on Windows NT" if(!Win32::IsWinNT());
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Service/Service.xs perl-libwin32-0.24/Service/Service.xs
--- libwin32-0.24-orig/Service/Service.xs	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Service/Service.xs	2004-12-01 23:55:58.000000000 +0000
@@ -2,13 +2,7 @@
  * Service.xs
  */
 
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
+#include "../win32perl.h"
 
 #define RETURNRESULT(x)		if ((x)){ XST_mYES(0); }\
                      		else { XST_mNO(0); }\
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Shortcut/Shortcut.pm perl-libwin32-0.24/Shortcut/Shortcut.pm
--- libwin32-0.24-orig/Shortcut/Shortcut.pm	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Shortcut/Shortcut.pm	2004-12-01 23:55:58.000000000 +0000
@@ -12,6 +12,7 @@
 
 require Exporter;       # to export the constants to the main:: space
 require DynaLoader;     # to dynuhlode the module.
+use Win32;
 
 @ISA= qw( Exporter DynaLoader );
 @EXPORT = qw(
@@ -148,8 +149,9 @@
     my($self, $file) = @_;
     return undef unless ref($self);
 
-    return undef if not $file and not $self->{'File'};
-    $file = $self->{'File'} if not $file;
+    $file = Win32::GetFullPathName($self->{'File'} || $file);
+    return undef if not $file;
+    $self->{'File'} = $file;
 
     _SetPath($self->{'ilink'}, $self->{'ifile'}, $self->{'Path'});
     _SetArguments($self->{'ilink'}, $self->{'ifile'}, $self->{'Arguments'});
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Shortcut/Shortcut.xs perl-libwin32-0.24/Shortcut/Shortcut.xs
--- libwin32-0.24-orig/Shortcut/Shortcut.xs	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Shortcut/Shortcut.xs	2004-12-01 23:55:58.000000000 +0000
@@ -9,35 +9,16 @@
  *
  */
 
-#define  WIN32_LEAN_AND_MEAN
-#include <stdlib.h>
-#include <math.h>
-#include <windows.h>
-
+#include "../win32perl.h"
 #include <shlobj.h>
 #include <shlguid.h>
 #include <objbase.h>
 
-#if defined(__cplusplus)
-extern "C" {
-#endif
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-#if defined(__cplusplus)
-}
-#endif
-
-#ifndef _WIN64
-#  define DWORD_PTR	DWORD
-#endif
-
 // Section for the constant definitions.
 #define CROAK croak
 #define MAX_LENGTH 2048
 #define TMPBUFSZ 1024
 
-
 DWORD
 constant(char *name, int arg)
 {
@@ -238,7 +219,6 @@
     IShellLink * ilink
     IPersistFile * ifile
 PPCODE:
-    HRESULT hres;
     ifile->Release();
     ilink->Release();
     XSRETURN_YES;
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Shortcut/mingw32.exc perl-libwin32-0.24/Shortcut/mingw32.exc
--- libwin32-0.24-orig/Shortcut/mingw32.exc	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Shortcut/mingw32.exc	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Shortcut/test.pl perl-libwin32-0.24/Shortcut/test.pl
--- libwin32-0.24-orig/Shortcut/test.pl	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Shortcut/test.pl	2004-12-01 23:55:58.000000000 +0000
@@ -2,6 +2,7 @@
 # Version 0.03
 # by Aldo Calpini <dada@divinf.it>
 
+use Win32;
 use Win32::Shortcut;
 use Cwd;
 
@@ -18,8 +19,10 @@
     # print "   L.ilink=".$L->{'ilink'}."\n";
     # print "   L.ifile=".$L->{'ifile'}."\n";
 
-    $L->Path($ENV{'SYSTEMROOT'}."\\Notepad.exe");
-    $L->WorkingDirectory($ENV{'TEMP'});
+    my $windows = $ENV{'SYSTEMROOT'} || $ENV{'WINDIR'};
+    $L->Path($windows."\\Notepad.exe");
+    my $temp = $ENV{'TEMP'}; $temp =~ s!/!\\!g;
+    $L->WorkingDirectory($temp);
     $L->ShowCmd(3);
 
     printf("%20s = %s\n","Path",            $L->Path);
@@ -51,9 +54,9 @@
     
     print "\n   Changing shortcut data...\n";
 
-    $L->Set($ENV{'SYSTEMROOT'}."\\Write.exe",
+    $L->Set($windows."\\Write.exe",
             "",
-            $ENV{'SYSTEMROOT'},
+            $windows,
             "This is a description",
             1,
             hex('0x0337'),
@@ -94,8 +97,8 @@
     $L = new Win32::Shortcut();
     if($L) {
         print "OK\n";
-        $L->Path("dummy.txt");
-        $pathto = Cwd::getcwd();
+        $pathto = Win32::GetCwd();
+        $L->Path("$pathto\\dummy.txt");
         $L->WorkingDirectory($pathto);
         printf("%20s = %s\n", "WorkingDirectory", $L->WorkingDirectory);
         printf("%20s = %s\n", "Path", $L->Path);
@@ -103,9 +106,10 @@
         $result = $L->Save("test3.lnk");
         if($result) {
             print "OK\n";
-            print "\n   Renaming \"dummy.txt\" to \"dummy2.txt\"...";
-            if(rename("dummy.txt", "dummy2.txt")) {
-                print "OK\n";
+## FIXME: why does resolving renamed shortcuts not work properly?
+#            print "\n   Renaming \"dummy.txt\" to \"dummy2.txt\"...";
+#            if(rename("dummy.txt", "dummy2.txt")) {
+#                print "OK\n";
                 print "   Attempting resolve...";
                 $L->Resolve() or print "Resolve failed\n";
                 if(-f $L->{'Path'}) {
@@ -118,9 +122,9 @@
                 } else {
                     print "FAILED\n";
                 }
-            } else {
-                print "** ERROR **\n";
-            }
+#            } else {
+#                print "** ERROR **\n";
+#            }
         } else {
             print "** ERROR **\n";
         }
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Shortcut/typemap perl-libwin32-0.24/Shortcut/typemap
--- libwin32-0.24-orig/Shortcut/typemap	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Shortcut/typemap	2004-12-01 23:55:58.000000000 +0000
@@ -4,3 +4,12 @@
 IShellLink *           T_IV
 IPersistFile *         T_IV
 
+INPUT
+
+T_IV
+	$var = ($type)(DWORD)SvIV($arg);
+
+OUTPUT
+
+T_IV
+	sv_setiv($arg, (IV)(DWORD)$var);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Sound/Sound.xs perl-libwin32-0.24/Sound/Sound.xs
--- libwin32-0.24-orig/Sound/Sound.xs	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Sound/Sound.xs	2004-12-01 23:55:58.000000000 +0000
@@ -12,23 +12,13 @@
 #######################################################################
 */
 
-#define  WIN32_LEAN_AND_MEAN
-#include <windows.h>
+#include "../win32perl.h"
 #include <mmsystem.h>
 
-#define __TEMP_WORD  WORD   /* perl defines a WORD, yikes! */
-
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
-
 // Section for the constant definitions.
-#define CROAK croak
-
-#undef WORD
-#define WORD __TEMP_WORD
+#ifndef CROAK
+# define CROAK croak
+#endif
 
 #define DEV_WAVEOUT 1
 #define DEV_WAVEIN  2
@@ -315,7 +305,6 @@
 void
 Play(...)
 PPCODE:
-    HANDLE myhandle;
     BOOL bResult;
     UINT flag=0; 
     LPCSTR name = NULL;
@@ -719,13 +708,13 @@
     }    
     tmpsv = hv_fetch(hself, "bits", 4, 0);
     if(tmpsv != NULL) {
-        wavfmt.wBitsPerSample = (DWORD) SvIV(*tmpsv);
+        wavfmt.wBitsPerSample = (WORD)SvIV(*tmpsv);
     } else {
         if(PL_dowarn) warn("Win32::Sound::WaveOut::OpenDevice: invalid format (bits)\n");
     }    
     tmpsv = hv_fetch(hself, "blockalign", 10, 0);
     if(tmpsv != NULL) {
-        wavfmt.nBlockAlign = (DWORD) SvIV(*tmpsv);
+        wavfmt.nBlockAlign = (WORD)SvIV(*tmpsv);
     } else {
         wavfmt.nBlockAlign = wavfmt.nChannels * wavfmt.wBitsPerSample / 8;
     }
@@ -740,8 +729,8 @@
         &wo,
         (UINT) id,
         &wavfmt,
-        NULL,
-        NULL,
+        0,
+        0,
         CALLBACK_NULL
     );
     if(RETVAL == MMSYSERR_NOERROR) {
@@ -763,7 +752,7 @@
     hself = (HV*) SvRV(self);
     tmpsv = hv_fetch(hself, "handle", 6, 0);
     if(tmpsv != NULL) {
-        wo = (HWAVEOUT) SvIV(*tmpsv);
+        wo = (HWAVEOUT)(DWORD) SvIV(*tmpsv);
         RETVAL = waveOutClose(wo);
         WaveOutCheckError(RETVAL);
     } else {
@@ -790,7 +779,7 @@
     hself = (HV*) SvRV(self);
     tmpsv = hv_fetch(hself, "handle", 6, 0);
     if(tmpsv != NULL) {
-        wo = (HWAVEOUT) SvIV(*tmpsv);
+        wo = (HWAVEOUT)(DWORD) SvIV(*tmpsv);
         wavlength = SvLEN(data);
         hgdata = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, wavlength);
         hv_store(hself, "wavdata", 7, newSViv((long) hgdata), 0);
@@ -825,10 +814,10 @@
     hself = (HV*)SvRV(self);
     tmpsv = hv_fetch(hself, "handle", 6, 0);
     if(tmpsv != NULL) {
-        wo = (HWAVEOUT) SvIV(*tmpsv);
+        wo = (HWAVEOUT)(DWORD) SvIV(*tmpsv);
         tmpsv = hv_fetch(hself, "wavheadlock", 11, 0);
         if(tmpsv != NULL) {
-            wh = (LPWAVEHDR) SvIV(*tmpsv);
+            wh = (LPWAVEHDR)(DWORD) SvIV(*tmpsv);
             RETVAL = waveOutWrite(wo, wh, sizeof(WAVEHDR));
             WaveOutCheckError(RETVAL);          
         } else {
@@ -851,8 +840,6 @@
     HV* hself;
     SV** tmpsv;
     HMMIO mmio;
-    HWAVEOUT wo;
-    LPWAVEHDR wh;
     WAVEFORMATEX wavfmt;
     MMCKINFO mmchunk; 
     MMCKINFO mmsubchunk; 
@@ -873,19 +860,19 @@
     }
     tmpsv = hv_fetch(hself, "samplerate", 10, 0);
     if(tmpsv != NULL) {
-        wavfmt.nSamplesPerSec = (DWORD) SvIV(*tmpsv);
+        wavfmt.nSamplesPerSec = (WORD) SvIV(*tmpsv);
     } else {
         if(PL_dowarn) warn("WaveOut::Save: invalid format (samplerate)");
     }
     tmpsv = hv_fetch(hself, "bits", 4, 0);
     if(tmpsv != NULL) {
-        wavfmt.wBitsPerSample = (DWORD) SvIV(*tmpsv);
+        wavfmt.wBitsPerSample = (WORD) SvIV(*tmpsv);
     } else {
         if(PL_dowarn) warn("WaveOut::Save: invalid format (bits)");
     }
     tmpsv = hv_fetch(hself, "blockalign", 10, 0);
     if(tmpsv != NULL) {
-        wavfmt.nBlockAlign = (DWORD) SvIV(*tmpsv);
+        wavfmt.nBlockAlign = (WORD) SvIV(*tmpsv);
     } else {
         wavfmt.nBlockAlign = wavfmt.nChannels * wavfmt.wBitsPerSample / 8;
     }
@@ -906,7 +893,7 @@
     } else {
         tmpsv = hv_fetch(hself, "wavdatalock", 11, 0);
         if(tmpsv != NULL) {
-            buffer = (char _huge*) SvIV(*tmpsv);
+            buffer = (char _huge*)(DWORD) SvIV(*tmpsv);
             bufferlen = (LONG) GlobalSize((HGLOBAL) buffer);
             printf("XS(WaveOut::Save): loaded bufferlen=%ld\n", bufferlen);
         } else {
@@ -960,10 +947,10 @@
     hself = (HV*)SvRV(self);
     tmpsv = hv_fetch(hself, "handle", 6, 0);
     if(tmpsv != NULL) {
-        wo = (HWAVEOUT) SvIV(*tmpsv);
+        wo = (HWAVEOUT)(DWORD) SvIV(*tmpsv);
         tmpsv = hv_fetch(hself, "wavheadlock", 11, 0);
         if(tmpsv != NULL) {
-            wh = (LPWAVEHDR) SvIV(*tmpsv);
+            wh = (LPWAVEHDR)(DWORD) SvIV(*tmpsv);
             if(wh->dwFlags & WHDR_PREPARED) {
                 RETVAL = waveOutUnprepareHeader(wo, wh, sizeof(wh));
             }
@@ -972,19 +959,19 @@
         }
         tmpsv = hv_fetch(hself, "wavhead", 7, 0);
         if(tmpsv != NULL) {
-            hg = (HGLOBAL) SvIV(*tmpsv);
+            hg = (HGLOBAL)(DWORD) SvIV(*tmpsv);
             GlobalFree(hg);
             hv_delete(hself, "wavhead", 7, 0);
         }
         tmpsv = hv_fetch(hself, "wavdatalock", 11, 0);
         if(tmpsv != NULL) {
-            hg = (HGLOBAL) SvIV(*tmpsv);
+            hg = (HGLOBAL)(DWORD) SvIV(*tmpsv);
             GlobalUnlock(hg);
             hv_delete(hself, "wavdatalock", 11, 0);
         }
         tmpsv = hv_fetch(hself, "wavdata", 7, 0);
         if(tmpsv != NULL) {
-            hg = (HGLOBAL) SvIV(*tmpsv);
+            hg = (HGLOBAL)(DWORD) SvIV(*tmpsv);
             GlobalFree(hg);
             hv_delete(hself, "wavdata", 7, 0);
         }        
@@ -1013,12 +1000,12 @@
     hself = (HV*) SvRV(self);
     tmpsv = hv_fetch(hself, "mmio", 4, 0);
     if(tmpsv != NULL) {
-        mmio = (HMMIO) SvIV(*tmpsv);
+        mmio = (HMMIO)(DWORD) SvIV(*tmpsv);
         mmioClose(mmio, 0);
     }
     tmpsv = hv_fetch(hself, "handle", 6, 0);
     if(tmpsv != NULL) {
-        wo = (HWAVEOUT) SvIV(*tmpsv);
+        wo = (HWAVEOUT)(DWORD) SvIV(*tmpsv);
         waveOutClose(wo);
     }   
     mmio = mmioOpen((LPSTR) filename, NULL, MMIO_READ);
@@ -1043,8 +1030,8 @@
                     &wo, 
                     (UINT) id, 
                     &wavfmt, 
-                    NULL, 
-                    NULL, 
+                    0, 
+                    0, 
                     CALLBACK_NULL /* | WAVE_ALLOWSYNC | WAVE_FORMAT_DIRECT */
                 );
                 if(mmr == MMSYSERR_NOERROR) {
@@ -1084,7 +1071,7 @@
     hself = (HV*)SvRV(self);
     hmmio = hv_fetch(hself, "mmio", 4, 0);
     if(hmmio != NULL) {
-        mmio = (HMMIO) SvIV(*hmmio);
+        mmio = (HMMIO)(DWORD) SvIV(*hmmio);
         mmioSeek(mmio, 0, SEEK_SET);
         mmchunk.fccType = mmioFOURCC('W', 'A', 'V', 'E'); 
         if (mmioDescend(mmio, &mmchunk, NULL, MMIO_FINDRIFF)) {
@@ -1122,7 +1109,7 @@
                 wh->dwFlags = 0;
                 hwo = hv_fetch(hself, "handle", 6, 0);
                 if(hwo != NULL) {
-                    wo = (HWAVEOUT) SvIV(*hwo);
+                    wo = (HWAVEOUT)(DWORD) SvIV(*hwo);
                     mmr = waveOutPrepareHeader(wo, wh, sizeof(WAVEHDR));
                     if(mmr == MMSYSERR_NOERROR) {
                         mmr = waveOutWrite(wo, wh, sizeof(WAVEHDR));
@@ -1157,7 +1144,7 @@
     hself = (HV*)SvRV(self);
     wavhead = hv_fetch(hself, "wavheadlock", 11, 0);
     if(wavhead != NULL) {
-        wh = (LPWAVEHDR) SvIV(*wavhead);
+        wh = (LPWAVEHDR)(DWORD) SvIV(*wavhead);
         if(wh->dwFlags & WHDR_DONE) {
             XSRETURN_IV(1);
         } else {
@@ -1171,7 +1158,6 @@
 void
 Position(self)
     SV* self
-    int type
 PPCODE:
     HV* hself;
     SV** handle;
@@ -1183,7 +1169,7 @@
     hself = (HV*)SvRV(self);
     handle = hv_fetch(hself, "handle", 6, 0);
     if(handle != NULL) {
-        wo = (HWAVEOUT) SvIV(*handle);
+        wo = (HWAVEOUT)(DWORD) SvIV(*handle);
         mmt.wType = (UINT) ttype;
         mmr = waveOutGetPosition(wo, &mmt, sizeof(MMTIME));
         if(mmr == MMSYSERR_NOERROR) {
@@ -1216,7 +1202,7 @@
     hself = (HV*)SvRV(self);
     handle = hv_fetch(hself, "handle", 6, 0);
     if(handle != NULL) {
-        RETVAL = waveOutPause((HWAVEOUT)SvIV(*handle));
+        RETVAL = waveOutPause((HWAVEOUT)(DWORD)SvIV(*handle));
         WaveOutCheckError(RETVAL);
     } else {
         PerlSetError(-1, "Device is not opened");
@@ -1235,7 +1221,7 @@
     hself = (HV*)SvRV(self);
     handle = hv_fetch(hself, "handle", 6, 0);
     if(handle != NULL) {
-        RETVAL = waveOutRestart((HWAVEOUT)SvIV(*handle));
+        RETVAL = waveOutRestart((HWAVEOUT)(DWORD)SvIV(*handle));
         WaveOutCheckError(RETVAL);
     } else {
         PerlSetError(-1, "Device is not opened");
@@ -1254,7 +1240,7 @@
     hself = (HV*)SvRV(self);
     handle = hv_fetch(hself, "handle", 6, 0);
     if(handle != NULL) {
-        RETVAL = waveOutReset((HWAVEOUT)SvIV(*handle));
+        RETVAL = waveOutReset((HWAVEOUT)(DWORD)SvIV(*handle));
         WaveOutCheckError(RETVAL);
     } else {
         PerlSetError(-1, "Device is not opened");
@@ -1275,7 +1261,7 @@
     hself = (HV*)SvRV(self);
     handle = hv_fetch(hself, "handle", 6, 0);    
     if(handle != NULL) {
-        wo = (HWAVEOUT)SvIV(*handle);
+        wo = (HWAVEOUT)(DWORD)SvIV(*handle);
         switch(items) {
         case 0:
             mmr = waveOutGetVolume(wo, &volume);
@@ -1329,7 +1315,7 @@
     hself = (HV*)SvRV(self);
     tmpsv = hv_fetch(hself, "mmio", 4, 0);
     if(tmpsv != NULL) {
-        mmio = (HMMIO) SvIV(*tmpsv);
+        mmio = (HMMIO)(DWORD) SvIV(*tmpsv);
         RETVAL = mmioClose(mmio, 0);
         hv_delete(hself, "mmio", 4, 0);
     } else {
@@ -1353,7 +1339,7 @@
     hself = (HV*)SvRV(self);
     tmpsv = hv_fetch(hself, "handle", 6, 0);
     if(tmpsv != NULL) {
-        wo = (HWAVEOUT) SvIV(*tmpsv);
+        wo = (HWAVEOUT)(DWORD) SvIV(*tmpsv);
         if(items == 1) {
             mmr = waveOutGetPitch(wo, &dwPitch);
             WaveOutCheckError(mmr);
@@ -1383,7 +1369,7 @@
     hself = (HV*)SvRV(self);
     tmpsv = hv_fetch(hself, "handle", 6, 0);
     if(tmpsv != NULL) {
-        wo = (HWAVEOUT) SvIV(*tmpsv);
+        wo = (HWAVEOUT)(DWORD) SvIV(*tmpsv);
         if(items == 1) {
             mmr = waveOutGetPlaybackRate(wo, &dwRate);
             WaveOutCheckError(mmr);
@@ -1430,10 +1416,10 @@
     hself = (HV*)SvRV(self);
     tmpsv = hv_fetch(hself, "handle", 6, 0);
     if(tmpsv != NULL) {
-        wo = (HWAVEOUT) SvIV(*tmpsv);
+        wo = (HWAVEOUT)(DWORD) SvIV(*tmpsv);
         tmpsv = hv_fetch(hself, "wavheadlock", 11, 0);
         if(tmpsv != NULL) {
-            wh = (LPWAVEHDR) SvIV(*tmpsv);
+            wh = (LPWAVEHDR)(DWORD) SvIV(*tmpsv);
             if(wh->dwFlags & WHDR_PREPARED) {
                 mmr = waveOutUnprepareHeader(wo, wh, sizeof(wh));
             }
@@ -1441,22 +1427,22 @@
         }
         tmpsv = hv_fetch(hself, "wavhead", 7, 0);
         if(tmpsv != NULL) {
-            hg = (HGLOBAL) SvIV(*tmpsv);
+            hg = (HGLOBAL)(DWORD) SvIV(*tmpsv);
             GlobalFree(hg);
         }
         tmpsv = hv_fetch(hself, "wavdatalock", 11, 0);
         if(tmpsv != NULL) {
-            hg = (HGLOBAL) SvIV(*tmpsv);
+            hg = (HGLOBAL)(DWORD) SvIV(*tmpsv);
             GlobalUnlock(hg);
         }
         tmpsv = hv_fetch(hself, "wavdata", 7, 0);
         if(tmpsv != NULL) {
-            hg = (HGLOBAL) SvIV(*tmpsv);
+            hg = (HGLOBAL)(DWORD) SvIV(*tmpsv);
             GlobalFree(hg);
         }        
 	tmpsv = hv_fetch(hself, "mmio", 4, 0);
 	if(tmpsv != NULL) {
-	    mmio = (HMMIO) SvIV(*tmpsv);
+	    mmio = (HMMIO)(DWORD) SvIV(*tmpsv);
 	    mmioClose(mmio, 0);
 	}
         waveOutClose(wo);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Sound/mingw32.exc perl-libwin32-0.24/Sound/mingw32.exc
--- libwin32-0.24-orig/Sound/mingw32.exc	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Sound/mingw32.exc	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/TieRegistry/TieRegistry.pm perl-libwin32-0.24/TieRegistry/TieRegistry.pm
--- libwin32-0.24-orig/TieRegistry/TieRegistry.pm	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/TieRegistry/TieRegistry.pm	2004-12-01 23:55:58.000000000 +0000
@@ -1797,7 +1797,7 @@
 [C<'\0'>].  Each subkey is also a key and so can contain subkeys
 and values [and has a class, time stamp, and security information].
 
-Each value has a name:  a string which E<can> be blank and E<can>
+Each value has a name:  a string which I<can> be blank and I<can>
 contain the delimiter character [backslash: C<'\\'>] and any
 character except for null, C<'\0'>.  Each value also has data
 associated with it.  Each value's data is a contiguous chunk of
@@ -1845,7 +1845,7 @@
 =item REG_DWORD
 
 A long [4-byte] integer value.  These values are expected either
-packed into a 4-character string or as a hex string of E<more than>
+packed into a 4-character string or as a hex string of I<more than>
 4 characters [but I<not> as a numeric value, unfortunately, as there is
 no sure way to tell a numeric value from a packed 4-byte string that
 just happens to be a string containing a valid numeric value].
@@ -1899,7 +1899,7 @@
 Note that you will most likely use C<$Registry> instead of using
 a tied hash.  C<$Registry> is a reference to a hash that has
 been tied to the virtual root of your computer's Registry [as if,
-C<$Registry= \%RegHash>].  So you would use C<$Registry-E<gt>{Key}>
+C<$Registry= \%RegHash>].  So you would use C<$Registry-I<gt>{Key}>
 rather than C<$RegHash{Key}> and use C<keys %{$Registry}> rather
 than C<keys %RegHash>, for example.
 
@@ -1959,7 +1959,7 @@
 fail, usually with C<ERROR_INSUFFICIENT_BUFFER>.  For example, you
 can't enumerate key names without also enumerating values which
 require huge buffers but the exact buffer size required cannot be
-determined beforehand because C<RegQueryInfoKey()> E<always> fails
+determined beforehand because C<RegQueryInfoKey()> I<always> fails
 with C<ERROR_INSUFFICIENT_BUFFER> for C<HKEY_PERFORMANCE_DATA> no
 matter how it is called.  So it is currently not very useful to
 tie a hash to this key.  You can use it to create an object to use
@@ -2428,7 +2428,7 @@
 you may not have C<KEY_WRITE> access to it or some of its subkeys.
 
 If the C<"Access"> option value is a string that starts with
-C<"KEY_">, then it should match E<one> of the predefined access
+C<"KEY_">, then it should match I<one> of the predefined access
 levels [probably C<"KEY_READ">, C<"KEY_WRITE">, or
 C<"KEY_ALL_ACCESS">] exported by the I<Win32API::Registry> module.
 Otherwise, a numeric value is expected.  For maximum flexibility,
@@ -3151,8 +3151,8 @@
 If true, specifies that the new key should be volatile, that is,
 stored only in memory and not backed by a hive file [and not saved
 if the computer is rebooted].  This option is ignored under
-Windows 95.  Specifying C<Volatile=E<GT>1>  is the same as
-specifying C<Options=E<GT>REG_OPTION_VOLATILE>.
+Windows 95.  Specifying C<Volatile=E<gt>1>  is the same as
+specifying C<Options=E<gt>REG_OPTION_VOLATILE>.
 
 =item Backup
 
@@ -3165,8 +3165,8 @@
 opened with C<KEY_WRITE> access as the C<"LocalSystem"> user which
 should have access to all subkeys.
 
-This option is ignored under Windows 95.  Specifying C<Backup=E<GT>1>
-is the same as specifying C<Options=E<GT>REG_OPTION_BACKUP_RESTORE>.
+This option is ignored under Windows 95.  Specifying C<Backup=E<gt>1>
+is the same as specifying C<Options=E<gt>REG_OPTION_BACKUP_RESTORE>.
 
 =item Options
 
@@ -3227,7 +3227,7 @@
 occurrences of either the delimiter or the OS delimiter.
 
 If C<$newSubKey> is not specified, then it is as if C<$key>
-was C<$Registry-E<GT>{LMachine}> and C<$newSubKey> is
+was C<$Registry-E<gt>{LMachine}> and C<$newSubKey> is
 C<"PerlTie:999"> where C<"999"> is actually a sequence number
 incremented each time this process calls C<Load()>.
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Win32.pm perl-libwin32-0.24/Win32.pm
--- libwin32-0.24-orig/Win32.pm	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Win32.pm	2004-12-01 23:55:58.000000000 +0000
@@ -11,6 +11,7 @@
 
     require Exporter;
     require DynaLoader;
+    eval { require Win32CORE; };
 
     @ISA = qw|Exporter DynaLoader|;
     $VERSION = '0.191';
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/Win32.xs perl-libwin32-0.24/Win32.xs
--- libwin32-0.24-orig/Win32.xs	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/Win32.xs	2004-12-01 23:55:58.000000000 +0000
@@ -1,10 +1,5 @@
-#include <windows.h>
-
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "ppport.h"
+#include "win32perl.h"
+#include <objbase.h>
 
 #define SE_SHUTDOWN_NAMEA   "SeShutdownPrivilege"
 #define SE_SHUTDOWN_NAMEW   L"SeShutdownPrivilege"
@@ -13,7 +8,7 @@
 {
     dXSARGS;
     char *lpSource;
-    BYTE buffer[4096];
+    char buffer[4096];
     DWORD dwDataLen;
     STRLEN n_a;
 
@@ -102,7 +97,6 @@
     char Domain[256];
     DWORD DomLen = sizeof(Domain);
     SID_NAME_USE snu;
-    long retval;
     STRLEN n_a;
     BOOL bResult;
 
@@ -112,7 +106,6 @@
     sid = SvPV(ST(1), n_a);
     if (IsValidSid(sid)) {
 	if (USING_WIDE()) {
-	    WCHAR wSID[sizeof(SID)];
 	    WCHAR wDomain[sizeof(Domain)];
 	    WCHAR wSystem[MAX_PATH+1];
 	    WCHAR wAccount[sizeof(Account)];
@@ -141,7 +134,7 @@
 	if (bResult) {
 	    sv_setpv(ST(2), Account);
 	    sv_setpv(ST(3), Domain);
-	    sv_setiv(ST(4), (double) snu);
+	    sv_setiv(ST(4), (IV) snu);
 	    XSRETURN_YES;
 	}
 	else {
@@ -334,7 +327,7 @@
     dXSARGS;
     if (items != 1)
 	croak("usage: Win32::FreeLibrary($handle)\n");
-    if (FreeLibrary((HINSTANCE) SvIV(ST(0)))) {
+    if (FreeLibrary((HINSTANCE)(DWORD)SvIV(ST(0)))) {
 	XSRETURN_YES;
     }
     XSRETURN_NO;
@@ -346,7 +339,7 @@
     STRLEN n_a;
     if (items != 2)
 	croak("usage: Win32::GetProcAddress($hinstance, $procname)\n");
-    XSRETURN_IV((long)GetProcAddress((HINSTANCE)SvIV(ST(0)), SvPV(ST(1), n_a)));
+    XSRETURN_IV((long)GetProcAddress((HINSTANCE)(DWORD)SvIV(ST(0)), SvPV(ST(1), n_a)));
 }
 
 XS(w32_RegisterServer)
@@ -354,7 +347,7 @@
     dXSARGS;
     BOOL result = FALSE;
     HINSTANCE hnd;
-    FARPROC func;
+    FARPROC(func);
     STRLEN n_a;
     char* lpName;
 
@@ -387,7 +380,7 @@
     dXSARGS;
     BOOL result = FALSE;
     HINSTANCE hnd;
-    FARPROC func;
+    FARPROC(func);
     STRLEN n_a;
     char* lpName;
 
@@ -437,14 +430,15 @@
 {
     dXSARGS;
     GUID guid;
-    char szGUID[50] = {'\0'};
-    HRESULT  hr     = CoCreateGuid(&guid);
+    char szGUID[100] = {'\0'};
+    HRESULT  hr      = CoCreateGuid(&guid);
 
     if (SUCCEEDED(hr)) {
-	LPOLESTR pStr = NULL;
-	StringFromCLSID(&guid, &pStr);
+	WCHAR pStr[100];
+	int retval = StringFromGUID2(guid, pStr, sizeof(pStr));
 	WideCharToMultiByte(CP_ACP, 0, pStr, wcslen(pStr), szGUID,
 			    sizeof(szGUID), NULL, NULL);
+	szGUID[retval - 1] = '\0';
 
 	XSRETURN_PV(szGUID);
     }
@@ -452,6 +446,9 @@
 	XSRETURN_UNDEF;
 }
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 XS(boot_Win32)
 {
     dXSARGS;
@@ -474,3 +471,6 @@
 
     XSRETURN_YES;
 }
+#ifdef __cplusplus
+}
+#endif
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/WinError/WinError.xs perl-libwin32-0.24/WinError/WinError.xs
--- libwin32-0.24-orig/WinError/WinError.xs	2002-07-09 00:15:53.000000000 +0000
+++ perl-libwin32-0.24/WinError/WinError.xs	2004-12-01 23:55:58.000000000 +0000
@@ -1,12 +1,5 @@
-#if !defined(__MINGW32__) && !(defined(__BORLANDC__) && __BORLANDC__ >= 0x0550)
-#include <wtypes.h>
-#endif
-#include <WinError.h>
-
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
+#include "../win32perl.h"
+#include <winerror.h>
 
 static double
 constant(char *name, int arg)
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/WinError/t/winerror.t perl-libwin32-0.24/WinError/t/winerror.t
--- libwin32-0.24-orig/WinError/t/winerror.t	1970-01-01 00:00:00.000000000 +0000
+++ perl-libwin32-0.24/WinError/t/winerror.t	2004-12-01 23:55:58.000000000 +0000
@@ -0,0 +1,12 @@
+#!perl
+# vim:syntax=perl:
+use strict;
+use Test;
+
+BEGIN { plan tests => 2 }
+
+use Win32::WinError;
+
+ok(1);
+
+ok(defined eval { ERROR_BUSY });
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/hints/MSWin32.pl perl-libwin32-0.24/hints/MSWin32.pl
--- libwin32-0.24-orig/hints/MSWin32.pl	1970-01-01 00:00:00.000000000 +0000
+++ perl-libwin32-0.24/hints/MSWin32.pl	2004-12-01 23:55:58.000000000 +0000
@@ -0,0 +1,105 @@
+use Config;
+
+my $mingw   = 1 if $Config{'cc'} =~ /^gcc/i;
+my $borland = 1 if $Config{'cc'} =~ /^bcc32/i;
+my $msvc    = 1 if $Config{'cc'} =~ /^cl/i;
+
+my $incpath = $Config{'incpath'};
+
+my @res_files = map { s/\.rc$/.res/i;$_ } <*.[Rr][Cc]>;
+
+if ($borland) {
+# Find the library path
+	my ($libpath) = ( grep { /borland .* lib \/* \W/ix }
+				split (/\s+/ms, $Config{'ldflags'})
+			);
+# Strip off the -L"..." around the path
+	$libpath =~ s/^-L["']?//; $libpath =~ s/["']?$//;
+
+	$self->{INC} .= qq{ -I"$incpath" -I"$incpath\\mfc" };
+	$self->{CCFLAGS} .= $Config{ccflags} . qq{ -L"$libpath" -L"$libpath\\PSDK" };
+
+# include the Microsoft Platform SDK libs
+	$self->{dynamic_lib}{OTHERLDFLAGS} .= qq{ c0d32.obj -L"$libpath\\PSDK" };
+
+	$self->{LDLOADLIBS} .= " import32.lib cw32mti.lib odbc32.lib comctl32.lib wininet.lib ";
+} elsif ($mingw) {
+	$self->{CCFLAGS} .= $Config{ccflags} . " -pipe ";
+
+	if (((`gcc --version`)[0] !~ /\s[3-9]\.\d+/) &&
+	    ($self->{CCFLAGS} !~ /-fvtable-thunks/)) {
+		$self->{CCFLAGS} .= ' -fvtable-thunks ';
+	} else {
+		$self->{CCFLAGS} =~ s/-fvtable-thunks//g;
+	}
+
+	$self->{LDLOADLIBS} = q{ -lnetapi32 -lwininet -lversion -lmpr -lodbc32 -lodbccp32 -lwinmm -lstdc++ -lole32 -loleaut32 -luuid  -lcomctl32 -lgdi32 -lcomdlg32 -lntdll -lws2_32 }; 
+} elsif ($msvc) {
+	$self->{INC}	.= ' -GX ';
+	$self->{LIBS}	.= ' :nosearch wininet.lib comctl32.lib ';
+	$self->{LDFROM}	.=  "\$(OBJECT) @res_files ";
+}
+
+$self->{clean}{FILES} .= ' *.res *.o *.obj vc*.pdb dll.base dll.exp *.stackdump';
+# Any way to include 'TMP*.$$$' in the above without having nmake go apeshit?
+
+$self->{dynamic_lib}{INST_DYNAMIC_DEP} .= " @res_files ";
+
+package MY;
+
+sub special_targets {
+    my $section = shift->SUPER::special_targets(@_);
+    $section =~ s/\.SUFFIXES([^\n]+)\n/\.SUFFIXES$1 .rc .res\n/;
+    return $section;
+}
+
+sub c_o {
+	my $section = shift->SUPER::c_o(@_);
+
+# Borland C doesn't preserve case in object files, this throws off dmake.
+	if ($borland) {
+		$section =~ s/^(\s+\$\(CCCMD.+?)\s+(\$\*\.\w+)/$1 $2 && ren \$*\$(OBJ_EXT) \$*\$(OBJ_EXT)\n/msg
+	}
+
+# Add target for compiling resource files.
+	if ($mingw) {
+            $section .= <<'EOF';
+
+# Added by hints/MSWin32.pl
+.rc.res:
+	windres -O coff -o $*.res $*.rc
+EOF
+	} else {
+	    my $rc = $borland ? qq{brcc32.exe -x -I"$incpath"} : "rc.exe";
+
+	    $section .= <<"EOF";
+
+# Added by hints/MSWin32.pl
+.rc.res:
+	$rc /l 0x409 /fo\$*.res \$*.rc
+EOF
+	}
+
+	return $section;
+}
+
+sub dynamic_lib {
+	my $section = shift->SUPER::dynamic_lib(@_);
+	if ($borland) {
+		return <<"EOF" . $section;
+
+# Added by hints/MSWin32.pl to dynamic_lib
+RESFILES = @res_files
+
+EOF
+	} elsif ($mingw) {
+		return <<"EOF" . $section;
+
+# Added by hints/MSWin32.pl to dynamic_lib
+OBJECT += @res_files
+
+EOF
+	} else {
+		return $section;
+	}
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/hints/cygwin.pl perl-libwin32-0.24/hints/cygwin.pl
--- libwin32-0.24-orig/hints/cygwin.pl	1970-01-01 00:00:00.000000000 +0000
+++ perl-libwin32-0.24/hints/cygwin.pl	2005-02-14 19:29:44.703125000 +0000
@@ -0,0 +1,68 @@
+use Config;
+
+for (qw(INCLUDE LIB)) {
+	warn
+"WARNING: Having environment variable $_ set will most likely cause your build to fail!\n"
+		if exists $ENV{$_} && $ENV{$_} ne '';
+}
+
+my @res_files = map { s/\.rc$/.res/i;$_ } <*.[Rr][Cc]>;
+
+$self->{LIBS} = [q{ -L/lib/w32api -lnetapi32 -lwininet -lversion -lmpr -lodbc32 -lodbccp32 -lwinmm -lstdc++ -lole32 -loleaut32 -luuid  -lcomctl32 -lgdi32 -lcomdlg32 -lntdll }]; 
+
+if ($Config{cc} =~ /\Wgcc/) {
+# Check for GCC >= 3.x
+	if (((`gcc --version`)[0] !~ /\s[3-9]\.\d+/) &&
+	    ($self->{CCFLAGS} !~ /-fvtable-thunks/)) {
+		$self->{CCFLAGS} .= ' -fvtable-thunks ';
+	} else {
+		$self->{CCFLAGS} =~ s/-fvtable-thunks//g;
+	}
+}
+if (!$Config{ccflags} or $Config{ccflags} =~ /-pipe/) {
+  $self->{CCFLAGS} .= $Config{ccflags} . " -pipe ";
+}
+$self->{CCFLAGS} =~ s|-I/usr/local/include/?||g;
+
+$self->{clean}{FILES} .= ' *.res *.o *.obj vc*.pdb TMP*.$$$ dll.base dll.exp *.stackdump ';
+
+$self->{dynamic_lib}{INST_DYNAMIC_DEP} .= " @res_files ";
+
+package MY;
+
+# Add targets for compiling resource files.
+
+sub special_targets {
+    my $section = shift->SUPER::special_targets(@_);
+    $section =~ s/\.SUFFIXES([^\n]+)\n/\.SUFFIXES$1 .rc .res\n/;
+    return $section;
+}
+
+sub c_o {
+	my $section = shift->SUPER::c_o(@_);
+        $section .= <<'EOF';
+
+# Added by hints/cygwin.pl
+.rc.res:
+	windres -O coff -o $*.res $*.rc
+
+EOF
+	return $section;
+}
+
+sub dynamic_lib {
+   my $section = shift->SUPER::dynamic_lib(@_);
+   if (defined $section && $section) {
+	$section = <<"EOF" . $section;
+
+# Added by hints/cygwin.pl to dynamic_lib
+OBJECT += @res_files
+
+EOF
+## This doesn't seem to help much.
+#	$section .= <<'EOF' if -e '/bin/rebase';
+#	rebase -v -d -b 0x70000000 -o 0x10000 $@
+#EOF
+   }
+   $section;
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x '*.orig' libwin32-0.24-orig/win32perl.h perl-libwin32-0.24/win32perl.h
--- libwin32-0.24-orig/win32perl.h	1970-01-01 00:00:00.000000000 +0000
+++ perl-libwin32-0.24/win32perl.h	2005-02-14 16:01:20.203125000 +0000
@@ -0,0 +1,408 @@
+/*
+ * This file provides some common includes and workarounds for libwin32
+ * extensions. Use as a replacement for all necessary Perl headers and
+ * <windows.h>. As well as some ANSI headers and the ppport.h compatibility
+ * header. Include any other headers you need after this one.
+ *
+ * Headers generally don't get included more than once, so don't worry about
+ * duplicating an #include by accident.
+ *
+ * If you want to pass macros to perl headers, such as #define NO_XSLOCKS,
+ * define them before including this header.
+ *
+ * Rafael Kitover - 12/2003
+ */
+
+#ifndef WIN32_PERL_H
+#define WIN32_PERL_H
+
+/* ANSI C stuff */
+
+#include <stdlib.h>
+#include <math.h>
+#include <stdio.h>
+#undef isnan
+#ifndef __BORLANDC__
+#include <malloc.h>
+#endif
+
+/* Win32 stuff */
+
+#include <windows.h>
+
+#if (!defined(__MINGW32__) && !(defined(__BORLANDC__)) || __BORLANDC__ >= 0x0550)
+#include <wtypes.h>
+#endif
+
+#if defined(__CYGWIN__) && PERL_REVISION <= 5 && PERL_VERSION <= 6
+/* No win32.h in cygwin perl 5.6 */
+# undef WIN32
+#endif
+
+/* This header conflicts with Perl's macros, so include it early. */
+#include <shlobj.h>
+
+/* Perl stuff */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "EXTERN.h"
+#include "perl.h"
+#include "XSUB.h"
+#include "patchlevel.h"
+
+#ifdef __cplusplus
+}
+#endif
+
+#include "ppport.h"
+
+#undef 	Top			/* some devel version pollutes */
+
+/* Type Fixups */
+
+#undef  WORD
+
+#if !defined(_WIN64) && !defined(DWORD_PTR)
+#  define DWORD_PTR	DWORD
+#endif
+
+#if !defined(_WIN64) && !defined(PDWORD_PTR)
+#  define PDWORD_PTR	DWORD*
+#endif
+
+#ifdef __cplusplus
+	#define lw32_perl_LIBCAST HINSTANCE__*
+#else
+	#define lw32_perl_LIBCAST HANDLE
+#endif
+
+#if !defined(__CYGWIN__) && !defined(__BORLANDC__)
+	#undef  stat
+	#define stat _stati64
+#endif
+
+#ifdef __BORLANDC__
+	#define FARPROC(fptr) int __stdcall (*fptr)(void)
+#else
+	#define FARPROC(fptr) FARPROC fptr
+#endif
+
+/* Constant Fixups */
+
+#ifndef _MAX_PATH
+#	define _MAX_PATH MAX_PATH
+#endif
+
+/* Function Fixups */
+
+/* Perl 5.005 added win32_get_osfhandle/win32_open_osfhandle */
+/* This block was taken from Tye's APIFile.xs and modified */
+#if (PERL_REVISION <= 5 && PERL_VERSION < 5) || defined(__CYGWIN__)
+# define win32_get_osfhandle _get_osfhandle
+# ifdef __CYGWIN__
+#  define win32_open_osfhandle(handle,mode) \
+	(Perl_croak(aTHX_ "_open_osfhandle not implemented on Cygwin!"), -1)
+# else
+#  define win32_open_osfhandle _open_osfhandle
+# endif
+# ifdef _get_osfhandle
+#  undef _get_osfhandle	/* stolen_get_osfhandle() isn't available here */
+# endif
+# ifdef _open_osfhandle
+#  undef _open_osfhandle /* stolen_open_osfhandle() isn't available here */
+# endif
+#endif
+
+#ifdef __BORLANDC__ /* Borland C Fixups */
+
+#define DllMain DllEntryPoint
+
+/* Disable "not expanded inline" warnings. */
+#pragma warn -inl
+
+/* Some Borland C compilers don't have odbccp32.lib, notably the free 5.5
+ * version, so we "delayload" a couple functions we need ourselves.
+ */
+
+#ifdef __cplusplus
+	#define static_inline static inline
+#else
+	#define static_inline static
+#endif
+
+#include <odbcinst.h>	/* To avoid prototype redefinition problems. */
+
+#undef  SQLConfigDataSource
+#define SQLConfigDataSource		lw32_perl_SQLConfigDataSource
+#undef  SQLGetPrivateProfileString
+#define SQLGetPrivateProfileString	lw32_perl_SQLGetPrivateProfileString
+
+static HANDLE odbccp32_dll = NULL;
+
+static BOOL __stdcall (*odbccp32_SQLConfigDataSource)(HWND, WORD, LPCSTR,
+			LPCSTR);
+
+static int __stdcall (*odbccp32_SQLGetPrivateProfileString)(LPCSTR, LPCSTR,
+			LPCSTR, LPCSTR, INT, LPCSTR);
+
+static_inline void odbccp32_init(void)
+{
+	odbccp32_dll = LoadLibrary("odbccp32.dll");
+	if (odbccp32_dll == NULL) {
+		croak("Could not LoadLibrary odbccp32.dll");
+	}
+
+	odbccp32_SQLConfigDataSource =
+	  (BOOL __stdcall (*)(HWND, WORD, LPCSTR, LPCSTR))
+          GetProcAddress((lw32_perl_LIBCAST)odbccp32_dll,
+	  	"SQLConfigDataSource");
+
+	if (odbccp32_SQLConfigDataSource == NULL) {
+	  croak("could not find function SQLConfigDataSource in odbccp32.dll");
+	}
+
+	odbccp32_SQLGetPrivateProfileString =
+	  (int __stdcall (*)(LPCSTR, LPCSTR, LPCSTR, LPCSTR, INT, LPCSTR))
+	  GetProcAddress((lw32_perl_LIBCAST)odbccp32_dll,
+	  	"SQLGetPrivateProfileString");
+
+	if (odbccp32_SQLGetPrivateProfileString == NULL) {
+		croak(
+"could not find function SQLGetPrivateProfileString in odbccp32.dll");
+	}
+}
+
+static_inline BOOL
+lw32_perl_SQLConfigDataSource(HWND hwndParent, WORD fRequest,
+	LPCSTR lpszDriver, LPCSTR lpszAttributes)
+{
+
+	if (odbccp32_dll == NULL) { odbccp32_init(); }
+	return (BOOL)(*odbccp32_SQLConfigDataSource)(
+		hwndParent, fRequest, lpszDriver, lpszAttributes);
+}
+
+static_inline int
+lw32_perl_SQLGetPrivateProfileString(LPCSTR lpszSection, LPCSTR lpszEntry,
+	LPCSTR lpszDefault, LPCSTR RetBuffer, INT cbRetBuffer,
+	LPCSTR lpszFilename)
+{
+	if (odbccp32_dll == NULL) { odbccp32_init(); }
+	return (int)(*odbccp32_SQLGetPrivateProfileString)(
+		lpszSection, lpszEntry, lpszDefault, RetBuffer, cbRetBuffer,
+		lpszFilename);
+}
+
+#endif /* Borland C Fixups */
+
+#if defined(__CYGWIN__) || defined(__MINGW32__) /* Cygwin and MinGW Fixups */
+
+#include <commctrl.h>
+
+/* Older w32api commctrl.h missing some defs */
+#ifndef LVIF_INDENT
+	#define LVIF_INDENT 16
+	#define TCM_SETMINTABWIDTH   	(TCM_FIRST + 49)
+	#define TB_GETPADDING		(WM_USER+86)
+	#define TB_SETPADDING		(WM_USER+87)
+	#define TB_SETINDENT		(WM_USER+47)
+	#define TB_GETMAXSIZE		(WM_USER+83)
+	#if (_WIN32_IE >= 0x0400)
+		#define TVGN_LASTVISIBLE	10
+	#endif
+#endif
+
+/* commctrl.h macro DateTime_(Get|Set)Systemtime is capitalized incorrectly in
+ * the w32api headers.
+ */
+
+#ifndef DateTime_GetSystemtime
+#define DateTime_GetSystemtime DateTime_GetSystemTime
+#define DateTime_SetSystemtime DateTime_SetSystemTime
+#endif
+
+/* Missing TreeView_GetLastVisible and ListView_GetCheckState macros.
+ */
+#define TreeView_GetLastVisible(w) TreeView_GetNextItem(w,NULL,TVGN_LASTVISIBLE)
+
+/* Taken this from Laurent Rocher's (rocherl@club-internet.fr) Win32::GUI patch
+ * from: http://perso.club-internet.fr/rocherl/HowTo/howto-mingw.html
+ */
+#ifndef ListView_GetCheckState
+#define ListView_GetCheckState(w,i) (int)(((SNDMSG((w), LVM_GETITEMSTATE, (WPARAM)i, LVIS_STATEIMAGEMASK)) >> 12) -1)
+#endif
+
+/* 
+ * w32api prior to 2.2-1 missed the Job functions (2003-01-31)
+ * See /usr/include/winbase.h 
+ */
+
+#if ((_WIN32_WINNT >= 0x0500) && !defined(CreateJobObject))
+/*
+ * Cygwin/Mingw libkernel32 did not have the Job functions, so we have to load
+ * them at run time from kernel32.dll
+ *
+ * These get optimized out when not referenced.
+ */
+
+
+#undef  CreateJobObject
+#define CreateJobObject			lw32_perl_CreateJobObject
+#undef  TerminateJobObject
+#define TerminateJobObject		lw32_perl_TerminateJobObject
+#undef  AssignProcessToJobObject
+#define AssignProcessToJobObject	lw32_perl_AssignProcessToJobObject
+
+static HANDLE kernel32_dll = NULL;
+
+static HANDLE __stdcall (*kernel32_CreateJobObjectA)(LPSECURITY_ATTRIBUTES, LPCSTR);
+
+static BOOL __stdcall (*kernel32_TerminateJobObject)(HANDLE, UINT);
+
+static BOOL __stdcall (*kernel32_AssignProcessToJobObject)(HANDLE, HANDLE);
+
+static inline void kernel32_init()
+{
+	kernel32_dll = LoadLibrary("kernel32.dll");
+	if (kernel32_dll == NULL) {
+		croak("Could not LoadLibrary kernel32.dll");
+	}
+
+	kernel32_CreateJobObjectA =
+	  (HANDLE __stdcall (*)(LPSECURITY_ATTRIBUTES, LPCSTR))
+	  GetProcAddress((lw32_perl_LIBCAST)kernel32_dll,"CreateJobObjectA");
+
+	if (kernel32_CreateJobObjectA == NULL) {
+	  croak("could not find function CreateJobObjectA in kernel32.dll");
+	}
+
+	kernel32_TerminateJobObject =
+	  (BOOL __stdcall (*)(HANDLE, UINT))
+	  GetProcAddress((lw32_perl_LIBCAST)kernel32_dll,"TerminateJobObject");
+
+	if (kernel32_TerminateJobObject  == NULL) {
+	  croak("could not find function TerminateJobObject in kernel32.dll");
+	}
+
+	kernel32_AssignProcessToJobObject =
+	  (BOOL __stdcall (*)(HANDLE, HANDLE))
+	  GetProcAddress((lw32_perl_LIBCAST)kernel32_dll,
+	  	"AssignProcessToJobObject");
+
+	if (kernel32_AssignProcessToJobObject == NULL) {
+	  croak(
+"could not find function AssignProcessToJobObject in kernel32.dll");
+	}
+}
+
+static inline HANDLE lw32_perl_CreateJobObject(
+	LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName)
+{
+	if (kernel32_dll == NULL) { kernel32_init(); }
+	return (HANDLE)(*kernel32_CreateJobObjectA)(lpJobAttributes, lpName);
+}
+
+static inline BOOL lw32_perl_TerminateJobObject(HANDLE hJob, UINT uExitCode)
+{
+	if (kernel32_dll == NULL) { kernel32_init(); }
+	return (BOOL)(*kernel32_TerminateJobObject)(hJob, uExitCode);
+}
+
+static inline BOOL lw32_perl_AssignProcessToJobObject(HANDLE hJob,
+	HANDLE hProcess)
+{
+	if (kernel32_dll == NULL) { kernel32_init(); }
+	return (BOOL)(*kernel32_AssignProcessToJobObject)(hJob, hProcess);
+}
+#endif /* Job functions */
+#endif /* Cygwin and MinGW Fixups */
+
+
+#ifdef __CYGWIN__ /* Cygwin specific Fixups */
+
+/* Headers */
+#include <netdb.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <wchar.h>
+
+/* Possibly missing prototypes */
+#define _wcscmpi _wcsicmp
+int  _wcsicmp(const wchar_t*, const wchar_t*);
+long _wtol (const wchar_t*);
+
+/* Make an itoa and ltoa macro using snprintf */
+
+#define itoa(num,str,len) snprintf(str, len, "%d",  num), str;
+#define ltoa(num,str,len) snprintf(str, len, "%ld", num), str;
+
+/* UNICODE stuff (from win32.h) */
+
+#undef USING_WIDE
+#undef A2WHELPER
+#undef A2WHELPER_LEN
+#undef W2AHELPER
+#undef W2AHELPER_LEN
+
+#define USING_WIDE() (0)
+
+#define A2WHELPER_LEN(lpa, alen, lpw, nBytes)\
+    (lpw[0] = 0, MultiByteToWideChar(CP_ACP, 0, \
+                                    lpa, alen, lpw, (nBytes/sizeof(WCHAR))))
+
+#define A2WHELPER(lpa, lpw, nBytes)     A2WHELPER_LEN(lpa, -1, lpw, nBytes)
+
+#define W2AHELPER_LEN(lpw, wlen, lpa, nChars)\
+    (lpa[0] = '\0', WideCharToMultiByte(CP_ACP, 0, \
+                                       lpw, wlen, (LPSTR)lpa, nChars,NULL,NULL))
+
+#define W2AHELPER(lpw, lpa, nChars)     W2AHELPER_LEN(lpw, -1, lpa, nChars)
+
+/*
+ * Implementation of missing functions.
+ *
+ * NOTE: These will not bloat the code, since on GCC at least a static inline
+ * function will only be compiled if there are calls to it.
+ */
+
+#ifndef strrev
+#define strrev lw32_perl_strrev
+
+static inline char *lw32_perl_strrev(char* str)
+{
+	int  start = 0;
+	int  end   = strlen(str) - 1;
+
+	while (start < end) {
+		char tmp   = str[start];
+		str[start] = str[end];
+		str[end]   = tmp;
+		start++; end--;
+	}
+}
+
+#endif /* strrev */
+
+/*
+ * Cygwin installations with postgres installed may have a conflicting
+ * /usr/include/sqltypes.h which will break trying to #include <sql.h>.
+ */
+# ifndef ODBCVER
+#  define ODBCVER 0x0351
+# endif
+
+# include <w32api/sqltypes.h>
+
+#endif /* Cygwin specific Fixups */
+
+/* Clear out unnecessary macros */
+
+#undef lw32_perl_LIBCAST
+
+#undef Stat
+#undef Move
+
+#endif /* WIN32_PERL_H */
