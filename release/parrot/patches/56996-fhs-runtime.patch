Remove stats to /usr/runtime/parrot at installed versions
("/usr" being the prefix).
Check the config_hash for the installed key and the 
interpreter INTERPINFO_RUNTIME_PREFIX or CONFIG_HASH if present.

The library.c code is not working yet with ENABLE_PARROT_LIBRARY_INSTALLED
Parrot VM: PANIC: Out of mem!
Not enough tuits yet to fix and debug it.

Index: parrot-svn/runtime/parrot/library/config.pir
===================================================================
--- parrot-svn.orig/runtime/parrot/library/config.pir
+++ parrot-svn/runtime/parrot/library/config.pir
@@ -48,12 +48,28 @@ undefined values) is undefined, and may 
 .sub _config
     .local pmc CONF
     .local string conf_file
+
+    #unless find_sub('_config') goto runtime
+    #$P0 = _config()
+    #.return( $P0 )
+
+runtime:
+    # conf_file = Parrot_locate_runtime_file_str(interp, "config.fpmc", 2)
     conf_file = interpinfo .INTERPINFO_RUNTIME_PREFIX
     conf_file .= "/runtime/parrot/include/config.fpmc"
+    stat $I0, conf_file, 0
+    if $I0 goto conf
 
+    # If installed into /usr/lib/parrot, not /usr/runtime/parrot
+    # This logic has to be reversed when installed versions should run faster
+    # than source builds.
+    conf_file = interpinfo .INTERPINFO_RUNTIME_PREFIX
+    conf_file .= "/lib/parrot/include/config.fpmc"
+conf:
     open CONF, conf_file, "<"
     $I0 = defined CONF
     if $I0 goto ok1
+
     printerr "Can't read '"
     printerr conf_file
     printerr "': "
Index: parrot-svn/runtime/parrot/library/parrotlib.pir
===================================================================
--- parrot-svn.orig/runtime/parrot/library/parrotlib.pir
+++ parrot-svn/runtime/parrot/library/parrotlib.pir
@@ -24,14 +24,13 @@ parrotlib's interface functions.
     .local pmc includes
     .local string root
 
-
-    # XXX todo: get root from config
     $P0 = new 'Env'
     root = $P0["PARROT_RUNTIME_ROOT"]
     length $I0, root
     if $I0 == 0 goto DEFAULT
     branch OKAY
 DEFAULT:
+    # lib/parrot on installed, or runtime
     root = "runtime/parrot"
 OKAY:
 
@@ -138,13 +137,22 @@ Returns the location of a dynamic extens
     stat $I0, name, 0
     if $I0 goto END
 
-    name = "runtime/parrot/dynext/"
+    .include "interpinfo.pasm"
+    name = interpinfo .INTERPINFO_RUNTIME_PREFIX
+    concat name, "lib/parrot/dynext/"
     concat name, request
     stat $I0, name, 0
     if $I0 goto END
 
+    concat name, ext
+    stat $I0, name, 0
+    if $I0 goto END
+
     name = "runtime/parrot/dynext/"
     concat name, request
+    stat $I0, name, 0
+    if $I0 goto END
+
     concat name, ext
     stat $I0, name, 0
     if $I0 goto END
Index: parrot-svn/src/library.c
===================================================================
--- parrot-svn.orig/src/library.c
+++ parrot-svn/src/library.c
@@ -1,6 +1,6 @@
 /*
 Copyright (C) 2004-2007, The Perl Foundation.
-$Id: library.c 27529 2008-05-16 01:38:16Z chromatic $
+$Id: library.c 30318 2008-08-19 02:02:46Z Whiteknight $
 
 =head1 NAME
 
@@ -121,64 +121,108 @@ if will be called as a function with thi
 Platform code may add, delete, or replace search path entries as needed. See
 also F<include/parrot/library.h> for C<enum_lib_paths>.
 
+#ifdef ENABLE_PARROT_LIBRARY_INSTALLED
+then the config hash is checked for the path prefix. This still crashes.
+
 =cut
 
 */
 
+#undef ENABLE_PARROT_LIBRARY_INSTALLED
+
 void
 parrot_init_library_paths(PARROT_INTERP)
 {
     PMC *paths;
     STRING *entry;
+    INTVAL installed = 0;
 
     PMC * const iglobals = interp->iglobals;
     /* create the lib_paths array */
     PMC * const lib_paths = pmc_new(interp, enum_class_FixedPMCArray);
+#ifdef ENABLE_PARROT_LIBRARY_INSTALLED
+    PMC * const config_hash = VTABLE_get_pmc_keyed_int(interp, iglobals, IGLOBALS_CONFIG_HASH);
+    STRING * const key = CONST_STRING(interp, "installed");
+#endif
 
     VTABLE_set_integer_native(interp, lib_paths, PARROT_LIB_PATH_SIZE);
     VTABLE_set_pmc_keyed_int(interp, iglobals,
             IGLOBALS_LIB_PATHS, lib_paths);
+#ifdef ENABLE_PARROT_LIBRARY_INSTALLED
+    if (VTABLE_elements(interp, config_hash) &&
+        VTABLE_exists_keyed_str(interp, config_hash, key))) {
+        installed = VTABLE_get_integer_keyed_str(interp, config_hash, key);
+    }
+#endif
+
     /* each is an array of strings */
     /* define include paths */
     paths = pmc_new(interp, enum_class_ResizableStringArray);
     VTABLE_set_pmc_keyed_int(interp, lib_paths,
             PARROT_LIB_PATH_INCLUDE, paths);
-    entry = CONST_STRING(interp, "runtime/parrot/include/");
-    VTABLE_push_string(interp, paths, entry);
-    entry = CONST_STRING(interp, "runtime/parrot/");
-    VTABLE_push_string(interp, paths, entry);
+#ifdef ENABLE_PARROT_LIBRARY_INSTALLED
+    if (installed) {
+#endif
+        entry = CONST_STRING(interp, "lib/parrot/include/");
+        VTABLE_push_string(interp, paths, entry);
+        entry = CONST_STRING(interp, "lib/parrot/");
+        VTABLE_push_string(interp, paths, entry);
+#ifdef ENABLE_PARROT_LIBRARY_INSTALLED
+    } else {
+#endif
+        entry = CONST_STRING(interp, "runtime/parrot/include/");
+        VTABLE_push_string(interp, paths, entry);
+        entry = CONST_STRING(interp, "runtime/parrot/");
+        VTABLE_push_string(interp, paths, entry);
+#ifdef ENABLE_PARROT_LIBRARY_INSTALLED
+    }
+#endif
     entry = CONST_STRING(interp, "./");
     VTABLE_push_string(interp, paths, entry);
-    entry = CONST_STRING(interp, "lib/parrot/include/");
-    VTABLE_push_string(interp, paths, entry);
-    entry = CONST_STRING(interp, "lib/parrot/");
-    VTABLE_push_string(interp, paths, entry);
 
     /* define library paths */
     paths = pmc_new(interp, enum_class_ResizableStringArray);
     VTABLE_set_pmc_keyed_int(interp, lib_paths,
             PARROT_LIB_PATH_LIBRARY, paths);
-    entry = CONST_STRING(interp, "runtime/parrot/library/");
-    VTABLE_push_string(interp, paths, entry);
-    entry = CONST_STRING(interp, "runtime/parrot/");
-    VTABLE_push_string(interp, paths, entry);
+#ifdef ENABLE_PARROT_LIBRARY_INSTALLED
+    if (installed) {
+#endif
+        entry = CONST_STRING(interp, "lib/parrot/library/");
+        VTABLE_push_string(interp, paths, entry);
+        entry = CONST_STRING(interp, "lib/parrot/");
+        VTABLE_push_string(interp, paths, entry);
+#ifdef ENABLE_PARROT_LIBRARY_INSTALLED
+    } else {
+#endif
+        entry = CONST_STRING(interp, "runtime/parrot/library/");
+        VTABLE_push_string(interp, paths, entry);
+        entry = CONST_STRING(interp, "runtime/parrot/");
+        VTABLE_push_string(interp, paths, entry);
+#ifdef ENABLE_PARROT_LIBRARY_INSTALLED
+    }
+#endif
     entry = CONST_STRING(interp, "./");
     VTABLE_push_string(interp, paths, entry);
-    entry = CONST_STRING(interp, "lib/parrot/library/");
-    VTABLE_push_string(interp, paths, entry);
-    entry = CONST_STRING(interp, "lib/parrot/");
-    VTABLE_push_string(interp, paths, entry);
 
     /* define dynext paths */
     paths = pmc_new(interp, enum_class_ResizableStringArray);
     VTABLE_set_pmc_keyed_int(interp, lib_paths,
             PARROT_LIB_PATH_DYNEXT, paths);
-    entry = CONST_STRING(interp, "runtime/parrot/dynext/");
-    VTABLE_push_string(interp, paths, entry);
+#ifdef ENABLE_PARROT_LIBRARY_INSTALLED
+    if (installed) {
+#endif
+        entry = CONST_STRING(interp, "lib/parrot/dynext/");
+        VTABLE_push_string(interp, paths, entry);
+#ifdef ENABLE_PARROT_LIBRARY_INSTALLED
+    } else {
+#endif
+        entry = CONST_STRING(interp, "runtime/parrot/dynext/");
+        VTABLE_push_string(interp, paths, entry);
+#ifdef ENABLE_PARROT_LIBRARY_INSTALLED
+    }
+#endif
     entry = CONST_STRING(interp, "");
     VTABLE_push_string(interp, paths, entry);
-    entry = CONST_STRING(interp, "lib/parrot/dynext/");
-    VTABLE_push_string(interp, paths, entry);
 
     /* shared exts */
     paths = pmc_new(interp, enum_class_ResizableStringArray);
@@ -202,7 +246,16 @@ parrot_init_library_paths(PARROT_INTERP)
 
 =item C<static PMC* get_search_paths>
 
-RT#48260: Not yet documented!!!
+Return lib_paths as array of StringArrays with library searchpaths and shared
+extension used for loading various files at runtime.
+The structure looks like this:
+
+  lib_paths = [
+    [ "runtime/parrot/include", ... ],   # paths for .include 'file'
+    [ "runtime/parrot/library", ... ],   # paths for load_bytecode
+    [ "runtime/parrot/dynext", ... ],    # paths for loadlib
+    [ ".so", ... ]                       # list of shared extensions
+  ]
 
 =cut
 
@@ -223,7 +276,9 @@ get_search_paths(PARROT_INTERP, enum_lib
 
 =item C<static int is_abs_path>
 
-RT#48260: Not yet documented!!!
+Determines whether a file name given by a fixed-8 or utf8 C<STRING> is an
+absolute file name. Returns C<1> if the filename is absolute, returns C<0>
+otherwise.
 
 =cut
 
@@ -244,7 +299,7 @@ is_abs_path(ARGIN(const STRING *file))
              (strncmp(file_name+1, ":\\", 2) == 0 ||
               strncmp(file_name+1, ":/",  2) == 0)))
 #else
-        if (file_name[0] == '/')     /* XXX  ../foo, ./bar */
+    if (file_name[0] == '/')     /* XXX  ../foo, ./bar */
 #endif
         {
             return 1;
@@ -287,7 +342,10 @@ cnv_to_win32_filesep(ARGMOD(STRING *path
 
 =item C<static STRING* path_finalize>
 
-RT#48260: Not yet documented!!!
+Ensures the given STRING C<path> has a C-style NULL character at the end. The
+length of the string is not increased to account for this NULL, however. In
+WIN32 systems, the path separator is switched from the unix-style "/" to the
+Windows-style "\".
 
 =cut
 
@@ -409,7 +467,9 @@ static const char* load_ext_code[ LOAD_E
 
 =item C<static STRING* try_load_path>
 
-RT#48260: Not yet documented!!!
+Attempts to load a file with name C<path>. If the file is successfully located,
+the finalized name of the file is returned as a STRING. Otherwise, returns
+NULL.
 
 =cut
 
Index: parrot-svn/config/gen/config_pm/config_lib.in
===================================================================
--- parrot-svn.orig/config/gen/config_pm/config_lib.in
+++ parrot-svn/config/gen/config_pm/config_lib.in
@@ -12,6 +12,7 @@ no_arg:
 
 	<<PCONFIG>>
 
+	set P0["installed"], I11
 	if I11, is_install
 	set S1, "<<PWD>>"
 	set P0["prefix"], S1
