diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/APIFile/File.pm perl-libwin32-0.191/APIFile/File.pm
--- libwin32-0.191/APIFile/File.pm	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/APIFile/File.pm	2004-01-12 16:46:39.312500000 -0800
@@ -5,12 +5,30 @@
 use strict;
 use Carp;
 use Fcntl qw( O_RDONLY O_RDWR O_WRONLY O_APPEND O_BINARY O_TEXT );
+use Config;
+use integer;
 use vars qw( $VERSION @ISA );
 use vars qw( @EXPORT @EXPORT_OK @EXPORT_FAIL %EXPORT_TAGS );
 $VERSION= '0.09';
 
-use base qw( Exporter DynaLoader );
+use base qw( Exporter DynaLoader Tie::Handle IO::File );
 
+use constant FALSE => 0;
+use constant TRUE  => 1;
+
+# Math::BigInt optimizations courtesy of Tels
+BEGIN {
+	require Math::BigInt;
+	Math::BigInt->import(lib => 'GMP') if $Math::BigInt::VERSION >= 1.60;
+}
+
+my $_64BITINT  = defined $Config{use64bitint} &&
+		 $Config{use64bitint} eq 'define';
+
+my $THIRTY_TWO = $_64BITINT ? 32 : new Math::BigInt 32;
+
+my $FFFFFFFF   = $_64BITINT ? 0xFFFFFFFF : new Math::BigInt 0xFFFFFFFF;
+		
 @EXPORT= qw();
 %EXPORT_TAGS= (
     Func =>	[qw(		attrLetsToBits		createFile
@@ -23,7 +41,8 @@
 	IsContainerPartition	MoveFile		MoveFileEx
 	OsFHandleOpen		OsFHandleOpenFd		QueryDosDevice
 	ReadFile		SetErrorMode		SetFilePointer
-	SetHandleInformation	WriteFile )],
+	SetHandleInformation	WriteFile		GetFileSize
+	getFileSize		setFilePointer		GetOverlappedResult)],
     FuncA =>	[qw(
 	CopyFileA		CreateFileA		DefineDosDeviceA
 	DeleteFileA		GetDriveTypeA		GetLogicalDriveStringsA
@@ -179,18 +198,29 @@
     return 0;
 }
 
-BEGIN {
-    my $code= 'return _fileLastError(@_)';
-    local( $!, $^E )= ( 1, 1 );
-    if(  $! ne $^E  ) {
-	$code= '
-	    local( $^E )= _fileLastError(@_);
-	    my $ret= $^E;
-	    return $ret;
-	';
-    }
-    eval "sub fileLastError { $code }";
-    die "$@"   if  $@;
+package Win32API::File::_error;
+
+use overload
+  '""' => sub {
+	use Win32;
+	$_ = Win32::FormatMessage(Win32API::File::_fileLastError());
+	tr/\r\n//d; return $_;
+  },
+  '0+' => sub { Win32API::File::_fileLastError() },
+  'fallback' => 1;
+
+sub new { return bless {}, shift }
+sub set { Win32API::File::_fileLastError($_[1]); return $_[0] }
+
+package Win32API::File;
+
+my $_error = new Win32API::File::_error;
+
+sub fileLastError {
+	croak 'Usage: ',__PACKAGE__,'::fileLastError( [$setWin32ErrCode] )'
+		if @_ > 1;
+	$_error->set($_[0]) if defined $_[0];
+	return $_error;
 }
 
 # Since we ISA DynaLoader which ISA AutoLoader, we ISA AutoLoader so we
@@ -259,9 +289,15 @@
 	$mode |= $o_text;
     }
     $mode |= O_BINARY   if  $access =~ /b/i;
-    my $fd= OsFHandleOpenFd( $osfh, $mode );
-    return  undef   if  $fd < 0;
-    return  open( $fh, $pref."&=".$fd );
+    undef $@;
+    my $fd = eval {
+	OsFHandleOpenFd( $osfh, $mode );
+    }; if ($@) {
+	return tie *{$fh}, __PACKAGE__, $osfh;
+    } else {
+	return  undef   if  $fd < 0;
+	return  open( $fh, $pref."&=".$fd );
+    }
 }
 
 sub GetOsFHandle {
@@ -274,7 +310,17 @@
 	    $file= caller() . "::" . $file;
 	}
 	no strict "refs";
-	$file= \*{$file};
+	 
+# The eval "" is necessary in Perl 5.6, avoid it otherwise.
+	my $tied = !defined($^]) || $^] < 5.008 ?
+		eval "tied *{$file}" :
+		tied *{$file};
+
+	if (UNIVERSAL::isa($tied => __PACKAGE__)) {
+		return $tied->win32_handle;
+	}
+
+	$file= *{$file};
     }
     my( $fd )= fileno($file);
     if(  ! defined( $fd )  ) {
@@ -293,6 +339,52 @@
     return $h;
 }
 
+sub getFileSize {
+	croak 'Win32API::File Usage:  $size= getFileSize($hNativeHandle)'
+		if @_ != 1;
+
+	my $handle    = shift;
+	my $high_size = 0;
+
+	my $low_size = GetFileSize($handle, $high_size);
+
+	my $retval = $_64BITINT ?
+		$high_size : new Math::BigInt $high_size;
+
+	$retval <<= $THIRTY_TWO;
+	$retval +=  $low_size;
+
+	return $retval;
+}
+
+sub setFilePointer {
+	croak 'Win32API::File Usage:  $pos= setFilePointer($hNativeHandle, $posl, $from_where)'
+		if @_ != 3;
+
+	my ($handle, $pos, $from_where) = @_;
+
+	my ($pos_low, $pos_high) = ($pos, 0);
+
+	if ($_64BITINT) {
+		$pos_low  = ($pos & $FFFFFFFF);
+		$pos_high = (($pos >> $THIRTY_TWO) & $FFFFFFFF);
+	} elsif (UNIVERSAL::isa($pos => 'Math::BigInt')) {
+		$pos_low  = ($pos & $FFFFFFFF)->numify();
+		$pos_high = (($pos >> $THIRTY_TWO) & $FFFFFFFF)->numify();
+	}
+
+	my $retval = SetFilePointer($handle, $pos_low, $pos_high, $from_where);
+
+	if (defined $pos_high && $pos_high != 0) {
+		$retval   = new Math::BigInt $retval   unless $_64BITINT;
+		$pos_high = new Math::BigInt $pos_high unless $_64BITINT;
+
+		$retval += $pos_high << $THIRTY_TWO;
+	}
+
+	return $retval;
+}
+
 sub attrLetsToBits
 {
     my( $lets )= @_;
@@ -443,6 +535,253 @@
     return $ref;
 }
 
+###############################################################################
+#   Experimental Tied Handle and Object Oriented interface.                   #
+###############################################################################
+
+sub new {
+	my $class = shift;
+	$class = ref $class || $class;
+
+	my $self = IO::File::new($class);
+	tie *$self, __PACKAGE__;
+
+	$self->open(@_) if @_;
+
+	return $self;
+}
+
+sub TIEHANDLE {
+	my ($class, $win32_handle) = @_;
+	$class = ref $class || $class;
+
+	return bless {
+		_win32_handle => $win32_handle,
+		_binmode      => FALSE,
+		_buffered     => FALSE,
+		_buffer       => '',
+		_eof          => FALSE,
+		_fileno       => undef,
+		_access       => 'r',
+		_append       => FALSE,
+	}, $class;
+}
+
+# This is called for getting the tied object from hard refs to glob refs in
+# some cases, for reasons I don't quite grok.
+
+sub FETCH { return $_[0] }
+
+# Public accessors
+
+sub win32_handle{ $_[0]->{_win32_handle}||= $_[1] }
+
+# Protected accessors
+
+sub _buffer	{ $_[0]->{_buffer}	||= $_[1] }
+sub _binmode	{ $_[0]->{_binmode}	||= $_[1] }
+sub _fileno	{ $_[0]->{_fileno}	||= $_[1] }
+sub _access	{ $_[0]->{_access}	||= $_[1] }
+sub _append	{ $_[0]->{_append}	||= $_[1] }
+
+# Tie interface
+
+sub OPEN {
+	my $self  = shift;
+	my $expr  = shift;
+	croak "Only the two argument form of open is supported at this time" if @_;
+# FIXME: this needs to parse the full Perl open syntax in $expr
+
+	my ($mixed, $mode, $path) =
+		($expr =~ /^\s* (\+)? \s* (<|>|>>)? \s* (.*?) \s*$/x);
+
+	croak "Unsupported open mode" if not $path;
+
+	my $access = 'r';
+	my $append = $mode eq '>>' ? TRUE : FALSE;
+
+	if ($mixed) {
+		$access = 'rw';
+	} elsif($mode eq '>') {
+		$access = 'w';
+	}
+
+	my $w32_handle = createFile($path, $access);
+
+	$self->win32_handle($w32_handle);
+
+	$self->seek(1,2) if $append;
+
+	$self->_access($access);
+	$self->_append($append);
+
+	return TRUE;
+}
+
+sub BINMODE {
+	$_[0]->_binmode(TRUE);
+}
+
+sub WRITE {
+	my ($self, $buf, $len, $offset, $overlap) = @_;
+
+	if ($offset) {
+		$buf = substr($buf, $offset);
+		$len = length($buf);
+	}
+
+	$len       = length($buf) if not defined $len;
+
+	$overlap   = [] if not defined $overlap;;
+
+	my $bytes_written = 0;
+
+	WriteFile (
+		$self->win32_handle, $buf, $len,
+		$bytes_written, $overlap
+	);
+
+	return $bytes_written;
+}
+
+sub PRINT {
+	my $self = shift;
+
+	my $buf = join defined $, ? $, : "" => @_;
+
+	$buf =~ s/\012/\015\012/sg unless $self->_binmode();
+
+	$buf .= $\ if defined $\;
+
+	$self->WRITE($buf, length($buf), 0);
+}
+
+sub READ {
+	my $self = shift;
+	my $into = \$_[0]; shift;
+	my ($len, $offset, $overlap) = @_;
+
+	my $buffer     = defined $self->_buffer ? $self->_buffer : "";
+	my $buf_length = length($buffer);
+	my $bytes_read = 0;
+	my $data;
+	$offset        = 0 if not defined $offset;
+
+	if ($buf_length >= $len) {
+		$data       = substr($buffer, 0, $len => "");
+		$bytes_read = $len;
+		$self->_buffer($buffer);
+	} else {
+		if ($buf_length > 0) {
+			$len -= $buf_length;
+			substr($$into, $offset) = $buffer;
+			$offset += $buf_length;
+		}
+
+		$overlap ||= [];
+
+		ReadFile (
+			$self->win32_handle, $data, $len,
+			$bytes_read, $overlap
+		);
+	}
+
+	$$into = "" if not defined $$into;
+
+	substr($$into, $offset) = $data;
+
+	return $bytes_read;
+}
+
+sub READLINE {
+	my $self = shift;
+	my $line = "";
+
+	while ((index $line, $/) == $[-1) { # read until end of line marker
+		my $char = $self->GETC();
+
+		last if !defined $char || $char eq '';
+
+		$line .= $char;
+	}
+
+	return undef if $line eq '';
+
+	return $line;
+}
+
+
+sub FILENO {
+	my $self = shift;
+
+	return $self->_fileno() if defined $self->_fileno();
+
+	return -1 if $^O eq 'cygwin';
+
+# FIXME: We don't always open the handle, better to query the handle or to set
+# the right access info at TIEHANDLE time.
+
+	my $access = $self->_access();
+	my $mode   = $access eq 'rw' ? O_RDWR :
+		$access eq 'w' ? O_WRONLY : O_RDONLY;
+
+	$mode |= O_APPEND if $self->_append();
+
+	$mode |= O_TEXT   if not $self->_binmode();
+
+	return $self->_fileno ( OsfHandleOpenFd (
+		$self->win32_handle, $mode
+	));
+}
+
+sub SEEK {
+	my ($self, $pos, $whence) = @_;
+
+	$whence = 0 if not defined $whence;
+	my @file_consts = map {
+		fileConstant($_)
+	} qw(FILE_BEGIN FILE_CURRENT FILE_END);
+
+	my $from_where = $file_consts[$whence];
+
+	return setFilePointer($self->win32_handle, $pos, $from_where);
+}
+
+sub TELL {
+# SetFilePointer with position 0 at FILE_CURRENT will return position.
+	return $_[0]->SEEK(0, 1);
+}
+
+sub EOF {
+	my $self = shift;
+
+	my $current = $self->TELL() + 0;
+	my $end     = getFileSize($self->win32_handle) + 0;
+
+	return $current == $end;
+}
+
+sub CLOSE {
+	my $self = shift;
+
+	my $retval = TRUE;
+	
+	if (defined $self->win32_handle) {
+		$retval = CloseHandle($self->win32_handle);
+
+		$self->win32_handle(undef);
+	}
+
+	return $retval;
+}
+
+# Only close the handle on explicit close, too many problems otherwise.
+sub UNTIE {}
+
+sub DESTROY {}
+
+# End of Tie/OO Interface
+
 # Autoload methods go after =cut, and are processed by the autosplit program.
 
 1;
@@ -476,6 +815,26 @@
 All functions, unless otherwise noted, return a true value for success
 and a false value for failure and set C<$^E> on failure.
 
+=head2 Object Oriented/Tied Handle Interface
+
+WARNING: this is new code, use at your own risk.
+
+This version of C<Win32API::File> can be used like an C<IO::File> object. Ie:
+
+  my $file = new Win32API::File "+> foo";
+  binmode $file;
+  print $file "hello there\n";
+  seek $file, 0, 0;
+  my $line = <$file>;
+  $file->close;
+
+It also supports tying via a win32 handle (for example, from C<createFile()>):
+
+  tie FILE, 'Win32API::File', $win32_handle;
+  print FILE "...";
+
+It has not been extensively tested yet and buffered I/O is not yet implemented.
+
 =head2 Exports
 
 Nothing is exported by default.  The following tags can be used to
@@ -500,7 +859,8 @@
 C<IsContainerPartition>,  C<MoveFile>,             C<MoveFileEx>,
 C<OsFHandleOpen>,         C<OsFHandleOpenFd>,      C<QueryDosDevice>,
 C<ReadFile>,              C<SetErrorMode>,         C<SetFilePointer>,
-C<SetHandleInformation>,  and                      C<WriteFile>.
+C<SetHandleInformation>,  C<GetFileSize>,          C<getFileSize>,
+C<setFilePointer>,        C<WriteFile> and         C<GetOverlappedResult>
 
 =over
 
@@ -1234,6 +1594,39 @@
 
 =back
 
+=item getFileSize
+
+=item C<$size= getFileSize( $hFile )>
+
+This is a Perl-friendly wrapper for the C<GetFileSize> (below) API call.
+
+It takes a Win32 native file handle and returns the size in bytes. Since the
+size can be a 64 bit value, on non 64 bit integer Perls the value returned will
+be an object of type C<Math::BigInt>.
+
+=item GetFileSize
+
+=item C<$iSizeLow= GetFileSize($win32Handle, $iSizeHigh)>
+
+Returns the size of a file pointed to by C<$win32Handle>, optionally storing
+the high order 32 bits into C<$iSizeHigh> if it is not C<[]>. If $iSizeHigh is
+C<[]>, a non-zero value indicates success. Otherwise, on failure the return
+value will be C<0xffffffff> and C<fileLastError()> will not be C<NO_ERROR>.
+
+=item GetOverlappedResult
+
+=item C<$bRetval= GetOverlappedResult( $win32Handle, $pOverlapped,
+ $numBytesTransferred, $bWait )>
+
+Used for asynchronous IO in Win32 to get the result of a pending IO operation,
+such as when a file operation returns C<ERROR_IO_PENDING>. Returns a false
+value on failure. The C<$overlapped> structure and C<$numBytesTransferred>
+will be modified with the results of the operation.
+
+As far as creating the C<$pOverlapped> structure, you are currently on your own.
+
+See L<http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/getoverlappedresult.asp> for more information.
+
 =item GetLogicalDrives
 
 =item C<$uDriveBits= GetLogicalDrives()>
@@ -1505,12 +1898,11 @@
 Opens a file descriptor [C<$ivFD>] based on an already open Win32
 native file handle, C<$hNativeHandle>.  This just calls the
 Win32-specific C routine C<_open_osfhandle()> or Perl's "improved"
-version called C<win32_open_osfhandle()>.  Prior to Perl5.005, C's
-C<_open_osfhandle()> is called which will fail if
-C<GetFileType($hNativeHandle)> would return C<FILE_TYPE_UNKNOWN>.  
-For Perl5.005 and later, C<OsFHandleOpenFd> calls
-C<win32_open_osfhandle()> from the Perl DLL which doesn't have this
-restriction.
+version called C<win32_open_osfhandle()>.  Prior to Perl5.005 and in Cygwin
+Perl, C's C<_open_osfhandle()> is called which will fail if
+C<GetFileType($hNativeHandle)> would return C<FILE_TYPE_UNKNOWN>.  For
+Perl5.005 and later, C<OsFHandleOpenFd> calls C<win32_open_osfhandle()> from
+the Perl DLL which doesn't have this restriction.
 
 C<$uMode> the logical combination of zero or more C<O_*> constants
 exported by the C<Fcntl> module.  Currently only C<O_APPEND> and
@@ -1632,6 +2024,15 @@
 
 =back
 
+=item setFilePointer
+
+=item C<$uNewPos= setFilePointer( $hFile, $ivOffset, $uFromWhere )>
+
+This is a perl-friendly wrapper for the SetFilePointer API (below).
+C<$ivOffset> can be a 64 bit integer or C<Math::BigInt> object if your Perl
+doesn't have 64 bit integers. The return value is the new offset and will
+likewise be a 64 bit integer or a C<Math::BigInt> object.
+
 =item SetFilePointer
 
 =item C<$uNewPos= SetFilePointer( $hFile, $ivOffset, $ioivOffsetHigh, $uFromWhere )>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/APIFile/File.xs perl-libwin32-0.191/APIFile/File.xs
--- libwin32-0.191/APIFile/File.xs	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/APIFile/File.xs	2004-01-12 16:46:39.328125000 -0800
@@ -1,38 +1,15 @@
 /* Win32API/File.xs */
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-/*#include "patchlevel.h"*/
+#include "../win32perl.h"
+#include <winioctl.h>
 
 /* Uncomment the next line unless set "WRITE_PERL=>1" in Makefile.PL: */
 #define NEED_newCONSTSUB
-#include "ppport.h"
-
-#ifdef WORD
-# undef WORD
-#endif
-
-#define  WIN32_LEAN_AND_MEAN	/* Tell windows.h to skip much */
-#include <windows.h>
-#include <winioctl.h>
 
 /*CONSTS_DEFINED*/
 
 #define oDWORD DWORD
 
-#if PERL_REVISION <= 5 && PERL_VERSION < 5
-/* Perl 5.005 added win32_get_osfhandle/win32_open_osfhandle */
-# define win32_get_osfhandle _get_osfhandle
-# define win32_open_osfhandle _open_osfhandle
-# ifdef _get_osfhandle
-#  undef _get_osfhandle	/* stolen_get_osfhandle() isn't available here */
-# endif
-# ifdef _open_osfhandle
-#  undef _open_osfhandle /* stolen_open_osfhandle() isn't available here */
-# endif
-#endif
-
 #ifndef DEBUGGING
 # define	Debug(list)	/*Nothing*/
 #else
@@ -129,10 +106,10 @@
 	    XSRETURN_NO;
 	} else if(  0 == RETVAL  ) {
 	    XSRETURN_PV( "0 but true" );
-	} else if(  (IV) RETVAL < 0  ) {
-	    XSRETURN_NV( (double) (IV) RETVAL );
+	} else if(  ((IV)(int)RETVAL) < 0  ) {
+	    XSRETURN_NV( (double) (IV)(DWORD)RETVAL );
 	} else {
-	    XSRETURN_IV( (IV) RETVAL );
+	    XSRETURN_IV( (IV)(DWORD)RETVAL );
 	}
 
 
@@ -153,10 +130,10 @@
 	    XSRETURN_NO;
 	} else if(  0 == RETVAL  ) {
 	    XSRETURN_PV( "0 but true" );
-	} else if(  (IV) RETVAL < 0  ) {
-	    XSRETURN_NV( (double) (IV) RETVAL );
+	} else if(  (IV)(int)RETVAL < 0  ) {
+	    XSRETURN_NV( (double) (IV)(DWORD)RETVAL );
 	} else {
-	    XSRETURN_IV( (IV) RETVAL );
+	    XSRETURN_IV( (IV)(DWORD)RETVAL );
 	}
 
 
@@ -476,11 +453,40 @@
 	opBuffer	trunc_buf_l( RETVAL, opBuffer,ST(1), olBytesRead );
 	olBytesRead
 
+BOOL
+GetOverlappedResult( hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait)
+	HANDLE hFile
+	LPOVERLAPPED lpOverlapped
+	LPDWORD lpNumberOfBytesTransferred
+	BOOL bWait
+    CODE:
+    	RETVAL= GetOverlappedResult( hFile, lpOverlapped,
+	 lpNumberOfBytesTransferred, bWait);
+	SaveErr( !RETVAL );
+    OUTPUT:
+    	RETVAL
+	lpOverlapped
+	lpNumberOfBytesTransferred
+
+DWORD
+GetFileSize( hFile, lpFileSizeHigh )
+	HANDLE hFile
+	LPDWORD lpFileSizeHigh
+    CODE:
+    	RETVAL= GetFileSize( hFile, lpFileSizeHigh );
+	SaveErr( NO_ERROR != GetLastError() );
+    OUTPUT:
+    	RETVAL
+	lpFileSizeHigh
+
 
 UINT
 SetErrorMode( uNewMode )
 	UINT	uNewMode
-
+    CODE:
+    	RETVAL= SetErrorMode( uNewMode );
+    OUTPUT:
+    	RETVAL
 
 LONG
 SetFilePointer( hFile, ivOffset, ioivOffsetHigh, uFromWhere )
@@ -490,7 +496,7 @@
 	DWORD	uFromWhere
     CODE:
 	RETVAL= SetFilePointer( hFile, ivOffset, ioivOffsetHigh, uFromWhere );
-	if(  ~0 == RETVAL  ) {
+	if(  RETVAL == INVALID_SET_FILE_POINTER && (GetLastError() != NO_ERROR)  ) {
 	    SaveErr( 1 );
 	    XST_mNO(0);
 	} else if(  0 == RETVAL  ) {
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/APIFile/MANIFEST perl-libwin32-0.191/APIFile/MANIFEST
--- libwin32-0.191/APIFile/MANIFEST	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/APIFile/MANIFEST	2004-01-12 16:46:39.328125000 -0800
@@ -8,8 +8,8 @@
 const2perl.h
 cFile.h
 cFile.pc
-ppport.h
 test.pl
+t/tie.t
 typemap
 ExtUtils/Myconst2perl.pm
 ex/CopyBoot.bat
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/APIFile/Makefile.PL perl-libwin32-0.191/APIFile/Makefile.PL
--- libwin32-0.191/APIFile/Makefile.PL	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/APIFile/Makefile.PL	2004-01-12 16:46:39.343750000 -0800
@@ -119,9 +119,9 @@
 
     push @m, "
 clean ::
-    $self->{RM_F} @clean\n"   if  @clean;
-    push @m, "
+	$self->{RM_F} @clean\n"   if  @clean;
+	push @m, "
 realclean ::
-    $self->{RM_F} @realclean\n"   if  @realclean;
-    return join('',@m);
+	$self->{RM_F} @realclean\n"   if  @realclean;
+	return join('',@m);
 }
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/APIFile/ppport.h perl-libwin32-0.191/APIFile/ppport.h
--- libwin32-0.191/APIFile/ppport.h	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/APIFile/ppport.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,283 +0,0 @@
-
-#ifndef _P_P_PORTABILITY_H_
-#define _P_P_PORTABILITY_H_
-
-/* Perl/Pollution/Portability Version 1.0007etm */
-
-/* Copyright (C) 1999, Kenneth Albanowski. This code may be used and
-   distributed under the same license as any version of Perl. */
-   
-/* For the latest version of this code, please retreive the Devel::PPPort
-   module from CPAN, contact the author at <kjahds@kjahds.com>, or check
-   with the Perl maintainers. */
-   
-/* If you needed to customize this file for your project, please mention
-   your changes, and visible alter the version number. */
-
-
-/*
-   In order for a Perl extension module to be as portable as possible
-   across differing versions of Perl itself, certain steps need to be taken.
-   Including this header is the first major one, then using dTHR is all the
-   appropriate places and using a PL_ prefix to refer to global Perl
-   variables is the second.
-*/
-
-
-/* If you use one of a few functions that were not present in earlier
-   versions of Perl, please add a define before the inclusion of ppport.h
-   for a static include, or use the GLOBAL request in a single module to
-   produce a global definition that can be referenced from the other
-   modules.
-   
-   Function:            Static define:           Extern define:
-   newCONSTSUB()        NEED_newCONSTSUB         NEED_newCONSTSUB_GLOBAL
-
-*/
- 
-
-/* To verify whether ppport.h is needed for your module, and whether any
-   special defines should be used, ppport.h can be run through Perl to check
-   your source code. Simply say:
-   
-   	perl -x ppport.h *.c *.h *.xs foo/*.c [etc]
-   
-   The result will be a list of patches suggesting changes that should at
-   least be acceptable, if not necessarily the most efficient solution, or a
-   fix for all possible problems. It won't catch where dTHR is needed, and
-   doesn't attempt to account for global macro or function definitions,
-   nested includes, typemaps, etc.
-   
-   In order to test for the need of dTHR, please try your module under a
-   recent version of Perl that has threading compiled-in.
- 
-*/ 
-
-
-/*
-#!/usr/bin/perl
-@ARGV = ("*.xs") if !@ARGV;
-%badmacros = %funcs = %macros = (); $replace = 0;
-foreach (<DATA>) {
-	$funcs{$1} = 1 if /Provide:\s+(\S+)/;
-	$macros{$1} = 1 if /^#\s*define\s+([a-zA-Z0-9_]+)/;
-	$replace = $1 if /Replace:\s+(\d+)/;
-	$badmacros{$2}=$1 if $replace and /^#\s*define\s+([a-zA-Z0-9_]+).*?\s+([a-zA-Z0-9_]+)/;
-	$badmacros{$1}=$2 if /Replace (\S+) with (\S+)/;
-}
-foreach $filename (map(glob($_),@ARGV)) {
-	unless (open(IN, "<$filename")) {
-		warn "Unable to read from $file: $!\n";
-		next;
-	}
-	print "Scanning $filename...\n";
-	$c = ""; while (<IN>) { $c .= $_; } close(IN);
-	$need_include = 0; %add_func = (); $changes = 0;
-	$has_include = ($c =~ /#.*include.*ppport/m);
-
-	foreach $func (keys %funcs) {
-		if ($c =~ /#.*define.*\bNEED_$func(_GLOBAL)?\b/m) {
-			if ($c !~ /\b$func\b/m) {
-				print "If $func isn't needed, you don't need to request it.\n" if
-				$changes += ($c =~ s/^.*#.*define.*\bNEED_$func\b.*\n//m);
-			} else {
-				print "Uses $func\n";
-				$need_include = 1;
-			}
-		} else {
-			if ($c =~ /\b$func\b/m) {
-				$add_func{$func} =1 ;
-				print "Uses $func\n";
-				$need_include = 1;
-			}
-		}
-	}
-
-	if (not $need_include) {
-		foreach $macro (keys %macros) {
-			if ($c =~ /\b$macro\b/m) {
-				print "Uses $macro\n";
-				$need_include = 1;
-			}
-		}
-	}
-
-	foreach $badmacro (keys %badmacros) {
-		if ($c =~ /\b$badmacro\b/m) {
-			$changes += ($c =~ s/\b$badmacro\b/$badmacros{$badmacro}/gm);
-			print "Uses $badmacros{$badmacro} (instead of $badmacro)\n";
-			$need_include = 1;
-		}
-	}
-	
-	if (scalar(keys %add_func) or $need_include != $has_include) {
-		if (!$has_include) {
-			$inc = join('',map("#define NEED_$_\n", sort keys %add_func)).
-			       "#include \"ppport.h\"\n";
-			$c = "$inc$c" unless $c =~ s/#.*include.*XSUB.*\n/$&$inc/m;
-		} elsif (keys %add_func) {
-			$inc = join('',map("#define NEED_$_\n", sort keys %add_func));
-			$c = "$inc$c" unless $c =~ s/^.*#.*include.*ppport.*$/$inc$&/m;
-		}
-		if (!$need_include) {
-			print "Doesn't seem to need ppport.h.\n";
-			$c =~ s/^.*#.*include.*ppport.*\n//m;
-		}
-		$changes++;
-	}
-	
-	if ($changes) {
-		open(OUT,">/tmp/ppport.h.$$");
-		print OUT $c;
-		close(OUT);
-		open(DIFF, "diff -u $filename /tmp/ppport.h.$$|");
-		while (<DIFF>) { s!/tmp/ppport\.h\.$$!$filename.patched!; print STDOUT; }
-		close(DIFF);
-		unlink("/tmp/ppport.h.$$");
-	} else {
-		print "Looks OK\n";
-	}
-}
-__DATA__
-*/
-
-#ifndef PERL_REVISION
-#   ifndef __PATCHLEVEL_H_INCLUDED__
-#       include "patchlevel.h"
-#   endif
-#   ifndef PERL_REVISION
-#	define PERL_REVISION	(5)
-        /* Replace: 1 */
-#       define PERL_VERSION	PATCHLEVEL
-#       define PERL_SUBVERSION	SUBVERSION
-        /* Replace PERL_PATCHLEVEL with PERL_VERSION */
-        /* Replace: 0 */
-#   endif
-#endif
-
-#define PERL_BCDVERSION ((PERL_REVISION * 0x1000000L) + (PERL_VERSION * 0x1000L) + PERL_SUBVERSION)
-
-#ifndef ERRSV
-#	define ERRSV perl_get_sv("@",FALSE)
-#endif
-
-#if (PERL_VERSION < 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION <= 5))
-/* Replace: 1 */
-#	define PL_sv_undef	sv_undef
-#	define PL_sv_yes	sv_yes
-#	define PL_sv_no		sv_no
-#	define PL_na		na
-#	define PL_stdingv	stdingv
-#	define PL_hints		hints
-#	define PL_curcop	curcop
-#	define PL_curstash	curstash
-#	define PL_copline	copline
-#	define PL_Sv		Sv
-/* Replace: 0 */
-#endif
-
-#ifndef dTHR
-#  ifdef WIN32
-#	define dTHR extern int Perl___notused
-#  else
-#	define dTHR extern int errno
-#  endif
-#endif
-
-#ifndef boolSV
-#	define boolSV(b) ((b) ? &PL_sv_yes : &PL_sv_no)
-#endif
-
-#ifndef gv_stashpvn
-#	define gv_stashpvn(str,len,flags) gv_stashpv(str,flags)
-#endif
-
-#ifndef newSVpvn
-#	define newSVpvn(data,len) ((len) ? newSVpv ((data), (len)) : newSVpv ("", 0))
-#endif
-
-#ifndef newRV_inc
-/* Replace: 1 */
-#	define newRV_inc(sv) newRV(sv)
-/* Replace: 0 */
-#endif
-
-#ifndef newRV_noinc
-#  ifdef __GNUC__
-#    define newRV_noinc(sv)               \
-      ({                                  \
-          SV *nsv = (SV*)newRV(sv);       \
-          SvREFCNT_dec(sv);               \
-          nsv;                            \
-      })
-#  else
-#    if defined(CRIPPLED_CC) || defined(USE_THREADS)
-static SV * newRV_noinc (SV * sv)
-{
-          SV *nsv = (SV*)newRV(sv);       
-          SvREFCNT_dec(sv);               
-          return nsv;                     
-}
-#    else
-#      define newRV_noinc(sv)    \
-        ((PL_Sv=(SV*)newRV(sv), SvREFCNT_dec(sv), (SV*)PL_Sv)
-#    endif
-#  endif
-#endif
-
-/* Provide: newCONSTSUB */
-
-/* newCONSTSUB from IO.xs is in the core starting with 5.004_63 */
-#if (PERL_VERSION < 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION < 63))
-
-#if defined(NEED_newCONSTSUB)
-static
-#else
-extern void newCONSTSUB _((HV * stash, char * name, SV *sv));
-#endif
-
-#if defined(NEED_newCONSTSUB) || defined(NEED_newCONSTSUB_GLOBAL)
-void
-newCONSTSUB( HV *stash, char *name, SV *sv )
-{
-	U32 oldhints = PL_hints;
-	HV *old_cop_stash = PL_curcop->cop_stash;
-	HV *old_curstash = PL_curstash;
-	line_t oldline = PL_curcop->cop_line;
-	PL_curcop->cop_line = PL_copline;
-
-	PL_hints &= ~HINT_BLOCK_SCOPE;
-	if (stash)
-		PL_curstash = PL_curcop->cop_stash = stash;
-
-	newSUB(
-
-#if (PERL_VERSION < 3) || ((PERL_VERSION == 3) && (PERL_SUBVERSION < 22))
-     /* before 5.003_22 */
-		start_subparse(),
-#else
-#  if (PERL_VERSION == 3) && (PERL_SUBVERSION == 22)
-     /* 5.003_22 */
-     		start_subparse(0),
-#  else
-     /* 5.003_23  onwards */
-     		start_subparse(FALSE, 0),
-#  endif
-#endif
-
-		newSVOP(OP_CONST, 0, newSVpv(name,0)),
-		newSVOP(OP_CONST, 0, &PL_sv_no),   /* SvPV(&PL_sv_no) == "" -- GMB */
-		newSTATEOP(0, Nullch, newSVOP(OP_CONST, 0, sv))
-	);
-
-	PL_hints = oldhints;
-	PL_curcop->cop_stash = old_cop_stash;
-	PL_curstash = old_curstash;
-	PL_curcop->cop_line = oldline;
-}
-#endif
-
-#endif /* newCONSTSUB */
-
-
-#endif /* _P_P_PORTABILITY_H_ */
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/APIFile/t/tie.t perl-libwin32-0.191/APIFile/t/tie.t
--- libwin32-0.191/APIFile/t/tie.t	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/APIFile/t/tie.t	2004-01-12 16:46:39.375000000 -0800
@@ -0,0 +1,79 @@
+#!perl
+# vim:syntax=perl:
+
+BEGIN { $|= 1; print "1..10\n"; }
+END   { print "not ok 1\n" unless $main::loaded; }
+
+use strict;
+use warnings;
+use Win32API::File qw(:ALL);
+use IO::File;
+
+$main::loaded = 1;
+
+print "ok 1\n";
+
+unlink "foo.txt";
+
+my $fh = new Win32API::File "+> foo.txt"
+	or die fileLastError();
+
+my $tell = tell $fh;
+print "# tell \$fh == '$tell'\n";
+print "not " unless
+	tell $fh == 0;
+print "ok 2\n";
+
+my $text = "some text\n";
+
+print "not " unless
+	print $fh $text;
+print "ok 3\n";
+
+$tell = tell $fh;
+print "# after printing 'some text\\n', tell is: '$tell'\n";
+print "not " unless
+	$tell == length($text) + 1;
+print "ok 4\n";
+
+print "not " unless
+	seek($fh, 0, 0) == 0;
+print "ok 5\n";
+
+print "not " unless
+	not eof $fh;
+print "ok 6\n";
+
+my $readline = <$fh>;
+
+my $pretty_readline = $readline;
+$pretty_readline =~ s/\r/\\r/g;  $pretty_readline =~ s/\n/\\n/g;  
+print "# read line is '$pretty_readline'\n";
+
+print "not " unless
+	$readline eq "some text\r\n";
+print "ok 7\n";
+
+print "not " unless
+	eof $fh;
+print "ok 8\n";
+
+print "not " unless
+	close $fh;
+print "ok 9\n";
+
+# Test out binmode (should be only LF with print, no CR).
+
+$fh = new Win32API::File "+> foo.txt"
+	or die fileLastError();
+binmode $fh;
+print $fh "hello there\n";
+seek $fh, 0, 0;
+
+print "not " unless
+	<$fh> eq "hello there\n";
+print "ok 10\n";
+
+close $fh;
+
+unlink "foo.txt";
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/APIFile/test.pl perl-libwin32-0.191/APIFile/test.pl
--- libwin32-0.191/APIFile/test.pl	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/APIFile/test.pl	2004-01-12 16:46:39.390625000 -0800
@@ -1,22 +1,17 @@
-#!/usr/bin/perl -w
-# Before `make install' is performed this script should be runnable with
-# `make test'. After `make install' it should work as `perl test.pl'
+#!perl
+# vim:syntax=perl:
 
 ######################### We start with some black magic to print on failure.
 
-BEGIN { $|= 1; print "1..245\n"; }
+BEGIN { $|= 1; print "1..249\n"; }
 END {print "not ok 1\n" unless $loaded;}
 use Win32API::File qw(:ALL);
+use Cwd;
 $loaded = 1;
 print "ok 1\n";
 
 ######################### End of black magic.
 
-$Debug=  ( -t STDIN ) != ( -t STDOUT );
-if(  $Debug  ) {
-    warn "# Running tests in debug mode ",
-      "since exactly one of STDIN/STDOUT is a tty.\n";
-}
 $test= 1;
 
 use strict qw(subs);
@@ -27,20 +22,23 @@
 $temp= "."		unless -d $temp;
 $dir= "W32ApiF.tmp";
 
+$ENV{WINDIR} = $ENV{SYSTEMROOT} if not exists $ENV{WINDIR};
+
 chdir( $temp )
   or  die "# Can't cd to temp directory, $temp: $!\n";
 
 if(  -d $dir  ) {
-    if(  glob( "$dir/*" )  ) {
-	system( "attrib -r -h -s $dir\\*" );
-	$Debug && warn "# echo y | del $temp\\$dir\\*\n";
-	system( "echo y | del $dir\\*" );
+    print "# deleting $temp\\$dir\\*\n" if glob "$dir/*";
+
+    for (glob "$dir/*") {
+	chmod 0777, $_;
+	unlink $_;
     }
-    system( "rd $dir" );
+    rmdir $dir or die "Could not rmdir $dir: $!";
 }
 mkdir( $dir, 0777 )
   or  die "# Can't create temp dir, $temp/$dir: $!\n";
-$Debug && warn "# chdir $temp\\$dir\n";
+print "# chdir $temp/$dir\n";
 chdir( $dir )
   or  die "# Can't cd to my dir, $temp/$dir: $!\n";
 
@@ -50,104 +48,110 @@
 if(  ! $ok  ) {   CloseHandle($h1);   unlink("ReadOnly.txt");   }
 
 $ok= $h1= createFile( "ReadOnly.txt", "wcn", { Attributes=>"r" } );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 3
 
 $ok= WriteFile( $h1, "Original text\n", 0, [], [] );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 4
 
 $h2= createFile( "ReadOnly.txt", "rcn" );
 $ok= ! $h2  &&  fileLastError() =~ /file exists?/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 5
 if(  ! $ok  ) {   CloseHandle($h2);   }
 
 $h2= createFile( "ReadOnly.txt", "rwke" );
 $ok= ! $h2  &&  fileLastError() =~ /access is denied?/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 6
 if(  ! $ok  ) {   CloseHandle($h2);   }
 
 $ok= $h2= createFile( "ReadOnly.txt", "r" );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 7
 
 $ok= SetFilePointer( $h1, length("Original"), [], FILE_BEGIN );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 8
 
 $ok= WriteFile( $h1, "ly was other text\n", 0, $len, [] )
   &&  $len == length("ly was other text\n");
-$Debug && !$ok && warn "# <$len> should be <",
+!$ok && print "# <$len> should be <",
   length("ly was other text\n"),">: ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 9
 
 $ok= ReadFile( $h2, $text, 80, $len, [] )
  &&  $len == length($text);
-$Debug && !$ok && warn "# <$len> should be <",length($text),
+!$ok && print "# <$len> should be <",length($text),
   ">: ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 10
 
 $ok= $text eq "Originally was other text\n";
-if(  $Debug  &&  ! $ok  ) {
+if(   ! $ok  ) {
     $text =~ s/\r/\\r/g;   $text =~ s/\n/\\n/g;
-    warn "# <$text> should be <Originally was other text\\n>.\n";
+    print "# <$text> should be <Originally was other text\\n>.\n";
 }
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 11
 
 $ok= CloseHandle($h2);
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 12
 
 $ok= ! ReadFile( $h2, $text, 80, $len, [] )
  &&  fileLastError() =~ /handle is invalid?/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 13
 
 CloseHandle($h1);
 
 $ok= $h1= createFile( "CanWrite.txt", "rw", FILE_SHARE_WRITE,
 	      { Create=>CREATE_ALWAYS } );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 14
 
 $ok= WriteFile( $h1, "Just this and not this", 10, [], [] );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 15
 
 $ok= $h2= createFile( "CanWrite.txt", "wk", { Share=>"rw" } );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 16
 
 $ok= OsFHandleOpen( "APP", $h2, "wat" );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 17
 
 $ok=  $h2 == GetOsFHandle( "APP" );
-$Debug && !$ok && warn "# $h2 != ",GetOsFHandle("APP"),"\n";
+!$ok && print "# $h2 != ",GetOsFHandle("APP"),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 18
 
-{   my $save= select(APP);   $|= 1;  select($save);   }
+{   my $save= select(APP) ;   $|= 1;  select($save);   }
 $ok= print APP "is enough\n";
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "#-> ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 19
 
-$ok= ReadFile( $h1, $text, 0, [], [] );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+SetFilePointer($h1, 0, [], FILE_BEGIN) if $^O eq 'cygwin';
+
+$ok= ReadFile( $h1, $text, 0, [], []);
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 20
 
-$ok=  $text eq "is enough\r\n";
-if(  $Debug  &&  ! $ok  ) {
-    $text =~ s/\r/\\r/g;
-    $text =~ s/\n/\\n/g;
-    warn "# <$text> should be <is enough\\r\\n>\n";
+$ok=  $text eq "is enough\015\012";
+if(   ! $ok  ) {
+    $text     =~ s/\r/\\r/g; $text     =~ s/\n/\\n/g;
+    print "# <$text> should be <is enough\\r\\n>\n";
 }
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 21
 
-$ok= ! unlink( "CanWrite.txt" )
- &&  $! =~ /permission denied/i;
-$Debug && !$ok && warn "# $!\n";
+if ($^O eq 'cygwin') {
+	$ok = 1;
+	print "# skipped on cygwin\n";
+} else {
+	unlink("CanWrite.txt");
+	$ok= -e "CanWrite.txt" &&  $! =~ /permission denied/i;
+	!$ok && print "# $!\n";
+}
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 22
 
 close(APP);		# Also does C<CloseHandle($h2)>
@@ -156,73 +160,73 @@
 
 $ok= ! DeleteFile( "ReadOnly.txt" )
  &&  fileLastError() =~ /access is denied?/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 23
 
 $ok= ! CopyFile( "ReadOnly.txt", "CanWrite.txt", 1 )
  &&  fileLastError() =~ /file exists?/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 24
 
 $ok= ! CopyFile( "CanWrite.txt", "ReadOnly.txt", 0 )
  &&  fileLastError() =~ /access is denied?/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 25
 
 $ok= ! MoveFile( "NoSuchFile", "NoSuchDest" )
  &&  fileLastError() =~ /not find the file/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 26
 
 $ok= ! MoveFileEx( "NoSuchFile", "NoSuchDest", 0 )
  &&  fileLastError() =~ /not find the file/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 27
 
 $ok= ! MoveFile( "ReadOnly.txt", "CanWrite.txt" )
  &&  fileLastError() =~ /file already exists?/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 28
 
 $ok= ! MoveFileEx( "ReadOnly.txt", "CanWrite.txt", 0 )
  &&  fileLastError() =~ /file already exists?/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 29
 
 $ok= CopyFile( "ReadOnly.txt", "ReadOnly.cp", 1 )
  &&  CopyFile( "CanWrite.txt", "CanWrite.cp", 1 );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 30
 
 $ok= ! MoveFileEx( "CanWrite.txt", "ReadOnly.cp", MOVEFILE_REPLACE_EXISTING )
- &&  fileLastError() =~ /access is denied?|cannot create/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+ &&  fileLastError() =~ /access is denied?|cannot create|cannot access/i;
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 31
 
 $ok= MoveFileEx( "ReadOnly.cp", "CanWrite.cp", MOVEFILE_REPLACE_EXISTING );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 32
 
 $ok= MoveFile( "CanWrite.cp", "Moved.cp" );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 33
 
 $ok= ! unlink( "ReadOnly.cp" )
  &&  $! =~ /no such file/i
  &&  ! unlink( "CanWrite.cp" )
  &&  $! =~ /no such file/i;
-$Debug && !$ok && warn "# $!\n";
+!$ok && print "# $!\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 34
 
 $ok= ! DeleteFile( "Moved.cp" )
  &&  fileLastError() =~ /access is denied?/i;
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 35
 
-system( "attrib -r Moved.cp" );
+chmod 0777, "Moved.cp";
 
 $ok= DeleteFile( "Moved.cp" );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 36
 
 $new= SEM_FAILCRITICALERRORS|SEM_NOOPENFILEERRORBOX;
@@ -231,45 +235,45 @@
 $reold= SetErrorMode( $old );
 
 $ok= $old == $reold;
-$Debug && !$ok && warn "# $old != $reold: ",fileLastError(),"\n";
+!$ok && print "# $old != $reold: ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 37
 
 $ok= ($renew&$new) == $new;
-$Debug && !$ok && warn "# $new != $renew: ",fileLastError(),"\n";
+!$ok && print "# $new != $renew: ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 38
 
 $ok= @drives= getLogicalDrives();
-$Debug && $ok && warn "# @drives\n";
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+$ok && print "# @drives\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 39
 
 $ok=  $drives[0] !~ /^[ab]/  ||  DRIVE_REMOVABLE == GetDriveType($drives[0]);
-$Debug && !$ok && warn "# ",DRIVE_REMOVABLE," != ",GetDriveType($drives[0]),
+!$ok && print "# ",DRIVE_REMOVABLE," != ",GetDriveType($drives[0]),
   ": ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 40
 
-$drive= substr( $ENV{windir}, 0, 3 );
+$drive= substr( $ENV{WINDIR}, 0, 3 );
 
 $ok= 1 == grep /^\Q$drive\E/i, @drives;
-$Debug && !$ok && warn "# No $drive found in list of drives.\n";
+!$ok && print "# No $drive found in list of drives.\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 41
 
 $ok= DRIVE_FIXED == GetDriveType( $drive );
-$Debug && !$ok && warn
+!$ok && print
   "# ",DRIVE_FIXED," != ",GetDriveType($drive),": ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 42
 
 $ok=  GetVolumeInformation( $drive, $vol, 64, $ser, $max, $flag, $fs, 16 );
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 43
-$vol= $ser= $max= $flag= $fs= "";	# Prevent warnings.
+$vol= $ser= $max= $flag= $fs= "";	# Prevent printings.
 
 chop($drive);
 $ok= QueryDosDevice( $drive, $dev, 80 );
-$Debug && !$ok && warn "# $drive: ",fileLastError(),"\n";
-if(  $Debug  &&  $ok  ) {
+!$ok && print "# $drive: ",fileLastError(),"\n";
+if(   $ok  ) {
     ( $text= $dev ) =~ s/\0/\\0/g;
-    warn "# $drive => $text\n";
+    print "# $drive => $text\n";
 }
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 44
 
@@ -281,41 +285,41 @@
     $bit >>= 1;
 }
 $let= pack( "C", $let + unpack("C","A") ) . ":";
-$Debug && warn "# Querying undefined $let.\n";
+print "# Querying undefined $let.\n";
 
-$ok= DefineDosDevice( 0, $let, $ENV{windir} );
-$Debug && !$ok && warn "# $let,$ENV{windir}: ",fileLastError(),"\n";
+$ok= DefineDosDevice( 0, $let, $ENV{WINDIR} );
+!$ok && print "# $let,$ENV{WINDIR}: ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 45
 
-$ok=  -s $let."/Win.ini"  ==  -s $ENV{windir}."/Win.ini";
-$Debug && !$ok && warn "# ", -s $let."/Win.ini", " vs. ",
-  -s $ENV{windir}."/Win.ini", ": ",fileLastError(),"\n";
+$ok=  -s $let."/Win.ini"  ==  -s $ENV{WINDIR}."/Win.ini";
+!$ok && print "# ", -s $let."/Win.ini", " vs. ",
+  -s $ENV{WINDIR}."/Win.ini", ": ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 46
 
 $ok= DefineDosDevice( DDD_REMOVE_DEFINITION|DDD_EXACT_MATCH_ON_REMOVE,
-		      $let, $ENV{windir} );
-$Debug && !$ok && warn "# $let,$ENV{windir}: ",fileLastError(),"\n";
+		      $let, $ENV{WINDIR} );
+!$ok && print "# $let,$ENV{WINDIR}: ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 47
 
 $ok= ! -f $let."/Win.ini"
   &&  $! =~ /no such file/i;
-$Debug && !$ok && warn "# $!\n";
+!$ok && print "# $!\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 48
 
 $ok= DefineDosDevice( DDD_RAW_TARGET_PATH, $let, $dev );
-if(  $Debug  &&  !$ok  ) {
+if(   !$ok  ) {
     ( $text= $dev ) =~ s/\0/\\0/g;
-    warn "# $let,$text: ",fileLastError(),"\n";
+    print "# $let,$text: ",fileLastError(),"\n";
 }
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 49
 
-$ok= -f $let.substr($ENV{windir},3)."/win.ini";
-$Debug && !$ok && warn "# ",fileLastError(),"\n";
+$ok= -f $let.substr($ENV{WINDIR},3)."/win.ini";
+!$ok && print "# ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 50
 
 $ok= DefineDosDevice( DDD_REMOVE_DEFINITION|DDD_EXACT_MATCH_ON_REMOVE
 		     |DDD_RAW_TARGET_PATH, $let, $dev );
-$Debug && !$ok && warn "# $let,$dev: ",fileLastError(),"\n";
+!$ok && print "# $let,$dev: ",fileLastError(),"\n";
 print $ok ? "" : "not ", "ok ", ++$test, "\n";	# ok 51
 
 #	DefineDosDevice
@@ -345,7 +349,7 @@
     } else {
 	$ok=  ! eval("$func()")  &&  $@ =~ /(::|\s)_?${func}A?[(:\s]/;
     }
-    $Debug && !$ok && warn "# $func: $@\n";
+    !$ok && print "# $func: $@\n";
     print $ok ? "" : "not ", "ok ", ++$test, "\n";
 }
 
@@ -353,19 +357,22 @@
                 @{$Win32API::File::EXPORT_TAGS{FuncW}} ) {
     $ok=  ! eval("$func()")  &&  $@ =~ /::_?${func}\(/;
     delete $consts{$func};
-    $Debug && !$ok && warn "# $func: $@\n";
+    !$ok && print "# $func: $@\n";
     print $ok ? "" : "not ", "ok ", ++$test, "\n";
 }
 
 foreach $const ( keys(%consts) ) {
     $ok= eval("my \$x= $const(); 1");
-    $Debug && !$ok && warn "# Constant $const: $@\n";
+    !$ok && print "# Constant $const: $@\n";
     print $ok ? "" : "not ", "ok ", ++$test, "\n";
 }
 
 chdir( $temp );
-system( "attrib -r $dir\\ReadOnly.txt" );
-unlink "$dir/CanWrite.txt", "$dir/ReadOnly.txt";
-system( "rd $dir" );
+if (-e "$dir/ReadOnly.txt") {
+    chmod 0777, "$dir/ReadOnly.txt";
+    unlink "$dir/ReadOnly.txt";
+}
+unlink "$dir/CanWrite.txt" if -e "$dir/CanWrite.txt";
+rmdir $dir;
 
 __END__
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/APIFile/typemap perl-libwin32-0.191/APIFile/typemap
--- libwin32-0.191/APIFile/typemap	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/APIFile/typemap	2004-01-12 16:46:39.390625000 -0800
@@ -15,8 +15,10 @@
 ValEntW *		T_BUF
 SECURITY_DESCRIPTOR *	T_BUF
 SECURITY_ATTRIBUTES *	T_BUF
+LPOVERLAPPED		T_BUF
 LONG *			T_IVBUF
 DWORD *			T_UVBUF
+LPDWORD		T_UVBUF
 oDWORD *		O_UVBUF
 HKEY *			T_UVBUFP
 oHKEY *			O_UVBUFP
@@ -36,7 +38,7 @@
 T_IV
 	$var= null_arg($arg) ? ($type)0 : ($type)SvIV($arg)
 T_UV
-	$var= null_arg($arg) ? ($type)0 : ($type)SvUV($arg)
+	$var= null_arg($arg) ? ($type)0 : ($type)(DWORD)SvUV($arg)
 O_IV
 	$var= optIV($arg)
 O_UV
@@ -105,7 +107,7 @@
 	    sv_setiv( $arg, (IV)$var );
 T_UV
 	if(  ! null_arg($arg)  &&  ! SvREADONLY($arg)  )
-	    sv_setuv( $arg, (UV)$var );
+	    sv_setuv( $arg, (UV)(DWORD)$var );
 O_IV
 	if(  ! null_arg($arg)  )
 	    sv_setiv( $arg, (IV)$var );
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/APINet/Net.xs perl-libwin32-0.191/APINet/Net.xs
--- libwin32-0.191/APINet/Net.xs	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/APINet/Net.xs	2004-01-12 16:46:39.406250000 -0800
@@ -1,22 +1,20 @@
-#include <windows.h>
-#include <winsock.h>
+#include "../win32perl.h"
+
+#ifndef __CYGWIN__
+#  include <winsock.h>
+#endif
+
 #include <lmcons.h>    /* LAN Manager common definitions */
 #include <lmerr.h>    /* LAN Manager network error definitions */
-#include <lmUseFlg.h>
-#include <lmAccess.h>
-#include <lmAPIBuf.h>
+#include <lmuseflg.h>
+#include <lmaccess.h>
+#include <lmapibuf.h>
 #include <lmwksta.h>
 #undef LPTSTR
 #define LPTSTR LPWSTR
-#include <lmServer.h>
+#include <lmserver.h>
 #undef LPTSTR
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
-
 static int
 not_here(char *s)
 {
@@ -485,7 +483,7 @@
     if (name != NULL) { // && *name != '\0') {
 	length = strlen(name)+1;
 	Newz(0, lpPtr, length, WCHAR);
-	MultiByteToWideChar(CP_ACP, NULL, name, -1, lpPtr,
+	MultiByteToWideChar(CP_ACP, 0, name, -1, lpPtr,
 				length * sizeof(WCHAR));
     }
     return lpPtr;
@@ -530,7 +528,7 @@
 	    croak("Value in logonHours should be an array reference,");	\
 	while (i < n) {							\
 	    if ((svTmp = av_fetch((AV*)svPtrIndirect, i, 0)) != NULL)	\
-		(BYTE)(((CAST)uiX)->field)[i] = SvIV(*svTmp);		\
+		(BYTE)(((CAST)uiX)->field)[i] = (BYTE)SvIV(*svTmp);	\
 	    else							\
 		(BYTE)(((CAST)uiX)->field)[i] = 0;			\
 	    i++;							\
@@ -893,7 +891,7 @@
 WCTMB(LPWSTR lpwStr, LPSTR lpStr, int size)
 {
     *lpStr = '\0';
-    return WideCharToMultiByte(CP_ACP, NULL, lpwStr, -1, lpStr, size,
+    return WideCharToMultiByte(CP_ACP, 0, lpwStr, -1, lpStr, size,
 			       NULL, NULL);
 }
 
@@ -1224,8 +1222,7 @@
     {
 	LPWSTR lpwServer = MBTWC(server);
 	PUSER_INFO_0 pwzUsers = NULL;
-	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0;
-	int index;
+	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0, index;
 	DWORD lastError = 0;
 	char tmpBuf[UNLEN+1];
 
@@ -1273,8 +1270,7 @@
 	LPWSTR lpwServer = MBTWC(server);
 	LPWSTR lpwUser = MBTWC(user);
 	PGROUP_INFO_0 pwzGroups;
-	DWORD entriesRead = 0, totalEntries = 0;
-	int index, len = PREFLEN;
+	DWORD entriesRead = 0, totalEntries = 0, index, len = PREFLEN;
 	DWORD lastError = 0;
 	char tmpBuf[UNLEN+1];
 
@@ -1366,8 +1362,7 @@
 	LPWSTR lpwServer = MBTWC(server);
 	LPWSTR lpwUser = MBTWC(user);
 	LPLOCALGROUP_USERS_INFO_0 pwzLocalGroupUsers=NULL;
-	DWORD entriesRead = 0, totalEntries = 0;
-	int index, len = PREFLEN;
+	DWORD entriesRead = 0, totalEntries = 0, index, len = PREFLEN;
 	char tmpBuf[UNLEN+1];
 	DWORD lastError = 0;
 
@@ -1457,7 +1452,6 @@
 	LPWSTR lpwServer = MBTWC(server);
 	LPWSTR lpwUser = MBTWC(user);
 	LPBYTE *uiX = NULL;
-	SV        **svPtr;
 	DWORD lastError = 0;
 
 	if (!(hash && SvROK(hash) &&
@@ -1590,8 +1584,7 @@
     {
 	LPWSTR lpwServer = MBTWC(server);
 	PGROUP_INFO_0 pwzGroups;
-	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0;
-	int index, len;
+	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0, index;
 	DWORD lastError = 0;
 	char tmpBuf[UNLEN+1];
 	
@@ -1667,8 +1660,7 @@
 	LPWSTR lpwServer = MBTWC(server);
 	LPWSTR lpwGroup = MBTWC(group);
 	PGROUP_USERS_INFO_0 pwzGroupUsers;
-	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0;
-	int index, len;
+	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0, index;
 	DWORD lastError = 0;
 	char tmpBuf[UNLEN+1];
 	
@@ -1912,7 +1904,7 @@
 	lastError = NetLocalGroupDelMembers(lpwServer, lpwGroup, 3,
 					    (LPBYTE)members, totalEntries);
 
-	for (i; i<len; i++) freeWideName(members[i].lgrmi3_domainandname);
+	for (; i<len; i++) freeWideName(members[i].lgrmi3_domainandname);
 	freeWideName(lpwGroup);
 	freeWideName(lpwServer);
 	Safefree(members);
@@ -1931,8 +1923,7 @@
     {
 	LPWSTR lpwServer = MBTWC(server);
 	PLOCALGROUP_INFO_0 pwzLocalGroups;
-	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0;
-	int index;
+	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0, index;
 	DWORD lastError = 0;
 	char tmpBuf[UNLEN+1];
 
@@ -2013,8 +2004,7 @@
 	LPWSTR lpwServer = MBTWC(server);
 	LPWSTR lpwGroup = MBTWC(group);
 	PLOCALGROUP_MEMBERS_INFO_1 pwzMembersInfo;
-	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0;
-	int index;
+	DWORD entriesRead = 0, totalEntries = 0, resumeHandle = 0, index;
 	DWORD lastError = 0;
 	char tmpBuf[UNLEN+1];
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/APINet/mingw32.exc perl-libwin32-0.191/APINet/mingw32.exc
--- libwin32-0.191/APINet/mingw32.exc	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/APINet/mingw32.exc	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/APINet/t/test.t perl-libwin32-0.191/APINet/t/test.t
--- libwin32-0.191/APINet/t/test.t	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/APINet/t/test.t	2004-01-12 16:46:39.437500000 -0800
@@ -1,5 +1,5 @@
-# Before `make install' is performed this script should be runnable with
-# `make test'. After `make install' it should work as `perl test.pl'
+#!perl
+# vim:syntax=perl:
 
 ######################### We start with some black magic to print on failure.
 
@@ -8,6 +8,7 @@
 
 BEGIN { $| = 1; print "1..18\n"; }
 END {print "not ok 1\n" unless $loaded;}
+use Win32;
 use Win32API::Net qw/ :ALL /;
 $loaded = 1;
 print "ok 1\n";
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/APIRegistry/MANIFEST perl-libwin32-0.191/APIRegistry/MANIFEST
--- libwin32-0.191/APIRegistry/MANIFEST	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/APIRegistry/MANIFEST	2004-01-12 16:46:39.437500000 -0800
@@ -8,7 +8,6 @@
 const2perl.h
 cRegistry.h
 cRegistry.pc
-ppport.h
 test.pl
 typemap
 ExtUtils/Myconst2perl.pm
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/APIRegistry/Makefile.PL perl-libwin32-0.191/APIRegistry/Makefile.PL
--- libwin32-0.191/APIRegistry/Makefile.PL	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/APIRegistry/Makefile.PL	2004-01-12 16:46:39.453125000 -0800
@@ -119,9 +119,9 @@
 
     push @m, "
 clean ::
-    $self->{RM_F} @clean\n"   if  @clean;
-    push @m, "
+	$self->{RM_F} @clean\n"   if  @clean;
+	push @m, "
 realclean ::
-    $self->{RM_F} @realclean\n"   if  @realclean;
-    return join('',@m);
+	$self->{RM_F} @realclean\n"   if  @realclean;
+	return join('',@m);
 }
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/APIRegistry/Registry.pm perl-libwin32-0.191/APIRegistry/Registry.pm
--- libwin32-0.191/APIRegistry/Registry.pm	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/APIRegistry/Registry.pm	2004-01-12 16:46:39.468750000 -0800
@@ -138,18 +138,30 @@
     return 0;
 }
 
-BEGIN {
-    my $code= 'return _regLastError(@_)';
-    local( $!, $^E )= ( 1, 1 );
-    if(  $! ne $^E  ) {
-	$code= '
-	    local( $^E )= _regLastError(@_);
-	    my $ret= $^E;
-	    return $ret;
-	';
-    }
-    eval "sub regLastError { $code }";
-    die "$@"   if  $@;
+package Win32API::Registry::_error;
+
+use overload
+  '""' => sub {
+	use Win32;
+	$_ = Win32::FormatMessage(Win32API::Registry::_regLastError());
+	tr/\r\n//d; return $_;
+  },
+  '0+' => sub { Win32API::Registry::_regLastError() },
+  'fallback' => 1;
+
+sub new { return bless {}, shift }
+sub set { Win32API::Registry::_regLastError($_[1]); return $_[0] }
+
+package Win32API::Registry;
+
+my $_error = new Win32API::Registry::_error;
+
+sub regLastError {
+	require Carp;
+	Carp::croak 'Usage: ',__PACKAGE__,'::regLastError( [$setWin32ErrCode] )'
+		if @_ > 1;
+	$_error->set($_[0]) if defined $_[0];
+	return $_error;
 }
 
 # Since we ISA DynaLoader which ISA AutoLoader, we ISA AutoLoader so we
@@ -1452,7 +1464,7 @@
 can be passed.  For parameter that are pointers to buffer sizes,
 you can also pass in C<NULL> by specifying an empty list reference,
 C<[]>.  Both of these cases will ensure that the variable has
-E<some> buffer space allocated to it and pass in that buffer's
+I<some> buffer space allocated to it and pass in that buffer's
 allocated size.  Many of the calls indicate, via C<ERROR_MORE_DATA>,
 that the buffer size was not sufficient and the F<Registry.xs>
 code will automatically enlarge the buffer to the required size
@@ -1482,7 +1494,7 @@
 Some Reg*() calls may not currently set the buffer size when they
 return C<ERROR_MORE_DATA>.  But some that are not documented as
 doing so, currently do so anyway.  So the code assumes that any
-routine E<might> do this and resizes any buffers and repeats the
+routine I<might> do this and resizes any buffers and repeats the
 call.   We hope that eventually all routines will provide this
 feature.
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/APIRegistry/Registry.xs perl-libwin32-0.191/APIRegistry/Registry.xs
--- libwin32-0.191/APIRegistry/Registry.xs	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/APIRegistry/Registry.xs	2004-01-12 16:46:39.484375000 -0800
@@ -1,24 +1,8 @@
 /* Win32API/Registry.xs */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-/*#include "patchlevel.h"*/
+#include "../win32perl.h"
 
 /* Uncomment the next line unless set "WRITE_PERL=>1" in Makefile.PL: */
 #define NEED_newCONSTSUB
-#include "ppport.h"
-
-#define  WIN32_LEAN_AND_MEAN	/* Tell windows.h to skip much */
-#include <windows.h>
-
-#ifdef __cplusplus
-}
-#endif
 
 /*CONSTS_DEFINED*/
 
@@ -140,7 +124,7 @@
 	) {
 	    SetLastError( ERROR_SUCCESS );
 	    AdjustTokenPrivileges( hToken, FALSE, &tokPrivNew,
-	      NULL, NULL, NULL );
+	      0, NULL, NULL );
 	    if(  ERROR_SUCCESS == GetLastError()  ) {
 		RETVAL= TRUE;
 	    }
@@ -350,7 +334,10 @@
 RegDeleteValueW( hKey, swValueName )
 	HKEY	hKey
 	WCHAR *	swValueName
-
+    CODE:
+	RETVAL= ErrorRet(  RegDeleteValueW( hKey, swValueName )  );
+    OUTPUT:
+	RETVAL
 
 bool
 _RegEnumKeyA( hKey, uIndex, osName, ilNameSize )
@@ -841,10 +828,10 @@
 	DWORD	uErr;
     CODE:
 	init_buf_pl( iolValueData,ST(3),LONG * );
-	grow_buf_pl( osValueData,ST(2),char *, iolValueData,ST(3),LONG * );
+	grow_buf_pl( osValueData,ST(2),char *, (ULONG *)iolValueData,ST(3),ULONG * );
 	uErr= RegQueryValueA( hKey, sSubKey, osValueData, iolValueData );
 	if(  ERROR_MORE_DATA == uErr  &&  autosize(ST(3))  ) {
-	    grow_buf_pl( osValueData,ST(2),char *, iolValueData,ST(3),LONG * );
+	    grow_buf_pl( osValueData,ST(2),char *, (ULONG *)iolValueData,ST(3),ULONG * );
 	    uErr= RegQueryValueA( hKey, sSubKey, osValueData, iolValueData );
 	}
 	RETVAL= ErrorRet( uErr );
@@ -864,11 +851,11 @@
 	DWORD	uErr;
     CODE:
 	init_buf_pl( iolValueData,ST(3),LONG * );
-	grow_buf_pl( oswValueData,ST(2),WCHAR *, iolValueData,ST(3),LONG * );
+	grow_buf_pl( oswValueData,ST(2),WCHAR *, (ULONG *)iolValueData,ST(3),ULONG * );
 	uErr= RegQueryValueW( hKey, swSubKey, oswValueData, iolValueData );
 	if(  ERROR_MORE_DATA == uErr  &&  autosize(ST(3))  ) {
 	    grow_buf_pl( oswValueData,ST(2),WCHAR *,
-	      iolValueData,ST(3),LONG * );
+	      (ULONG *)iolValueData,ST(3),ULONG * );
 	    uErr= RegQueryValueW( hKey, swSubKey, oswValueData, iolValueData );
 	}
 	RETVAL= ErrorRet( uErr );
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/APIRegistry/ppport.h perl-libwin32-0.191/APIRegistry/ppport.h
--- libwin32-0.191/APIRegistry/ppport.h	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/APIRegistry/ppport.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,283 +0,0 @@
-
-#ifndef _P_P_PORTABILITY_H_
-#define _P_P_PORTABILITY_H_
-
-/* Perl/Pollution/Portability Version 1.0007etm */
-
-/* Copyright (C) 1999, Kenneth Albanowski. This code may be used and
-   distributed under the same license as any version of Perl. */
-   
-/* For the latest version of this code, please retreive the Devel::PPPort
-   module from CPAN, contact the author at <kjahds@kjahds.com>, or check
-   with the Perl maintainers. */
-   
-/* If you needed to customize this file for your project, please mention
-   your changes, and visible alter the version number. */
-
-
-/*
-   In order for a Perl extension module to be as portable as possible
-   across differing versions of Perl itself, certain steps need to be taken.
-   Including this header is the first major one, then using dTHR is all the
-   appropriate places and using a PL_ prefix to refer to global Perl
-   variables is the second.
-*/
-
-
-/* If you use one of a few functions that were not present in earlier
-   versions of Perl, please add a define before the inclusion of ppport.h
-   for a static include, or use the GLOBAL request in a single module to
-   produce a global definition that can be referenced from the other
-   modules.
-   
-   Function:            Static define:           Extern define:
-   newCONSTSUB()        NEED_newCONSTSUB         NEED_newCONSTSUB_GLOBAL
-
-*/
- 
-
-/* To verify whether ppport.h is needed for your module, and whether any
-   special defines should be used, ppport.h can be run through Perl to check
-   your source code. Simply say:
-   
-   	perl -x ppport.h *.c *.h *.xs foo/*.c [etc]
-   
-   The result will be a list of patches suggesting changes that should at
-   least be acceptable, if not necessarily the most efficient solution, or a
-   fix for all possible problems. It won't catch where dTHR is needed, and
-   doesn't attempt to account for global macro or function definitions,
-   nested includes, typemaps, etc.
-   
-   In order to test for the need of dTHR, please try your module under a
-   recent version of Perl that has threading compiled-in.
- 
-*/ 
-
-
-/*
-#!/usr/bin/perl
-@ARGV = ("*.xs") if !@ARGV;
-%badmacros = %funcs = %macros = (); $replace = 0;
-foreach (<DATA>) {
-	$funcs{$1} = 1 if /Provide:\s+(\S+)/;
-	$macros{$1} = 1 if /^#\s*define\s+([a-zA-Z0-9_]+)/;
-	$replace = $1 if /Replace:\s+(\d+)/;
-	$badmacros{$2}=$1 if $replace and /^#\s*define\s+([a-zA-Z0-9_]+).*?\s+([a-zA-Z0-9_]+)/;
-	$badmacros{$1}=$2 if /Replace (\S+) with (\S+)/;
-}
-foreach $filename (map(glob($_),@ARGV)) {
-	unless (open(IN, "<$filename")) {
-		warn "Unable to read from $file: $!\n";
-		next;
-	}
-	print "Scanning $filename...\n";
-	$c = ""; while (<IN>) { $c .= $_; } close(IN);
-	$need_include = 0; %add_func = (); $changes = 0;
-	$has_include = ($c =~ /#.*include.*ppport/m);
-
-	foreach $func (keys %funcs) {
-		if ($c =~ /#.*define.*\bNEED_$func(_GLOBAL)?\b/m) {
-			if ($c !~ /\b$func\b/m) {
-				print "If $func isn't needed, you don't need to request it.\n" if
-				$changes += ($c =~ s/^.*#.*define.*\bNEED_$func\b.*\n//m);
-			} else {
-				print "Uses $func\n";
-				$need_include = 1;
-			}
-		} else {
-			if ($c =~ /\b$func\b/m) {
-				$add_func{$func} =1 ;
-				print "Uses $func\n";
-				$need_include = 1;
-			}
-		}
-	}
-
-	if (not $need_include) {
-		foreach $macro (keys %macros) {
-			if ($c =~ /\b$macro\b/m) {
-				print "Uses $macro\n";
-				$need_include = 1;
-			}
-		}
-	}
-
-	foreach $badmacro (keys %badmacros) {
-		if ($c =~ /\b$badmacro\b/m) {
-			$changes += ($c =~ s/\b$badmacro\b/$badmacros{$badmacro}/gm);
-			print "Uses $badmacros{$badmacro} (instead of $badmacro)\n";
-			$need_include = 1;
-		}
-	}
-	
-	if (scalar(keys %add_func) or $need_include != $has_include) {
-		if (!$has_include) {
-			$inc = join('',map("#define NEED_$_\n", sort keys %add_func)).
-			       "#include \"ppport.h\"\n";
-			$c = "$inc$c" unless $c =~ s/#.*include.*XSUB.*\n/$&$inc/m;
-		} elsif (keys %add_func) {
-			$inc = join('',map("#define NEED_$_\n", sort keys %add_func));
-			$c = "$inc$c" unless $c =~ s/^.*#.*include.*ppport.*$/$inc$&/m;
-		}
-		if (!$need_include) {
-			print "Doesn't seem to need ppport.h.\n";
-			$c =~ s/^.*#.*include.*ppport.*\n//m;
-		}
-		$changes++;
-	}
-	
-	if ($changes) {
-		open(OUT,">/tmp/ppport.h.$$");
-		print OUT $c;
-		close(OUT);
-		open(DIFF, "diff -u $filename /tmp/ppport.h.$$|");
-		while (<DIFF>) { s!/tmp/ppport\.h\.$$!$filename.patched!; print STDOUT; }
-		close(DIFF);
-		unlink("/tmp/ppport.h.$$");
-	} else {
-		print "Looks OK\n";
-	}
-}
-__DATA__
-*/
-
-#ifndef PERL_REVISION
-#   ifndef __PATCHLEVEL_H_INCLUDED__
-#       include "patchlevel.h"
-#   endif
-#   ifndef PERL_REVISION
-#	define PERL_REVISION	(5)
-        /* Replace: 1 */
-#       define PERL_VERSION	PATCHLEVEL
-#       define PERL_SUBVERSION	SUBVERSION
-        /* Replace PERL_PATCHLEVEL with PERL_VERSION */
-        /* Replace: 0 */
-#   endif
-#endif
-
-#define PERL_BCDVERSION ((PERL_REVISION * 0x1000000L) + (PERL_VERSION * 0x1000L) + PERL_SUBVERSION)
-
-#ifndef ERRSV
-#	define ERRSV perl_get_sv("@",FALSE)
-#endif
-
-#if (PERL_VERSION < 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION <= 5))
-/* Replace: 1 */
-#	define PL_sv_undef	sv_undef
-#	define PL_sv_yes	sv_yes
-#	define PL_sv_no		sv_no
-#	define PL_na		na
-#	define PL_stdingv	stdingv
-#	define PL_hints		hints
-#	define PL_curcop	curcop
-#	define PL_curstash	curstash
-#	define PL_copline	copline
-#	define PL_Sv		Sv
-/* Replace: 0 */
-#endif
-
-#ifndef dTHR
-#  ifdef WIN32
-#	define dTHR extern int Perl___notused
-#  else
-#	define dTHR extern int errno
-#  endif
-#endif
-
-#ifndef boolSV
-#	define boolSV(b) ((b) ? &PL_sv_yes : &PL_sv_no)
-#endif
-
-#ifndef gv_stashpvn
-#	define gv_stashpvn(str,len,flags) gv_stashpv(str,flags)
-#endif
-
-#ifndef newSVpvn
-#	define newSVpvn(data,len) ((len) ? newSVpv ((data), (len)) : newSVpv ("", 0))
-#endif
-
-#ifndef newRV_inc
-/* Replace: 1 */
-#	define newRV_inc(sv) newRV(sv)
-/* Replace: 0 */
-#endif
-
-#ifndef newRV_noinc
-#  ifdef __GNUC__
-#    define newRV_noinc(sv)               \
-      ({                                  \
-          SV *nsv = (SV*)newRV(sv);       \
-          SvREFCNT_dec(sv);               \
-          nsv;                            \
-      })
-#  else
-#    if defined(CRIPPLED_CC) || defined(USE_THREADS)
-static SV * newRV_noinc (SV * sv)
-{
-          SV *nsv = (SV*)newRV(sv);       
-          SvREFCNT_dec(sv);               
-          return nsv;                     
-}
-#    else
-#      define newRV_noinc(sv)    \
-        ((PL_Sv=(SV*)newRV(sv), SvREFCNT_dec(sv), (SV*)PL_Sv)
-#    endif
-#  endif
-#endif
-
-/* Provide: newCONSTSUB */
-
-/* newCONSTSUB from IO.xs is in the core starting with 5.004_63 */
-#if (PERL_VERSION < 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION < 63))
-
-#if defined(NEED_newCONSTSUB)
-static
-#else
-extern void newCONSTSUB _((HV * stash, char * name, SV *sv));
-#endif
-
-#if defined(NEED_newCONSTSUB) || defined(NEED_newCONSTSUB_GLOBAL)
-void
-newCONSTSUB( HV *stash, char *name, SV *sv )
-{
-	U32 oldhints = PL_hints;
-	HV *old_cop_stash = PL_curcop->cop_stash;
-	HV *old_curstash = PL_curstash;
-	line_t oldline = PL_curcop->cop_line;
-	PL_curcop->cop_line = PL_copline;
-
-	PL_hints &= ~HINT_BLOCK_SCOPE;
-	if (stash)
-		PL_curstash = PL_curcop->cop_stash = stash;
-
-	newSUB(
-
-#if (PERL_VERSION < 3) || ((PERL_VERSION == 3) && (PERL_SUBVERSION < 22))
-     /* before 5.003_22 */
-		start_subparse(),
-#else
-#  if (PERL_VERSION == 3) && (PERL_SUBVERSION == 22)
-     /* 5.003_22 */
-     		start_subparse(0),
-#  else
-     /* 5.003_23  onwards */
-     		start_subparse(FALSE, 0),
-#  endif
-#endif
-
-		newSVOP(OP_CONST, 0, newSVpv(name,0)),
-		newSVOP(OP_CONST, 0, &PL_sv_no),   /* SvPV(&PL_sv_no) == "" -- GMB */
-		newSTATEOP(0, Nullch, newSVOP(OP_CONST, 0, sv))
-	);
-
-	PL_hints = oldhints;
-	PL_curcop->cop_stash = old_cop_stash;
-	PL_curstash = old_curstash;
-	PL_curcop->cop_line = oldline;
-}
-#endif
-
-#endif /* newCONSTSUB */
-
-
-#endif /* _P_P_PORTABILITY_H_ */
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/APIRegistry/test.pl perl-libwin32-0.191/APIRegistry/test.pl
--- libwin32-0.191/APIRegistry/test.pl	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/APIRegistry/test.pl	2004-01-12 16:46:39.515625000 -0800
@@ -1,6 +1,5 @@
-#!/usr/bin/perl -w
-# Before `make install' is performed this script should be runnable with
-# `make test'. After `make install' it should work as `perl test.pl'
+#!perl
+# vim:syntax=perl:
 
 ######################### We start with some black magic to print on failure.
 
@@ -17,7 +16,7 @@
 
 BEGIN { eval "use Win32API::Registry qw(:SE_);" }
 
-$|= 1   if  $Debug= ( -t STDIN ) != ( -t STDOUT );
+$Debug= $ENV{TEST_VERBOSE};
 
 $zero= 0;	# Change to 0 when RegEnumKeyExA() and RegEnumValueA()
 		# handle ERROR_MORE_DATA better!
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/APIRegistry/typemap perl-libwin32-0.191/APIRegistry/typemap
--- libwin32-0.191/APIRegistry/typemap	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/APIRegistry/typemap	2004-01-12 16:46:39.515625000 -0800
@@ -16,7 +16,8 @@
 SECURITY_DESCRIPTOR *	T_BUF
 SECURITY_ATTRIBUTES *	T_BUF
 LONG *			T_IVBUF
-DWORD *			T_UVBUF
+ULONG *		T_UVBUF
+DWORD *		T_UVBUF
 oDWORD *		O_UVBUF
 HKEY *			T_UVBUFP
 oHKEY *			O_UVBUFP
@@ -37,7 +38,7 @@
 T_IV
 	$var= null_arg($arg) ? ($type)0 : ($type)SvIV($arg)
 T_UV
-	$var= null_arg($arg) ? ($type)0 : ($type)SvUV($arg)
+	$var= null_arg($arg) ? ($type)0 : ($type)(DWORD)SvUV($arg)
 O_IV
 	$var= optIV($arg)
 O_UV
@@ -73,7 +74,7 @@
 	if(  null_arg($arg)  )
 	    $var= NULL;
 	else
-	    *( $var= ($type) TempAlloc( sizeof(*($var)) ) )= (void *)SvUV($arg)
+	    *( $var= ($type) TempAlloc( sizeof(*($var)) ) )= (void *)(DWORD)SvUV($arg)
 O_IVBUFP
 	if(  null_arg($arg)  )
 	    $var= NULL;
@@ -85,7 +86,7 @@
 	    $var= NULL;
 	else
 	    *( $var= ($type) TempAlloc( sizeof(*($var)) ) )=
-	      SvOK($arg) ? (void *)SvUV($arg) : 0;
+	      SvOK($arg) ? (void *)(DWORD)SvUV($arg) : 0;
 
 #############################################################################
 OUTPUT
@@ -130,10 +131,10 @@
 	    sv_setiv( $arg, (IV)*($var) );
 T_UVBUFP
 	if(  ! null_arg($arg)  &&  ! SvREADONLY($arg)  )
-	    sv_setuv( $arg, (UV)*($var) );
+	    sv_setuv( $arg, (UV)(DWORD)*($var) );
 O_IVBUFP
 	if(  ! null_arg($arg)  )
 	    sv_setiv( $arg, (IV)*($var) );
 O_UVBUFP
 	if(  ! null_arg($arg)  )
-	    sv_setuv( $arg, (UV)*($var) );
+	    sv_setuv( $arg, (UV)(DWORD)*($var) );
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/CYGWIN-PATCHES/README perl-libwin32-0.191/CYGWIN-PATCHES/README
--- libwin32-0.191/CYGWIN-PATCHES/README	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/CYGWIN-PATCHES/README	2004-01-12 16:46:39.531250000 -0800
@@ -0,0 +1,71 @@
+perl-libwin32
+------------------------------------------
+Perl extensions for using the Win32 API.
+Included modules: Win32CORE, Win32API::File, Win32API::Net, Win32API::Registry,
+ChangeNotify, Clipboard, Console, Event, EventLog, File, FileSecurity, GUI,
+IPC, Internet, Job, Mutex, NetAdmin, NetResource, ODBC, OLE, PerfLib, Pipe,
+Process, Registry, Semaphore, Service, Shortcut, Sound, TieRegistry and
+WinError.
+
+Runtime requirements:
+  cygwin
+  perl-5.8.2
+  w32api
+
+Build requirements:
+  cygwin
+  cygutils
+  perl-5.8.2
+  w32api
+  gzip
+
+Project Homepages:
+  http://search.cpan.org/search?query=libwin32&mode=Distributions
+  http://sourceforge.net/projects/perl-win32-gui/
+  http://sourceforge.net/projects/libwin32-exp/
+
+------------------------------------
+
+Build instructions:
+  unpack perl-libwin32-0.191-1-src.tar.bz2
+    if you use setup to install this src package, it will be
+	 unpacked under /usr/src automatically
+  cd /usr/src
+  ./perl-libwin32-0.191-1.sh all
+
+This will create:
+  /usr/src/perl-libwin32-0.191-1.tar.bz2
+  /usr/src/perl-libwin32-0.191-1-src.tar.bz2
+
+------------------
+
+Port Notes:
+
+To Cygwin Developers:
+
+If something breaks and I'm not around for any reason, please feel free to
+either fix it and do a Non Maintainer Upload (I won't mind, honestly) or drop
+it from the distribution.
+
+Port TODO:
+
+* Alot of stuff needs to be fed back upstream, will add details later to this
+  file or the sourceforge project, including some references to previous
+  discussions on p5p.
+* Win32::GUI needs to be separated out into its own original source and patch,
+  even though multi source -> one binary packaging is nasty and evil.
+* Need to make a cleaner package script and/or add some support to
+  ExtUtils::MakeMaker and Module::Build for Cygwin packages. At the very least
+  need to make a template package script for making other Perl modules, as the
+  sample setup script requires a good deal of modification.
+* Some of the hints stuff might be nicer reworked using something like:
+  http://search.cpan.org/~jstowe/TermReadKey-2.21/Configure.pm
+* Win32CORE should be either statically built into or autoloaded from Cygwin
+  Perl to be compatible with native builds. Will wait until I can figure out if
+  a patch to the Perl core would be feasible and accepted.
+* Put these and other issues, in detail, into the sourceforge BTS.
+
+----- version 0.191-1 -----
+Initial Cygwin package.
+
+Cygwin port maintained by: Rafael Kitover  (caelum@debian.org)
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/CYGWIN-PATCHES/perl-libwin32-0.191-1.sh perl-libwin32-0.191/CYGWIN-PATCHES/perl-libwin32-0.191-1.sh
--- libwin32-0.191/CYGWIN-PATCHES/perl-libwin32-0.191-1.sh	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/CYGWIN-PATCHES/perl-libwin32-0.191-1.sh	2004-01-12 16:46:39.546875000 -0800
@@ -0,0 +1,205 @@
+#!/bin/sh
+# find out where the build script is located
+tdir=`echo "$0" | sed 's%[\\/][^\\/][^\\/]*$%%'`
+test "x$tdir" = "x$0" && tdir=.
+scriptdir=`cd $tdir; pwd`
+# find src directory.  
+# If scriptdir ends in SPECS, then topdir is $scriptdir/.. 
+# If scriptdir ends in CYGWIN-PATCHES, then topdir is $scriptdir/../..
+# Otherwise, we assume that topdir = scriptdir
+topdir1=`echo ${scriptdir} | sed 's%/SPECS$%%'`
+topdir2=`echo ${scriptdir} | sed 's%/CYGWIN-PATCHES$%%'`
+if [ "x$topdir1" != "x$scriptdir" ] ; then # SPECS
+  topdir=`cd ${scriptdir}/..; pwd`
+else
+  if [ "x$topdir2" != "x$scriptdir" ] ; then # CYGWIN-PATCHES
+    topdir=`cd ${scriptdir}/../..; pwd`
+  else
+    topdir=`cd ${scriptdir}; pwd`
+  fi
+fi
+
+cd ${topdir}
+
+tscriptname=`basename $0 .sh`
+export PKG=`echo $tscriptname | sed -e 's/\-[^\-]*\-[^\-]*$//'`
+export VER=`echo $tscriptname | sed -e "s/${PKG}\-//" -e 's/\-[^\-]*$//'`
+export REL=`echo $tscriptname | sed -e "s/${PKG}\-${VER}\-//"`
+export FULLPKG=${PKG}-${VER}-${REL}
+
+export ORIG_PKG=`echo $PKG | sed -e 's/^perl-//'`
+
+# determine correct decompression option and tarball filename
+if [ -e ${ORIG_PKG}-${VER}.tar.gz ] ; then
+  export opt_decomp=z
+  export src_orig_pkg_ext=gz
+elif [ -e ${ORIG_PKG}-${VER}.tar.bz2 ] ; then
+  export opt_decomp=j
+  export src_orig_pkg_ext=bz2
+fi
+
+export src_orig_pkg_name=${ORIG_PKG}-${VER}.tar.${src_orig_pkg_ext}
+export src_pkg_name=${FULLPKG}-src.tar.bz2
+export src_patch_name=${FULLPKG}.patch
+export bin_pkg_name=${FULLPKG}.tar.bz2
+
+export src_orig_pkg=${topdir}/${src_orig_pkg_name}
+export src_pkg=${topdir}/${src_pkg_name}
+export src_patch=${topdir}/${src_patch_name}
+export bin_pkg=${topdir}/${bin_pkg_name}
+export srcdir=${topdir}/${PKG}-${VER}
+export objdir=${srcdir}/.build
+export instdir=${srcdir}/.inst
+export srcinstdir=${srcdir}/.sinst
+export checkfile=${topdir}/${FULLPKG}.check
+# run on
+host=i686-pc-cygwin
+# if this package creates binaries, they run on
+target=i686-pc-cygwin
+prefix=/usr
+sysconfdir=/etc
+
+mkdirs() {
+  (cd ${topdir} && \
+  rm -fr ${objdir} ${instdir} ${srcinstdir} && \
+  mkdir -p ${objdir} && \
+  mkdir -p ${instdir} && \
+  mkdir -p ${srcinstdir} )
+}
+prep() {
+  (cd ${topdir} && \
+  tar xv${opt_decomp}f ${src_orig_pkg} && \
+  mv ${ORIG_PKG}-${VER} ${PKG}-${VER} ; \
+  cd ${topdir} && \
+  patch -p0 < ${src_patch} 
+  && mkdirs )
+}
+conf() {
+  (cd ${srcdir} && \
+  perl Makefile.PL INSTALLDIRS=site PREFIX=${instdir}/usr/)
+}
+build() {
+  (cd ${srcdir} && make all manifypods)
+}
+check() {
+  (cd ${srcdir} && \
+  make test | tee ${checkfile} 2>&1 )
+}
+clean() {
+  (cd ${srcdir} && \
+  if test -f Makefile; then \
+    make realclean; \
+  elif test -f Makefile.old; then \
+    make -f Makefile.old realclean; \
+  fi )
+}
+install() {
+  rm -rf ${instdir}/*; \
+  (cd ${srcdir} && \
+  make pure_install INSTALLMAN1DIR=${instdir}/usr/share/man/man1 \
+  	INSTALLMAN3DIR=${instdir}/usr/share/man/man3 && \
+  find ${instdir} \( -name '.packlist' -o -name 'perllocal.pod' \) -exec rm -f {} \; && \
+  find ${instdir}/usr/share/man -name '*.3pm' -type f -exec gzip -9 {} \; && \
+  for d in ${prefix}/share/doc/${PKG}-${VER} ${prefix}/share/doc/Cygwin ; do \
+    if [ ! -d ${instdir}${d} ] ; then \
+      mkdir -p ${instdir}${d} ;\
+    fi ;\
+  done &&\
+  doclist="`find . \( \
+  	    -ipath '*/doc/*' \
+  	-or -ipath '*/docs/*' \
+  	-or -ipath '*/eg/*' \
+  	-or -ipath '*/ex/*' \
+  	-or -ipath '*/sample*/*' \
+  	-or -iregex '.*/\(ANNOUNCE\|Changes\|INSTALL\|KNOWNBUG\|LICENSE\|README\|TODO\|COPYING\)' \
+	-or -name '*.t' \
+	-or \( -name '*.pl' -not -path '*/hints/*' \) \
+        -or \( -name '*.bat' -not -iname 'install.bat' \) \
+  \) -not -ipath '*/CVS/*' -not -ipath '*/.inst/*' -not -ipath '*/CYGWIN-PATCHES/*' | \
+  sed -e 's|^./||'`" && \
+  if [ ! "x$doclist" = "x" ]; then \
+    for i in $doclist; do \
+      d=`dirname $i` ;\
+      d_dest=`echo $d | sed -e 's|/t/|/tests/|' -e 's|/t$|/tests|'`; \
+      i_dest=`echo $i | sed -e 's|/t/|/tests/|' -e 's|/t$|/tests|' -e 's|\.t$|.pl|'`; \
+      /usr/bin/install -d ${instdir}${prefix}/share/doc/${PKG}-${VER}/$d_dest ;\
+      if [ -d $i ]; then \
+        /usr/bin/install -d ${instdir}${prefix}/share/doc/${PKG}-${VER}/$i_dest ;\
+      else \
+        /usr/bin/install -m 644 $i ${instdir}${prefix}/share/doc/${PKG}-${VER}/$i_dest ;\
+      fi; \
+    done; \
+  fi && \
+  /usr/bin/install -m 644 ${srcdir}/OLE/lib/Win32/OLE/NEWS.pod ${instdir}${prefix}/share/doc/${PKG}-${VER}/OLE/NEWS.pod ;\
+  /usr/bin/install -m 644 ${srcdir}/OLE/lib/Win32/OLE/TPJ.pod  ${instdir}${prefix}/share/doc/${PKG}-${VER}/OLE/TPJ.pod ;\
+  if [ -f ${srcdir}/CYGWIN-PATCHES/${PKG}.README ]; then \
+    /usr/bin/install -m 644 ${srcdir}/CYGWIN-PATCHES/${PKG}.README \
+      ${instdir}${prefix}/share/doc/Cygwin/${PKG}-${VER}.README ; \
+  else \
+    if [ -f ${srcdir}/CYGWIN-PATCHES/README ]; then \
+      /usr/bin/install -m 644 ${srcdir}/CYGWIN-PATCHES/README \
+        ${instdir}${prefix}/share/doc/Cygwin/${PKG}-${VER}.README ; \
+    fi ;\
+  fi ;\
+  if [ -f ${srcdir}/CYGWIN-PATCHES/postinstall.sh ] ; then \
+  /usr/bin/install -m 755 ${srcdir}/CYGWIN-PATCHES/postinstall.sh \
+      ${instdir}${sysconfdir}/postinstall/${PKG}.sh; \
+  fi )
+}
+strip() {
+  (cd ${instdir} && \
+  find . -name "*.dll" | xargs strip > /dev/null 2>&1
+  find . -name "*.exe" | xargs strip > /dev/null 2>&1
+  true )
+}
+list() {
+  (cd ${instdir} && \
+  find . -name "*" ! -type d | sed 's/\.\/\(.*\)/\1/'
+  true )
+}
+pkg() {
+  (cd ${instdir} && \
+  tar cvjf ${bin_pkg} * )
+}
+mkpatch() {
+  clean && \
+  (cd ${topdir} && \
+  tar x${opt_decomp}f ${src_orig_pkg} && \
+  diff --strip-trailing-cr -aruN -x '.build' -x '.inst' -x '.sinst' -x 'CVS' \
+    -x '*.sw?' -x '.cvsignore' -I ' $Id: ' \
+    ${ORIG_PKG}-${VER} ${PKG}-${VER} > \
+    ${srcinstdir}/${src_patch_name} ; \
+  rm -rf ${ORIG_PKG}-${VER} )
+}
+spkg() {
+  (mkpatch && \
+  cp ${src_orig_pkg} ${srcinstdir}/${src_orig_pkg_name} && \
+  cp $0 ${srcinstdir}/`basename $0` && \
+  cd ${srcinstdir} && \
+  tar --exclude='CVS*' -cjf ${src_pkg} * )
+}
+finish() {
+#  rm -rf ${srcdir} 
+}
+case $1 in
+  prep)	prep ; STATUS=$? ;;
+  mkdirs)	mkdirs; STATUS=$? ;;
+  conf)	conf ; STATUS=$? ;;
+  build)	build ; STATUS=$? ;;
+  check)	check ; STATUS=$? ;;
+  clean)	clean ; STATUS=$? ;;
+  install)	install ; STATUS=$? ;;
+  list)	list ; STATUS=$? ;;
+  strip)	strip ; STATUS=$? ;;
+  package)	pkg ; STATUS=$? ;;
+  pkg)	pkg ; STATUS=$? ;;
+  mkpatch)	mkpatch ; STATUS=$? ;;
+  src-package)	spkg ; STATUS=$? ;;
+  spkg)	spkg ; STATUS=$? ;;
+  finish) finish ; STATUS=$? ;;
+  all) prep && conf && build && install && \
+     strip && pkg && spkg && finish ; \
+	  STATUS=$? ;;
+  *) echo "Error: bad arguments" ; exit 1 ;;
+esac
+exit ${STATUS}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/CYGWIN-PATCHES/setup.hint perl-libwin32-0.191/CYGWIN-PATCHES/setup.hint
--- libwin32-0.191/CYGWIN-PATCHES/setup.hint	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/CYGWIN-PATCHES/setup.hint	2004-01-12 16:46:39.562500000 -0800
@@ -0,0 +1,11 @@
+@ perl-libwin32
+curr: 0.191-1
+sdesc: "Perl extensions for using the Win32 API"
+category: "System" "Libs" "Interpreters"
+requires: perl cygwin
+ldesc: "Perl extensions for using the Win32 API.
+Included modules: Win32CORE, Win32API::File, Win32API::Net, Win32API::Registry,
+ChangeNotify, Clipboard, Console, Event, EventLog, File, FileSecurity, Gui,
+IPC, Internet, Job, Mutex, NetAdmin, NetResource, ODBC, OLE, PerfLib, Pipe,
+Process, Registry, Semaphore, Service, Shortcut, Sound, TieRegistry and
+WinError."
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/ChangeNotify/ChangeNotify.xs perl-libwin32-0.191/ChangeNotify/ChangeNotify.xs
--- libwin32-0.191/ChangeNotify/ChangeNotify.xs	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/ChangeNotify/ChangeNotify.xs	2004-01-12 16:46:39.578125000 -0800
@@ -1,5 +1,5 @@
 //--------------------------------------------------------------------
-// $Id$
+// $Id: ChangeNotify.xs,v 1.1.1.1 2003/01/28 18:59:17 caelum Exp $
 //--------------------------------------------------------------------
 //
 //   Win32::ChangeNotify
@@ -9,14 +9,7 @@
 //
 //--------------------------------------------------------------------
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
-
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
+#include "../win32perl.h"
 
 static DWORD
 constant(char* name)
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/ChangeNotify/test.pl perl-libwin32-0.191/ChangeNotify/test.pl
--- libwin32-0.191/ChangeNotify/test.pl	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/ChangeNotify/test.pl	2004-01-12 16:46:39.578125000 -0800
@@ -1,10 +1,5 @@
-# Before `make install' is performed this script should be runnable with
-# `make test'. After `make install' it should work as `perl test.pl'
-
-######################### We start with some black magic to print on failure.
-
-# Change 1..1 below to 1..last_test_to_print .
-# (It may become useful if the test is moved to ./t subdirectory.)
+#!perl
+# vim:syntax=perl:
 
 BEGIN { $| = 1; print "1..3\n"; }
 END {print "not ok 1\n" unless $loaded;}
@@ -12,12 +7,6 @@
 $loaded = 1;
 print "ok 1\n";
 
-######################### End of black magic.
-
-# Insert your test code below (better if it prints "ok 13"
-# (correspondingly "not ok 13") depending on the success of chunk 13
-# of the test code):
-
 print 'not ' if FILE_NOTIFY_CHANGE_FILE_NAME == 0;
 print "ok 2\n";
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/ChangeNotify/typemap perl-libwin32-0.191/ChangeNotify/typemap
--- libwin32-0.191/ChangeNotify/typemap	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/ChangeNotify/typemap	2004-01-12 16:46:39.593750000 -0800
@@ -8,7 +8,7 @@
 T_PTROBJ
 	if (sv_derived_from($arg, \"${Package}\")) {
 	    IV tmp = SvIV((SV*)SvRV($arg));
-	    $var = ($type) tmp;
+	    $var = ($type)(DWORD) tmp;
 	}
 	else
 	    croak(\"$var is not of type ${Package}\")
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Clipboard/Clipboard.xs perl-libwin32-0.191/Clipboard/Clipboard.xs
--- libwin32-0.191/Clipboard/Clipboard.xs	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/Clipboard/Clipboard.xs	2004-01-12 16:46:39.609375000 -0800
@@ -10,35 +10,12 @@
 #######################################################################
  */
 
-/* uncomment next line for debug messages */
-// #define WIN32__CLIPBOARD__DEBUG
-
-#define  WIN32_LEAN_AND_MEAN
-#include <windows.h>
-#include <string.h>
+#include "../win32perl.h"
 #include <winuser.h>
 #include <shellapi.h>
 
-#define __TEMP_WORD  WORD   /* perl defines a WORD, yikes! */
-
-#ifdef __cplusplus
-#include <stdlib.h>
-#include <math.h>
-extern "C" {
-#endif
-
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#ifdef __cplusplus
-}
-#endif
-
-#include "../ppport.h"
-
-#undef WORD
-#define WORD __TEMP_WORD
+/* uncomment next line for debug messages */
+// #define WIN32__CLIPBOARD__DEBUG
 
 // Section for the constant definitions.
 #define CROAK croak
@@ -52,7 +29,6 @@
 
 /* DLL entry point */
 BOOL WINAPI DllMain(HINSTANCE hDll, DWORD reason, LPVOID reserved) {
-    BOOL ccb;
 #ifdef WIN32__CLIPBOARD__DEBUG
     printf("!XS(DllMain): DLL entry point called with reason: %ld\n", reason);
     printf("!XS(DllMain): ClipboardViewer is: %ld\n", GetClipboardViewer());
@@ -443,12 +419,11 @@
     HANDLE myhandle;
 	LPTSTR filename;
 	UINT namelength;
-	int i, toreturn;
-	UINT count;
+	UINT i, toreturn, count;
     if(OpenClipboard(NULL)) {
 		if(myhandle = GetClipboardData(CF_HDROP)) {
 			count = DragQueryFile((HDROP) myhandle, 0xFFFFFFFF, NULL, 0);
-			EXTEND(SP, count);
+			EXTEND(SP, (int)count);
 			for(i=0; i<count; i++) {
 				namelength = DragQueryFile((HDROP) myhandle, i, NULL, 0);
 				filename = (LPTSTR) safemalloc(namelength+1);
@@ -539,7 +514,7 @@
     UINT namelength;
     int toret;
     UINT count;
-    int i;
+    UINT i;
 	WORD cClrBits;
 	LPBITMAPINFO bmi;
 	BITMAPFILEHEADER hdr;
@@ -550,7 +525,7 @@
 		case CF_HDROP:
 			if(myhandle = GetClipboardData(CF_HDROP)) {
 				count = DragQueryFile((HDROP) myhandle, 0xFFFFFFFF, NULL, 0);
-				EXTEND(SP, count);
+				EXTEND(SP, (int)count);
 				for(i=0; i<count; i++) {
 					namelength = DragQueryFile((HDROP) myhandle, i, NULL, 0);
 					filename = (LPTSTR) safemalloc(namelength+1);
@@ -693,7 +668,6 @@
 EnumFormats(...)
 PPCODE:
 	UINT format;
-	LPTSTR formatname[1024];
 	int count;
     if(OpenClipboard(NULL)) {
 		format = EnumClipboardFormats(0);
@@ -711,7 +685,6 @@
 IsFormatAvailable(svformat,...)
     SV *svformat
 PPCODE:
-	UINT format;
     if (items > 1)
         svformat = ST(1);
 	XST_mIV(0, (long) IsClipboardFormatAvailable((UINT) SvIV(svformat)));
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Console/Console.xs perl-libwin32-0.191/Console/Console.xs
--- libwin32-0.191/Console/Console.xs	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/Console/Console.xs	2004-01-12 16:46:39.625000000 -0800
@@ -9,21 +9,7 @@
  *
  */
 
-#define  WIN32_LEAN_AND_MEAN
-#include <windows.h>
-
-#define __TEMP_WORD  WORD	/* perl defines a WORD, yikes! */
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#undef Top			/* some devel version pollutes */
-#undef WORD
-#define WORD __TEMP_WORD
-
-// Section for the constant definitions.
-#define CROAK croak
-
+#include "../win32perl.h"
 
 DWORD
 constant(char *name, int arg)
@@ -423,7 +409,7 @@
     SHORT x
     SHORT y
 PPCODE:
-    int i;
+    DWORD i;
     COORD coords;
     DWORD written;
     unsigned short buffer[80*999*sizeof(unsigned short)];
@@ -490,7 +476,7 @@
     SHORT x
     SHORT y
 PPCODE:
-    int i;
+    unsigned int i;
     COORD coords;
     DWORD nofread;
     unsigned short abuffer[80*999*sizeof(unsigned short)];
@@ -755,19 +741,19 @@
     case KEY_EVENT:
 	kevent=(KEY_EVENT_RECORD *)&(event.Event);
 	kevent->bKeyDown=(BOOL)SvIV(ST(2));
-	kevent->wRepeatCount=SvIV(ST(3));
-	kevent->wVirtualKeyCode=SvIV(ST(4));
-	kevent->wVirtualScanCode=SvIV(ST(5));
+	kevent->wRepeatCount=(WORD)SvIV(ST(3));
+	kevent->wVirtualKeyCode=(WORD)SvIV(ST(4));
+	kevent->wVirtualScanCode=(WORD)SvIV(ST(5));
 #ifdef UNICODE
 	kevent->uChar.UnicodeChar=SvIV(ST(6));
 #else
-	kevent->uChar.AsciiChar=SvIV(ST(7));
+	kevent->uChar.AsciiChar=(CHAR)SvIV(ST(7));
 #endif
 	break;
     case MOUSE_EVENT:
 	mevent=(MOUSE_EVENT_RECORD *)&(event.Event);
-	mevent->dwMousePosition.X=SvIV(ST(2));
-	mevent->dwMousePosition.Y=SvIV(ST(3));
+	mevent->dwMousePosition.X=(SHORT)SvIV(ST(2));
+	mevent->dwMousePosition.Y=(SHORT)SvIV(ST(3));
 	mevent->dwButtonState=SvIV(ST(4));
 	mevent->dwControlKeyState=SvIV(ST(5));
 	mevent->dwEventFlags=SvIV(ST(6));
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Console/test.pl perl-libwin32-0.191/Console/test.pl
--- libwin32-0.191/Console/test.pl	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/Console/test.pl	2004-01-12 16:46:39.625000000 -0800
@@ -1,6 +1,7 @@
 #these tests are useless in the automated build process
-exit if $ENV{ACTIVEPERL_SKIP_INTERACTIVE_TESTS};
+exit if $ENV{ACTIVEPERL_SKIP_INTERACTIVE_TESTS} || !$ENV{TEST_VERBOSE};
 
+use Win32;
 use Win32::Console;
 
 $^W = 0;  # we get about a trillion warn_undef-s
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Event/Event.xs perl-libwin32-0.191/Event/Event.xs
--- libwin32-0.191/Event/Event.xs	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/Event/Event.xs	2004-01-12 16:46:39.640625000 -0800
@@ -1,5 +1,5 @@
 //--------------------------------------------------------------------
-// $Id$
+// $Id: Event.xs,v 1.1.1.1 2003/01/28 18:59:21 caelum Exp $
 //--------------------------------------------------------------------
 //
 //   Win32::Event
@@ -9,15 +9,7 @@
 //
 //--------------------------------------------------------------------
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
-
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-
+#include "../win32perl.h"
 
 MODULE = Win32::Event		PACKAGE = Win32::Event
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Event/typemap perl-libwin32-0.191/Event/typemap
--- libwin32-0.191/Event/typemap	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/Event/typemap	2004-01-12 16:46:39.656250000 -0800
@@ -7,7 +7,7 @@
 T_PTROBJ
 	if (sv_derived_from($arg, \"${Package}\")) {
 	    IV tmp = SvIV((SV*)SvRV($arg));
-	    $var = ($type) tmp;
+	    $var = ($type)(DWORD) tmp;
 	}
 	else
 	    croak(\"$var is not of type ${Package}\")
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/EventLog/EventLog.pm perl-libwin32-0.191/EventLog/EventLog.pm
--- libwin32-0.191/EventLog/EventLog.pm	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/EventLog/EventLog.pm	2004-01-12 16:46:39.671875000 -0800
@@ -13,6 +13,7 @@
 
 require Exporter;
 require DynaLoader;
+require Win32;
 
 die "The Win32::Eventlog module works only on Windows NT"
 	unless Win32::IsWinNT();
@@ -119,10 +120,16 @@
     die "usage: OBJECT->Read(FLAGS, RECORDOFFSET, HASHREF)\n" unless @_ == 3;
 
     my ($readflags,$recordoffset) = @_;
+
+    # This is to get rid of a weird "Use of uninitialized value in subroutine
+    # entry" warning in Perl 5.6.
+    my ($header, $source, $computer, $sid, $data, $strings) =
+	    map { "" } (1..6);
+
     # The following is stolen shamelessly from Wyt's tests for the registry.
     my $result = ReadEventLog($self->{handle}, $readflags, $recordoffset,
-			      my $header, my $source, my $computer, my $sid,
-			      my $data, my $strings);
+			      $header, $source, $computer, $sid, $data,
+			      $strings);
     my ($length,
 	$reserved,
 	$recordnumber,
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/EventLog/EventLog.xs perl-libwin32-0.191/EventLog/EventLog.xs
--- libwin32-0.191/EventLog/EventLog.xs	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/EventLog/EventLog.xs	2004-01-12 16:46:39.671875000 -0800
@@ -3,13 +3,7 @@
  * Written by Jesse Dougherty for hip communications
  */
 
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
+#include "../win32perl.h"
 
 #define SETIV(index,value) sv_setiv(ST(index),value)
 #define SETPV(index,string) sv_setpv(ST(index),string)
@@ -204,7 +198,7 @@
     DWORD eventType
     DWORD category
     DWORD eventID
-    DWORD reserved = NO_INIT
+    DWORD reserved
     char *data = NO_INIT
 CODE:
 {
@@ -240,7 +234,7 @@
 	data = SvPV(ST(6), dataLength);
 	if (USING_WIDE()) {
 	    New(3101, warray, items - 7, LPWSTR);
-	    for (index = 0; index < items - 7; ++index) {
+	    for (index = 0; index < (unsigned)items - 7; ++index) {
 		buffer = SvPV(ST(index+7), bufLength);
 		New(0, pwChar, bufLength+1, WCHAR);
 		A2WHELPER(buffer, pwChar, (bufLength+1)*sizeof(WCHAR));
@@ -248,33 +242,33 @@
 	    }
 	    RETVAL = ReportEventW(
                 hLog,                  /* handle returned by RegisterEventSource */
-                SvIV(ST(2)),           /* event type to log */
-                SvIV(ST(3)),           /* event category */
+                (WORD)SvIV(ST(2)),     /* event type to log */
+                (WORD)SvIV(ST(3)),     /* event category */
                 SvIV(ST(4)),           /* event identifier */
                 NULL,                  /* user security identifier (optional) */
-                items - 7,             /* number of strings to merge with message */
+                (WORD)(items - 7),     /* number of strings to merge with message */
                 dataLength,            /* size of raw (binary) data (in bytes) */
                 (const WCHAR**)warray, /* array of strings to merge with message */
                 data                   /* address of binary data */
 		);
-	    for (index = 0; index < items - 7; ++index) {
+	    for (index = 0; index < (unsigned)items - 7; ++index) {
 		Safefree(warray[index]);
 	    }
 	    Safefree(warray);
 	}
 	else {
 	    New(3101, array, items - 7, char*);
-	    for (index = 0; index < items - 7; ++index) {
+	    for (index = 0; index < (unsigned)items - 7; ++index) {
 		buffer = SvPV(ST(index+7), bufLength);
 		array[index] = buffer;
 	    }
 	    RETVAL = ReportEventA(
                 hLog,                /* handle returned by RegisterEventSource */
-                SvIV(ST(2)),         /* event type to log */
-                SvIV(ST(3)),         /* event category */
+                (WORD)SvIV(ST(2)),   /* event type to log */
+                (WORD)SvIV(ST(3)),   /* event category */
                 SvIV(ST(4)),         /* event identifier */
                 NULL,                /* user security identifier (optional) */
-                items - 7,           /* number of strings to merge with message */
+                (WORD)items - 7,     /* number of strings to merge with message */
                 dataLength,          /* size of raw (binary) data (in bytes) */
                 (const char**)array, /* array of strings to merge with message */
                 data                 /* address of binary data */
@@ -292,12 +286,12 @@
     size_t handle
     DWORD Flags
     DWORD Record
-    char *evtHeader = NO_INIT
-    char *sourceName = NO_INIT
-    char *computerName = NO_INIT
-    char *sid = NO_INIT
-    char *data = NO_INIT
-    char *strings = NO_INIT
+    char *evtHeader
+    char *sourceName
+    char *computerName
+    char *sid
+    char *data
+    char *strings
 CODE:
 {
     int length;
@@ -308,7 +302,6 @@
     lpEvtLog = SVE(handle);
     if ((lpEvtLog != NULL) && (lpEvtLog->dwID == EVTLOGID)) {
 	DWORD NumRead, Required;
-	long retval;
 	if (Flags != lpEvtLog->Flags) {
 	    /* Reset to new read mode & force a re-read call */
 	    lpEvtLog->Flags      = Flags;
@@ -407,7 +400,7 @@
     DWORD id
     char *longstring
     int numstrings
-    char *message = NO_INIT
+    char *message
 CODE:
 {
     HINSTANCE dll = NULL;
@@ -468,7 +461,7 @@
         /* Try to retrieve message *without* expanding the inserts yet */
         ptr = wmsgfile;
         while (ptr && !wmessage) {
-            WCHAR *semi = wcschr(ptr, L';');
+            WCHAR *semi = (WCHAR *)wcschr(ptr, L';');
             if (semi)
                 *semi++ = '\0';
             dll = LoadLibraryExW(ptr, 0, LOAD_LIBRARY_AS_DATAFILE);
@@ -489,7 +482,7 @@
         /* Determine higest %n insert number */
         maxinsert = numstrings;
         ptr = wmessage;
-        while ((percent=wcschr(ptr, L'%'))
+        while ((percent=(WCHAR *)wcschr(ptr, L'%'))
                && swscanf(percent, L"%%%d", &id2) == 1)
         {
             if (id2 > maxinsert)
@@ -519,7 +512,7 @@
 	    wstrings[j] = ptr;
 
 	    ptr += wcslen(ptr)+1;
-	    while ((percent = wcschr(wstrings[j], L'%'))
+	    while ((percent = (WCHAR *)wcschr(wstrings[j], L'%'))
 		   && swscanf(percent, L"%%%%%d", &id2) == 1)
 	    {
 		if (!dll) {		/* first time round - load dll */
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/EventLog/t/eventlog.t perl-libwin32-0.191/EventLog/t/eventlog.t
--- libwin32-0.191/EventLog/t/eventlog.t	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/EventLog/t/eventlog.t	2004-01-12 16:46:39.687500000 -0800
@@ -1,23 +1,27 @@
+#!perl
+# vim:syntax=perl:
+#
 # (c) 1995 Microsoft Corporation. All rights reserved.
 #	Developed by ActiveWare Internet Corp., http://www.ActiveWare.com
 
 # eventlog.t - Event Logging tests
 
-BEGIN {
-    if (Win32::IsWin95()) {
-        print"1..0\n";
-        print STDERR "# EventLog is not supported on Windows 95 or Win32s\n";
-    }
-}
-
 use strict;
+use Win32;
 use Win32::EventLog;
 
+if (not Win32::IsWinNT()) {
+    print "1..0\n";
+    print "# EventLog is not supported on Windows 95 or Win32s\n";
+    exit;
+}
+
 my $bug = 1;
 
 # accounting for the test harness
+
 open ME, $0 or die $!;
-my $bugs = grep /^\$bug\+\+;\n$/, <ME>;
+my $bugs = grep /^\$bug\+\+;/, <ME>;
 close ME;
 
 print "1..$bugs\n";
@@ -75,6 +79,3 @@
 $EventInfo->{Data} eq 'unix' or print "not ";
 print "ok $bug\n";
 $bug++;
-
-
-
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/File/File.xs perl-libwin32-0.191/File/File.xs
--- libwin32-0.191/File/File.xs	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/File/File.xs	2004-01-12 16:46:39.703125000 -0800
@@ -2,14 +2,7 @@
  *
  */
 
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
-
+#include "../win32perl.h"
 
 /* constant function for exporting NT definitions. */
 static long constant(char *name)
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/FileSecurity/FileSecurity.pm perl-libwin32-0.191/FileSecurity/FileSecurity.pm
--- libwin32-0.191/FileSecurity/FileSecurity.pm	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/FileSecurity/FileSecurity.pm	2004-01-12 16:46:39.718750000 -0800
@@ -12,10 +12,11 @@
 require Exporter;
 require DynaLoader;
 use Carp ;
+use Win32;
 
 $VERSION = '1.04';
 
-croak "The Win32::FileSecurity module works only on Windows NT" if (!Win32::IsWinNT()) ;
+croak "The Win32::FileSecurity module works only on Windows NT" if not Win32::IsWinNT();
 
 @ISA= qw( Exporter DynaLoader );
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/FileSecurity/FileSecurity.xs perl-libwin32-0.191/FileSecurity/FileSecurity.xs
--- libwin32-0.191/FileSecurity/FileSecurity.xs	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/FileSecurity/FileSecurity.xs	2004-01-12 16:46:39.718750000 -0800
@@ -9,15 +9,8 @@
  *
  */
 
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
+#include "../win32perl.h"
 #include <winbase.h>
-#include <string.h>
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
 
 #undef New
 #undef Newc
@@ -149,7 +142,7 @@
 	char *name ;
 	I32 Mask = 0 ;
 	
-	for( i = 0 ; i < items ; i++ ) {
+	for( i = 0 ; i < (unsigned)items ; i++ ) {
 	    if ( ! SvPOK( ST(i) ) ) continue ;
 	    name = SvPV( ST(i), len ) ;
 	    
@@ -172,7 +165,7 @@
 	SV *av
     CODE:
 	{
-	    int j, Ok ;
+	    int j;
 	    if (!(av && SvROK(av) && (av = SvRV(av)) && SvTYPE(av) == SVt_PVAV))
     		croak( "second arg must be ARRAYREF" ) ;
 
@@ -201,7 +194,6 @@
 	{
 	    SV*  sv;
 	    SV** psv;
-	    AV*  av;
 	    PSECURITY_DESCRIPTOR pSecDesc = NULL;
 	    SECURITY_DESCRIPTOR_CONTROL Control = 0;
 	    BOOL bDaclPresent, bDaclDefaulted ;
@@ -213,7 +205,7 @@
 		bName = MAXIMUM_NAME_LENGTH, bDName = MAXIMUM_NAME_LENGTH;
 	    SID_NAME_USE eUse ;
 	    DWORD nLength = 0, nLengthNeeded = 1, tries = 2, Revision = 0 ;
-	    DWORD error, i, j ;
+	    DWORD error, i;
 	    BOOL bResult;
 
 	    RETVAL = FALSE;
@@ -422,7 +414,7 @@
 	    /* Initialize a new security descriptor. */
  
 	    /* SECURITY_DESCRIPTOR_MIN_LENGTH defined in WINNT.H */
-	    Newc( 4, pSD, SECURITY_DESCRIPTOR_MIN_LENGTH, char, PSECURITY_DESCRIPTOR );
+	    Newc( 4, pSD, SECURITY_DESCRIPTOR_MIN_LENGTH, char, SECURITY_DESCRIPTOR );
 	    if (pSD == NULL) { 
 		ErrorHandler( "Newc SECURITY_DESCRIPTOR"); 
 		goto SetCleanup ;
@@ -561,7 +553,7 @@
 		while (tries--) {
 		    /* Add Ace */
 		    if ( AccountRights ) {
-			pAllAce->Header.AceSize = sizeof( ACCESS_ALLOWED_ACE ) - sizeof( DWORD ) + GetLengthSid( (PSID) pSID  ) ;
+			pAllAce->Header.AceSize = (WORD)(sizeof( ACCESS_ALLOWED_ACE ) - sizeof( DWORD ) + GetLengthSid( (PSID) pSID  )) ;
 			pAllAce->Mask = (ACCESS_MASK) AccountRights ;
 			
 			if (!AddAce(
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/FileSecurity/mingw32.exc perl-libwin32-0.191/FileSecurity/mingw32.exc
--- libwin32-0.191/FileSecurity/mingw32.exc	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/FileSecurity/mingw32.exc	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/FileSecurity/test.pl perl-libwin32-0.191/FileSecurity/test.pl
--- libwin32-0.191/FileSecurity/test.pl	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/FileSecurity/test.pl	2004-01-12 16:46:39.750000000 -0800
@@ -12,7 +12,7 @@
 foreach (<*>) {
     next unless -e $_;
     my(%hash) = ();
-    if ( Get( $_, \%hash ) ) {
+    if ( eval { Get( $_, \%hash ) } ) {
         print STDERR "----- File: $_ -----\n";
 	while( ($name, $mask) = each %hash ) {
 	    print STDERR "$name:\n\t"; 
@@ -20,8 +20,8 @@
 	    print STDERR join( "\n\t", @happy ), "\n";
 	}
     } else {
-	print( "Error #", int( $! ), ": $!" ) ;
+	my $error = Win32::GetLastError();
+	print( "Error #", $error, ": ", Win32::FormatMessage($error), "\n" ) ;
+	print "$@\n";
     }
 }
-
-
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/Animation.xs perl-libwin32-0.191/GUI/Animation.xs
--- libwin32-0.191/GUI/Animation.xs	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/Animation.xs	2004-01-12 16:46:39.765625000 -0800
@@ -0,0 +1,92 @@
+    /*
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::Animation
+    #
+    # $Id: Animation.xs,v 1.3 2003/12/28 07:17:42 caelum Exp $
+    #
+    ###########################################################################
+	*/
+
+#include "GUI.h"
+
+BOOL
+Animation_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs) {
+	BOOL retval;
+	retval = FALSE;
+	BitmaskOptionValue("-autoplay", perlcs->cs.style, ACS_AUTOPLAY)
+	} else BitmaskOptionValue("-center", perlcs->cs.style, ACS_CENTER)
+	} else BitmaskOptionValue("-transparent", perlcs->cs.style, ACS_TRANSPARENT)
+	}
+	return retval;
+}
+
+
+MODULE = Win32::GUI::Animation		PACKAGE = Win32::GUI::Animation
+
+PROTOTYPES: DISABLE
+
+
+    ###########################################################################
+    # (@)METHOD:Open(FILE)
+    # Opens an AVI clip and displays its first frame in an animation control. 
+BOOL
+Open(handle,file)
+    HWND handle
+    char * file
+CODE:
+    RETVAL = Animate_Open(handle, (LPSTR) file);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Close()
+    # Closes an AVI clip and displays its first frame in an animation control
+BOOL
+Close(handle)
+    HWND handle
+CODE:
+    RETVAL = Animate_Close(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Play([FROM], [TO], [REPEAT])
+    # Plays an AVI clip in an animation control.     
+BOOL
+Play(handle,from=0,to=(UINT)-1,repeat=(UINT)-1)
+    HWND handle
+    UINT from
+    UINT to
+    UINT repeat
+CODE:
+    RETVAL = Animate_Play(handle, from, to, repeat);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Stop()
+    # Stops playing an AVI clip in an animation control. 
+BOOL
+Stop(handle)
+    HWND handle
+CODE:
+    RETVAL = Animate_Stop(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Seek(FRAME)
+    # Directs an animation control to display a particular frame of an AVI clip.
+BOOL
+Seek(handle,frame)
+    HWND handle
+    UINT frame
+CODE:
+    RETVAL = Animate_Seek(handle, frame);
+OUTPUT:
+    RETVAL
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/BUGS perl-libwin32-0.191/GUI/BUGS
--- libwin32-0.191/GUI/BUGS	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/BUGS	2004-01-12 16:46:39.781250000 -0800
@@ -0,0 +1 @@
+- various :-)
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/Bitmap.xs perl-libwin32-0.191/GUI/Bitmap.xs
--- libwin32-0.191/GUI/Bitmap.xs	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/Bitmap.xs	2004-01-12 16:46:39.796875000 -0800
@@ -0,0 +1,196 @@
+	/*
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::Bitmap
+    ###########################################################################
+	*/
+
+#include "GUI.h"
+
+MODULE = Win32::GUI::Bitmap		PACKAGE = Win32::GUI::Bitmap
+
+PROTOTYPES: DISABLE
+
+    ###########################################################################
+    # (@)METHOD:Info()
+    # returns a four elements array containing the following information
+    # about the bitmap: width, height, color planes, bits per pixel
+    # or undef on errors
+void
+Info(handle)
+    HBITMAP handle
+PREINIT:
+    BITMAP bitmap;
+PPCODE:
+    ZeroMemory(&bitmap, sizeof(BITMAP));
+    if(GetObject((HGDIOBJ) handle, sizeof(BITMAP), &bitmap)) {
+        EXTEND(SP, 4);
+        XST_mIV(0, bitmap.bmWidth);
+        XST_mIV(1, bitmap.bmHeight);
+        XST_mIV(2, bitmap.bmPlanes);
+        XST_mIV(3, bitmap.bmBitsPixel);
+        XSRETURN(4);
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+    ###########################################################################
+    # (@)METHOD:GetDIBits()
+    # The GetDIBits function retrieves the bits of the specified bitmap and copies them into a buffer using the specified format. 
+void
+GetDIBits(handle, hdc)
+    HBITMAP handle
+    HDC hdc
+PREINIT:
+    BITMAP bitmap;
+    BITMAPINFO bInfo;
+    long bufferlen;
+    LPVOID buffer;
+PPCODE:
+    ZeroMemory(&bInfo, sizeof(BITMAPINFO));
+    bInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+    ZeroMemory(&bitmap, sizeof(BITMAP));
+    if(GetObject((HGDIOBJ) handle, sizeof(BITMAP), &bitmap)) {
+        bufferlen = bitmap.bmHeight * bitmap.bmWidthBytes;
+        buffer = (LPVOID) safemalloc(bufferlen);
+        bInfo.bmiHeader.biWidth       = bitmap.bmWidth;
+        bInfo.bmiHeader.biHeight      = bitmap.bmHeight;
+        bInfo.bmiHeader.biPlanes      = bitmap.bmPlanes;
+        bInfo.bmiHeader.biBitCount    = bitmap.bmBitsPixel;
+        bInfo.bmiHeader.biCompression = BI_RGB;
+#ifdef PERLWIN32GUI_DEBUG
+        printf("XS(Bitmap::GetDIBits): getting %ld bytes...\n", bufferlen);
+#endif
+        if(GetDIBits(
+            hdc,                        // handle of device context
+            handle,                     // handle of bitmap
+            0,                          // first scan line to set in destination bitmap
+            bitmap.bmHeight,            // number of scan lines to copy
+            buffer,                     // address of array for bitmap bits
+            &bInfo,                     // address of structure with bitmap data
+            DIB_RGB_COLORS              // RGB or palette index
+        )) {
+            EXTEND(SP, 5);
+            XST_mIV(0, bitmap.bmWidth);
+            XST_mIV(1, bitmap.bmHeight);
+            XST_mIV(2, bitmap.bmPlanes);
+            XST_mIV(3, bitmap.bmBitsPixel);
+            sv_setpvn(ST(4), (char*) buffer, bufferlen);
+            safefree(buffer);
+            XSRETURN(5);
+        } else {
+#ifdef PERLWIN32GUI_DEBUG
+            printf("XS(Bitmap::GetDIBits): GetDIBits failed (%d)\n", GetLastError());
+#endif
+            safefree(buffer);
+            XSRETURN_UNDEF;
+        }
+    } else {
+#ifdef PERLWIN32GUI_DEBUG
+        printf("XS(Bitmap::GetDIBits): GetObject failed (%d)\n", GetLastError());
+#endif
+        XSRETURN_UNDEF;
+    }
+
+    ###########################################################################
+    # (@)METHOD:Create(WIDTH, HEIGHT, PLANES, BPP, DATA)
+HBITMAP
+Create(width, height, planes, bpp, data)
+    int width
+    int height
+    UINT planes
+    UINT bpp
+    LPVOID data
+CODE:
+    RETVAL = CreateBitmap(width, height, planes, bpp, data);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)INTERNAL:OldInfo()
+void
+OldInfo(handle)
+    HBITMAP handle
+PREINIT:
+    BITMAPINFO bInfo;
+PPCODE:
+    ZeroMemory(&bInfo, sizeof(BITMAPINFO));
+#ifdef PERLWIN32GUI_DEBUG
+	    printf("XS(Bitmap::OldInfo): handle=0x%x\n", handle);
+#endif
+    bInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+    bInfo.bmiHeader.biBitCount = 0; // don't care about colors, just general infos
+    if(GetDIBits(NULL,          // handle of device context
+                 handle,        // handle of bitmap
+                 0,             // first scan line to set in destination bitmap
+                 0,             // number of scan lines to copy
+                 NULL,          // address of array for bitmap bits
+                 &bInfo,        // address of structure with bitmap data
+                 DIB_RGB_COLORS // RGB or palette index
+                )) {
+        EXTEND(SP, 9);
+        XST_mIV(0, bInfo.bmiHeader.biWidth);
+        XST_mIV(1, bInfo.bmiHeader.biHeight);
+        XST_mIV(2, bInfo.bmiHeader.biBitCount);
+        XST_mIV(3, bInfo.bmiHeader.biCompression);
+        XST_mIV(4, bInfo.bmiHeader.biSizeImage);
+        XST_mIV(5, bInfo.bmiHeader.biXPelsPerMeter);
+        XST_mIV(6, bInfo.bmiHeader.biYPelsPerMeter);
+        XST_mIV(7, bInfo.bmiHeader.biClrUsed);
+        XST_mIV(8, bInfo.bmiHeader.biClrImportant);
+        XSRETURN(9);
+    } else {
+#ifdef PERLWIN32GUI_DEBUG
+        printf("XS(Bitmap::OldInfo): GetDIBits failed...\n");
+        printf("XS(Bitmap::OldInfo): LastError is %d\n", GetLastError());
+        printf("XS(Bitmap::OldInfo): bInfo.bmiHeader.biWidth=%d\n", bInfo.bmiHeader.biWidth);
+#endif
+        XSRETURN_UNDEF;
+    }
+
+    ###########################################################################
+    # (@)INTERNAL:OldInfoC()
+void
+OldInfoC(handle)
+    HBITMAP handle
+PREINIT:
+    BITMAPCOREINFO bInfo;
+PPCODE:
+    ZeroMemory(&bInfo, sizeof(BITMAPCOREINFO));
+#ifdef PERLWIN32GUI_DEBUG
+	    printf("XS(Bitmap::OldInfoC): handle=0x%x\n", handle);
+#endif
+    bInfo.bmciHeader.bcSize = sizeof(BITMAPCOREHEADER);
+    bInfo.bmciHeader.bcBitCount = 0; // don't care about colors, just general infos
+    if(GetDIBits(NULL,          // handle of device context
+                 handle,        // handle of bitmap
+                 0,             // first scan line to set in destination bitmap
+                 0,             // number of scan lines to copy
+                 NULL,          // address of array for bitmap bits
+                 (LPBITMAPINFO) &bInfo,        // address of structure with bitmap data
+                 DIB_RGB_COLORS // RGB or palette index
+                )) {
+        EXTEND(SP, 3);
+        XST_mIV(0, bInfo.bmciHeader.bcWidth);
+        XST_mIV(1, bInfo.bmciHeader.bcHeight);
+        XST_mIV(2, bInfo.bmciHeader.bcBitCount);
+        XSRETURN(3);
+    } else {
+#ifdef PERLWIN32GUI_DEBUG
+        printf("XS(Bitmap::OldInfoC): GetDIBits failed...\n");
+        printf("XS(Bitmap::OldInfoC): LastError is %d\n", GetLastError());
+        printf("XS(Bitmap::OldInfoC): bInfo.bmciHeader.bcWidth=%d\n", bInfo.bmciHeader.bcWidth);
+#endif
+        XSRETURN_UNDEF;
+    }
+
+    ###########################################################################
+    # (@)INTERNAL:DESTROY(HANDLE)
+BOOL
+DESTROY(handle)
+    HBITMAP handle
+CODE:
+    RETVAL = DeleteObject((HGDIOBJ) handle);
+OUTPUT:
+    RETVAL
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/BitmapInline.pm perl-libwin32-0.191/GUI/BitmapInline.pm
--- libwin32-0.191/GUI/BitmapInline.pm	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/BitmapInline.pm	2004-01-12 16:46:39.812500000 -0800
@@ -0,0 +1,208 @@
+package Win32::GUI::BitmapInline;
+
+require Exporter;
+@ISA = qw(Exporter);
+@EXPORT = qw(inline);
+
+$VERSION = "0.02";
+
+$Counter = 1;
+
+require Win32::GUI;
+require MIME::Base64;
+
+sub new {
+    my($class, $data) = @_;
+    open(BMP, ">~$$.tmp") or return undef;
+    binmode(BMP);
+    print BMP MIME::Base64::decode($data);
+    close(BMP); 
+    my $B = new Win32::GUI::Bitmap("~$$.tmp");
+    unlink("~$$.tmp");
+    return $B;  
+}
+
+sub newCursor {
+    my($class, $data) = @_;
+    open(BMP, ">~$$.tmp") or return undef;
+    binmode(BMP);
+    print BMP MIME::Base64::decode($data);
+    close(BMP); 
+    my $B = new Win32::GUI::Cursor("~$$.tmp");
+    unlink("~$$.tmp");
+    return $B;  
+}
+
+sub newIcon {
+    my($class, $data) = @_;
+    open(BMP, ">~$$.tmp") or return undef;
+    binmode(BMP);
+    print BMP MIME::Base64::decode($data);
+    close(BMP); 
+    my $B = new Win32::GUI::Icon("~$$.tmp");
+    unlink("~$$.tmp");
+    return $B;  
+}
+
+sub inline {
+    my ($file, $name) = @_;
+
+    $name = "Bitmap" . $Win32::GUI::BitmapInline::Counter++ unless $name;
+
+    my $type = "";
+    $file =~ /\.ico$/i and $type = "Icon";
+    $file =~ /\.cur$/i and $type = "Cursor";
+
+
+    open(BMP, $file) or
+        $! = "Bitmap file '$file' not found",
+        return undef;
+    my $oldsep = $/;
+    undef $/;
+    binmode(BMP);
+    my $ret = "";
+    $ret .= "\$$name = new$type Win32::GUI::BitmapInline( q(\n";
+    $ret .= MIME::Base64::encode( <BMP> );
+    $ret .= ") );\n";
+    close(BMP);
+    $/ = $oldsep;
+    print $ret;
+    return length($ret);
+}
+
+1;
+
+__END__
+
+=head1 NAME
+
+Win32::GUI::BitmapInline - Inline bitmap support for Win32::GUI
+
+=head1 SYNOPSIS
+
+To create a BitmapInline:
+
+    perl -MWin32::GUI::BitmapInline -e inline('image.bmp') >>script.pl
+
+To use a BitmapInline (in script.pl):
+
+    use Win32::GUI;
+    use Win32::GUI::BitmapInline ();
+    
+    $Bitmap1 = new Win32::GUI::BitmapInline( q(
+    Qk32AAAAAAAAAHYAAAAoAAAAEAAAABAAAAABAAQAAAAAAIAAAAAAAAAAAAAAABAAAAAQAAAAAAAA
+    AACcnABjzs4A9/f3AJzO/wCc//8Azv//AP///wD///8A////AP///wD///8A////AP///wD///8A
+    ////AHd3d3d3d3d3d3d3d3d3d3dwAAAAAAAABxIiIiIiIiIHFkVFRUVEQgcWVVRUVFRCBxZVVVVF
+    RUIHFlVVVFRUUgcWVVVVVUVCBxZVVVVUVFIHFlVVVVVVQgcWZmZmZmZSBxIiIiIRERF3cTZlUQd3
+    d3d3EREQd3d3d3d3d3d3d3d3
+    ) );
+
+=head1 DESCRIPTION
+
+This module can be used to "inline" a bitmap file in your script, so
+that it doesn't need to be accompained by several external files 
+(less hassle when you need to redistribute your script or move it 
+to another location).
+
+The C<inline> function is used to create an inlined bitmap resource; it
+will print on STDOUT the packed data including the lines of Perl  
+needed to use the inlined bitmap resource; it is intended to be used as 
+a one-liner whose output is appended to your script.
+
+The function takes the name of the bitmap file to inline as its first
+parameter; an additional, optional parameter can be given which will be 
+the name of the bitmap object in the resulting scriptlet, eg:
+
+    perl -MWin32::GUI::BitmapInline -e inline('image.bmp','IMAGE')
+    
+    $IMAGE = new Win32::GUI::BitmapInline( q( ...
+
+If no name is given, the resulting object name will be $Bitmap1 
+(the next ones $Bitmap2 , $Bitmap3 and so on).
+
+Note that the object returned by C<new Win32::GUI::BitmapInline> is
+a regular Win32::GUI::Bitmap object.
+
+With version 0.02 you can inline icons and cursors too. Nothing changes
+in the inlining process, just the file extension:
+
+    perl -MWin32::GUI::BitmapInline -e inline('harrow.cur','Cursor1') >>script.pl
+    perl -MWin32::GUI::BitmapInline -e inline('guiperl.ico','Icon1') >>script.pl
+
+The module recognizes from the extension the type of object that it
+should recreate, so it will add these lines to F<script.pl>:
+
+    $Cursor1 = newCursor Win32::GUI::BitmapInline( q( ...
+    $Icon1 = newIcon Win32::GUI::BitmapInline( q( ...
+   
+C<newCursor> or C<newIcon> are used in place of just C<new>. As above,
+the returned objects are regular Win32::GUI objects (respectively,
+Win32::GUI::Cursor and Win32::GUI::Icon).
+
+=head1 WARNINGS
+
+=over 4
+
+=item * 
+
+B<Requires MIME::Base64>
+
+...and, of course, Win32::GUI :-)
+
+=for html <P>
+
+=item * 
+
+B<Don't use it on large bitmap files!>
+
+BitmapInline was designed for small bitmaps, such as
+toolbar items, icons, et alia; it is not at all 
+performant.
+Inlined data takes approximatively the size of your
+bitmap file plus a 30%; thus, if you inline a 100k bitmap 
+you're adding about 130k of bad-looking data to your script...
+
+=for html <P>
+
+=item * 
+
+B<Your script must have write access to its current directory>
+
+When inlined data are used in your script (with 
+C<new Win32::GUI::BitmapInline...>)
+a temporary file is created, then loaded as a regular
+bitmap and then immediately deleted.
+This will fail if your script is not able to create and delete
+files in the current directory at the moment of the call.
+One workaround could be to change directory to a safer place
+before constructing the bitmap:
+
+    chdir("c:\\temp");
+    $Bitmap1 = new Win32::GUI::BitmapInline( ... );
+
+A better solution could pop up in some future release...
+
+=for html <P>
+
+=item *
+
+B<The package exports C<inline> by default>
+
+For practical reasons (see one-liners above), C<inline> is 
+exported by default into your C<main> namespace; to avoid
+this side-effect is recommended to use the module in your
+production scripts as follows:
+
+    use Win32::GUI::BitmapInline ();
+
+=back
+
+=head1 VERSION
+
+Win32::GUI::BitmapInline version 0.02, 24 January 2001.
+
+=head1 AUTHOR
+
+Aldo Calpini ( C<dada@perl.it> ).
+
+=cut
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/CHANGELOG perl-libwin32-0.191/GUI/CHANGELOG
--- libwin32-0.191/GUI/CHANGELOG	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/CHANGELOG	2004-01-12 16:46:39.812500000 -0800
@@ -0,0 +1,50 @@
+###############################################################################
+# CHANGELOG
+# $Id: CHANGELOG,v 1.2 2003/12/28 07:17:42 caelum Exp $
+###############################################################################
+
+Win32-GUI-665-Fix ChangeLog
+===========================
+
++ [Laurent Rocher]
+	- GUI.pm : Change version to 0.0.670
+	- GUI.h  : Set NO_XSLOCKS for perl 5.005
+	- GUI_MessageLoops.cpp : Fix for perl 5.005
++ [Steve Pick]
+	- GUI.xs : Update to Hook() - now returns previous handler coderef on hook reassignment, 0 if no previous assignment, and undef if error.
+	- GUI_MessageLoops.cpp : Added code to call Hook()ed handlers to NEM_ChildMsgLoop
++ [Laurent Rocher]
+	- GUI.pm : Add AddDatetime, AddGraphics methods
+	- GUI.xs : Fix DoEvents double event, add some DateTime methods (GetTime, SetTime, SetNone, IsNone).
+	- GUI_Options.cpp : Add option parsing for DateTime control (-align, -format, -shownone, -updown)
+	- Typemap : LPARAM handle as string or integer.
++ [Steve Pick]
+	- GUI.xs : Added Hook and UnHook methods. These let you do $win->Hook(MsgID, \&somesub); to hook a message to a sub. The sub must be a coderef, and is called with self, wparam and lparam args when the message is received by the window.
+	- GUI.h  : Addition of avHooks to PERLWIN32GUI_CREATESTRUCT and PERLWIN32GUI_USERDATA.
+	- GUI_MessageLoops.cpp : Addition of hook-calling code to NEM_WindowMsgLoop.
++ [Laurent Rocher]
+	- GUI.pm : Fix -prompt option for TextField, correct color option for class (Win98SE).
+	- GUI_Options.cpp : Correct -popstyle and -popexstyle like options.
++ [Glenn Linderman] GUI_Options.cpp : Correct menu -enabled option.
++ [Steve Pick] GUI.h : Added PERLWIN32GUI_NEM_TIMER event.
+	- GUI.pm: fixed Win32::GUI::Class::new to avoid the "white background" syndrome on Windows 2000. Fixed conditional so that all operating systems with version above and including 5.1 have the no-white-background fix.
+	- GUI_MessageLoops.cpp: added WM_TIMER event to NEM_WindowMsgLoop, now NEM handler -onTimer will be called whenever a timer added to the window triggers. The NAME of the timer is provided as an argument to the handler.
+	- GUI_Options.cpp: Fix to allow -onTimer.
+	- GUI_Events.cpp: NEM Events always returned PerlResult of -2, even if a handler was found and called for the event. Now it returns 0 if everything was successful, as it should judging by the rest of the code.
++ [Laurent Rocher] Add build with MinGW and ExtUtils-FakeConfig support.
+  You can build Win32-GUI for ActiveState Perl with Free MingW Compiler.
+  See HowTo : http://perso.club-internet.fr/rocherl/Win32GUI.html
++ [Steve Pick] GUI.pm: Fix ImageList bug
++ [Glenn Linderman] MessageLoops.cpp: Fix Window Cursor bug (Without return FALSE statement)
++ [Steve Pick] GUI.xs : Fix PeekMessage (move SvROK in inner if and remove sv_2mortal)
++ [Aldo Calpini] GUI.pm
+	- fixed Win32::GUI::Class::new to avoid the "white background" syndrome on XP)
+	- fixed a bug with options parsing in Win32::GUI::Textfield::new
+	- reworked a little the code for Win32::GUI::AcceleratorTable
++ [Glenn Linderman] Accelerator key patch, Correct NotifyIcon DESTROY, add PM_* constants for use with TrackPopupMenu.
++ [Laurent Rocher] Fix some warnings, Remove unused variables, remove constants.c file.
++ [Trevor Garside] Add new RichEdit methods.
++ [Steve Pick & Laurent Rocher] Add parameters for WM_KEYDOWN and WM_KEYUP NEM events in NEM_ChildMsgLoop.
++ [Johan Lindstrom] Add WM_DROPFILES event in WindowMsgLoop.
++ [Laurent Rocher] Add new options for GetOpenFileName and GetSaveFileName.
++ [Jeremy White & Laurent Rocher] Add new datetime control methods and DTS_* styles constants.
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/DC.xs perl-libwin32-0.191/GUI/DC.xs
--- libwin32-0.191/GUI/DC.xs	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/DC.xs	2004-01-12 16:46:39.828125000 -0800
@@ -0,0 +1,589 @@
+
+#include "GUI.h"
+
+	/*
+    ###########################################################################
+    #(@)PACKAGE:Win32::GUI::DC
+    #
+    # $Id: DC.xs,v 1.3 2003/12/28 07:17:42 caelum Exp $
+    #
+    ###########################################################################
+	*/
+
+MODULE = Win32::GUI::DC		PACKAGE = Win32::GUI::DC
+
+PROTOTYPES: DISABLE
+
+
+    ###########################################################################
+    # (@)INTERNAL:CreateDC(DRIVER, DEVICE)
+    # Used by new Win32::GUI::DC.
+HDC
+CreateDC(driver, device)
+    LPCTSTR driver
+    LPCTSTR device
+CODE:
+    RETVAL = CreateDC(driver, device, NULL, NULL);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)INTERNAL:DeleteDC(HANDLE)
+BOOL
+DeleteDC(handle)
+    HDC handle
+CODE:
+    RETVAL = DeleteDC(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)INTERNAL:GetDC(HANDLE)
+    # Gets a handle to the DC associated with the given window
+    # (eg. gets an HDC from an HWND).
+    # Used by new Win32::GUI::DC
+HDC
+GetDC(handle)
+    HWND handle
+CODE:
+    RETVAL = GetDC(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)INTERNAL:ReleaseDC(HWND, HDC)
+    # Opposite of GetDC().
+BOOL
+ReleaseDC(hwnd, hdc)
+    HWND hwnd
+    HDC hdc
+CODE:
+    RETVAL = ReleaseDC(hwnd, hdc);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:TextColor([COLOR])
+    # Gets or sets the text color.
+long
+TextColor(handle, color=(COLORREF) -1)
+    HDC handle
+    COLORREF color
+CODE:
+    if(items == 1) {
+        RETVAL = GetTextColor(handle);
+    } else {
+        RETVAL = SetTextColor(handle, color);
+    }
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:BackColor([COLOR])
+    # Gets or sets the background color.
+long
+BackColor(handle, color=(COLORREF) -1)
+    HDC handle
+    COLORREF color
+CODE:
+    if(items == 1) {
+        RETVAL = (long) GetBkColor(handle);
+    } else {
+        RETVAL = (long) SetBkColor(handle, color);
+    }
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:BkMode([MODE])
+    # Gets or sets the current background mix mode for the DC;
+    # possible values are:
+    #  1 TRANSPARENT
+    #  2 OPAQUE
+long
+BkMode(handle, mode=-1)
+    HDC handle
+    int mode
+CODE:
+    if(items == 1) {
+        RETVAL = (long) GetBkMode(handle);
+    } else {
+        RETVAL = (long) SetBkMode(handle, mode);
+    }
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Save()
+    # Saves the current state of the DC (this means the currently selected
+    # colors, brushes, pens, drawing modes, etc.) to an internal stack.
+    # The function returns a number identifying the saved state; this number
+    # can then be passed to the Restore() function to load it back.
+    # If the return value is zero, an error occurred.
+    # See also Restore().
+int
+Save(handle)
+    HDC handle
+CODE:
+    RETVAL = SaveDC(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Restore([STATE])
+    # Restores the state of the DC saved by Save(). STATE can identify a state
+    # from the saved stack (use the identifier returned by the corresponding
+    # Save() call) or a negative number that specifies how many steps backwards
+    # in the stack to recall (eg. -1 recalls the last saved state).
+    # The default if STATE is not specified is -1.
+    # Note that the restored state is removed from the stack, and if you restore
+    # an early one, all the subsequent states will be removed too.
+    # Returns nonzero if succesful, zero on errors.
+    # See also Save().
+BOOL
+Restore(handle,state=-1)
+    HDC handle
+    int state
+CODE:
+    RETVAL = RestoreDC(handle, state);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:SetPixel(X, Y, [COLOR])
+    # Sets the pixel at X, Y to the specified COLOR
+    # (or to the current TextColor() if COLOR is not specified).
+COLORREF
+SetPixel(handle, x, y, color=(COLORREF)-1)
+    HDC handle
+    int x
+    int y
+    COLORREF color
+CODE:
+    if(items == 3) {
+        color = GetTextColor(handle);
+    }
+    RETVAL = SetPixel(handle, x, y, color);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetPixel(X, Y)
+    # Returns the color of the pixel at X, Y.
+
+COLORREF
+GetPixel(handle, x, y)
+    HDC handle
+    int x
+    int y
+CODE:
+    RETVAL = GetPixel(handle, x, y);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:MoveTo(X, Y)
+    # Moves the current drawing position to the point specified by X, Y.
+    # Returns nonzero if succesful, zero on errors.
+long
+MoveTo(handle, x, y)
+    HDC handle
+    int x
+    int y
+CODE:
+    RETVAL = MoveToEx(handle, x, y, NULL);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:LineTo(X, Y)
+    # Draws a line from the current drawing position up to, but not including,
+    # the point specified by X, Y.
+    # Returns nonzero if succesful, zero on errors.
+long
+LineTo(handle, x, y)
+    HDC handle
+    int x
+    int y
+CODE:
+    RETVAL = LineTo(handle, x, y);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Circle(X, Y, (WIDTH, HEIGHT | RADIUS))
+    # Draws a circle or an ellipse; X, Y, RADIUS specifies the center point
+    # and the radius of the circle, while X, Y, WIDTH, HEIGHT specifies the
+    # center point and the size of the ellipse.
+    # Returns nonzero if succesful, zero on errors.
+BOOL
+Circle(handle, x, y, width, height=-1)
+    HDC handle
+    int x
+    int y
+    int width
+    int height
+CODE:
+    if(height == -1) {
+        width *= 2;
+        height = width;
+    }
+    RETVAL = Arc(handle, x-width/2, y-height/2, width-x, height-y, 0, 0, 0, 0);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Arc(X, Y, RADIUS, START, SWEEP)
+BOOL
+Arc(handle, x, y, radius, start, sweep)
+    HDC handle
+    int x
+    int y
+    DWORD radius
+    FLOAT start
+    FLOAT sweep
+CODE:
+    RETVAL = AngleArc(handle, x, y, radius, start, sweep);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:TextOut(X, Y, TEXT)
+BOOL
+TextOut(handle, x, y, text)
+    HDC handle
+    int x
+    int y
+    char * text
+CODE:
+    RETVAL = TextOut(handle, x, y, text, strlen(text));
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:BeginPath()
+BOOL
+BeginPath(handle)
+    HDC handle
+CODE:
+    RETVAL = BeginPath(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:EndPath()
+BOOL
+EndPath(handle)
+    HDC handle
+CODE:
+    RETVAL = EndPath(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:StrokeAndFillPath()
+BOOL
+StrokeAndFillPath(handle)
+    HDC handle
+CODE:
+    RETVAL = StrokeAndFillPath(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:FillPath()
+BOOL
+FillPath(handle)
+    HDC handle
+CODE:
+    RETVAL = FillPath(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:StrokePath()
+BOOL
+StrokePath(handle)
+    HDC handle
+CODE:
+    RETVAL = StrokePath(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:CloseFigure()
+BOOL
+CloseFigure(handle)
+    HDC handle
+CODE:
+    RETVAL = CloseFigure(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:AbortPath()
+BOOL
+AbortPath(handle)
+    HDC handle
+CODE:
+    RETVAL = AbortPath(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:MapMode([MODE])
+int
+MapMode(handle, mode=-1)
+    HDC handle
+    int mode
+CODE:
+    if(items == 1) {
+        RETVAL = GetMapMode(handle);
+    } else {
+        RETVAL = SetMapMode(handle, mode);
+    }
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:SelectObject(OBJECT)
+HGDIOBJ
+SelectObject(handle, object)
+    HDC handle
+    HGDIOBJ object
+CODE:
+    RETVAL = SelectObject(handle, object);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Rectangle(LEFT, TOP, RIGHT, BOTTOM)
+BOOL
+Rectangle(handle, left, top, right, bottom)
+    HDC handle
+    int left
+    int top
+    int right
+    int bottom
+CODE:
+    RETVAL = Rectangle(handle, left, top, right, bottom);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Ellipse(LEFT, TOP, RIGHT, BOTTOM)
+BOOL
+Ellipse(handle, left, top, right, bottom)
+    HDC handle
+    int left
+    int top
+    int right
+    int bottom
+CODE:
+    RETVAL = Ellipse(handle, left, top, right, bottom);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:InvertRect(LEFT, TOP, RIGHT, BOTTOM)
+BOOL
+InvertRect(handle, left, top, right, bottom)
+    HDC handle
+    int left
+    int top
+    int right
+    int bottom
+PREINIT:
+    RECT rc;
+CODE:
+    rc.left = left;
+    rc.top = top;
+    rc.right = right;
+    rc.bottom = bottom;
+    RETVAL = InvertRect(handle, &rc);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Pie(LEFT, TOP, RIGHT, BOTTOM, XF, YF, XS, YS)
+BOOL
+Pie(handle, left, top, right, bottom, xf, yf, xs, ys)
+    HDC handle
+    int left
+    int top
+    int right
+    int bottom
+    int xf
+    int yf
+    int xs
+    int ys
+CODE:
+    RETVAL = Pie(handle, left, top, right, bottom, xf, yf, xs, ys);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Fill(X, Y, [COLOR], [TYPE])
+BOOL
+Fill(handle, x, y, color=(COLORREF) -1, type=FLOODFILLSURFACE)
+    HDC handle
+    int x
+    int y
+    COLORREF color
+    UINT type
+CODE:
+    if(items == 3) {
+        color = GetPixel(handle, x, y);
+    }
+    RETVAL = ExtFloodFill(handle, x, y, color, type);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:PaintDesktop()
+    # Fills the DC content with the desktop pattern or wallpaper.
+    # Returns nonzero if succesful, zero on errors.
+BOOL
+PaintDesktop(handle)
+    HDC handle
+CODE:
+    RETVAL = PaintDesktop(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Validate()
+    # Validates (removes from the update region) the whole DC area.
+    # This function is intended to be used in a Paint event;
+    # see Win32::GUI::Graphic::Paint().
+    # Returns nonzero if succesful, zero on errors.
+BOOL
+Validate(handle)
+    SV* handle
+CODE:
+    HWND hwnd;
+    SV** window;
+    HV* self;
+    char szKey[] = "-window";
+
+    if(NULL != handle)  {
+        if(SvROK(handle)) {
+        	self = (HV*) SvRV(handle);
+            window = hv_fetch_mg(NOTXSCALL self, szKey, strlen(szKey), 0);
+        	if(window != NULL) {
+            	hwnd = (HWND)(DWORD)SvIV(*window);
+            } else {
+            	XSRETURN_NO;
+            }
+        } else {
+            XSRETURN_NO;
+        }
+    } else {
+    	XSRETURN_NO;
+    }
+    RETVAL = ValidateRect(hwnd, NULL);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:GetUpdateRect([ERASE])
+    # Returns the rectangle (as a four-element array containing left, top,
+    # right, bottom coordinates) that needs to be updated.
+    # If the update region is empty (eg. no need to update, the function
+    # returns undef).
+    # The optional ERASE parameter can be set to 1 to force an erase of
+    # the update region, if there is any; by default, no erase action is
+    # performed.
+    # This function is intended to be used in a Paint event;
+    # see Win32::GUI::Graphic::Paint().
+void
+GetUpdateRect(handle, erase=0)
+    SV* handle
+    BOOL erase
+PREINIT:
+    HWND hwnd;
+    SV** window;
+    HV* self;
+    RECT myRect;
+PPCODE:
+    if(NULL != handle)  {
+        if(SvROK(handle)) {
+        	self = (HV*) SvRV(handle);
+            window = hv_fetch_mg(NOTXSCALL self, "-window", 7, 0);
+        	if(window != NULL) {
+            	hwnd = (HWND)(DWORD)SvIV(*window);
+            } else {
+            	XSRETURN_UNDEF;
+            }
+        } else {
+            XSRETURN_UNDEF;
+        }
+    } else {
+    	XSRETURN_UNDEF;
+    }
+    ZeroMemory(&myRect, sizeof(RECT));
+    if(GetUpdateRect(hwnd, &myRect, erase)) {
+		EXTEND(SP, 4);
+		XST_mIV(0, myRect.left);
+		XST_mIV(1, myRect.top);
+		XST_mIV(2, myRect.right);
+		XST_mIV(3, myRect.bottom);
+		XSRETURN(4);
+	} else {
+		XSRETURN_UNDEF;
+	}
+
+
+    ###########################################################################
+    # (@)METHOD:DrawEdge(LEFT, TOP, RIGHT, BOTTOM, [EDGE, FLAGS])
+BOOL
+DrawEdge(handle, left, top, right, bottom, edge=EDGE_RAISED, flags=BF_RECT)
+    HDC handle
+    int left
+    int top
+    int right
+    int bottom
+    UINT edge
+    UINT flags
+PREINIT:
+    RECT rc;
+CODE:
+    rc.left = left;
+    rc.top = top;
+    rc.right = right;
+    rc.bottom = bottom;
+    RETVAL = DrawEdge(handle, &rc, edge, flags);
+OUTPUT:
+    RETVAL
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/Font.xs perl-libwin32-0.191/GUI/Font.xs
--- libwin32-0.191/GUI/Font.xs	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/Font.xs	2004-01-12 16:46:39.843750000 -0800
@@ -0,0 +1,288 @@
+	/*
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::Font
+    ###########################################################################
+	*/
+
+#include "GUI.h"
+
+
+MODULE = Win32::GUI::Font		PACKAGE = Win32::GUI::Font
+
+PROTOTYPES: DISABLE
+
+
+    ###########################################################################
+    # (@)INTERNAL:Create(%OPTIONS)
+    # Used by new Win32::GUI::Font.
+void
+Create(...)
+PPCODE:
+    int nHeight;
+    int nWidth;
+    int nEscapement;
+    int nOrientation;
+    int fnWeight;
+    DWORD fdwItalic;
+    DWORD fdwUnderline;
+    DWORD fdwStrikeOut;
+    DWORD fdwCharSet;
+    DWORD fdwOutputPrecision;
+    DWORD fdwClipPrecision;
+    DWORD fdwQuality;
+    DWORD fdwPitchAndFamily;
+    char lpszFace[32];                        // pointer to typeface name string
+    int i, next_i;
+    char *option;
+
+    nHeight = 0;                              // logical height of font
+    nWidth = 0;                               // logical average character width
+    nEscapement = 0;                          // angle of escapement
+    nOrientation = 0;                         // base-line orientation angle
+    fnWeight = 400;                           // font weight
+    fdwItalic = 0;                            // italic attribute flag
+    fdwUnderline = 0;                         // underline attribute flag
+    fdwStrikeOut = 0;                         // strikeout attribute flag
+    fdwCharSet = DEFAULT_CHARSET;             // character set identifier
+    fdwOutputPrecision = OUT_DEFAULT_PRECIS;  // output precision
+    fdwClipPrecision = CLIP_DEFAULT_PRECIS;   // clipping precision
+    fdwQuality = DEFAULT_QUALITY;             // output quality
+    fdwPitchAndFamily = DEFAULT_PITCH
+                      | FF_DONTCARE;          // pitch and family
+
+    next_i = -1;
+    for(i = 0; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-height") == 0
+            || strcmp(option, "-size") == 0) {
+				HDC hDisplay;
+                next_i = i + 1;
+                hDisplay = CreateDC("DISPLAY", NULL, NULL, NULL);
+                nHeight = (int) -MulDiv(SvIV(ST(next_i)), GetDeviceCaps(hDisplay, LOGPIXELSY), 72);
+                DeleteDC(hDisplay);
+            }
+            if(strcmp(option, "-width") == 0) {
+                next_i = i + 1;
+                nWidth = (int) SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-escapement") == 0) {
+                next_i = i + 1;
+                nEscapement = (int) SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-orientation") == 0) {
+                next_i = i + 1;
+                nOrientation = (int) SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-weight") == 0) {
+                next_i = i + 1;
+                fnWeight = (int) SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-bold") == 0) {
+                next_i = i + 1;
+                if(SvIV(ST(next_i)) != 0) fnWeight = 700;
+            }
+            if(strcmp(option, "-italic") == 0) {
+                next_i = i + 1;
+                fdwItalic = (DWORD) SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-underline") == 0) {
+                next_i = i + 1;
+                fdwUnderline = (DWORD) SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-strikeout") == 0) {
+                next_i = i + 1;
+                fdwStrikeOut = (DWORD) SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-charset") == 0) {
+                next_i = i + 1;
+                fdwCharSet = (DWORD) SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-outputprecision") == 0) {
+                next_i = i + 1;
+                fdwOutputPrecision = (DWORD) SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-clipprecision") == 0) {
+                next_i = i + 1;
+                fdwClipPrecision = (DWORD) SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-quality") == 0) {
+                next_i = i + 1;
+                fdwQuality = (DWORD) SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-family") == 0) {
+                next_i = i + 1;
+                fdwPitchAndFamily = (DWORD) SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-name") == 0
+            || strcmp(option, "-face") == 0) {
+                next_i = i + 1;
+                strncpy(lpszFace, SvPV_nolen(ST(next_i)), 32);
+            }
+
+        } else {
+            next_i = -1;
+        }
+    }
+    XSRETURN_IV((long) CreateFont(
+        nHeight,
+        nWidth,
+        nEscapement,
+        nOrientation,
+        fnWeight,
+        fdwItalic,
+        fdwUnderline,
+        fdwStrikeOut,
+        fdwCharSet,
+        fdwOutputPrecision,
+        fdwClipPrecision,
+        fdwQuality,
+        fdwPitchAndFamily,
+        (LPCTSTR) lpszFace)
+    );
+
+
+    ###########################################################################
+    # (@)METHOD:GetMetrics()
+    # Returns an associative array of information about the Font:
+    #  -height
+    #  -ascent
+    #  -descent
+    #  -ileading
+    #  -eleading
+    #  -avgwidth
+    #  -maxwidth
+    #  -overhang
+    #  -aspectx
+    #  -aspecty
+    #  -firstchar
+    #  -lastchar
+    #  -breakchar
+    #  -italic
+    #  -underline
+    #  -strikeout
+    #  -flags
+    #  -charset
+void
+GetMetrics(handle)
+    HFONT handle
+PREINIT:
+    HDC hdc;
+    TEXTMETRIC metrics;
+PPCODE:
+    ZeroMemory(&metrics, sizeof(TEXTMETRIC));
+    hdc = CreateDC("DISPLAY", NULL, NULL, NULL);
+    if(hdc != NULL) {
+        SelectObject(hdc, (HGDIOBJ) handle);
+        if(GetTextMetrics(hdc, &metrics)) {
+            DeleteDC(hdc);
+            EXTEND(SP, 38);
+            XST_mPV( 0, "-height");
+            XST_mIV( 1, metrics.tmHeight);
+            XST_mPV( 2, "-ascent");
+            XST_mIV( 3, metrics.tmAscent);
+            XST_mPV( 4, "-descent");
+            XST_mIV( 5, metrics.tmDescent);
+            XST_mPV( 6, "-ileading");
+            XST_mIV( 7, metrics.tmInternalLeading);
+            XST_mPV( 8, "-eleading");
+            XST_mIV( 9, metrics.tmExternalLeading);
+            XST_mPV(10, "-avgwidth");
+            XST_mIV(11, metrics.tmAveCharWidth);
+            XST_mPV(12, "-maxwidth");
+            XST_mIV(13, metrics.tmMaxCharWidth);
+            XST_mPV(14, "-overhang");
+            XST_mIV(15, metrics.tmOverhang);
+            XST_mPV(16, "-aspectx");
+            XST_mIV(17, metrics.tmDigitizedAspectX);
+            XST_mPV(18, "-aspecty");
+            XST_mIV(19, metrics.tmDigitizedAspectY);
+            XST_mPV(20, "-firstchar");
+            XST_mIV(21, metrics.tmFirstChar);
+            XST_mPV(22, "-lastchar");
+            XST_mIV(23, metrics.tmLastChar);
+            XST_mPV(24, "-defchar");
+            XST_mIV(25, metrics.tmDefaultChar);
+            XST_mPV(26, "-breakchar");
+            XST_mIV(27, metrics.tmBreakChar);
+            XST_mPV(28, "-italic");
+            XST_mIV(29, metrics.tmItalic);
+            XST_mPV(30, "-underline");
+            XST_mIV(31, metrics.tmUnderlined);
+            XST_mPV(32, "-strikeout");
+            XST_mIV(33, metrics.tmStruckOut);
+            XST_mPV(34, "-flags");
+            XST_mIV(35, metrics.tmPitchAndFamily);
+            XST_mPV(36, "-charset");
+            XST_mIV(37, metrics.tmCharSet);
+            XSRETURN(38);
+        } else {
+            DeleteDC(hdc);
+            XSRETURN_UNDEF;
+        }
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+    ###########################################################################
+    # (@)METHOD:Info()
+    # Returns an associative array of information about the Font, with
+    # the same options given when creating the font.
+void
+Info(handle)
+    HFONT handle
+PREINIT:
+    LOGFONT logfont;
+PPCODE:
+    ZeroMemory(&logfont, sizeof(LOGFONT));
+    if(GetObject((HGDIOBJ) handle, sizeof(LOGFONT), (LPVOID) &logfont)) {
+		HDC hDisplay;
+		hDisplay = CreateDC("DISPLAY", NULL, NULL, NULL);
+		logfont.lfHeight = -MulDiv(logfont.lfHeight, 72, GetDeviceCaps(hDisplay, LOGPIXELSY));
+		DeleteDC(hDisplay);
+
+        EXTEND(SP, 28);
+        XST_mPV( 0, "-height");
+        XST_mIV( 1, logfont.lfHeight);
+        XST_mPV( 2, "-width");
+        XST_mIV( 3, logfont.lfWidth);
+        XST_mPV( 4, "-escapement");
+        XST_mIV( 5, logfont.lfEscapement);
+        XST_mPV( 6, "-orientation");
+        XST_mIV( 7, logfont.lfOrientation);
+        XST_mPV( 8, "-weight");
+        XST_mIV( 9, logfont.lfWeight);
+        XST_mPV(10, "-italic");
+        XST_mIV(11, logfont.lfItalic);
+        XST_mPV(12, "-underline");
+        XST_mIV(13, logfont.lfUnderline);
+        XST_mPV(14, "-strikeout");
+        XST_mIV(15, logfont.lfStrikeOut);
+        XST_mPV(16, "-charset");
+        XST_mIV(17, logfont.lfCharSet);
+        XST_mPV(18, "-outputprecision");
+        XST_mIV(19, logfont.lfOutPrecision);
+        XST_mPV(20, "-clipprecision");
+        XST_mIV(21, logfont.lfClipPrecision);
+        XST_mPV(22, "-quality");
+        XST_mIV(23, logfont.lfQuality);
+        XST_mPV(24, "-family");
+        XST_mIV(25, logfont.lfPitchAndFamily);
+        XST_mPV(26, "-name");
+        XST_mPV(27, logfont.lfFaceName);
+        XSRETURN(28);
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+
+    ###########################################################################
+    # (@)INTERNAL:DESTROY(handle)
+BOOL
+DESTROY(handle)
+    HFONT handle
+CODE:
+    RETVAL = DeleteObject((HGDIOBJ) handle);
+OUTPUT:
+    RETVAL
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/GUI.h perl-libwin32-0.191/GUI/GUI.h
--- libwin32-0.191/GUI/GUI.h	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/GUI.h	2004-01-12 16:46:39.859375000 -0800
@@ -0,0 +1,447 @@
+// #### Uncomment the next two lines (in increasing verbose order)
+// #### for debugging info
+// #define PERLWIN32GUI_DEBUG
+// #define PERLWIN32GUI_STRONGDEBUG
+
+#define  WIN32_LEAN_AND_MEAN
+#define _WIN32_IE 0x0401
+#ifndef _WIN32_WINNT
+#define _WIN32_WINNT 0x0400
+#endif
+#define STRICT
+#undef NOTRACKMOUSEEVENT
+#include "../win32perl.h"
+#include <winuser.h>
+#include <commctrl.h>
+#include <commdlg.h>
+#include <richedit.h>
+#include <shellapi.h>
+#include <shlobj.h>
+
+// #include <ctl3d.h>
+
+#include "resource.h"
+
+#define MAX_WINDOW_NAME 128
+#define MAX_EVENT_NAME 255
+
+#define WM_EXITLOOP   (WM_APP+1)    /* custom message to exit from the Dialog() function */
+#define WM_NOTIFYICON (WM_APP+2)    /* custom message to process NotifyIcon events */
+
+#define PERLWIN32GUI_DIALOGUI                           0x0001
+#define PERLWIN32GUI_TRACKING                           0x0002
+#define PERLWIN32GUI_HORIZONTAL                         0x0004
+#define PERLWIN32GUI_CHECKED                            0x0008
+#define PERLWIN32GUI_SEENCHECKED                        0x0010
+#define PERLWIN32GUI_CONTAINER                          0x0020
+
+#define PERLWIN32GUI_NEM                                0x2000
+#define PERLWIN32GUI_NEM_PARENT                         0x4000
+#define PERLWIN32GUI_NEM_CHILD                          0x8000
+
+#define PERLWIN32GUI_NEM_MOUSEMOVE                      0x00000001
+#define PERLWIN32GUI_NEM_MOUSEDOWN                      0x00000002
+#define PERLWIN32GUI_NEM_MOUSEUP                        0x00000004
+#define PERLWIN32GUI_NEM_KEYDOWN                        0x00000008
+#define PERLWIN32GUI_NEM_KEYUP                          0x00000010
+#define PERLWIN32GUI_NEM_CLICK                          0x00000020
+#define PERLWIN32GUI_NEM_DBLCLICK                       0x00000040
+#define PERLWIN32GUI_NEM_GOTFOCUS                       0x00000080
+#define PERLWIN32GUI_NEM_LOSTFOCUS                      0x00000100
+
+#define PERLWIN32GUI_NEM_DEACTIVATE                     0x10000001
+#define PERLWIN32GUI_NEM_ACTIVATE                       0x10000002
+#define PERLWIN32GUI_NEM_TERMINATE                      0x10000004
+#define PERLWIN32GUI_NEM_MINIMIZE                       0x10000008
+#define PERLWIN32GUI_NEM_MAXIMIZE                       0x10000010
+#define PERLWIN32GUI_NEM_RESIZE                         0x10000020
+
+#define PERLWIN32GUI_NEM_CHANGE                         0x00000200
+#define PERLWIN32GUI_NEM_CHANGING                       0x00000400
+#define PERLWIN32GUI_NEM_ITEMCLICK                      0x00000800
+#define PERLWIN32GUI_NEM_BUTTONCLICK                    0x00001000
+#define PERLWIN32GUI_NEM_COLUMNCLICK                    0x00002000
+#define PERLWIN32GUI_NEM_COLLAPSE                       0x00004000
+#define PERLWIN32GUI_NEM_EXPAND                         0x00008000
+#define PERLWIN32GUI_NEM_COLLAPSING                     0x00010000
+#define PERLWIN32GUI_NEM_EXPANDING                      0x00020000
+#define PERLWIN32GUI_NEM_NODECLICK                      0x00040000
+#define PERLWIN32GUI_NEM_NEEDTEXT                       0x00080000
+#define PERLWIN32GUI_NEM_HEIGHTCHANGE                   0x00100000
+#define PERLWIN32GUI_NEM_BEGINTRACK                     0x00200000
+#define PERLWIN32GUI_NEM_ENDTRACK                       0x00400000
+#define PERLWIN32GUI_NEM_TRACK                          0x00800000
+#define PERLWIN32GUI_NEM_DIVIDERDBLCLICK                0x01000000
+#define PERLWIN32GUI_NEM_ITEMDBLCLICK                   0x02000000
+#define PERLWIN32GUI_NEM_ITEMCHECK                      0x04000000
+#define PERLWIN32GUI_NEM_TIMER                          0x08000000
+
+#define PERLWIN32GUI_ARGTYPE_INT                        0x0001
+#define PERLWIN32GUI_ARGTYPE_LONG                       0x0002
+#define PERLWIN32GUI_ARGTYPE_WORD                       0x0004
+#define PERLWIN32GUI_ARGTYPE_STRING                     0x0008
+
+#define PERLWIN32GUI_EM_BYNAME                          0x0000
+#define PERLWIN32GUI_EM_BYREF                           0x0001
+#define PERLWIN32GUI_EM_BOTH                            0x0002
+
+/*
+ * object types (for switch()ing)
+ */
+#define WIN32__GUI__WINDOW      0
+#define WIN32__GUI__DIALOG      1
+
+#define WIN32__GUI__STATIC      11
+#define WIN32__GUI__BUTTON      12
+#define WIN32__GUI__EDIT        13
+#define WIN32__GUI__LISTBOX     14
+#define WIN32__GUI__COMBOBOX    15
+
+#define WIN32__GUI__CHECKBOX    21
+#define WIN32__GUI__RADIOBUTTON 22
+#define WIN32__GUI__GROUPBOX    23
+
+#define WIN32__GUI__TOOLBAR     30
+#define WIN32__GUI__PROGRESS    31
+#define WIN32__GUI__STATUS      32
+#define WIN32__GUI__TAB         33
+#define WIN32__GUI__RICHEDIT    34
+#define WIN32__GUI__LISTVIEW    35
+#define WIN32__GUI__TREEVIEW    36
+#define WIN32__GUI__TRACKBAR    37
+#define WIN32__GUI__UPDOWN      38
+#define WIN32__GUI__TOOLTIP     39
+#define WIN32__GUI__ANIMATION   40
+#define WIN32__GUI__REBAR       41
+#define WIN32__GUI__HEADER      42
+#define WIN32__GUI__COMBOBOXEX  43
+#define WIN32__GUI__DTPICK      44
+
+#define WIN32__GUI__GRAPHIC    101
+#define WIN32__GUI__SPLITTER   102
+#define WIN32__GUI__MDICLIENT  103
+
+#define PERLWIN32GUI_CLS_WINDOW      0
+#define PERLWIN32GUI_CLS_DIALOG      1
+
+#define PERLWIN32GUI_CLS_STATIC      11
+#define PERLWIN32GUI_CLS_BUTTON      12
+#define PERLWIN32GUI_CLS_EDIT        13
+#define PERLWIN32GUI_CLS_LISTBOX     14
+#define PERLWIN32GUI_CLS_COMBOBOX    15
+
+#define PERLWIN32GUI_CLS_CHECKBOX    21
+#define PERLWIN32GUI_CLS_RADIOBUTTON 22
+#define PERLWIN32GUI_CLS_GROUPBOX    23
+
+#define PERLWIN32GUI_CLS_TOOLBAR     30
+#define PERLWIN32GUI_CLS_PROGRESS    31
+#define PERLWIN32GUI_CLS_STATUS      32
+#define PERLWIN32GUI_CLS_TAB         33
+#define PERLWIN32GUI_CLS_RICHEDIT    34
+#define PERLWIN32GUI_CLS_LISTVIEW    35
+#define PERLWIN32GUI_CLS_TREEVIEW    36
+#define PERLWIN32GUI_CLS_TRACKBAR    37
+#define PERLWIN32GUI_CLS_UPDOWN      38
+#define PERLWIN32GUI_CLS_TOOLTIP     39
+#define PERLWIN32GUI_CLS_ANIMATION   40
+#define PERLWIN32GUI_CLS_REBAR       41
+#define PERLWIN32GUI_CLS_HEADER      42
+#define PERLWIN32GUI_CLS_COMBOBOXEX  43
+#define PERLWIN32GUI_CLS_DTPICK      44
+
+#define PERLWIN32GUI_CLS_GRAPHIC    101
+#define PERLWIN32GUI_CLS_SPLITTER   102
+#define PERLWIN32GUI_CLS_MDICLIENT  103
+
+
+/*
+ * Various definitions to accomodate the different Perl versions around
+ */
+#ifdef PERL_OBJECT
+#   ifdef _INC_WIN32_PERL5
+#       define NOTXSPROC   CPerlObj *pPerl,
+#       define NOTXSCALL   pPerl,
+#       define CPerl CPerlObj
+#   else // not _INC_WIN32_PERL5
+#       define NOTXSPROC   CPerl *pPerl,
+#       define NOTXSCALL   pPerl,
+#   endif  //  _INC_WIN32_PERL5
+#else
+#   define NOTXSPROC
+#   define NOTXSCALL
+#endif
+
+/*
+ * an extension to Window's CREATESTRUCT structure
+ */
+typedef struct tagPERLWIN32GUI_CREATESTRUCT {
+    CREATESTRUCT cs;
+    /*
+    CREATESTRUCT has the following members:
+        LPVOID      lpCreateParams;
+        HINSTANCE   hInstance;
+        HMENU       hMenu;
+        HWND        hwndParent;
+        int         cy;
+        int         cx;
+        int         y;
+        int         x;
+        LONG        style;
+        LPCTSTR     lpszName;
+        LPCTSTR     lpszClass;
+        DWORD       dwExStyle;
+    */
+    HIMAGELIST  hImageList;
+    HV*         hvParent;
+    HV*         hvSelf;
+    char *      szWindowName;
+    char *      szWindowFunction;
+    HFONT       hFont;
+    int         iClass;
+	HACCEL		hAcc;
+	HWND		hTooltip;
+	HCURSOR		hCursor;
+	char *		szTip;
+	DWORD		dwPlStyle;
+	int			iMinWidth;
+	int			iMaxWidth;
+	int			iMinHeight;
+	int			iMaxHeight;
+	COLORREF	clrForeground;
+	COLORREF	clrBackground;
+	HBRUSH		hBackgroundBrush;
+	int			iEventModel;
+	HV*			hvEvents;
+	DWORD		dwEventMask;
+	AV*			avHooks;
+} PERLWIN32GUI_CREATESTRUCT, *LPPERLWIN32GUI_CREATESTRUCT;
+
+/*
+ * what we'll store in GWL_USERDATA
+ */
+typedef struct tagPERLWIN32GUI_USERDATA {
+	DWORD 		dwSize;							// struct size (our signature)
+#ifdef PERL_OBJECT
+	CPerl   	*pPerl; 						// a pointer to the Perl Object
+#endif
+	SV*			svSelf;							// a pointer to ourself
+	char 		szWindowName[MAX_WINDOW_NAME];	// our -name
+	BOOL		fDialogUI;						// are we to intercept dialog messages?
+	int			iClass;							// our (Perl) class
+	HACCEL		hAcc;							// our accelerator table
+	HWND		hTooltip;
+	HCURSOR		hCursor;
+	DWORD		dwPlStyle;
+	int			iMinWidth;
+	int			iMaxWidth;
+	int			iMinHeight;
+	int			iMaxHeight;
+	COLORREF	clrForeground;
+	COLORREF	clrBackground;
+	HBRUSH		hBackgroundBrush;
+	WNDPROC		wndprocPreContainer;
+	WNDPROC		wndprocPreNEM;
+	int			iEventModel;
+	HV*			hvEvents;
+	DWORD		dwEventMask;
+	HWND		Modal;
+	AV*			avHooks;
+} PERLWIN32GUI_USERDATA, *LPPERLWIN32GUI_USERDATA;
+
+typedef struct tagPERLWIN32GUI_MENUITEMDATA {
+	DWORD		dwSize;
+	char		szName[MAX_WINDOW_NAME];
+	SV*			svCode;
+} PERLWIN32GUI_MENUITEMDATA, *LPPERLWIN32GUI_MENUITEMDATA;
+
+typedef struct tagPERLWIN32GUI_WINPROCS {
+	HWND 		hWnd;
+	WNDPROC		wndProc;
+} PERLWIN32GUI_WINPROCS, *LPPERLWIN32GUI_WINPROCS;
+
+#define ValidUserData(ptr) (ptr != NULL && ptr->dwSize == sizeof(PERLWIN32GUI_USERDATA))
+
+#define HV_SELF_FROM_WINDOW(x) (SV_SELF_FROM_WINDOW(x) ? (HV*)SvRV(SV_SELF_FROM_WINDOW(x)) : NULL)
+
+/*
+ * Section for the constant definitions.
+ */
+#define CROAK croak
+
+
+/*
+ * some Perl macros for backward compatibility
+ */
+#ifndef SvIV
+#	define SvIV(sv) (SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv))
+#endif
+
+#ifndef SvPV
+#	define SvPV(sv, lp) (SvPOK(sv) ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pv(sv, &lp))
+#endif
+
+#ifndef SvPV_nolen
+#	define SvPV_nolen(sv) SvPV(sv, PL_na)
+#endif
+
+#define PERLPUSHMARK(p) if (++markstack_ptr == markstack_max)   \
+    markstack_grow();           \
+    *markstack_ptr = (p) - stack_base
+
+#define PERLXPUSHs(s)   do {\
+    if (stack_max - sp < 1) {\
+        sp = stack_grow(sp, sp, 1);\
+    }\
+    (*++sp = (s)); } while (0)
+
+#ifdef NT_BUILD_NUMBER
+#   ifndef dowarn
+#       define dowarn FALSE
+#   endif
+#endif
+
+#ifndef call_sv
+#	define call_sv	perl_call_sv
+#endif
+
+/*
+ * other useful things
+ */
+#define SwitchBit(mask, bit, set) \
+    if(set == 0) { \
+        if(mask & bit) { \
+            mask ^= bit; \
+        } \
+    } else { \
+        if(!(mask & bit)) { \
+            mask |= bit; \
+        } \
+    }
+
+#define BitmaskOption(string, mask, bit) \
+    if(strcmp(option, string) == 0) { \
+        next_i = i + 1; \
+        SwitchBit(mask, bit, SvIV(ST(next_i)));
+
+#define BitmaskOptionValue(string, mask, bit) \
+    if(strcmp(option, string) == 0) { \
+		retval = TRUE; \
+        SwitchBit(mask, bit, SvIV(value));
+
+
+/* prototypes */
+
+/* GUI_Constants.cpp */
+DWORD constant(NOTXSPROC char *name, int arg);
+
+/* GUI_Helpers.cpp */
+#ifdef PERL_OBJECT
+CPerl *	PERL_OBJECT_FROM_WINDOW(HWND hwnd);
+#endif
+SV * SV_SELF_FROM_WINDOW(HWND hwnd);
+static void hv_magic_check (NOTXSPROC HV *hv, bool *needs_copy, bool *needs_store);
+SV** hv_fetch_mg(NOTXSPROC HV *hv, char *key, U32 klen, I32 lval);
+SV** hv_store_mg(NOTXSPROC HV *hv, char *key, U32 klen, SV* val, U32 hash);
+HWND handle_From(NOTXSPROC SV *pSv);
+char *classname_From(NOTXSPROC SV *pSv);
+COLORREF SvCOLORREF(NOTXSPROC SV* c);
+HWND CreateTooltip(NOTXSPROC HV* parent);
+void CalcControlSize(NOTXSPROC LPPERLWIN32GUI_CREATESTRUCT perlcs, int add_x, int add_y);
+BOOL GetObjectName(NOTXSPROC HWND hwnd, char *Name);
+BOOL GetObjectNameAndClass(NOTXSPROC HWND hwnd, char *Name, int *obj_class);
+HMENU GetMenuFromID(NOTXSPROC int nID);
+BOOL GetMenuName(NOTXSPROC HWND hwnd, int nID, char *Name);
+BOOL GetAcceleratorName(NOTXSPROC int nID, char *Name);
+BOOL GetTimerName(NOTXSPROC HWND hwnd, UINT nID, char *Name);
+BOOL GetNotifyIconName(NOTXSPROC HWND hwnd, UINT nID, char *Name);
+DWORD CALLBACK RichEditSave(DWORD dwCookie, LPBYTE pbBuff, LONG cb, LONG FAR *pcb);
+DWORD CALLBACK RichEditLoad(DWORD dwCookie, LPBYTE pbBuff, LONG cb, LONG FAR *pcb);
+int CALLBACK BrowseForFolderProc(HWND hWnd, UINT uMsg, LPARAM lParam, LPARAM lpData);
+int AdjustSplitterCoord(NOTXSPROC LPPERLWIN32GUI_USERDATA perlud, int x, HWND phwnd);
+void DrawSplitter(NOTXSPROC HWND hwnd);
+BOOL CALLBACK EnumMyWindowsProc(HWND hwnd, LPARAM lparam);
+BOOL CALLBACK CountMyWindowsProc(HWND hwnd, LPARAM lparam);
+
+/* GUI_Events.cpp */
+BOOL ProcessEventError(NOTXSPROC char *Name, int* PerlResult);
+int DoEvent_Generic(NOTXSPROC char *Name);
+int DoEvent_Long(NOTXSPROC char *Name, long argh);
+int DoEvent_TwoLongs(NOTXSPROC char *Name, long argone, long argtwo);
+int DoEvent_ButtonClick(NOTXSPROC char *Name, WPARAM wParam);
+int DoEvent_ListView(NOTXSPROC char *Name, LPARAM lParam);
+int DoEvent_TreeView(NOTXSPROC char *Name, LPARAM lParam);
+int DoEvent_MouseMove(NOTXSPROC char *Name, WPARAM wParam, LPARAM lParam);
+int DoEvent_MouseButton(NOTXSPROC char *Name, WPARAM wParam, LPARAM lParam);
+char * DoEvent_NeedText(NOTXSPROC char *Name, UINT id);
+int DoEvent_NEM(NOTXSPROC LPPERLWIN32GUI_USERDATA perlud, int iEventId, char *Name, ...);
+int DoEvent_NEM_Menu(NOTXSPROC HWND hwnd, int nID, ...);
+
+/* GUI_Options.cpp */
+void ParseNEMEvent(NOTXSPROC LPPERLWIN32GUI_CREATESTRUCT perlcs, char *name, SV* event);
+void ParseWindowOptions(NOTXSPROC register SV **sp, register SV **mark, I32 ax, I32 items, int from_i, LPPERLWIN32GUI_CREATESTRUCT perlcs);
+void ParseMenuItemOptions(NOTXSPROC register SV **sp, register SV **mark, I32 ax, I32 items, int from_i, LPMENUITEMINFO mii, LPPERLWIN32GUI_MENUITEMDATA perlmid, UINT* myItem);
+void ParseHeaderItemOptions(NOTXSPROC register SV **sp, register SV **mark, I32 ax, I32 items, int from_i, LPHDITEMA hditem, int * index);
+void ParseComboboxExItemOptions(NOTXSPROC register SV **sp, register SV **mark, I32 ax, I32 items, int from_i, COMBOBOXEXITEM *item);
+
+
+/* GUI_MessageLoops.cpp */
+LRESULT CommonMsgLoop(NOTXSPROC HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+LRESULT CALLBACK NEM_WindowMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+LRESULT CALLBACK NEM_ChildMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+LRESULT CALLBACK ContainerMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+LRESULT CALLBACK SplitterMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+LRESULT CALLBACK ButtonMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+LRESULT CALLBACK ListboxMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+LRESULT CALLBACK RichEditMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+LRESULT CALLBACK TabStripMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+LRESULT CALLBACK GraphicMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+LRESULT CALLBACK InteractiveGraphicMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+LRESULT CALLBACK WindowMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+LRESULT CALLBACK MsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+LRESULT CALLBACK InactiveMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+
+/*
+ * default procedures for controls
+ */
+
+#define MY_CXT_KEY "Win32::GUI::_guts" XS_VERSION
+
+typedef struct {
+	WNDPROC DefButtonProc;
+	WNDPROC DefListboxProc;
+	WNDPROC DefTabStripProc;
+	WNDPROC DefRichEditProc;
+} my_cxt_t;
+
+START_MY_CXT
+
+/*
+ * class-specific routines for (options|create|etc)
+*/
+BOOL Animation_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs);
+
+BOOL Label_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs);
+void Label_onPostCreate(NOTXSPROC HWND myhandle, LPPERLWIN32GUI_CREATESTRUCT perlcs);
+
+BOOL Listbox_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs);
+void Listbox_onPostCreate(NOTXSPROC HWND myhandle, LPPERLWIN32GUI_CREATESTRUCT perlcs);
+
+BOOL ListView_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs);
+void ListView_onPostCreate(NOTXSPROC HWND myhandle, LPPERLWIN32GUI_CREATESTRUCT perlcs);
+
+BOOL Rebar_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs);
+void Rebar_onPostCreate(NOTXSPROC HWND myhandle, LPPERLWIN32GUI_CREATESTRUCT perlcs);
+
+BOOL Splitter_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs);
+
+BOOL TabStrip_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs);
+void TabStrip_onPostCreate(NOTXSPROC HWND myhandle, LPPERLWIN32GUI_CREATESTRUCT perlcs);
+
+BOOL Textfield_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs);
+
+BOOL Toolbar_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs);
+void Toolbar_onPostCreate(NOTXSPROC HWND myhandle, LPPERLWIN32GUI_CREATESTRUCT perlcs);
+
+BOOL TreeView_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs);
+void TreeView_onPostCreate(NOTXSPROC HWND myhandle, LPPERLWIN32GUI_CREATESTRUCT perlcs);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/GUI.pm perl-libwin32-0.191/GUI/GUI.pm
--- libwin32-0.191/GUI/GUI.pm	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/GUI.pm	2004-01-12 16:46:39.875000000 -0800
@@ -0,0 +1,3047 @@
+###############################################################################
+#
+# Win32::GUI - Perl-Win32 Graphical User Interface Extension
+#
+# 29 Jan 1997 by Aldo Calpini <dada@perl.it>
+#
+# Version: 0.0.665 (27 Feb 2002)
+#
+# Copyright (c) 1997..2002 Aldo Calpini. All rights reserved.
+# This program is free software; you can redistribute it and/or
+# modify it under the same terms as Perl itself.
+#
+# $Id: GUI.pm,v 1.5 2003/12/28 07:17:42 caelum Exp $
+#
+###############################################################################
+package Win32::GUI;
+
+eval { require Win32 };
+require Exporter;       # to export the constants to the main:: space
+require DynaLoader;     # to dynuhlode the module.
+
+# Reserves GUI in the main namespace for us (uhmmm...)
+*GUI:: = \%Win32::GUI::;
+
+###############################################################################
+# STATIC OBJECT PROPERTIES
+#
+$VERSION             = "0.0.670";
+$MenuIdCounter       = 1;
+$TimerIdCounter      = 1;
+$NotifyIconIdCounter = 1;
+%Menus               = ();
+%Accelerators        = ();
+$AcceleratorCounter  = 9001;
+
+@ISA = qw( Exporter DynaLoader );
+@EXPORT = qw(
+    BS_3STATE
+    BS_AUTO3STATE
+    BS_AUTOCHECKBOX
+    BS_AUTORADIOBUTTON
+    BS_CHECKBOX
+    BS_DEFPUSHBUTTON
+    BS_GROUPBOX
+    BS_LEFTTEXT
+    BS_NOTIFY
+    BS_OWNERDRAW
+    BS_PUSHBUTTON
+    BS_RADIOBUTTON
+    BS_USERBUTTON
+    BS_BITMAP
+    BS_BOTTOM
+    BS_CENTER
+    BS_ICON
+    BS_LEFT
+    BS_MULTILINE
+    BS_RIGHT
+    BS_RIGHTBUTTON
+    BS_TEXT
+    BS_TOP
+    BS_VCENTER
+
+    COLOR_3DFACE
+    COLOR_ACTIVEBORDER
+    COLOR_ACTIVECAPTION
+    COLOR_APPWORKSPACE
+    COLOR_BACKGROUND
+    COLOR_BTNFACE
+    COLOR_BTNSHADOW
+    COLOR_BTNTEXT
+    COLOR_CAPTIONTEXT
+    COLOR_GRAYTEXT
+    COLOR_HIGHLIGHT
+    COLOR_HIGHLIGHTTEXT
+    COLOR_INACTIVEBORDER
+    COLOR_INACTIVECAPTION
+    COLOR_MENU
+    COLOR_MENUTEXT
+    COLOR_SCROLLBAR
+    COLOR_WINDOW
+    COLOR_WINDOWFRAME
+    COLOR_WINDOWTEXT
+
+    DS_3DLOOK
+    DS_ABSALIGN
+    DS_CENTER
+    DS_CENTERMOUSE
+    DS_CONTEXTHELP
+    DS_CONTROL
+    DS_FIXEDSYS
+    DS_LOCALEDIT
+    DS_MODALFRAME
+    DS_NOFAILCREATE
+    DS_NOIDLEMSG
+    DS_RECURSE
+    DS_SETFONT
+    DS_SETFOREGROUND
+    DS_SYSMODAL
+
+    DTS_UPDOWN
+    DTS_SHOWNONE
+    DTS_SHORTDATEFORMAT
+    DTS_LONGDATEFORMAT
+    DTS_TIMEFORMAT
+    DTS_APPCANPARSE
+    DTS_RIGHTALIGN
+
+    ES_AUTOHSCROLL
+    ES_AUTOVSCROLL
+    ES_CENTER
+    ES_LEFT
+    ES_LOWERCASE
+    ES_MULTILINE
+    ES_NOHIDESEL
+    ES_NUMBER
+    ES_OEMCONVERT
+    ES_PASSWORD
+    ES_READONLY
+    ES_RIGHT
+    ES_UPPERCASE
+    ES_WANTRETURN
+
+    GW_CHILD
+    GW_HWNDFIRST
+    GW_HWNDLAST
+    GW_HWNDNEXT
+    GW_HWNDPREV
+    GW_OWNER
+
+    IMAGE_BITMAP
+    IMAGE_CURSOR
+    IMAGE_ICON
+
+    LR_DEFAULTCOLOR
+    LR_MONOCHROME
+    LR_COLOR
+    LR_COPYRETURNORG
+    LR_COPYDELETEORG
+    LR_LOADFROMFILE
+    LR_LOADTRANSPARENT
+    LR_DEFAULTSIZE
+    LR_LOADMAP3DCOLORS
+    LR_CREATEDIBSECTION
+    LR_COPYFROMRESOURCE
+    LR_SHARED
+
+    MB_ABORTRETRYIGNORE
+    MB_OK
+    MB_OKCANCEL
+    MB_RETRYCANCEL
+    MB_YESNO
+    MB_YESNOCANCEL
+    MB_ICONEXCLAMATION
+    MB_ICONWARNING
+    MB_ICONINFORMATION
+    MB_ICONASTERISK
+    MB_ICONQUESTION
+    MB_ICONSTOP
+    MB_ICONERROR
+    MB_ICONHAND
+    MB_DEFBUTTON1
+    MB_DEFBUTTON2
+    MB_DEFBUTTON3
+    MB_DEFBUTTON4
+    MB_APPLMODAL
+    MB_SYSTEMMODAL
+    MB_TASKMODAL
+    MB_DEFAULT_DESKTOP_ONLY
+    MB_HELP
+    MB_RIGHT
+    MB_RTLREADING
+    MB_SETFOREGROUND
+    MB_TOPMOST
+    MB_SERVICE_NOTIFICATION
+    MB_SERVICE_NOTIFICATION_NT3X
+
+    MF_STRING
+    MF_POPUP
+
+    SM_ARRANGE
+    SM_CLEANBOOT
+    SM_CMOUSEBUTTONS
+    SM_CXBORDER
+    SM_CYBORDER
+    SM_CXCURSOR
+    SM_CYCURSOR
+    SM_CXDLGFRAME
+    SM_CYDLGFRAME
+    SM_CXDOUBLECLK
+    SM_CYDOUBLECLK
+    SM_CXDRAG
+    SM_CYDRAG
+    SM_CXEDGE
+    SM_CYEDGE
+    SM_CXFIXEDFRAME
+    SM_CYFIXEDFRAME
+    SM_CXFRAME
+    SM_CYFRAME
+    SM_CXFULLSCREEN
+    SM_CYFULLSCREEN
+    SM_CXHSCROLL
+    SM_CYHSCROLL
+    SM_CXHTHUMB
+    SM_CXICON
+    SM_CYICON
+    SM_CXICONSPACING
+    SM_CYICONSPACING
+    SM_CXMAXIMIZED
+    SM_CYMAXIMIZED
+    SM_CXMAXTRACK
+    SM_CYMAXTRACK
+    SM_CXMENUCHECK
+    SM_CYMENUCHECK
+    SM_CXMENUSIZE
+    SM_CYMENUSIZE
+    SM_CXMIN
+    SM_CYMIN
+    SM_CXMINIMIZED
+    SM_CYMINIMIZED
+    SM_CXMINSPACING
+    SM_CYMINSPACING
+    SM_CXMINTRACK
+    SM_CYMINTRACK
+    SM_CXSCREEN
+    SM_CYSCREEN
+    SM_CXSIZE
+    SM_CYSIZE
+    SM_CXSIZEFRAME
+    SM_CYSIZEFRAME
+    SM_CXSMICON
+    SM_CYSMICON
+    SM_CXSMSIZE
+    SM_CYSMSIZE
+    SM_CXVSCROLL
+    SM_CYVSCROLL
+    SM_CYCAPTION
+    SM_CYKANJIWINDOW
+    SM_CYMENU
+    SM_CYSMCAPTION
+    SM_CYVTHUMB
+    SM_DBCSENABLED
+    SM_DEBUG
+    SM_MENUDROPALIGNMENT
+    SM_MIDEASTENABLED
+    SM_MOUSEPRESENT
+    SM_MOUSEWHEELPRESENT
+    SM_NETWORK
+    SM_PENWINDOWS
+    SM_SECURE
+    SM_SHOWSOUNDS
+    SM_SLOWMACHINE
+    SM_SWAPBUTTON
+
+    WM_CREATE
+    WM_DESTROY
+    WM_MOVE
+    WM_SIZE
+    WM_ACTIVATE
+    WM_SETFOCUS
+    WM_KILLFOCUS
+    WM_ENABLE
+    WM_SETREDRAW
+    WM_COMMAND
+    WM_KEYDOWN
+    WM_SETCURSOR
+    WM_KEYUP
+
+    WS_BORDER
+    WS_CAPTION
+    WS_CHILD
+    WS_CHILDWINDOW
+    WS_CLIPCHILDREN
+    WS_CLIPSIBLINGS
+    WS_DISABLED
+    WS_DLGFRAME
+    WS_GROUP
+    WS_HSCROLL
+    WS_ICONIC
+    WS_MAXIMIZE
+    WS_MAXIMIZEBOX
+    WS_MINIMIZE
+    WS_MINIMIZEBOX
+    WS_OVERLAPPED
+    WS_OVERLAPPEDWINDOW
+    WS_POPUP
+    WS_POPUPWINDOW
+    WS_SIZEBOX
+    WS_SYSMENU
+    WS_TABSTOP
+    WS_THICKFRAME
+    WS_TILED
+    WS_TILEDWINDOW
+    WS_VISIBLE
+    WS_VSCROLL
+
+    WS_EX_ACCEPTFILES
+    WS_EX_APPWINDOW
+    WS_EX_CLIENTEDGE
+    WS_EX_CONTEXTHELP
+    WS_EX_CONTROLPARENT
+    WS_EX_DLGMODALFRAME
+    WS_EX_LEFT
+    WS_EX_LEFTSCROLLBAR
+    WS_EX_LTRREADING
+    WS_EX_MDICHILD
+    WS_EX_NOPARENTNOTIFY
+    WS_EX_OVERLAPPEDWINDOW
+    WS_EX_PALETTEWINDOW
+    WS_EX_RIGHT
+    WS_EX_RIGHTSCROLLBAR
+    WS_EX_RTLREADING
+    WS_EX_STATICEDGE
+    WS_EX_TOOLWINDOW
+    WS_EX_TOPMOST
+    WS_EX_TRANSPARENT
+    WS_EX_WINDOWEDGE
+
+    TPM_LEFTBUTTON
+    TPM_RIGHTBUTTON
+	TPM_LEFTALIGN
+	TPM_CENTERALIGN
+	TPM_RIGHTALIGN
+	TPM_TOPALIGN
+	TPM_VCENTERALIGN
+	TPM_BOTTOMALIGN
+	TPM_HORIZONTAL
+	TPM_VERTICAL
+	TPM_NONOTIFY
+	TPM_RETURNCMD
+	TPM_RECURSE
+);
+
+###############################################################################
+# This AUTOLOAD is used to 'autoload' constants from the constant()
+# XS function.  If a constant is not found then control is passed
+# to the AUTOLOAD in AutoLoader.
+#
+
+sub AUTOLOAD {
+    my($constname);
+    ($constname = $AUTOLOAD) =~ s/.*:://;
+    #reset $! to zero to reset any current errors.
+    $! = 0;
+    my $val = constant($constname, @_ ? $_[0] : 0);
+    if ($! != 0) {
+        if ($! =~ /Invalid/) {
+            $AutoLoader::AUTOLOAD = $AUTOLOAD;
+            goto &AutoLoader::AUTOLOAD;
+        } else {
+            my($pack,$file,$line) = caller; # undef $pack;
+            die "Can't find '$constname' in package '$pack' ".
+                "used at $file line $line.";
+        }
+    }
+    eval "sub $AUTOLOAD { $val }";
+    goto &$AUTOLOAD;
+}
+
+sub bootstrap_subpackage {
+    my($package) = @_;
+    $package = 'Win32::GUI::' . $package;
+    my $symbol = $package;
+    $symbol =~ s/\W/_/g;
+    no strict 'refs';
+    DynaLoader::dl_install_xsub(
+        "${package}::bootstrap",
+        DynaLoader::dl_find_symbol_anywhere( "boot_$symbol" )
+    );
+    &{ "${package}::bootstrap" };
+}
+
+###############################################################################
+# PUBLIC METHODS
+# (@)PACKAGE:Win32::GUI
+
+    ###########################################################################
+    # (@)METHOD:Version()
+    # Returns the module version number.
+sub Version {
+    return $VERSION;
+}
+
+    ###########################################################################
+    # (@)METHOD:SetFont(FONT)
+    # Sets the font of the window (FONT is a Win32::GUI::Font object).
+sub SetFont {
+    my($self, $font) = @_;
+    $font = $font->{-handle} if ref($font);
+    # 48 == WM_SETFONT
+    return Win32::GUI::SendMessage($self, 48, $font, 0);
+}
+
+    ###########################################################################
+    # (@)METHOD:GetFont(FONT)
+    # Gets the font of the window (returns an handle; use
+    #   $Font = $W->GetFont();
+    #   %details = Win32::GUI::Font::Info( $Font );
+    # to get font details).
+sub GetFont {
+    my($self) = shift;
+    # 49 == WM_GETFONT
+    return Win32::GUI::SendMessage($self, 49, 0, 0);
+}
+
+    ###########################################################################
+    # (@)METHOD:SetIcon(ICON, [TYPE])
+    # Sets the icon of the window; TYPE can be 0 for the small icon, 1 for
+    # the big icon. Default is the same icon for small and big.
+sub SetIcon {
+    my($self, $icon, $type) = @_;
+    $icon = $icon->{-handle} if ref($icon);
+    # 128 == WM_SETICON
+    if(defined($type)) {
+        return Win32::GUI::SendMessage($self, 128, $type, $icon);
+    } else {
+        Win32::GUI::SendMessage($self, 128, 0, $icon); # small icon
+        Win32::GUI::SendMessage($self, 128, 1, $icon); # big icon
+    }
+}
+
+    ###########################################################################
+    # (@)METHOD:SetRedraw(FLAG)
+    # Determines if a window is automatically redrawn when its content changes.
+    # FLAG can be a true value to allow redraw, false to prevent it.
+sub SetRedraw {
+    my($self, $value) = @_;
+    # 11 == WM_SETREDRAW
+    my $r = Win32::GUI::SendMessage($self, 11, $value, 0);
+    return $r;
+}
+
+    ###########################################################################
+    # (@)INTERNAL:MakeMenu(...)
+    # better used as new Win32::GUI::Menu(...)
+sub MakeMenu {
+    my(@menudata) = @_;
+    my $i;
+    my $M = new Win32::GUI::Menu();
+    my $text;
+    my %data;
+    my $level;
+    my %last;
+    my $parent;
+    for($i = 0; $i <= $#menudata; $i += 2) {
+        $text = $menudata[$i];
+        undef %data;
+        if(ref($menudata[$i+1])) {
+            %data = %{$menudata[$i+1]};
+        } else {
+            $data{-name} = $menudata[$i+1];
+        }
+        $level = 0;
+        $level++ while($text =~ s/^\s*>\s*//);
+
+        # print "PM(MakeMenu) processing '$data{-name}', level=$level\n";
+
+        if($level == 0) {
+            $M->{$data{-name}} = $M->AddMenuButton(
+                -id => $MenuIdCounter++,
+                -text => $text,
+                %data,
+            );
+            $last{$level} = $data{-name};
+            $last{$level+1} = "";
+        } elsif($level == 1) {
+            $parent = $last{$level-1};
+            if($text eq "-") {
+                $data{-name} = "dummy$MenuIdCounter";
+                $M->{$data{-name}} = $M->{$parent}->AddMenuItem(
+                    -item => 0,
+                    -id => $MenuIdCounter++,
+                    -separator => 1,
+                    -name => $data{-name},
+                );
+            } else {
+                $M->{$data{-name}} = $M->{$parent}->AddMenuItem(
+                    -item => 0,
+                    -id => $MenuIdCounter++,
+                    -text => $text,
+                    %data,
+                );
+            }
+            $last{$level} = $data{-name};
+            $last{$level+1} = "";
+        } else {
+            $parent = $last{$level-1};
+            if(!$M->{$parent."_Submenu"}) {
+                $M->{$parent."_Submenu"} = new Win32::GUI::Menu();
+                $M->{$parent."_SubmenuButton"} =
+                    $M->{$parent."_Submenu"}->AddMenuButton(
+                        -id => $MenuIdCounter++,
+                        -text => $parent,
+                        -name => $parent."_SubmenuButton",
+                    );
+                $M->{$parent}->Change(
+                    -submenu => $M->{$parent."_SubmenuButton"}
+                );
+            }
+            if($text eq "-") {
+                $data{-name} = "dummy$MenuIdCounter";
+                $M->{$data{-name}} =
+                    $M->{$parent."_SubmenuButton"}->AddMenuItem(
+                        -item => 0,
+                        -id => $MenuIdCounter++,
+                        -separator => 1,
+                        -name => $data{-name},
+                    );
+            } else {
+                $M->{$data{-name}} =
+                    $M->{$parent."_SubmenuButton"}->AddMenuItem(
+                        -item => 0,
+                        -id => $MenuIdCounter++,
+                        -text => $text,
+                        %data,
+                    );
+            }
+            $last{$level} = $data{-name};
+            $last{$level+1} = "";
+        }
+    }
+    return $M;
+}
+
+    ###########################################################################
+    # (@)INTERNAL:_new(TYPE, %OPTIONS)
+    # This is the generalized constructor;
+    # it works pretty well for almost all controls.
+    # However, other kind of objects may overload it.
+sub _new {
+    # this is always Win32::GUI (class of _new):
+    my $xclass = shift;
+
+    # the window type passed by new():
+    my $type = shift;
+
+    # this is the real class:
+    my $class = shift;
+
+    my $oself = {};
+    # bless($oself, $class);
+    my %tier = ();
+    tie %tier, $class, $oself;
+    my $self = bless \%tier, $class;
+
+
+    my (@input) = @_;
+    # print "PM(Win32::GUI::_new) self='$self' type='$type' input='@input'\n";
+    my $handle = Win32::GUI::Create($self, $type, @input);
+
+    # $self->{-handle} = $handle;
+
+    # print "[_new] enumerating self.keys\n";
+    # foreach my $k (keys %$self) {
+    #   print "[_new] '$k' = '$self->{$k}'\n";
+    # }
+    if($handle) {
+        return $self;
+    } else {
+        return undef;
+    }
+}
+
+###############################################################################
+# SUB-PACKAGES
+#
+
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Font
+#
+package Win32::GUI::Font;
+@ISA = qw(Win32::GUI);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Font(%OPTIONS)
+    # Creates a new Font object. %OPTIONS are:
+    #   -size
+    #   -height
+    #   -width
+    #   -escapement
+    #   -orientation
+    #   -weight
+    #   -bold => 0/1
+    #   -italic => 0/1
+    #   -underline => 0/1
+    #   -strikeout => 0/1
+    #   -charset
+    #   -outputprecision
+    #   -clipprecision
+    #   -family
+    #   -quality
+    #   -name
+    #   -face
+sub new {
+    my $class = shift;
+    my $self = {};
+
+    my $handle = Create(@_);
+
+    if($handle) {
+        $self->{-handle} = $handle;
+        bless($self, $class);
+        return $self;
+    } else {
+        return undef;
+    }
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Bitmap
+#
+package Win32::GUI::Bitmap;
+@ISA = qw(Win32::GUI);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Bitmap(FILENAME, [TYPE, X, Y, FLAGS])
+    # Creates a new Bitmap object reading from FILENAME; all other arguments
+    # are optional. TYPE can be:
+    #   0  bitmap (this is the default)
+    #   1  icon
+    #   2  cursor
+    # You can eventually specify your desired size for the image with X and
+    # Y and pass some FLAGS to the underlying LoadImage API (at your own risk)
+sub new {
+    my $class = shift;
+    my $self = {};
+
+    my $handle = Win32::GUI::LoadImage(@_);
+
+    if($handle) {
+        $self->{-handle} = $handle;
+        bless($self, $class);
+        return $self;
+    } else {
+        return undef;
+    }
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Icon
+#
+package Win32::GUI::Icon;
+@ISA = qw(Win32::GUI);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Icon(FILENAME)
+    # Creates a new Icon object reading from FILENAME.
+sub new {
+    my $class = shift;
+    my $file = shift;
+    my $self = {};
+
+    my $handle = Win32::GUI::LoadImage(
+        $file,
+        Win32::GUI::constant("IMAGE_ICON", 0),
+    );
+
+    if($handle) {
+        $self->{-handle} = $handle;
+        bless($self, $class);
+        return $self;
+    } else {
+        return undef;
+    }
+}
+
+    ###########################################################################
+    # (@)INTERNAL:DESTROY()
+sub DESTROY {
+    my $self = shift;
+    Win32::GUI::DestroyIcon($self);
+}
+
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Cursor
+#
+package Win32::GUI::Cursor;
+@ISA = qw(Win32::GUI);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Cursor(FILENAME)
+    # Creates a new Cursor object reading from FILENAME.
+sub new {
+    my $class = shift;
+    my $file = shift;
+    my $self = {};
+
+    my $handle = Win32::GUI::LoadImage(
+        $file,
+        Win32::GUI::constant("IMAGE_CURSOR", 0),
+    );
+
+    if($handle) {
+        $self->{-handle} = $handle;
+        bless($self, $class);
+        return $self;
+    } else {
+        return undef;
+    }
+}
+
+    ###########################################################################
+    # (@)INTERNAL:DESTROY()
+sub DESTROY {
+    my $self = shift;
+    Win32::GUI::DestroyCursor($self);
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Class
+#
+package Win32::GUI::Class;
+@ISA = qw(Win32::GUI);
+
+    ###########################################################################
+    # (@)METHOD: new Win32::GUI::Class(%OPTIONS)
+    # Creates a new window class object.
+    # Allowed %OPTIONS are:
+    #   -name => STRING
+    #       the name for the class (it must be unique!).
+    #   -icon => Win32::GUI::Icon object
+    #   -cursor => Win32::GUI::Cursor object
+    #   -color => COLOR or Win32::GUI::Brush object
+    #       the window background color.
+    #   -menu => STRING
+    #       a menu name (not yet implemented).
+    #   -extends => STRING
+    #       name of the class to extend (aka subclassing).
+    #   -widget => STRING
+    #       name of a widget class to subclass; currently available are:
+    #       Button, Listbox, TabStrip, RichEdit.
+    #   -style => FLAGS
+    #       use with caution!
+sub new {
+    my $class = shift;
+    my %args = @_;
+    my $self = {};
+
+	# figure out the correct background color
+	# (to avoid the "white background" syndrome on XP)
+	if(not exists $args{-color}) {
+		my($undef, $major, $minor) = Win32::GetOSVersion();
+		if($major == 5 && $minor > 0) {
+			$args{-color} = Win32::GUI::constant("COLOR_BTNFACE", 0)+1;
+		} else {
+			$args{-color} = Win32::GUI::constant("COLOR_WINDOW", 0);
+		}
+	}
+
+    my $handle = Win32::GUI::RegisterClassEx(%args);
+
+    if($handle) {
+        $self->{-name}   = $args{-name};
+        $self->{-handle} = $handle;
+        bless($self, $class);
+        return $self;
+    } else {
+        return undef;
+    }
+}
+
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Window
+#
+package Win32::GUI::Window;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Window(%OPTIONS)
+    # Creates a new Window object.
+    # Class specific %OPTIONS are:
+    #   -minsize => [X, Y]
+    #     specifies the minimum size (width and height) in pixels;
+    #     X and Y must be passed in an array reference
+    #   -maxsize => [X, Y]
+    #     specifies the maximum size (width and height) in pixels;
+    #     X and Y must be passed in an array reference
+    #   -minwidth  => N
+    #   -minheight => N
+    #   -maxwidht  => N
+    #   -maxheight => N
+    #     specify the minimum and maximum size width
+    #     and height, in pixels
+    #   -topmost => 0/1 (default 0)
+    #     the window "stays on top" even when deactivated
+sub new {
+    my $self = Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__WINDOW", 0), @_);
+    if($self) {
+        return $self;
+    } else {
+        return undef;
+    }
+}
+
+    ###########################################################################
+    # (@)METHOD:AddButton(%OPTIONS)
+    # See new Win32::GUI::Button().
+sub AddButton      { return Win32::GUI::Button->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddLabel(%OPTIONS)
+    # See new Win32::GUI::Label().
+sub AddLabel       { return Win32::GUI::Label->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddCheckbox(%OPTIONS)
+    # See new Win32::GUI::Checkbox().
+sub AddCheckbox    { return Win32::GUI::Checkbox->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddRadioButton(%OPTIONS)
+    # See new Win32::GUI::RadioButton().
+sub AddRadioButton { return Win32::GUI::RadioButton->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddGroupbox(%OPTIONS)
+    # See new Win32::GUI::Groupbox().
+sub AddGroupbox    { return Win32::GUI::Groupbox->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddTextfield(%OPTIONS)
+    # See new Win32::GUI::Textfield().
+sub AddTextfield   { return Win32::GUI::Textfield->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddListbox(%OPTIONS)
+    # See new Win32::GUI::Listbox().
+sub AddListbox     { return Win32::GUI::Listbox->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddCombobox(%OPTIONS)
+    # See new Win32::GUI::Combobox().
+sub AddCombobox    { return Win32::GUI::Combobox->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddStatusBar(%OPTIONS)
+    # See new Win32::GUI::StatusBar().
+sub AddStatusBar   { return Win32::GUI::StatusBar->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddProgressBar(%OPTIONS)
+    # See new Win32::GUI::ProgressBar().
+sub AddProgressBar { return Win32::GUI::ProgressBar->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddTabStrip(%OPTIONS)
+    # See new Win32::GUI::TabStrip().
+sub AddTabStrip    { return Win32::GUI::TabStrip->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddToolbar(%OPTIONS)
+    # See new Win32::GUI::Toolbar().
+sub AddToolbar     { return Win32::GUI::Toolbar->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddListView(%OPTIONS)
+    # See new Win32::GUI::ListView().
+sub AddListView    { return Win32::GUI::ListView->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddTreeView(%OPTIONS)
+    # See new Win32::GUI::TreeView().
+sub AddTreeView    { return Win32::GUI::TreeView->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddRichEdit(%OPTIONS)
+    # See new Win32::GUI::RichEdit().
+sub AddRichEdit    { return Win32::GUI::RichEdit->new(@_); }
+
+    ###########################################################################
+    # (@)INTERNAL:AddTrackbar(%OPTIONS)
+    # Better used as AddSlider().
+sub AddTrackbar    { return Win32::GUI::Trackbar->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddSlider(%OPTIONS)
+    # See new Win32::GUI::Slider().
+sub AddSlider      { return Win32::GUI::Slider->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddUpDown(%OPTIONS)
+    # See new Win32::GUI::UpDown().
+sub AddUpDown      { return Win32::GUI::UpDown->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddAnimation(%OPTIONS)
+    # See new Win32::GUI::Animation().
+sub AddAnimation   { return Win32::GUI::Animation->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddRebar(%OPTIONS)
+    # See new Win32::GUI::Rebar().
+sub AddRebar       { return Win32::GUI::Rebar->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddHeader(%OPTIONS)
+    # See new Win32::GUI::Header().
+sub AddHeader      { return Win32::GUI::Header->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddComboboxEx(%OPTIONS)
+    # See new Win32::GUI::Combobox().
+sub AddComboboxEx  { return Win32::GUI::ComboboxEx->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddSplitter(%OPTIONS)
+    # See new Win32::GUI::Splitter().
+sub AddSplitter    { return Win32::GUI::Splitter->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddTimer(NAME, ELAPSE)
+    # See new Win32::GUI::Timer().
+sub AddTimer       { return Win32::GUI::Timer->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddNotifyIcon(%OPTIONS)
+    # See new Win32::GUI::NotifyIcon().
+sub AddNotifyIcon  { return Win32::GUI::NotifyIcon->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddDateTime(%OPTIONS)
+    # See new Win32::GUI::DateTime().
+sub AddDateTime  { return Win32::GUI::DateTime->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddGraphic(%OPTIONS)
+    # See new Win32::GUI::Graphic().
+sub AddGraphic  { return Win32::GUI::Graphic->new(@_); }
+
+    ###########################################################################
+    # (@)METHOD:AddMenu()
+    # See new Win32::GUI::Menu().
+sub AddMenu {
+    my $self = shift;
+    my $menu = Win32::GUI::Menu->new();
+    my $r = Win32::GUI::SetMenu($self, $menu->{-handle});
+    # print "SetMenu=$r\n";
+    return $menu;
+}
+
+    ###########################################################################
+    # (@)METHOD:GetDC()
+    # Returns the DC object associated with the window.
+sub GetDC {
+    my $self = shift;
+    return Win32::GUI::DC->new($self);
+}
+
+    ###########################################################################
+    # (@)INTERNAL:DESTROY(HANDLE)
+sub DESTROY {
+    my $self = shift;
+    if(tied($self)) {
+        my $timer;
+        if( exists $self->{-timers} ) {
+            foreach $timer ($self->{-timers}) {
+                undef $self->{-timers}->{$timer};
+            }
+        }
+    }
+    # Win32::GUI::DestroyWindow($self);
+}
+
+    ###########################################################################
+    # (@)INTERNAL:AUTOLOAD(HANDLE, METHOD)
+sub AUTOLOAD {
+    my($self, $method) = @_;
+    $AUTOLOAD =~ s/.*:://;
+    # print "Win32::GUI::Window::AUTOLOAD called for object '$self', method '$method', AUTOLOAD=$AUTOLOAD\n";
+    if( exists $self->{$AUTOLOAD}) {
+        return $self->{$AUTOLOAD};
+    } else {
+        $AutoLoader::AUTOLOAD = $AUTOLOAD;
+        goto &AutoLoader::AUTOLOAD;
+    }
+}
+
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::DialogBox
+#
+package Win32::GUI::DialogBox;
+@ISA = qw(Win32::GUI::Window);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::DialogBox(%OPTIONS)
+    # Creates a new DialogBox object. See new Win32::GUI::Window().
+sub new {
+    my $self = Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__DIALOG", 0), @_);
+    if($self) {
+        $self->DialogUI(1);
+        return $self;
+    } else {
+        return undef;
+    }
+}
+
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::MDI
+#
+package Win32::GUI::MDI;
+@ISA = qw(
+    Win32::GUI::Window
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::MDI(%OPTIONS)
+    # Creates a new MDI (Multiple Document Interface) object.
+    # Class specific %OPTIONS are:
+    #   -minsize => [X, Y]
+    #     specifies the minimum size (width and height) in pixels;
+    #     X and Y must be passed in an array reference
+    #   -maxsize => [X, Y]
+    #     specifies the maximum size (width and height) in pixels;
+    #     X and Y must be passed in an array reference
+    #   -minwidth  => N
+    #   -minheight => N
+    #   -maxwidht  => N
+    #   -maxheight => N
+    #     specify the minimum and maximum size width
+    #     and height, in pixels
+    #   -topmost => 0/1 (default 0)
+    #     the window "stays on top" even when deactivated
+sub new {
+    my $self = Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__MDICLIENT", 0), @_);
+    if($self) {
+        return $self;
+    } else {
+        return undef;
+    }
+}
+
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Button
+#
+package Win32::GUI::Button;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Button(PARENT, %OPTIONS)
+    # Creates a new Button object;
+    # can also be called as PARENT->AddButton(%OPTIONS).
+    # Class specific %OPTIONS are:
+    #     -align   => left/center/right (default left)
+    #     -valign  => top/center/bottom
+    #
+    #     -default => 0/1 (default 0)
+    #     -ok      => 0/1 (default 0)
+    #     -cancel  => 0/1 (default 0)
+    #     -bitmap  => Win32::GUI::Bitmap object
+    #     -picture => see -bitmap
+    #     -icon    => Win32::GUI::Icon object
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__BUTTON", 0), @_);
+}
+
+    ###########################################################################
+    # (@)METHOD:SetImage(BITMAP)
+    # Draws the specified BITMAP, a Win32::GUI::Bitmap or Win32::GUI::Icon
+    # object, in the Button.
+sub SetImage {
+    my $self = shift;
+    my $image = shift;
+    my $type = Win32::GUI::constant("IMAGE_BITMAP", 0);
+    $type = Win32::GUI::constant("IMAGE_ICON", 0) if ref($image) =~ /Icon/;
+    $image = $image->{-handle} if ref($image);
+    # 247 == BM_SETIMAGE
+    return Win32::GUI::SendMessage($self, 247, $type, $image);
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::RadioButton
+#
+package Win32::GUI::RadioButton;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::RadioButton(PARENT, %OPTIONS)
+    # Creates a new RadioButton object;
+    # can also be called as PARENT->AddRadioButton(%OPTIONS).
+    # %OPTIONS are the same of Button (see new Win32::GUI::Button() ).
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__RADIOBUTTON", 0), @_);
+}
+
+    ###########################################################################
+    # (@)METHOD:Checked([VALUE])
+    # Gets or sets the checked state of the RadioButton; if called without
+    # arguments, returns the current state:
+    #   0 not checked
+    #   1 checked
+    # If a VALUE is specified, it can be one of these (eg. 0 to uncheck the
+    # RadioButton, 1 to check it).
+sub Checked {
+    my $self = shift;
+    my $check = shift;
+    if(defined($check)) {
+        # 241 == BM_SETCHECK
+        return Win32::GUI::SendMessage($self, 241, $check, 0);
+    } else {
+        # 240 == BM_GETCHECK
+        return Win32::GUI::SendMessage($self, 240, 0, 0);
+    }
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Checkbox
+#
+package Win32::GUI::Checkbox;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Checkbox(PARENT, %OPTIONS)
+    # Creates a new Checkbox object;
+    # can also be called as PARENT->AddCheckbox(%OPTIONS).
+    # %OPTIONS are the same of Button (see new Win32::GUI::Button() ).
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__CHECKBOX", 0), @_);
+}
+
+
+    ###########################################################################
+    # (@)METHOD:GetCheck()
+    # Returns the check state of the Checkbox:
+    #   0 not checked
+    #   1 checked
+    #   2 indeterminate (grayed)
+sub GetCheck {
+    my $self = shift;
+    # 240 == BM_GETCHECK
+    return Win32::GUI::SendMessage($self, 240, 0, 0);
+}
+
+    ###########################################################################
+    # (@)METHOD:SetCheck([VALUE])
+    # Sets the check state of the Checkbox; for a list of possible values,
+    # see GetCheck().
+    # If called without arguments, it checks the Checkbox (eg. state = 1).
+sub SetCheck {
+    my $self = shift;
+    my $check = shift;
+    $check = 1 unless defined($check);
+    # 241 == BM_SETCHECK
+    return Win32::GUI::SendMessage($self, 241, $check, 0);
+}
+
+    ###########################################################################
+    # (@)METHOD:Checked([VALUE])
+    # Gets or sets the check state of the Checkbox; if called without
+    # arguments, returns the current state:
+    #   0 not checked
+    #   1 checked
+    #   2 indeterminate (grayed)
+    # If a VALUE is specified, it can be one of these (eg. 0 to uncheck the
+    # Checkbox, 1 to check it).
+sub Checked {
+    my $self = shift;
+    my $check = shift;
+    if(defined($check)) {
+        # 241 == BM_SETCHECK
+        return Win32::GUI::SendMessage($self, 241, $check, 0);
+    } else {
+        # 240 == BM_GETCHECK
+        return Win32::GUI::SendMessage($self, 240, 0, 0);
+    }
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Groupbox
+#
+package Win32::GUI::Groupbox;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Groupbox(PARENT, %OPTIONS)
+    # Creates a new Groupbox object;
+    # can also be called as PARENT->AddGroupbox(%OPTIONS).
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__GROUPBOX", 0), @_);
+}
+
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Label
+#
+package Win32::GUI::Label;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Label(PARENT, %OPTIONS)
+    # Creates a new Label object;
+    # can also be called as PARENT->AddLabel(%OPTIONS).
+    # Class specific %OPTIONS are:
+    #    -align    => left/center/right (default left)
+    #    -bitmap   => Win32::GUI::Bitmap object
+    #    -fill     => black/gray/white/none (default none)
+    #        fills the control rectangle ("black", "gray" and "white" are
+    #        the window frame color, the desktop color and the window
+    #        background color respectively).
+    #    -frame    => black/gray/white/etched/none (default none)
+    #        draws a border around the control. colors are the same
+    #        of -fill, with the addition of "etched" (a raised border).
+    #    -icon     => Win32::GUI::Icon object
+    #    -noprefix => 0/1 (default 0)
+    #        disables the interpretation of "&" as accelerator prefix.
+    #    -notify   => 0/1 (default 0)
+    #        enables the Click(), DblClick, etc. events.
+    #    -picture  => see -bitmap
+    #    -sunken   => 0/1 (default 0)
+    #        draws a half-sunken border around the control.
+    #    -truncate => 0/1/word/path (default 0)
+    #        specifies how the text is to be truncated:
+    #            0 the text is not truncated
+    #            1 the text is truncated at the end
+    #         path the text is truncated before the last "\"
+    #              (used to shorten paths).
+    #    -wrap     => 0/1 (default 1)
+    #        the text wraps automatically to a new line.
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__STATIC", 0), @_);
+}
+
+    ###########################################################################
+    # (@)METHOD:SetImage(BITMAP)
+    # Draws the specified BITMAP, a Win32::GUI::Bitmap object, in the Label.
+sub SetImage {
+    my $self = shift;
+    my $image = shift;
+    $image = $image->{-handle} if ref($image);
+    my $type = Win32::GUI::constant("IMAGE_BITMAP", 0);
+    # 370 == STM_SETIMAGE
+    return Win32::GUI::SendMessage($self, 370, $type, $image);
+}
+
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Textfield
+#
+package Win32::GUI::Textfield;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Textfield(PARENT, %OPTIONS)
+    # Creates a new Textfield object;
+    # can also be called as PARENT->AddTextfield(%OPTIONS).
+    # Class specific %OPTIONS are:
+    #   -align         => left/center/right (default left)
+    #       aligns the text in the control accordingly.
+    #   -keepselection => 0/1 (default 0)
+    #       the selection is not hidden when the control loses focus.
+    #   -multiline     => 0/1 (default 0)
+    #       the control can have more than one line (note that newline
+    #       is "\r\n", not "\n"!).
+    #   -password      => 0/1 (default 0)
+    #       masks the user input (like password prompts).
+    #   -passwordchar  => char (default '*')
+    #       the char that is shown instead of the text with -password => 1.
+    #   -prompt        => (see below)
+    #   -readonly      => 0/1 (default 0)
+    #       text can't be changed.
+    #
+    # The -prompt option is very special; if a string is passed, a
+    # Win32::GUI::Label object (with text set to the string passed) is created
+    # to the left of the Textfield.
+    # Example:
+    #     $Window->AddTextfield(
+    #         -name   => "Username",
+    #         -left   => 75,
+    #         -top    => 150,
+    #         -prompt => "Your name:",
+    #     );
+    # Furthermore, the value to -prompt can be a reference to a list containing
+    # the string and an additional parameter, which sets the width for
+    # the Label (eg. [ STRING, WIDTH ] ). If WIDTH is negative, it is calculated
+    # relative to the Textfield left coordinate. Example:
+    #
+    #     -left => 75,                          (Label left) (Textfield left)
+    #     -prompt => [ "Your name:", 30 ],       75           105 (75+30)
+    #
+    #     -left => 75,
+    #     -prompt => [ "Your name:", -30 ],      45 (75-30)   75
+    #
+    # Note that the Win32::GUI::Label object is named like the Textfield, with
+    # a "_Prompt" suffix (in the example above, the Label is named
+    # "Username_Prompt").
+sub new {
+    my($class, $parent, @options) = @_;
+    my %options = @options;
+    if(exists $options{-prompt}) {
+        my $add = 0;
+        my ($text, $left, $width, $height, );
+        my $visible = 1;
+        # Convert -pos and -size options to -left, -top, -width and -height options
+        if (exists $options{-pos}) {
+          $options{-left} = $options{-pos}[0];
+          $options{-top}  = $options{-pos}[1];
+        }
+        if (exists $options{-size}) {
+          $options{-width}  = $options{-size}[0];
+          $options{-height} = $options{-size}[1];
+        }
+
+        if(ref($options{-prompt}) eq "ARRAY") {
+            $left = pop(@{$options{'-prompt'}});
+            $text = pop(@{$options{'-prompt'}});
+            if($left < 0) {
+                $left = $options{-left} + $left;
+                $width = -$left;
+            } else {
+                $width = $left;
+                $left = $options{-left};
+                $add = $width;
+            }
+        } else {
+            $text = $options{-prompt};
+            $add = -1;
+        }
+        if(exists $options{-height}) {
+            $height = $options{-height}-3;
+        } else {
+            $height = 0;
+        }
+        if(exists $options{-visible}) {
+            $visible = $options{-visible};
+        }
+        my $prompt = new Win32::GUI::Label(
+            $parent,
+            -name    => $options{-name} . '_Prompt',
+            -width   => $width,
+            -left    => $left,
+            -top     => $options{-top} + 3,
+            -text    => $text,
+            -height  => $height,
+            -visible => $visible,
+        );
+        $add = $prompt->Width if $add == -1;
+        $options{-left} += $add;
+
+        # Update array options
+        for (my $i = 0; $i < @options; $i += 2) {
+            if ($options[$i] eq '-left') {
+                $options[$i+1] = $options{-left};
+                last;
+            }
+            if ($options[$i] eq '-pos') {
+                $options[$i+1][0] = $options{-left};
+                last;
+            }
+        }
+    }
+    return Win32::GUI->_new(
+        Win32::GUI::constant("WIN32__GUI__EDIT", 0),
+        $class, $parent, @options,
+    );
+}
+
+    ###########################################################################
+    # (@)METHOD:Select(START, END)
+    # Selects the specified range of characters.
+sub Select {
+    my($self, $wparam, $lparam) = @_;
+    # 177 == EM_SETSEL
+    return Win32::GUI::SendMessage($self, 177, $wparam, $lparam);
+}
+
+    ###########################################################################
+    # (@)METHOD:SelectAll()
+sub SelectAll {
+    my($self, $wparam, $lparam) = @_;
+    # 177 == EM_SETSEL
+    #  14 == WM_GETTEXTLENGTH
+    return Win32::GUI::SendMessage(
+        $self, 177,
+        0, Win32::GUI::SendMessage($self, 14, 0, 0),
+    );
+}
+
+    ###########################################################################
+    # (@)METHOD:MaxLength([CHARS])
+sub MaxLength {
+    my($self, $chars) = @_;
+    if(defined $chars) {
+        # 197 == EM_SETLIMITTEXT
+        return Win32::GUI::SendMessage($self, 197, $chars, 0);
+    } else {
+        # 213 == EM_GETLIMITTEXT
+        return Win32::GUI::SendMessage($self, 213, 0, 0);
+    }
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Listbox
+#
+package Win32::GUI::Listbox;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Listbox(PARENT, %OPTIONS)
+    # Creates a new Listbox object;
+    # can also be called as PARENT->AddListbox(%OPTIONS).
+    # Class specific %OPTIONS are:
+    #    -multisel => 0/1/2 (default 0)
+    #        specifies the selection type:
+    #            0 single selection
+    #            1 multiple selection
+    #            2 multiple selection ehnanced (with Shift, Control, etc.)
+    #    -sort     => 0/1 (default 0)
+    #        items are sorted alphabetically.
+
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__LISTBOX", 0), @_);
+}
+
+    ###########################################################################
+    # (@)METHOD:SelectedItem()
+sub SelectedItem {
+    my $self = shift;
+    # 392 == LB_GETCURSEL
+    return Win32::GUI::SendMessage($self, 392, 0, 0);
+}
+    ###########################################################################
+    # (@)METHOD:ListIndex()
+sub ListIndex { SelectedItem(@_); }
+
+    ###########################################################################
+    # (@)METHOD:Select(INDEX)
+    # Selects the zero-based INDEX item in the Listbox.
+sub Select {
+    my $self = shift;
+    my $item = shift;
+    # 390 == LB_SETCURSEL
+    my $r = Win32::GUI::SendMessage($self, 390, $item, 0);
+    return $r;
+}
+
+    ###########################################################################
+    # (@)METHOD:Reset()
+sub Reset {
+    my $self = shift;
+    # 388 == LB_RESETCONTENT
+    my $r = Win32::GUI::SendMessage($self, 388, 0, 0);
+    return $r;
+}
+    ###########################################################################
+    # (@)METHOD:Clear()
+sub Clear { Reset(@_); }
+
+
+    ###########################################################################
+    # (@)METHOD:RemoveItem(INDEX)
+    # Removes the zero-based INDEX item from the Listbox.
+sub RemoveItem {
+    my $self = shift;
+    my $item = shift;
+    # 386 == LB_DELETESTRING
+    my $r = Win32::GUI::SendMessage($self, 386, $item, 0);
+    return $r;
+}
+
+    ###########################################################################
+    # (@)METHOD:Count()
+    # Returns the number of items in the Listbox.
+sub Count {
+    my $self = shift;
+    # 395 == LB_GETCOUNT
+    my $r = Win32::GUI::SendMessage($self, 395, 0, 0);
+    return $r;
+}
+
+sub List {
+    my $self = shift;
+    my $index = shift;
+    if(not defined $index) {
+        my @list = ();
+        for my $i (0..($self->Count-1)) {
+            push @list, Win32::GUI::Listbox::Item->new($self, $i);
+        }
+        return @list;
+    } else {
+        return Win32::GUI::Listbox::Item->new($self, $index);
+    }
+}
+sub Item { &List; }
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Listbox::Item
+#
+package Win32::GUI::Listbox::Item;
+
+sub new {
+    my($class, $listbox, $index) = @_;
+    $self = {
+        -parent => $listbox,
+        -index  => $index,
+        -string => $listbox->GetString($index),
+    };
+    return bless $self, $class;
+}
+
+sub Remove {
+    my($self) = @_;
+    $self->{-parent}->RemoveItem($self->{-index});
+    undef $_[0];
+}
+
+sub Select {
+    my($self) = @_;
+    $self->{-parent}->Select($self->{-index});
+}
+
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Combobox
+#
+package Win32::GUI::Combobox;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Combobox(PARENT, %OPTIONS)
+    # Creates a new Combobox object;
+    # can also be called as PARENT->AddCombobox(%OPTIONS).
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__COMBOBOX", 0), @_);
+}
+
+    ###########################################################################
+    # (@)METHOD:SelectedItem()
+    # Returns the zero-based index of the currently selected item, or -1 if
+    # no item is selected.
+sub SelectedItem {
+    my $self = shift;
+    # 327 == CB_GETCURSEL
+    return Win32::GUI::SendMessage($self, 327, 0, 0);
+}
+    ###########################################################################
+    # (@)METHOD:ListIndex()
+    # See SelectedItem().
+sub ListIndex { SelectedItem(@_); }
+
+    ###########################################################################
+    # (@)METHOD:Select(INDEX)
+    # Selects the zero-based INDEX item in the Combobox.
+sub Select {
+    my $self = shift;
+    my $item = shift;
+    # 334 == CB_SETCURSEL
+    my $r = Win32::GUI::SendMessage($self, 334, $item, 0);
+    return $r;
+}
+
+    ###########################################################################
+    # (@)METHOD:Reset()
+sub Reset {
+    my $self = shift;
+    # 331 == CB_RESETCONTENT
+    my $r = Win32::GUI::SendMessage($self, 331, 0, 0);
+    return $r;
+}
+    ###########################################################################
+    # (@)METHOD:Clear()
+sub Clear { Reset(@_); }
+
+    ###########################################################################
+    # (@)METHOD:RemoveItem(INDEX)
+    # Removes the zero-based INDEX item from the Combobox.
+sub RemoveItem {
+    my $self = shift;
+    my $item = shift;
+    # 324 == CB_DELETESTRING
+    my $r = Win32::GUI::SendMessage($self, 324, $item, 0);
+    return $r;
+}
+
+    ###########################################################################
+    # (@)METHOD:Count()
+sub Count {
+    my $self = shift;
+    # 326 == CB_GETCOUNT
+    my $r = Win32::GUI::SendMessage($self, 326, 0, 0);
+    return $r;
+}
+
+
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::ProgressBar
+#
+package Win32::GUI::ProgressBar;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::ProgressBar(PARENT, %OPTIONS)
+    # Creates a new ProgressBar object;
+    # can also be called as PARENT->AddProgressBar(%OPTIONS).
+    # Class specific %OPTIONS are:
+    #     -smooth   => 0/1 (default 0)
+    #         uses a smooth bar instead of the default segmented bar.
+    #     -vertical => 0/1 (default 0)
+    #         display progress status vertically (from bottom to top).
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__PROGRESS", 0), @_);
+}
+
+    ###########################################################################
+    # (@)METHOD:SetPos(VALUE)
+    # Sets the position of the ProgressBar to the specified VALUE.
+sub SetPos {
+    my $self = shift;
+    my $pos = shift;
+    # 1026 == PBM_SETPOS
+    return Win32::GUI::SendMessage($self, 1026, $pos, 0);
+}
+
+    ###########################################################################
+    # (@)METHOD:StepIt()
+    # Increments the position of the ProgressBar of the defined step value;
+    # see SetStep().
+sub StepIt {
+    my $self = shift;
+    # 1029 == PBM_STEPIT
+    return Win32::GUI::SendMessage($self, 1029, 0, 0);
+}
+
+    ###########################################################################
+    # (@)METHOD:SetRange([MIN], MAX)
+sub SetRange {
+    my $self = shift;
+    my ($min, $max) = @_;
+    ($min, $max) = (0, $min) unless defined($max);
+    # 1030 == PBM_SETRANGE32
+    # return Win32::GUI::SendMessage($self, 1030, 0, ($max + $min >> 8));
+    return Win32::GUI::SendMessage($self, 1030, $min, $max);
+}
+
+    ###########################################################################
+    # (@)METHOD:SetStep([VALUE])
+    # Sets the increment value for the ProgressBar; see StepIt().
+sub SetStep {
+    my $self = shift;
+    my $step = shift;
+    $step = 10 unless $step;
+    # 1028 == PBM_SETSTEP
+    return Win32::GUI::SendMessage($self, 1028, $step, 0);
+}
+
+    # TODO 4.71: Color, BackColor
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::StatusBar
+#
+package Win32::GUI::StatusBar;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::StatusBar(PARENT, %OPTIONS)
+    # Creates a new StatusBar object;
+    # can also be called as PARENT->AddStatusBar(%OPTIONS).
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__STATUS", 0), @_);
+}
+
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::TabStrip
+#
+package Win32::GUI::TabStrip;
+@ISA = qw(
+    Win32::GUI::Window
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::TabStrip(PARENT, %OPTIONS)
+    # Creates a new TabStrip object;
+    # can also be called as PARENT->AddTabStrip(%OPTIONS).
+    # Class specific %OPTIONS are:
+    #   -bottom    => 0/1 (default 0)
+    #   -buttons   => 0/1 (default 0)
+    #   -hottrack  => 0/1 (default 0)
+    #   -imagelist => Win32::GUI::ImageList object
+    #   -justify   => 0/1 (default 0)
+    #   -multiline => 0/1 (default 0)
+    #   -right     => 0/1 (default 0)
+    #   -vertical  => 0/1 (default 0)
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__TAB", 0), @_);
+}
+
+    ###########################################################################
+    # (@)METHOD:SelectedItem()
+    # Returns the zero-based index of the currently selected item.
+sub SelectedItem {
+    my $self = shift;
+    # 4875 == TCM_GETCURSEL
+    return Win32::GUI::SendMessage($self, 4875, 0, 0);
+}
+
+    ###########################################################################
+    # (@)METHOD:Select(INDEX)
+    # Selects the zero-based INDEX item in the TabStrip.
+sub Select {
+    my $self = shift;
+    # 4876 == TCM_SETCURSEL
+    return Win32::GUI::SendMessage($self, 4876, shift, 0);
+}
+
+    ###########################################################################
+    # (@)METHOD:DisplayArea()
+sub DisplayArea {
+    my $self = shift;
+    my ($left,$top,$right,$bottom) = $self->AdjustRect($self->GetClientRect());
+    return ($left, $top, $right - $left, $bottom - $top);
+}
+
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Toolbar
+#
+package Win32::GUI::Toolbar;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Toolbar(PARENT, %OPTIONS)
+    # Creates a new Toolbar object;
+    # can also be called as PARENT->AddToolbar(%OPTIONS).
+    # Class specific %OPTIONS are:
+    #   -flat      => 0/1
+    #   -imagelist => IMAGELIST
+    #   -multiline => 0/1
+    #   -nodivider => 0/1
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__TOOLBAR", 0), @_);
+}
+
+    ###########################################################################
+    # (@)METHOD:SetBitmapSize([X, Y])
+sub SetBitmapSize {
+    my $self = shift;
+    my ($x, $y) = @_;
+    $x = 16 unless defined($x);
+    $y = 15 unless defined($y);
+    # 1056 == TB_SETBITMAPSIZE
+    return Win32::GUI::SendMessage($self, 1056, 0, ($x | $y << 16));
+}
+
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::RichEdit
+#
+package Win32::GUI::RichEdit;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::RichEdit(PARENT, %OPTIONS)
+    # Creates a new RichEdit object;
+    # can also be called as PARENT->AddRichEdit(%OPTIONS).
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__RICHEDIT", 0), @_);
+}
+
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::ListView
+#
+package Win32::GUI::ListView;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::ListView(PARENT, %OPTIONS)
+    # Creates a new ListView object;
+    # can also be called as PARENT->AddListView(%OPTIONS).
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__LISTVIEW", 0), @_);
+}
+
+sub Item {
+    my($self, $index) = @_;
+    return Win32::GUI::ListView::Item->new($self, $index);
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::ListView::Item
+#
+package Win32::GUI::ListView::Item;
+
+sub new {
+    my($class, $listview, $index) = @_;
+    my $self = {
+        -parent => $listview,
+        -index  => $index,
+    };
+    return bless $self, $class;
+}
+
+sub SubItem {
+    my($self, $index) = @_;
+    return Win32::GUI::ListView::SubItem->new($self, $index);
+}
+
+sub Remove {
+    my($self) = @_;
+    $self->{-parent}->DeleteItem($self->{-index});
+    undef $_[0];
+}
+
+sub Select {
+    my($self) = @_;
+    $self->{-parent}->Select($self->{-index});
+}
+
+sub Text {
+    my($self, $text) = @_;
+    if(not defined $text) {
+        my %data = $self->{-parent}->ItemInfo($self->{-index});
+        return $data{-text};
+    } else {
+        return $self->{-parent}->ChangeItem(
+            -item => $self->{-index},
+            -text => $text,
+        );
+    }
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::ListView::SubItem
+#
+package Win32::GUI::ListView::SubItem;
+
+sub new {
+    my($class, $parent, $index) = @_;
+    my $self = {
+        -parent    => $parent->{-parent},
+        -index     => $parent->{-index},
+        -subindex  => $index,
+    };
+    return bless $self, $class;
+}
+
+sub Text {
+    my($self, $text) = @_;
+    if(not defined $text) {
+        my %data = $self->{-parent}->ItemInfo(
+            $self->{-index},
+            $self->{-subindex},
+        );
+        return $data{-text};
+    } else {
+        return $self->{-parent}->ChangeItem(
+            -item => $self->{-index},
+            -subitem => $self->{-subindex},
+            -text => $text,
+        );
+    }
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::TreeView
+#
+package Win32::GUI::TreeView;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::TreeView(PARENT, %OPTIONS)
+    # Creates a new TreeView object
+    # can also be called as PARENT->AddTreeView(%OPTIONS).
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__TREEVIEW", 0), @_);
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Slider
+# also Trackbar
+#
+package Win32::GUI::Trackbar;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Slider(PARENT, %OPTIONS)
+    # Creates a new Slider object;
+    # can also be called as PARENT->AddSlider(%OPTIONS).
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__TRACKBAR", 0), @_);
+}
+
+sub SetRange {
+
+}
+
+sub Min {
+    my $self = shift;
+    my $value = shift;
+    if(defined($value)) {
+        my $flag = shift;
+        $flag = 1 unless defined($flag);
+        # 1031 == TBM_SETRANGEMIN
+        return Win32::GUI::SendMessage($self, 1031, $flag, $value);
+    } else {
+        # 1025 == TBM_GETRANGEMIN
+        return Win32::GUI::SendMessage($self, 1025, 0, 0);
+    }
+}
+
+sub Max {
+    my $self = shift;
+    my $value = shift;
+    if(defined($value)) {
+        my $flag = shift;
+        $flag = 1 unless defined($flag);
+        # 1032 == TBM_SETRANGEMAX
+        return Win32::GUI::SendMessage($self, 1032, $flag, $value);
+    } else {
+        # 1026 == TBM_GETRANGEMAX
+        return Win32::GUI::SendMessage($self, 1026, 0, 0);
+    }
+}
+
+sub Pos {
+    my $self = shift;
+    my $value = shift;
+    if(defined($value)) {
+        my $flag = shift;
+        $flag = 1 unless defined($flag);
+        # 1029 == TBM_SETPOS
+        return Win32::GUI::SendMessage($self, 1029, $flag, $value);
+    } else {
+        # 1024 == TBM_GETPOS
+        return Win32::GUI::SendMessage($self, 1024, 0, 0);
+    }
+}
+
+sub TicFrequency {
+    my $self = shift;
+    my $value = shift;
+    # 1044 == TBM_SETTICFREQ
+    return Win32::GUI::SendMessage($self, 1044, $value, 0);
+}
+
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Slider
+#
+package Win32::GUI::Slider;
+@ISA = qw(Win32::GUI::Trackbar);
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::UpDown
+#
+package Win32::GUI::UpDown;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::UpDown(PARENT, %OPTIONS)
+    # Creates a new UpDown object;
+    # can also be called as PARENT->AddUpDown(%OPTIONS).
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__UPDOWN", 0), @_);
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Tooltip
+#
+package Win32::GUI::Tooltip;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Tooltip(PARENT, %OPTIONS)
+    # (preliminary) creates a new Tooltip object
+sub new {
+    my $parent = $_[1];
+    my $new = Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__TOOLTIP", 0), @_);
+    if($new) {
+        if($parent->{-tooltips}) {
+            push(@{$parent->{-tooltips}}, $new->{-handle});
+        } else {
+            $parent->{-tooltips} = [ $new->{-handle} ];
+        }
+    }
+    return $new;
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Animation
+#
+package Win32::GUI::Animation;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Animation(PARENT, %OPTIONS)
+    # Creates a new Animation object;
+    # can also be called as PARENT->AddAnimation(%OPTIONS).
+    # Class specific %OPTIONS are:
+    #   -autoplay    => 0/1 (default 0)
+    #     starts playing the animation as soon as an AVI clip is loaded
+    #   -center      => 0/1 (default 0)
+    #     centers the animation in the control window
+    #   -transparent => 0/1 (default 0)
+    #     draws the animation using a transparent background
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__ANIMATION", 0), @_);
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Rebar
+#
+package Win32::GUI::Rebar;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Rebar(PARENT, %OPTIONS)
+    # Creates a new Rebar object;
+    # can also be called as PARENT->AddRebar(%OPTIONS).
+    # Class specific %OPTIONS are:
+    #   -bandborders => 0/1 (default 0)
+    #     display a border to separate bands.
+    #   -fixedorder => 0/1 (default 0)
+    #     band position cannot be swapped.
+    #   -imagelist => Win32::GUI::ImageList object
+    #   -varheight => 0/1 (default 1)
+    #     display bands using the minimum required height.
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__REBAR", 0), @_);
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Header
+#
+package Win32::GUI::Header;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Header(PARENT, %OPTIONS)
+    # Creates a new Header object;
+    # can also be called as PARENT->AddHeader(%OPTIONS).
+    # Class specific %OPTIONS are:
+    #   -buttons => 0/1 (default 0)
+    #     header items look like push buttons and can be clicked.
+    #   -hottrack => 0/1 (default 0)
+    #   -imagelist => Win32::GUI::ImageList object
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__HEADER", 0), @_);
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Splitter
+#
+package Win32::GUI::Splitter;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Splitter(PARENT, %OPTIONS)
+    # Creates a new Splitter object;
+    # can also be called as PARENT->AddHeader(%OPTIONS).
+    # Class specific %OPTIONS are:
+    #   -buttons => 0/1 (default 0)
+    #     header items look like push buttons and can be clicked.
+    #   -hottrack => 0/1 (default 0)
+    #   -imagelist => Win32::GUI::ImageList object
+sub new {
+    my $new = Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__SPLITTER", 0), @_);
+    if($new) {
+        $new->{-tracking} = 0;
+        return $new;
+    } else {
+        return undef;
+    }
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::ComboboxEx
+#
+package Win32::GUI::ComboboxEx;
+@ISA = qw(
+    Win32::GUI::Combobox
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::ComboboxEx(PARENT, %OPTIONS)
+    # Creates a new ComboboxEx object;
+    # can also be called as PARENT->AddComboboxEx(%OPTIONS).
+    # Class specific %OPTIONS are:
+    #   -imagelist => Win32::GUI::ImageList object
+    # Except for images, a ComboboxEx object acts like a Win32::GUI::Combobox
+    # object. See also new Win32::GUI::Combobox().
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__COMBOBOXEX", 0), @_);
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::DateTime
+#
+package Win32::GUI::DateTime;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::DateTime(PARENT, %OPTIONS)
+    # Creates a new DateTime object;
+    # can also be called as PARENT->AddDateTime(%OPTIONS).
+    # Class specific %OPTIONS are:
+    #   -align  => 'right'/'left' (default 'left')
+    #     The drop-down month calendar alignement.
+    #   -format => 'shortdate', 'longdate', 'time'
+    #     Control format type (Use local format date/time).
+    #   -shownone => 0/1 (default 0)
+    #     Allow no datetime (add a prefix checkbox).
+    #   -updown   => 0/1 (default 0 for date, 1 for time format)
+    #     Use updown control instead of the drop-down month calendar.
+sub new {
+    return Win32::GUI->_new(Win32::GUI::constant("WIN32__GUI__DTPICK", 0), @_);
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Graphic
+#
+package Win32::GUI::Graphic;
+@ISA = qw(
+    Win32::GUI
+    Win32::GUI::WindowProps
+);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Graphic(PARENT, %OPTIONS)
+    # Creates a new Graphic object;
+    # can also be called as PARENT->AddGraphic(%OPTIONS).
+    # Class specific %OPTIONS are:
+sub new {
+    my $class = shift;
+    my $self = {};
+    bless($self, $class);
+    my(@input) = @_;
+    my $handle = Win32::GUI::Create($self, 101, @input);
+    if($handle) {
+        return $self;
+    } else {
+        return undef;
+    }
+}
+
+    ###########################################################################
+    # (@)METHOD:GetDC()
+    # Returns the DC object associated with the window.
+sub GetDC {
+    my $self = shift;
+    return Win32::GUI::DC->new($self);
+}
+
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::ImageList
+#
+package Win32::GUI::ImageList;
+@ISA = qw(Win32::GUI);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::ImageList(X, Y, FLAGS, INITAL, GROW)
+    # Creates an ImageList object; X and Y specify the size of the images,
+    # FLAGS [TBD]. INITIAL and GROW specify the number of images the ImageList
+    # actually contains (INITIAL) and the number of images for which memory
+    # is allocated (GROW).
+sub new {
+    my $class = shift;
+    my $self = {};
+    my $handle = Win32::GUI::ImageList::Create(@_);
+    if($handle) {
+        $self->{-handle} = $handle;
+        bless($self, $class);
+        return $self;
+    } else {
+        return undef;
+    }
+}
+
+    ###########################################################################
+    # (@)METHOD:Add(BITMAP, [BITMAPMASK])
+    # Adds a bitmap to the ImageList; both BITMAP and BITMAPMASK can be either
+    # Win32::GUI::Bitmap objects or filenames.
+sub Add {
+    my($self, $bitmap, $bitmapMask) = @_;
+    $bitmap = new Win32::GUI::Bitmap($bitmap) unless ref($bitmap);
+    if(defined($bitmapMask)) {
+        $bitmapMask = new Win32::GUI::Bitmap($bitmapMask) unless ref($bitmapMask);
+        $self->AddBitmap($bitmap, $bitmapMask);
+    } else {
+        $self->AddBitmap($bitmap);
+    }
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Menu
+#
+package Win32::GUI::Menu;
+@ISA = qw(Win32::GUI);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Menu(...)
+sub new {
+    my $class = shift;
+    $class = "Win32::" . $class if $class =~ /^GUI::/;
+    my $self = {};
+
+    if($#_ > 0) {
+        return Win32::GUI::MakeMenu(@_);
+    } else {
+        my $handle = Win32::GUI::CreateMenu();
+
+        if($handle) {
+            $self->{-handle} = $handle;
+            bless($self, $class);
+            return $self;
+        } else {
+            return undef;
+        }
+    }
+}
+
+    ###########################################################################
+    # (@)METHOD:AddMenuButton()
+    # see new Win32::GUI::MenuButton()
+sub AddMenuButton {
+    return Win32::GUI::MenuButton->new(@_);
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::MenuButton
+#
+package Win32::GUI::MenuButton;
+@ISA = qw(Win32::GUI);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::MenuButton()
+sub new {
+    my $class = shift;
+    $class = "Win32::" . $class if $class =~ /^GUI::/;
+    my $menu = shift;
+    $menu = $menu->{-handle} if ref($menu);
+    # print "new MenuButton: menu=$menu\n";
+    my %args = @_;
+    my $self = {};
+
+    my $handle = Win32::GUI::CreatePopupMenu();
+
+    if($handle) {
+        $args{-submenu} = $handle;
+        # print "PM(MenuButton::new) calling InsertMenuItem with menu=$menu, args=", join(", ", %args), "\n";
+        Win32::GUI::MenuButton::InsertMenuItem($menu, %args);
+        # print "PM(MenuButton::new) back from InsertMenuItem\n";
+        $self->{-handle} = $handle;
+        bless($self, $class);
+        $Win32::GUI::Menus{ $args{-id} } = $handle;
+        #if($args{-name}) {
+        #    $Win32::GUI::Menus{$args{-id}} = $self;
+        #    $self->{-name} = $args{-name};
+        #}
+        # print "PM(MenuButton::new) returning self=$self\n";
+        return $self;
+    } else {
+        return undef;
+    }
+}
+
+    ###########################################################################
+    # (@)METHOD:AddMenuItem()
+    # see new Win32::GUI::MenuItem()
+sub AddMenuItem {
+    return Win32::GUI::MenuItem->new(@_);
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::MenuItem
+#
+package Win32::GUI::MenuItem;
+@ISA = qw(Win32::GUI);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::MenuItem()
+sub new {
+    my $class = shift;
+    $class = "Win32::" . $class if $class =~ /^GUI::/;
+    my $menu = shift;
+    return undef unless ref($menu) =~ /^Win32::GUI::Menu/;
+    my %args = @_;
+    my $self = {};
+
+    # print "PM(MenuItem::new) calling InsertMenuItem with menu=$menu, args=", join(", ", %args), "\n";
+    my $handle = Win32::GUI::MenuButton::InsertMenuItem($menu, %args);
+    # print "PM(MenuItem::new) back from InsertMenuItem\n";
+
+    if($handle) {
+        # $self->{-handle} = $handle;
+        # $Win32::GUI::menucallbacks{$args{-id}} = $args{-function} if $args{-function};
+        $self->{-id} = $args{-id};
+        $self->{-menu} = $menu->{-handle};
+        bless($self, $class);
+        $Win32::GUI::Menus{ $args{-id} } = $menu->{-handle};
+        #if($args{-name}) {
+        #    $Win32::GUI::Menus{$args{-id}} = $self;
+        #    $self->{-name} = $args{-name};
+        #}
+        # print "PM(MenuItem::new) returning self=$self\n";
+        return $self;
+    } else {
+        return undef;
+    }
+}
+
+###############################################################################
+# (@)PACKAGE: Win32::GUI::Timer
+#
+package Win32::GUI::Timer;
+@ISA = qw(Win32::GUI);
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Timer(PARENT, NAME, ELAPSE)
+    # Creates a new timer in the PARENT window named NAME that will
+    # trigger its Timer() event after ELAPSE milliseconds.
+    # Can also be called as PARENT->AddTimer(NAME, ELAPSE).
+sub new {
+    my $class = shift;
+    $class = "Win32::" . $class if $class =~ /^GUI::/;
+    my $window = shift;
+    my $name = shift;
+    my $elapse = shift;
+
+    my %args = @_;
+    my $id = $Win32::GUI::TimerIdCounter;
+
+    $Win32::GUI::TimerIdCounter++;
+
+    Win32::GUI::SetTimer($window, $id, $elapse);
+
+    my $self = {};
+    bless($self, $class);
+
+    # add $self->{name}
+    $self->{-id} = $id;
+    $self->{-name} = $name;
+    $self->{-parent} = $window;
+    $self->{-handle} = $window->{-handle};
+    $self->{-interval} = $elapse;
+
+    # add to $window->timers->{$id} = $self;
+    $window->{-timers}->{$id} = $self;
+    $window->{$name} = $self;
+
+    return $self;
+}
+
+    ###########################################################################
+    # (@)METHOD:Interval(ELAPSE)
+sub Interval {
+    my $self = shift;
+    my $interval = shift;
+    if(defined $interval) {
+        Win32::GUI::SetTimer($self->{-parent}->{-handle}, $self->{-id}, $interval);
+        $self->{-interval} = $interval;
+    } else {
+        return $self->{-interval};
+    }
+}
+
+    ###########################################################################
+    # (@)METHOD:Kill()
+sub Kill {
+    my $self = shift;
+    Win32::GUI::KillTimer($self->{-parent}->{-handle}, $self->{-id});
+}
+
+    ###########################################################################
+    # (@)INTERNAL:DESTROY(HANDLE)
+sub DESTROY {
+    my $self = shift;
+    Win32::GUI::KillTimer($self->{-handle}, $self->{-id});
+    undef $self->{-parent}->{-timers}->{$self->{-id}};
+}
+
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::NotifyIcon
+#
+package Win32::GUI::NotifyIcon;
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::NotifyIcon(PARENT, %OPTIONS)
+    # Creates a new NotifyIcon (also known as system tray icon) object;
+    # can also be called as PARENT->AddNotifyIcon(%OPTIONS).
+    # %OPTIONS are:
+    #     -icon => Win32::GUI::Icon object
+    #     -id => NUMBER
+    #         a unique identifier for the NotifyIcon object
+    #     -name => STRING
+    #         the name for the object
+    #     -tip => STRING
+    #         the text that will appear as tooltip when the mouse is
+    #         on the NotifyIcon
+sub new {
+    my $class = shift;
+    $class = "Win32::" . $class if $class =~ /^GUI::/;
+    my $window = shift;
+
+    my %args = @_;
+
+    $Win32::GUI::NotifyIconIdCounter++;
+
+    if(!exists($args{-id})) {
+        $args{-id} = $Win32::GUI::NotifyIconIdCounter;
+    }
+
+    Win32::GUI::NotifyIcon::Add($window, %args);
+
+    my $self = {};
+    bless($self, $class);
+
+    $self->{-id} = $args{-id};
+    $self->{-name} = $args{-name};
+    $self->{-parent} = $window;
+    $self->{-handle} = $window->{-handle};
+
+    $window->{-notifyicons}->{$args{-id}} = $self;
+    $window->{$args{-name}} = $self;
+
+    return $self;
+}
+
+    ###########################################################################
+    # (@)INTERNAL:DESTROY(OBJECT)
+
+sub DESTROY {
+	my($self) = @_;
+    if ( defined $self &&
+         defined $self->{-parent} &&
+	     defined $self->{-id} &&
+		 defined $self->{-parent}->{$self->{-name}} ) {
+        Win32::GUI::NotifyIcon::Delete(
+			$self->{-parent},
+			-id => $self->{-id},
+		);
+		undef $self->{-parent}->{$self->{-name}};
+	}
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::DC
+#
+package Win32::GUI::DC;
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::DC(WINDOW | DRIVER, DEVICE)
+    # Creates a new DC object; the first form (WINDOW is a Win32::GUI object)
+    # gets the DC for the specified window (can also be called as
+    # WINDOW->GetDC). The second form creates a DC for the specified DEVICE;
+    # actually, the only supported DRIVER is the display driver (eg. the
+    # screen). To get the DC for the entire screen use:
+    #     $Screen = new Win32::GUI::DC("DISPLAY");
+    #
+sub new {
+    my $class = shift;
+    $class = "Win32::" . $class if $class =~ /^GUI::/;
+
+    my $self = {};
+    bless($self, $class);
+
+    my $window = shift;
+    if(defined($window)) {
+        if(ref($window)) {
+            $self->{-handle} = GetDC($window->{-handle});
+            $self->{-window} = $window->{-handle};
+        } else {
+            my $device = shift;
+            $self->{-handle} = CreateDC($window, $device);
+        }
+    } else {
+        $self = CreateDC("DISPLAY", 0);
+    }
+    return $self;
+}
+
+sub DESTROY {
+    my $self = shift;
+    if($self->{-window}) {
+        ReleaseDC($self->{-window}, $self->{-handle});
+    } else {
+        DeleteDC($self->{-handle});
+    }
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Pen
+#
+package Win32::GUI::Pen;
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Pen(COLOR | %OPTIONS)
+    # Creates a new Pen object.
+    # Allowed %OPTIONS are:
+    #   -style =>
+    #     0 PS_SOLID
+    #     1 PS_DASH
+    #     2 PS_DOT
+    #     3 PS_DASHDOT
+    #     4 PS_DASHDOTDOT
+    #     5 PS_NULL
+    #     6 PS_INSIDEFRAME
+    #   -width => number
+    #   -color => COLOR
+sub new {
+    my $class = shift;
+    $class = "Win32::" . $class if $class =~ /^GUI::/;
+
+    my $self = {};
+    bless($self, $class);
+    $self->{-handle} = Create(@_);
+    return $self;
+}
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::Brush
+#
+package Win32::GUI::Brush;
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::Brush(COLOR | %OPTIONS)
+    # Creates a new Brush object.
+    # Allowed %OPTIONS are:
+    #   -style =>
+    #     0 BS_SOLID
+    #     1 BS_NULL
+    #     2 BS_HATCHED
+    #     3 BS_PATTERN
+    #   -pattern => Win32::GUI::Bitmap object (valid for -style => BS_PATTERN)
+    #   -hatch => (valid for -style => BS_HATCHED)
+    #     0 HS_ORIZONTAL (-----)
+    #     1 HS_VERTICAL  (|||||)
+    #     2 HS_FDIAGONAL (\\\\\)
+    #     3 HS_BDIAGONAL (/////)
+    #     4 HS_CROSS     (+++++)
+    #     5 HS_DIAGCROSS (xxxxx)
+    #   -color => COLOR
+sub new {
+    my $class = shift;
+    $class = "Win32::" . $class if $class =~ /^GUI::/;
+
+    my $self = {};
+    bless($self, $class);
+    $self->{-handle} = Create(@_);
+    return $self;
+}
+
+
+###############################################################################
+# (@)PACKAGE:Win32::GUI::AcceleratorTable
+# an accelerator table
+#
+
+package Win32::GUI::AcceleratorTable;
+
+    ###########################################################################
+    # (@)METHOD:new Win32::GUI::AcceleratorTable(%ACCELERATORS)
+    # Creates an AcceleratorTable object.
+    # %ACCELERATORS is an associative array of key combinations and
+    # accelerator names, in pair:
+    # Example:
+    #     $A = new Win32::GUI::AcceleratorTable(
+    #         "Ctrl-X"       => "Close",
+    #         "Shift-N"      => "New",
+    #         "Ctrl-Alt-Del" => "Reboot",
+    #     );
+    # The AcceleratorTable object can be associated to a window
+    # with the -accel option; then, when an accelerator is used, a
+    # corresponding <name>_Click event is fired.
+    # Keyboard combinations currently support the following modifier :
+    #     Shift
+    #     Ctrl  (or Control)
+    #     Alt
+    # and the following keys:
+    #     A..Z, 0..9
+    #     Left, Right, Up, Down
+    #     Home, End, PageUp, PageDown (or PgUp/PgDn)
+    #     Space, Ins, Del, Esc, Backspace, Tab, Return
+    #     F1..F12
+sub new {
+    my $class = shift;
+    $class = "Win32::" . $class if $class =~ /^GUI::/;
+    my($k, $v);
+    my $flag = 0;
+    my $key = 0;
+    my %accels = @_;
+
+    while( ($k, $v) = each %accels) {
+        $flag = 0x0001;
+        if($k =~ s/shift[-\+]//i)                { $flag |= 0x0004; }
+        if($k =~ s/(ctrl|control)[-\+]//i)       { $flag |= 0x0008; }
+        if($k =~ s/alt[-\+]//i)                  { $flag |= 0x0010; }
+
+                                                 # { $key = 0x01; } # VK_LBUTTON
+                                                 # { $key = 0x02; } # VK_RBUTTON
+                                                 # { $key = 0x03; } # VK_CANCEL
+                                                 # { $key = 0x04; } # VK_MBUTTON
+           if($k =~ /^backspace$/i)                { $key = 0x08; } # VK_BACK
+        elsif($k =~ /^tab$/i)                      { $key = 0x09; } # VK_TAB
+#       elsif($k =~ /^clear$/i)                    { $key = 0x0c; } # VK_CLEAR
+        elsif($k =~ /^return$/i)                   { $key = 0x0d; } # VK_RETURN
+                                                 # { $key = 0x10; } # VK_SHIFT
+                                                 # { $key = 0x11; } # VK_CONTROL
+                                                 # { $key = 0x12; } # VK_MENU /ALT
+        elsif($k =~ /^pause$/i)                    { $key = 0x13; } # VK_PAUSE
+        elsif($k =~ /^capslock$/i)                 { $key = 0x14; } # VK_CAPITAL
+        elsif($k =~ /^(esc|escape)$/i)             { $key = 0x1b; } # VK_ESCAPE
+        elsif($k =~ /^space$/i)                    { $key = 0x20; } # VK_SPACE
+        elsif($k =~ /^(pgup|pageup)$/i)            { $key = 0x21; } # VK_PRIOR
+        elsif($k =~ /^(pgdn|pagedn|pagedown)$/i)   { $key = 0x22; } # VK_NEXT
+        elsif($k =~ /^end$/i)                      { $key = 0x23; } # VK_END
+        elsif($k =~ /^home$/i)                     { $key = 0x24; } # VK_HOME
+        elsif($k =~ /^left$/i)                     { $key = 0x25; } # VK_LEFT
+        elsif($k =~ /^up$/i)                       { $key = 0x26; } # VK_UP
+        elsif($k =~ /^right$/i)                    { $key = 0x27; } # VK_RIGHT
+        elsif($k =~ /^down$/i)                     { $key = 0x28; } # VK_DOWN
+#       elsif($k =~ /^select$/i)                   { $key = 0x29; } # VK_SELECT
+#       elsif($k =~ /^print$/i)                    { $key = 0x2a; } # VK_PRINT
+#       elsif($k =~ /^execute$/i)                  { $key = 0x2b; } # VK_EXECUTE
+        elsif($k =~ /^(prntscrn|printscreen)$/i)   { $key = 0x2c; } # VK_SNAPSHOT
+        elsif($k =~ /^ins$/i)                      { $key = 0x2d; } # VK_INSERT
+        elsif($k =~ /^del$/i)                      { $key = 0x2e; } # VK_DELETE
+#       elsif($k =~ /^help$/i)                     { $key = 0x2f; } # VK_HELP
+        elsif($k =~ /^[0-9a-z]$/i)                 { $key = ord(uc($k)); }
+                                                 # 0x30-0x39: ASCII 0-9
+                                                 # 0x41-0x5a: ASCII A-Z
+        elsif($k =~ /^left(win|windows)$/i)        { $key = 0x5b; } # VK_LWIN
+        elsif($k =~ /^right(win|windows)$/i)       { $key = 0x5c; } # VK_RWIN
+        elsif($k =~ /^(app|application)$/i)        { $key = 0x5d; } # VK_APPS
+#       elsif($k =~ /^sleep$/i)                    { $key = 0x5e; } # VK_SLEEP
+        elsif($k =~ /^(num|numeric|keypad)0$/i)    { $key = 0x60; } # VK_NUMPAD0
+        elsif($k =~ /^(num|numeric|keypad)1$/i)    { $key = 0x61; } # VK_NUMPAD1
+        elsif($k =~ /^(num|numeric|keypad)2$/i)    { $key = 0x62; } # VK_NUMPAD2
+        elsif($k =~ /^(num|numeric|keypad)3$/i)    { $key = 0x63; } # VK_NUMPAD3
+        elsif($k =~ /^(num|numeric|keypad)4$/i)    { $key = 0x64; } # VK_NUMPAD4
+        elsif($k =~ /^(num|numeric|keypad)5$/i)    { $key = 0x65; } # VK_NUMPAD5
+        elsif($k =~ /^(num|numeric|keypad)6$/i)    { $key = 0x66; } # VK_NUMPAD6
+        elsif($k =~ /^(num|numeric|keypad)7$/i)    { $key = 0x67; } # VK_NUMPAD7
+        elsif($k =~ /^(num|numeric|keypad)8$/i)    { $key = 0x68; } # VK_NUMPAD8
+        elsif($k =~ /^(num|numeric|keypad)9$/i)    { $key = 0x69; } # VK_NUMPAD9
+        elsif($k =~ /^multiply$/i)                 { $key = 0x6a; } # VK_MULTIPLY
+        elsif($k =~ /^add$/i)                      { $key = 0x6b; } # VK_ADD
+#       elsif($k =~ /^separator$/i)                { $key = 0x6c; } # VK_SEPARATOR
+        elsif($k =~ /^subtract$/i)                 { $key = 0x6d; } # VK_SUBTRACT
+        elsif($k =~ /^decimal$/i)                  { $key = 0x6e; } # VK_DECIMAL
+        elsif($k =~ /^divide$/i)                   { $key = 0x6f; } # VK_DIVIDE
+        elsif($k =~ /^f1$/i)                       { $key = 0x70; } # VK_F1
+        elsif($k =~ /^f2$/i)                       { $key = 0x71; } # VK_F2
+        elsif($k =~ /^f3$/i)                       { $key = 0x72; } # VK_F3
+        elsif($k =~ /^f4$/i)                       { $key = 0x73; } # VK_F4
+        elsif($k =~ /^f5$/i)                       { $key = 0x74; } # VK_F5
+        elsif($k =~ /^f6$/i)                       { $key = 0x75; } # VK_F6
+        elsif($k =~ /^f7$/i)                       { $key = 0x76; } # VK_F7
+        elsif($k =~ /^f8$/i)                       { $key = 0x77; } # VK_F8
+        elsif($k =~ /^f9$/i)                       { $key = 0x78; } # VK_F9
+        elsif($k =~ /^f10$/i)                      { $key = 0x79; } # VK_F10
+        elsif($k =~ /^f11$/i)                      { $key = 0x7a; } # VK_F11
+        elsif($k =~ /^f12$/i)                      { $key = 0x7b; } # VK_F12
+#       elsif($k =~ /^f13$/i)                      { $key = 0x7c; } # VK_F13
+#       elsif($k =~ /^f14$/i)                      { $key = 0x7d; } # VK_F14
+#       elsif($k =~ /^f15$/i)                      { $key = 0x7e; } # VK_F15
+#       elsif($k =~ /^f16$/i)                      { $key = 0x7f; } # VK_F16
+#       elsif($k =~ /^f17$/i)                      { $key = 0x80; } # VK_F17
+#       elsif($k =~ /^f18$/i)                      { $key = 0x81; } # VK_F18
+#       elsif($k =~ /^f19$/i)                      { $key = 0x82; } # VK_F19
+#       elsif($k =~ /^f20$/i)                      { $key = 0x83; } # VK_F20
+#       elsif($k =~ /^f21$/i)                      { $key = 0x84; } # VK_F21
+#       elsif($k =~ /^f22$/i)                      { $key = 0x85; } # VK_F22
+#       elsif($k =~ /^f23$/i)                      { $key = 0x86; } # VK_F23
+#       elsif($k =~ /^f24$/i)                      { $key = 0x87; } # VK_F24
+        elsif($k =~ /^numlock$/i)                  { $key = 0x90; } # VK_NUMLOCK
+        elsif($k =~ /^scrolllock$/i)               { $key = 0x91; } # VK_SCROLL
+                                                 # { $key = 0xa0; } # VK_LSHIFT
+                                                 # { $key = 0xa1; } # VK_RSHIFT
+                                                 # { $key = 0xa2; } # VK_LCONTROL
+                                                 # { $key = 0xa3; } # VK_RCONTROL
+                                                 # { $key = 0xa4; } # VK_LMENU
+                                                 # { $key = 0xa5; } # VK_RMENU
+#       elsif($k =~ /^browserback$/i)              { $key = 0xa6; } # VK_BROWSER_BACK
+#       elsif($k =~ /^browserforward$/i)           { $key = 0xa7; } # VK_BROWSER_FORWARD
+#       elsif($k =~ /^browserrefresh$/i)           { $key = 0xa8; } # VK_BROWSER_REFRESH
+#       elsif($k =~ /^browserstop$/i)              { $key = 0xa9; } # VK_BROWSER_STOP
+#       elsif($k =~ /^browsersearch$/i)            { $key = 0xaa; } # VK_BROWSER_SEARCH
+#       elsif($k =~ /^browserfavorites$/i)         { $key = 0xab; } # VK_BROWSER_FAVORITES
+#       elsif($k =~ /^browserhome$/i)              { $key = 0xac; } # VK_BROWSER_HOME
+#       elsif($k =~ /^volumemute$/i)               { $key = 0xad; } # VK_VOLUME_MUTE
+#       elsif($k =~ /^volumedown$/i)               { $key = 0xae; } # VK_VOLUME_UP
+#       elsif($k =~ /^volumenup$/i)                { $key = 0xaf; } # VK_VOLUME_DOWN
+#       elsif($k =~ /^medianexttrack$/i)           { $key = 0xb0; } # VK_MEDIA_NEXT_TRACK
+#       elsif($k =~ /^mediaprevtrack$/i)           { $key = 0xb1; } # VK_MEDIA_PREV_TRACK
+#       elsif($k =~ /^mediastop$/i)                { $key = 0xb2; } # VK_MEDIA_STOP
+#       elsif($k =~ /^mediaplaypause$/i)           { $key = 0xb3; } # VK_MEDIA_PLAY_PAUSE
+#       elsif($k =~ /^launchmail$/i)               { $key = 0xb4; } # VK_LAUNCH_MAIL
+#       elsif($k =~ /^launchmediaselect$/i)        { $key = 0xb5; } # VK_LAUNCH_MEDIA_SELECT
+#       elsif($k =~ /^launchapp1$/i)               { $key = 0xb6; } # VK_LAUNCH_APP1
+#       elsif($k =~ /^launchapp2$/i)               { $key = 0xb7; } # VK_LAUNCH_APP2
+        elsif($k =~ /^semicolon$/i)                { $key = 0xba; } # VK_OEM_1
+        elsif($k =~ /^(plus|equal)$/i)             { $key = 0xbb; } # VK_OEM_PLUS
+        elsif($k =~ /^(comma|lessthan)$/i)         { $key = 0xbc; } # VK_OEM_COMMA
+        elsif($k =~ /^(minus|underscore)$/i)       { $key = 0xbd; } # VK_OEM_MINUS
+        elsif($k =~ /^(period|greaterthan)$/i)     { $key = 0xbe; } # VK_OEM_PERIOD
+        elsif($k =~ /^(slash|question)$/i)         { $key = 0xbf; } # VK_OEM_2
+        elsif($k =~ /^(acute|tilde)$/i)            { $key = 0xc0; } # VK_OEM_3
+        elsif($k =~ /^(left|open)brac(e|ket)$/i)   { $key = 0xdb; } # VK_OEM_4
+        elsif($k =~ /^(backslash|verticalbar)$/i)  { $key = 0xdc; } # VK_OEM_5
+        elsif($k =~ /^(right|close)brac(e|ket)$/i) { $key = 0xdd; } # VK_OEM_6
+        elsif($k =~ /^(single|double|)quote$/i)    { $key = 0xde; } # VK_OEM_7
+#       elsif($k =~ /^unknown$/i)                  { $key = 0xdf; } # VK_OEM_8
+#       elsif($k =~ /^process$/i)                  { $key = 0xe5; } # VK_PROCESSKEY
+        elsif($k =~ /^(attn|attention)$/i)         { $key = 0xf6; } # VK_ATTN
+        elsif($k =~ /^crsel$/i)                    { $key = 0xf7; } # VK_CRSEL
+        elsif($k =~ /^exsel$/i)                    { $key = 0xf8; } # VK_EXSEL
+        elsif($k =~ /^(ereof|eraseeof)$/i)         { $key = 0xf9; } # VK_EREOF
+        elsif($k =~ /^play$/i)                     { $key = 0xfa; } # VK_PLAY
+        elsif($k =~ /^zoom$/i)                     { $key = 0xfb; } # VK_ZOOM
+        elsif($k =~ /^noname$/i)                   { $key = 0xfc; } # VK_NONAME
+        elsif($k =~ /^pa1$/i)                      { $key = 0xfd; } # VK_PA1
+        elsif($k =~ /^oem_clear$/i)                { $key = 0xfe; } # VK_OEM_CLEAR
+        else {$key = 0; print "Key name '$k' unknown\n"; }
+
+        if ($key) {
+            my $id = $Win32::GUI::AcceleratorCounter++;
+            push @acc, $id, $key, $flag;
+            $Win32::GUI::Accelerators{$id} = $v;
+        }
+    }
+    my $handle = Win32::GUI::CreateAcceleratorTable( @acc );
+    if($handle) {
+        my $self = {};
+        $self->{-handle} = $handle;
+        bless $self, $class;
+        return $self;
+    } else {
+        return undef;
+    }
+}
+
+sub DESTROY {
+    my($self) = @_;
+    # print "DESTROYING AcceleratorTable $self->{-handle}\n";
+    if( $self->{-handle} ) {
+        Win32::GUI::DestroyAcceleratorTable( $self->{-handle} );
+    }
+}
+
+###############################################################################
+# (@)INTERNAL:Win32::GUI::WindowProps
+# the package to tie to a window hash to set/get properties in a more
+# fashionable way...
+#
+package Win32::GUI::WindowProps;
+
+my %TwoWayMethodMap = (
+    -text   => "Text",
+    -left   => "Left",
+    -top    => "Top",
+    -width  => "Width",
+    -height => "Height",
+    -dialogui => "DialogUI",
+);
+
+my $Textfield_TwoWayMethodMap = {
+    -passwordchar => "PasswordChar",
+};
+
+my %PackageSpecific_TwoWayMethodMap = (
+    Splitter => {
+        -min => "Min",
+        -max => "Max",
+        -horizontal => "Horizontal",
+        -vertical => "Vertical",
+    },
+    MenuItem => {
+        -checked => "Checked",
+        -enabled => "Enabled",
+    },
+    Textfield => $Textfield_TwoWayMethodMap,
+    RichEdit  => $Textfield_TwoWayMethodMap,
+);
+
+
+my %OneWayMethodMap = (
+    -scalewidth   => "ScaleHeight",
+    -scaleheight  => "ScaleWidth",
+    -abstop       => "AbsTop",
+    -absleft      => "AbsLeft",
+);
+
+    ###########################################################################
+    # (@)INTERNAL:TIEHASH
+sub TIEHASH {
+    my($class, $object) = @_;
+    # my $tied = { UNDERLYING => $object };
+    # print "[TIEHASH] called for '$class' '$object'\n";
+    # return bless $tied, $class;
+    return bless $object, $class;
+}
+
+    ###########################################################################
+    # (@)INTERNAL:STORE
+sub STORE {
+    my($self, $key, $value) = @_;
+    # print "[STORE] called for '$self' {$key}='$value'\n";
+
+    my $Package = ref($self);
+    $Package =~ s/Win32::GUI:://;
+
+    if(exists $PackageSpecific_TwoWayMethodMap{$Package}{$key}) {
+        if(my $method = $self->can($PackageSpecific_TwoWayMethodMap{$Package}{$key})) {
+            #print "[STORE] calling method '$PackageSpecific_TwoWayMethodMap{$Package}{$key}' on '$self'\n";
+            return &{$method}($self, $value);
+        } else {
+            #print "[STORE] PROBLEM: method '$PackageSpecific_TwoWayMethodMap{$Package}{$key}' not found on '$self'\n";
+        }
+    } elsif(exists $TwoWayMethodMap{$key}) {
+        if(my $method = $self->can($TwoWayMethodMap{$key})) {
+            # print "[STORE] calling method '$TwoWayMethodMap{$key}' on '$self'\n";
+            return &{$method}($self, $value);
+        } else {
+            # print "[STORE] PROBLEM: method '$TwoWayMethodMap{$key}' not found on '$self'\n";
+        }
+    } elsif($key eq "-style") {
+        # print "[STORE] calling GetWindowLong\n";
+        return Win32::GUI::GetWindowLong($self, -16, $value);
+
+    } else {
+        # print "[STORE] storing key '$key' in '$self'\n";
+        # return $self->{UNDERLYING}->{$key} = $value;
+        return $self->{$key} = $value;
+    }
+}
+
+    ###########################################################################
+    # (@)INTERNAL:FETCH
+sub FETCH {
+    my($self, $key) = @_;
+
+    my $Package = ref($self);
+    $Package =~ s/Win32::GUI:://;
+
+    if($key eq "UNDERLYING") {
+        # print "[FETCH] returning UNDERLYING for '$self'\n";
+        return $self->{UNDERLYING};
+
+    } elsif(exists $PackageSpecific_TwoWayMethodMap{$Package}{$key}) {
+        if(my $method = $self->can($PackageSpecific_TwoWayMethodMap{$Package}{$key})) {
+            #print "[FETCH] calling method '$PackageSpecific_TwoWayMethodMap{$package}{$key}' on '$self'\n";
+            return &{$method}($self);
+        } else {
+            #print "[FETCH] PROBLEM: method '$PackageSpecific_TwoWayMethodMap{$package}{$key}' not found on '$self'\n";
+        }
+
+    } elsif(exists $TwoWayMethodMap{$key}) {
+        # if(my $method = $self->{UNDERLYING}->can($TwoWayMethodMap{$key})) {
+        if(my $method = $self->can($TwoWayMethodMap{$key})) {
+            # print "[FETCH] calling method $TwoWayMethodMap{$key} on $self->{UNDERLYING}\n";
+            # print "[FETCH] calling method '$TwoWayMethodMap{$key}' on '$self'\n";
+            # return &{$method}($self->{UNDERLYING});
+            return &{$method}($self);
+        } else {
+            # print "[FETCH] method not found '$TwoWayMethodMap{$key}'\n";
+            return undef;
+        }
+
+    } elsif($key eq "-style") {
+        return Win32::GUI::GetWindowLong($self->{UNDERLYING}, -16);
+
+    #} elsif(exists $self->{UNDERLYING}->{$key}) {
+    #   print "[FETCH] fetching key $key from $self->{UNDERLYING}\n";
+    #   return $self->{UNDERLYING}->{$key};
+
+    } elsif(exists $self->{$key}) {
+        # print "[FETCH] fetching key '$key' from '$self'\n";
+        return $self->{$key};
+
+    } else {
+        # print "Win32::GUI::WindowProps::FETCH returning nothing for '$key' on $self->{UNDERLYING}\n";
+        # print "[FETCH] returning nothing for '$key' on '$self'\n";
+        return undef;
+        # return 0;
+    }
+}
+
+sub FIRSTKEY {
+    my $self = shift;
+    my $a = keys %{ $self };
+    my ($k, $v) = each %{ $self };
+#    print "[FIRSTKEY] k='$k' v='$v'\n";
+    return $k;
+}
+
+sub NEXTKEY {
+    my $self = shift;
+    my ($k, $v) = each %{ $self };
+#    print "[NEXTKEY] k='$k' v='$v'\n";
+    return $k;
+}
+
+sub EXISTS {
+    my($self, $key) = @_;
+    # return exists $self->{UNDERLYING}->{$key};
+    return exists $self->{$key};
+}
+
+
+###############################################################################
+# dynamically load in the GUI.dll module.
+#
+
+package Win32::GUI;
+
+bootstrap Win32::GUI;
+
+bootstrap_subpackage 'Animation';
+bootstrap_subpackage 'Bitmap';
+bootstrap_subpackage 'DC';
+bootstrap_subpackage 'Font';
+bootstrap_subpackage 'ImageList';
+bootstrap_subpackage 'Label';
+bootstrap_subpackage 'Listbox';
+bootstrap_subpackage 'ListView';
+bootstrap_subpackage 'NotifyIcon';
+bootstrap_subpackage 'Rebar';
+bootstrap_subpackage 'RichEdit';
+bootstrap_subpackage 'Splitter';
+bootstrap_subpackage 'TabStrip';
+bootstrap_subpackage 'Textfield';
+bootstrap_subpackage 'Toolbar';
+bootstrap_subpackage 'TreeView';
+
+# Preloaded methods go here.
+
+$Win32::GUI::StandardWinClass = Win32::GUI::Class->new(
+    -name => "PerlWin32GUI_STD_OBSOLETED"
+);
+
+$Win32::GUI::StandardWinClassVisual = Win32::GUI::Class->new(
+    -name => "PerlWin32GUI_STD",
+    -visual => 1,
+);
+
+$Win32::GUI::GraphicWinClass = Win32::GUI::Class->new(
+    -name => "Win32::GUI::Graphic",
+    -widget => "Graphic",
+);
+
+$Win32::GUI::InteractiveGraphicWinClass = Win32::GUI::Class->new(
+    -name => "Win32::GUI::InteractiveGraphic",
+    -widget => "InteractiveGraphic",
+);
+
+$Win32::GUI::SplitterHorizontal = Win32::GUI::Class->new(
+    -name => "Win32::GUI::Splitter(horizontal)",
+    -widget => "SplitterH",
+);
+$Win32::GUI::SplitterVertical = Win32::GUI::Class->new(
+    -name => "Win32::GUI::Splitter(vertical)",
+    -widget => "Splitter",
+);
+
+$Win32::GUI::RICHED = Win32::GUI::LoadLibrary("RICHED32");
+
+END {
+    # print "Freeing library RICHED32\n";
+    Win32::GUI::FreeLibrary($Win32::GUI::RICHED);
+}
+
+#Currently Autoloading is not implemented in Perl for win32
+# Autoload methods go after __END__, and are processed by the autosplit program.
+
+1;
+__END__
+
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/GUI.rc perl-libwin32-0.191/GUI/GUI.rc
--- libwin32-0.191/GUI/GUI.rc	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/GUI.rc	2004-01-12 16:46:39.890625000 -0800
@@ -0,0 +1,5 @@
+#include "resource.h"
+
+IDI_DEFAULTICON         ICON    DISCARDABLE     "guiperl.ico"
+IDC_HSPLIT         		CURSOR  DISCARDABLE     "hsplit.cur"
+IDC_VSPLIT         		CURSOR  DISCARDABLE     "vsplit.cur"
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/GUI.xs perl-libwin32-0.191/GUI/GUI.xs
--- libwin32-0.191/GUI/GUI.xs	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/GUI.xs	2004-01-12 16:46:39.921875000 -0800
@@ -0,0 +1,5243 @@
+/*
+###############################################################################
+#
+# Win32::GUI - Perl-Win32 Graphical User Interface Extension
+#
+# 29 Jan 1997 by Aldo Calpini <dada@perl.it>
+#
+# Version: 0.0.665 (27 Feb 2002)
+#
+# Copyright (c) 1997..2002 Aldo Calpini. All rights reserved.
+# This program is free software; you can redistribute it and/or
+# modify it under the same terms as Perl itself.
+#
+# $Id: GUI.xs,v 1.3 2003/12/28 07:17:43 caelum Exp $
+#
+###############################################################################
+ */
+
+#include "GUI.h"
+
+    /*
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI
+    ###########################################################################
+     */
+
+MODULE = Win32::GUI     PACKAGE = Win32::GUI
+
+PROTOTYPES: DISABLE
+
+     ##########################################################################
+     # (@)INTERNAL:constant(NAME, ARG)
+DWORD
+constant(name,arg)
+    char *name
+    int arg
+CODE:
+    RETVAL = constant(NOTXSCALL name, arg);
+OUTPUT:
+    RETVAL
+
+
+     ##########################################################################
+     # (@)INTERNAL:LoadLibrary(NAME)
+HINSTANCE
+LoadLibrary(name)
+    char *name;
+CODE:
+    RETVAL = LoadLibrary(name);
+OUTPUT:
+    RETVAL
+
+     ##########################################################################
+     # (@)INTERNAL:FreeLibrary(LIBRARY)
+bool
+FreeLibrary(library)
+    HINSTANCE library;
+CODE:
+    RETVAL = FreeLibrary(library);
+OUTPUT:
+    RETVAL
+
+
+     ##########################################################################
+     # (@)METHOD:GetPerlWindow()
+void
+GetPerlWindow()
+PPCODE:
+    char OldPerlWindowTitle[1024];
+    char NewPerlWindowTitle[1024];
+    HWND hwndFound;
+    HINSTANCE hinstanceFound;
+    // this is an hack from M$'s Knowledge Base
+    // to get the HWND of the console in which
+    // Perl is running (and Hide() it :-).
+    GetConsoleTitle(OldPerlWindowTitle, 1024);
+    wsprintf(NewPerlWindowTitle,
+             "PERL-%d-%d",
+             GetTickCount(),
+             GetCurrentProcessId());
+
+    SetConsoleTitle(NewPerlWindowTitle);
+    Sleep(40);
+    hwndFound = FindWindow(NULL, NewPerlWindowTitle);
+
+    // another hack to get the program's instance
+#ifdef NT_BUILD_NUMBER
+    hinstanceFound = GetModuleHandle("GUI.PLL");
+#else
+    hinstanceFound = GetModuleHandle("GUI.DLL");
+#endif
+    // hinstanceFound = (HINSTANCE) GetWindowLong(hwndFound, GWL_HINSTANCE);
+    // sv_hinstance = perl_get_sv("Win32::GUI::hinstance", TRUE);
+    // sv_setiv(sv_hinstance, (IV) hinstanceFound);
+    SetConsoleTitle(OldPerlWindowTitle);
+    if(GIMME == G_ARRAY) {
+        EXTEND(SP, 2);
+        XST_mIV(0, (long) hwndFound);
+        XST_mIV(1, (long) hinstanceFound);
+        XSRETURN(2);
+    } else {
+        XSRETURN_IV((long) hwndFound);
+    }
+
+
+     ##########################################################################
+     # (@)INTERNAL:RegisterClassEx(%OPTIONS)
+     # used by new Win32::GUI::Class
+void
+RegisterClassEx(...)
+PPCODE:
+    WNDCLASSEX wcx;
+    HINSTANCE hinstance;
+    char * option;
+    int i, next_i;
+    dMY_CXT;
+
+    ZeroMemory(&wcx, sizeof(WNDCLASSEX));
+    wcx.cbSize = sizeof(WNDCLASSEX);
+
+    wcx.style = CS_HREDRAW | CS_VREDRAW; // TODO (default class style...)
+    wcx.cbClsExtra = 0;
+    wcx.cbWndExtra = 0;
+    wcx.lpfnWndProc = WindowMsgLoop;
+#ifdef NT_BUILD_NUMBER
+    hinstance = GetModuleHandle("GUI.PLL");
+#else
+    hinstance = GetModuleHandle("GUI.DLL");
+#endif
+    wcx.hIcon = LoadIcon(hinstance, MAKEINTRESOURCE(IDI_DEFAULTICON));
+    wcx.hIconSm = NULL;
+    wcx.hCursor = LoadCursor(NULL, IDC_ARROW);
+    wcx.lpszMenuName = NULL;
+
+    for(i = 0; i < items; i++) {
+        if(strcmp(SvPV_nolen(ST(i)), "-extends") == 0) {
+            next_i = i + 1;
+            if(!GetClassInfoEx((HINSTANCE) NULL, (LPCTSTR) SvPV_nolen(ST(next_i)), &wcx)) {
+                if(PL_dowarn) warn("Win32::GUI: Class '%s' not found!\n", SvPV_nolen(ST(next_i)));
+                XSRETURN_NO;
+            }
+        }
+    }
+
+    next_i = -1;
+    for(i = 0; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-name") == 0) {
+                next_i = i + 1;
+                wcx.lpszClassName = (char *) SvPV_nolen(ST(next_i));
+            } else if(strcmp(option, "-color") == 0) {
+                next_i = i + 1;
+                wcx.hbrBackground = (HBRUSH) SvCOLORREF(NOTXSCALL ST(next_i));
+            } else if(strcmp(option, "-visual") == 0) {
+                next_i = i + 1;
+                // -visual => 0 is obsolete
+                if(SvIV(ST(next_i)) == 0) {
+                    wcx.lpfnWndProc = MsgLoop;
+                }
+            } else if(strcmp(option, "-widget") == 0) {
+                next_i = i + 1;
+                if(strcmp(SvPV_nolen(ST(next_i)), "Button") == 0) {
+                    MY_CXT.DefButtonProc = wcx.lpfnWndProc;
+                    wcx.lpfnWndProc = ButtonMsgLoop;
+                } else if(strcmp(SvPV_nolen(ST(next_i)), "Listbox") == 0) {
+                    MY_CXT.DefListboxProc = wcx.lpfnWndProc;
+                    wcx.lpfnWndProc = ListboxMsgLoop;
+                } else if(strcmp(SvPV_nolen(ST(next_i)), "TabStrip") == 0) {
+                    MY_CXT.DefTabStripProc = wcx.lpfnWndProc;
+                    wcx.lpfnWndProc = TabStripMsgLoop;
+                } else if(strcmp(SvPV_nolen(ST(next_i)), "RichEdit") == 0) {
+                    MY_CXT.DefRichEditProc = wcx.lpfnWndProc;
+                    wcx.lpfnWndProc = RichEditMsgLoop;
+                } else if(strcmp(SvPV_nolen(ST(next_i)), "Graphic") == 0) {
+                    wcx.lpfnWndProc = GraphicMsgLoop;
+                } else if(strcmp(SvPV_nolen(ST(next_i)), "InteractiveGraphic") == 0) {
+                    wcx.lpfnWndProc = InteractiveGraphicMsgLoop;
+                } else if(strcmp(SvPV_nolen(ST(next_i)), "Splitter") == 0) {
+                    wcx.lpfnWndProc = SplitterMsgLoop;
+                    wcx.hCursor = LoadCursor(hinstance, MAKEINTRESOURCE(IDC_HSPLIT));
+                } else if(strcmp(SvPV_nolen(ST(next_i)), "SplitterH") == 0) {
+                    wcx.lpfnWndProc = SplitterMsgLoop;
+                    wcx.hCursor = LoadCursor(hinstance, MAKEINTRESOURCE(IDC_VSPLIT));
+                }
+            } else if(strcmp(option, "-style") == 0) {
+                next_i = i + 1;
+                wcx.style = SvIV(ST(next_i));
+            } else if(strcmp(option, "-icon") == 0) {
+                next_i = i + 1;
+                wcx.hIcon = (HICON) handle_From(NOTXSCALL ST(next_i));
+            } else if(strcmp(option, "-cursor") == 0) {
+                next_i = i + 1;
+                wcx.hCursor = (HCURSOR) handle_From(NOTXSCALL ST(next_i));
+            } else if(strcmp(option, "-menu") == 0) {
+                next_i = i + 1;
+                wcx.lpszMenuName = (char *) SvPV_nolen(ST(next_i));
+            }
+        } else {
+            next_i = -1;
+        }
+    }
+
+    // Register the window class.
+    if(RegisterClassEx(&wcx)) {
+        XSRETURN_YES;
+    } else {
+        XSRETURN_NO;
+    }
+
+
+
+     ##########################################################################
+     # (@)INTERNAL:CreateWindowEx(%OPTIONS)
+     # obsoleted, use Create() instead
+void
+CreateWindowEx(...)
+PPCODE:
+    HWND myhandle;
+    int i, next_i;
+    HWND  hParent;
+    HMENU hMenu;
+    HINSTANCE hInstance;
+    LPVOID pPointer;
+    DWORD dwStyle;
+    DWORD dwExStyle;
+    LPCTSTR szClassname;
+    LPCTSTR szText;
+    int nX, nY, nWidth, nHeight;
+    char * option;
+
+    hParent = NULL;
+    hMenu = NULL;
+    hInstance = NULL;
+    pPointer = NULL;
+    dwStyle = 0;
+    dwExStyle = 0;
+    szText = NULL;
+
+    next_i = -1;
+    for(i = 0; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-exstyle") == 0) {
+                next_i = i + 1;
+                dwExStyle = (DWORD) SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-class") == 0) {
+                next_i = i + 1;
+                szClassname = (LPCTSTR) SvPV_nolen(ST(next_i));
+            }
+            if(strcmp(option, "-text") == 0
+            || strcmp(option, "-title") == 0) {
+                next_i = i + 1;
+                szText = (LPCTSTR) SvPV_nolen(ST(next_i));
+            }
+            if(strcmp(option, "-style") == 0) {
+                next_i = i + 1;
+                dwStyle = (DWORD) SvIV(ST(next_i));
+            }
+
+            if(strcmp(option, "-left") == 0) {
+                next_i = i + 1;
+                nX = (int) SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-top") == 0) {
+                next_i = i + 1;
+                nY = (int) SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-height") == 0) {
+                next_i = i + 1;
+                nHeight = (int) SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-width") == 0) {
+                next_i = i + 1;
+                nWidth = (int) SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-parent") == 0) {
+                next_i = i + 1;
+                hParent = (HWND) handle_From(NOTXSCALL ST(next_i));
+            }
+            if(strcmp(option, "-menu") == 0) {
+                next_i = i + 1;
+                hMenu = (HMENU) handle_From(NOTXSCALL ST(next_i));
+            }
+            if(strcmp(option, "-instance") == 0) {
+                next_i = i + 1;
+                hInstance = (HINSTANCE)(DWORD)SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-data") == 0) {
+                next_i = i + 1;
+                pPointer = (LPVOID) SvPV_nolen(ST(next_i));
+            }
+
+        } else {
+            next_i = -1;
+        }
+    }
+#ifdef PERLWIN32GUI_DEBUG
+    printf("XS(CreateWindowEx): Done parsing parameters...\n");
+    printf("XS(CreateWindowEx): dwExStyle = 0x%x\n", dwExStyle);
+    printf("XS(CreateWindowEx): szClassname = %s\n", szClassname);
+    printf("XS(CreateWindowEx): szText = %s\n", szText);
+    printf("XS(CreateWindowEx): dwStyle = 0x%x\n", dwStyle);
+    printf("XS(CreateWindowEx): nX = %d\n", nX);
+    printf("XS(CreateWindowEx): nY = %d\n", nY);
+    printf("XS(CreateWindowEx): nWidth = %d\n", nWidth);
+    printf("XS(CreateWindowEx): nHeight = %d\n", nHeight);
+    printf("XS(CreateWindowEx): hParent = 0x%x\n", hParent);
+    printf("XS(CreateWindowEx): hMenu = 0x%x\n", hMenu);
+    printf("XS(CreateWindowEx): hInstance = 0x%x\n", hInstance);
+    printf("XS(CreateWindowEx): pPointer = 0x%x\n", pPointer);
+#endif
+    if(myhandle = CreateWindowEx(dwExStyle,
+                                 szClassname,
+                                 szText,
+                                 dwStyle,
+                                 nX,
+                                 nY,
+                                 nWidth,
+                                 nHeight,
+                                 hParent,
+                                 hMenu,
+                                 hInstance,
+                                 pPointer)) {
+        XSRETURN_IV((long) myhandle);
+    } else {
+        XSRETURN_NO;
+    }
+
+
+    ###########################################################################
+    # (@)INTERNAL:Create(%OPTIONS)
+    # this is where all the windows are created
+void
+Create(...)
+PPCODE:
+    HWND myhandle;
+    int first_i;
+    PERLWIN32GUI_CREATESTRUCT perlcs;
+    LPVOID pPointer;
+    SV* tempsv;
+    SV* self;
+    SV** stored;
+    SV* storing;
+    SV** font;
+    LPPERLWIN32GUI_USERDATA perlud;
+
+    ZeroMemory(&perlcs, sizeof(PERLWIN32GUI_CREATESTRUCT));
+
+    self = newSVsv(ST(0));
+    perlcs.hvSelf = (HV*) SvRV(self);
+    perlcs.iClass = SvIV(ST(1));
+    perlcs.clrForeground = CLR_INVALID;
+    perlcs.clrBackground = CLR_INVALID;
+    perlcs.iMinWidth = -1;
+    perlcs.iMaxWidth = -1;
+    perlcs.iMinHeight = -1;
+    perlcs.iMaxHeight = -1;
+    perlcs.iEventModel = PERLWIN32GUI_EM_BYNAME;
+
+    // #### fill the default parameters for classes
+    switch(perlcs.iClass) {
+    case WIN32__GUI__WINDOW:
+        perlcs.cs.style = WS_OVERLAPPEDWINDOW;
+        break;
+    case WIN32__GUI__DIALOG:
+        perlcs.cs.style = WS_BORDER | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU;
+        perlcs.cs.dwExStyle = WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE
+                            | WS_EX_CONTEXTHELP | WS_EX_CONTROLPARENT;
+        break;
+    case WIN32__GUI__BUTTON:
+        perlcs.cs.lpszClass = "BUTTON";
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON;
+        break;
+    case WIN32__GUI__CHECKBOX:
+        perlcs.cs.lpszClass = "BUTTON";
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD | BS_AUTOCHECKBOX;
+        break;
+    case WIN32__GUI__RADIOBUTTON:
+        perlcs.cs.lpszClass = "BUTTON";
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD | BS_AUTORADIOBUTTON;
+        break;
+    case WIN32__GUI__GROUPBOX:
+        perlcs.cs.lpszClass = "BUTTON";
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD | BS_GROUPBOX;
+        break;
+    case WIN32__GUI__STATIC:
+        perlcs.cs.lpszClass = "STATIC";
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD | SS_LEFT;
+        break;
+    case WIN32__GUI__EDIT:
+        perlcs.cs.lpszClass = "EDIT";
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD | WS_BORDER | ES_LEFT
+                        | ES_AUTOHSCROLL | ES_AUTOVSCROLL; // evtl. DS_3DLOOK?
+        perlcs.cs.dwExStyle = WS_EX_CLIENTEDGE;
+        break;
+    case WIN32__GUI__LISTBOX:
+        perlcs.cs.lpszClass = "LISTBOX";
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD | LBS_NOTIFY;
+        perlcs.cs.dwExStyle = WS_EX_CLIENTEDGE;
+        break;
+    case WIN32__GUI__COMBOBOX:
+        perlcs.cs.lpszClass = "COMBOBOX";
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD;
+        perlcs.cs.dwExStyle = WS_EX_CLIENTEDGE;
+        break;
+    case WIN32__GUI__PROGRESS:
+        perlcs.cs.lpszClass = PROGRESS_CLASS;
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD;
+        perlcs.cs.dwExStyle = WS_EX_CLIENTEDGE;
+        break;
+    case WIN32__GUI__STATUS:
+        perlcs.cs.lpszClass = STATUSCLASSNAME;
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD;
+        break;
+    case WIN32__GUI__TAB:
+        perlcs.cs.lpszClass = WC_TABCONTROL;
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD;
+        break;
+    case WIN32__GUI__TOOLBAR:
+        perlcs.cs.lpszClass = TOOLBARCLASSNAME;
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD;
+        break;
+    case WIN32__GUI__LISTVIEW:
+        perlcs.cs.lpszClass = WC_LISTVIEW;
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD | WS_BORDER | LVS_REPORT | LVS_SHOWSELALWAYS;
+        perlcs.cs.dwExStyle = WS_EX_CLIENTEDGE;
+        break;
+    case WIN32__GUI__TREEVIEW:
+        perlcs.cs.lpszClass = WC_TREEVIEW;
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD | WS_BORDER | TVS_SHOWSELALWAYS;
+        perlcs.cs.dwExStyle = WS_EX_CLIENTEDGE;
+        break;
+    case WIN32__GUI__RICHEDIT:
+        perlcs.cs.lpszClass = "RichEdit";
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD | ES_MULTILINE | ES_AUTOHSCROLL | ES_AUTOVSCROLL;
+        perlcs.cs.dwExStyle = WS_EX_CLIENTEDGE;
+        break;
+    case WIN32__GUI__TRACKBAR:
+        perlcs.cs.lpszClass = TRACKBAR_CLASS;
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD | TBS_AUTOTICKS | TBS_ENABLESELRANGE;
+        break;
+    case WIN32__GUI__UPDOWN:
+        perlcs.cs.lpszClass = UPDOWN_CLASS;
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD | UDS_SETBUDDYINT | UDS_AUTOBUDDY | UDS_ALIGNRIGHT;
+        break;
+    case WIN32__GUI__TOOLTIP:
+        perlcs.cs.lpszClass = TOOLTIPS_CLASS;
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD | TTS_ALWAYSTIP;
+        break;
+    case WIN32__GUI__ANIMATION:
+        perlcs.cs.lpszClass = ANIMATE_CLASS;
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD;
+        break;
+    case WIN32__GUI__REBAR:
+        perlcs.cs.lpszClass = REBARCLASSNAME;
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS
+                        | WS_CLIPCHILDREN | RBS_VARHEIGHT | CCS_NODIVIDER;
+        perlcs.cs.dwExStyle = WS_EX_TOOLWINDOW;
+        break;
+    case WIN32__GUI__HEADER:
+        perlcs.cs.lpszClass = WC_HEADER;
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD | HDS_HORZ;
+        break;
+    case WIN32__GUI__COMBOBOXEX:
+        perlcs.cs.lpszClass = WC_COMBOBOXEX;
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD;
+        break;
+    case WIN32__GUI__DTPICK:
+        perlcs.cs.lpszClass = DATETIMEPICK_CLASS;
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD;
+        break;
+    case WIN32__GUI__GRAPHIC:
+        perlcs.cs.lpszClass = "Win32::GUI::Graphic";
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD;
+        perlcs.cs.dwExStyle = WS_EX_NOPARENTNOTIFY;
+        break;
+    case WIN32__GUI__SPLITTER:
+        perlcs.cs.lpszClass = "Win32::GUI::Splitter(vertical)";
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD;
+        perlcs.cs.dwExStyle = WS_EX_NOPARENTNOTIFY;
+        break;
+    case WIN32__GUI__MDICLIENT:
+        perlcs.cs.lpszClass = "MDICLIENT";
+        perlcs.cs.style = WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN | WS_VSCROLL | WS_HSCROLL;
+        break;
+    }
+    first_i = 2;
+    if(SvROK(ST(2))) {
+        perlcs.cs.hwndParent = (HWND) handle_From(NOTXSCALL ST(2));
+        perlcs.hvParent = (HV*) SvRV(ST(2));
+        first_i = 3;
+    }
+
+    // #### options parsing loop
+    ParseWindowOptions(NOTXSCALL sp, mark, ax, items, first_i, &perlcs);
+
+    // #### post-processing default parameters
+    switch(perlcs.iClass) {
+    case WIN32__GUI__WINDOW:
+    case WIN32__GUI__DIALOG:
+        if(perlcs.cs.lpszClass == NULL) {
+            if(perlcs.szWindowName == NULL) {
+                tempsv = perl_get_sv("Win32::GUI::StandardWinClass", FALSE);
+                perlcs.cs.lpszClass = classname_From(NOTXSCALL tempsv);
+            } else {
+                tempsv = perl_get_sv("Win32::GUI::StandardWinClassVisual", FALSE);
+                perlcs.cs.lpszClass = classname_From(NOTXSCALL tempsv);
+            }
+        }
+        break;
+    case WIN32__GUI__BUTTON:
+        CalcControlSize(NOTXSCALL &perlcs, 16, 8);
+        break;
+    case WIN32__GUI__CHECKBOX:
+    case WIN32__GUI__RADIOBUTTON:
+        CalcControlSize(NOTXSCALL &perlcs, 24, 8);
+        break;
+    case WIN32__GUI__STATIC:
+        CalcControlSize(NOTXSCALL &perlcs, 0, 0);
+        break;
+    }
+
+    // #### default styles for all controls
+    if(perlcs.iClass != WIN32__GUI__WINDOW
+    && perlcs.iClass != WIN32__GUI__DIALOG) {
+        SwitchBit(perlcs.cs.style, WS_CHILD, 1);
+    }
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    printf("XS(Create): Done parsing parameters...\n");
+    printf("XS(Create): dwExStyle = 0x%x\n", perlcs.cs.dwExStyle);
+    printf("XS(Create): szClassname = '%s'\n", perlcs.cs.lpszClass);
+    printf("XS(Create): szName = '%s'\n", perlcs.cs.lpszName);
+    printf("XS(Create): dwStyle = 0x%x\n", perlcs.cs.style);
+    printf("XS(Create): nX = %d\n", perlcs.cs.x);
+    printf("XS(Create): nY = %d\n", perlcs.cs.y);
+    printf("XS(Create): nWidth = %d\n", perlcs.cs.cx);
+    printf("XS(Create): nHeight = %d\n", perlcs.cs.cy);
+    printf("XS(Create): hParent = 0x%x\n", perlcs.cs.hwndParent);
+    printf("XS(Create): hMenu = 0x%x\n", perlcs.cs.hMenu);
+    printf("XS(Create): hInstance = 0x%x\n", perlcs.cs.hInstance);
+    printf("XS(Create): dwPlStyle = 0x%x\n", perlcs.dwPlStyle);
+#endif
+
+    // #### prepare the ground for the window
+    Newz(0, perlud, 1, PERLWIN32GUI_USERDATA);
+    perlud->dwSize = sizeof(PERLWIN32GUI_USERDATA);
+#ifdef PERL_OBJECT
+    perlud->pPerl = pPerl;
+#endif
+    perlud->svSelf = self;
+    if(NULL != perlcs.szWindowName) {
+        strcpy( (perlud->szWindowName), perlcs.szWindowName);
+    }
+    perlud->fDialogUI = 0;
+    perlud->iClass = perlcs.iClass;
+    perlud->hAcc = perlcs.hAcc;
+    perlud->hCursor = perlcs.hCursor;
+    perlud->dwPlStyle = perlcs.dwPlStyle;
+    perlud->iMinWidth = perlcs.iMinWidth;
+    perlud->iMaxWidth = perlcs.iMaxWidth;
+    perlud->iMinHeight = perlcs.iMinHeight;
+    perlud->iMaxHeight = perlcs.iMaxHeight;
+    perlud->clrForeground = perlcs.clrForeground;
+    perlud->clrBackground = perlcs.clrBackground;
+    perlud->hBackgroundBrush = perlcs.hBackgroundBrush;
+    perlud->iEventModel = perlcs.iEventModel;
+    perlud->hvEvents = perlcs.hvEvents;
+    perlud->dwEventMask = perlcs.dwEventMask;
+    perlud->avHooks = perlcs.avHooks;
+    pPointer = perlud;
+
+    // #### the following can be vital for the window
+    // #### because as soon as it is created the message
+    // #### loop is activated and data needs to be there
+    storing = newSViv((long) perlcs.iClass);
+    stored = hv_store_mg(NOTXSCALL perlcs.hvSelf, "-type", 5, storing, 0);
+    if(perlcs.szWindowName != NULL) {
+        storing = newSVpv((char *)perlcs.szWindowName, 0);
+        stored = hv_store_mg(NOTXSCALL perlcs.hvSelf, "-name", 5, storing, 0);
+    }
+
+    // #### and finally, creation of the window
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    printf("XS(Create): Done initialization of USERDATA struct...\n");
+#endif
+    if(myhandle = CreateWindowEx(
+        perlcs.cs.dwExStyle,
+        perlcs.cs.lpszClass,
+        perlcs.cs.lpszName,
+        perlcs.cs.style,
+        perlcs.cs.x,
+        perlcs.cs.y,
+        perlcs.cs.cx,
+        perlcs.cs.cy,
+        perlcs.cs.hwndParent,
+        perlcs.cs.hMenu,
+        perlcs.cs.hInstance,
+        pPointer
+    )) {
+        // #### ok, we can fill this object's hash
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("XS(Create): storing -handle...\n");
+#endif
+        storing = newSViv((long) myhandle);
+        stored = hv_store_mg(NOTXSCALL perlcs.hvSelf, "-handle", 7, storing, 0);
+        // #### set the font for the control
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("XS(Create): storing -font...\n");
+#endif
+        if(perlcs.hFont != NULL) {
+            storing = newSViv((long) perlcs.hFont);
+            stored = hv_store_mg(NOTXSCALL perlcs.hvSelf, "-font", 5, storing, 0);
+            SendMessage(myhandle, WM_SETFONT, (WPARAM) perlcs.hFont, 0);
+        } else if(perlcs.cs.hwndParent != NULL) {
+            font = hv_fetch_mg(NOTXSCALL perlcs.hvParent, "-font", 5, FALSE);
+            if(font != NULL && SvOK(*font)) {
+                perlcs.hFont = (HFONT) handle_From(NOTXSCALL *font);
+                SendMessage(myhandle, WM_SETFONT, (WPARAM) perlcs.hFont, 0);
+            } else {
+                perlcs.hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
+                SendMessage(myhandle, WM_SETFONT, (WPARAM) perlcs.hFont, 0);
+            }
+        }
+        if(NULL == perlcs.hAcc) {
+#ifdef PERLWIN32GUI_STRONGDEBUG
+            printf("XS(Create): storing -accel...\n");
+#endif
+            stored = hv_store_mg(NOTXSCALL perlcs.hvSelf, "-accel", 6, newSViv(0), 0);
+        }
+
+        // #### add (or create) the tooltip
+        if(perlcs.szTip != NULL) {
+            if(perlcs.hvParent != NULL) {
+                if(perlcs.hTooltip == NULL) {
+                    SV** t;
+                    t = hv_fetch_mg(NOTXSCALL perlcs.hvParent, "-tooltip", 8, 0);
+                    if(t != NULL && SvOK( *t )) {
+						perlcs.hTooltip = (HWND)(DWORD)SvIV(*t);
+                    }
+                }
+                if(perlcs.hTooltip == NULL) {
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                    printf("XS(Create): creating -tooltip...\n");
+#endif
+                    perlcs.hTooltip = CreateTooltip(NOTXSCALL perlcs.hvParent);
+                }
+            }
+#ifdef PERLWIN32GUI_STRONGDEBUG
+            printf("XS(Create): adding -tooltip...\n");
+#endif
+            TOOLINFO ti;
+            ZeroMemory(&ti, sizeof(TOOLINFO));
+            ti.cbSize = sizeof(TOOLINFO);
+            ti.uFlags = TTF_IDISHWND | TTF_CENTERTIP | TTF_SUBCLASS;
+            ti.hwnd = perlcs.cs.hwndParent;
+            ti.uId = (WPARAM) myhandle;
+            ti.lpszText = perlcs.szTip;
+            SendMessage(perlcs.hTooltip, TTM_ADDTOOL, 0, (LPARAM) &ti);
+        }
+
+        // #### store the child in the parent hash
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("XS(Create): storing child into parent...\n");
+#endif
+        if(perlcs.hvParent != NULL && perlcs.szWindowName != NULL) {
+            storing = self;
+            stored = hv_store_mg(NOTXSCALL perlcs.hvParent, perlcs.szWindowName, strlen(perlcs.szWindowName), storing, 0);
+        }
+
+        // #### other post-creation class-specific initializations...
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("XS(Create): post-creation phase...\n");
+#endif
+        switch(perlcs.iClass) {
+        case WIN32__GUI__STATIC:
+            Label_onPostCreate(NOTXSCALL myhandle, &perlcs);
+            break;
+        case WIN32__GUI__BUTTON:
+            if(perlcs.hImageList != NULL) {
+                if(perlcs.cs.style & BS_ICON) {
+                    SendMessage(
+                        myhandle,
+                        BM_SETIMAGE,
+                        (WPARAM) IMAGE_ICON,
+                        (LPARAM) perlcs.hImageList
+                    );
+                } else {
+                    SendMessage(
+                        myhandle,
+                        BM_SETIMAGE,
+                        (WPARAM) IMAGE_BITMAP,
+                        (LPARAM) perlcs.hImageList
+                    );
+                }
+            }
+            break;
+        case WIN32__GUI__CHECKBOX:
+        case WIN32__GUI__RADIOBUTTON:
+            if(perlcs.dwPlStyle & PERLWIN32GUI_CHECKED) {
+                SendMessage(
+                    myhandle,
+                    BM_SETCHECK,
+                    (WPARAM) BST_CHECKED,
+                    (LPARAM) 0
+                );
+            }
+            break;
+        case WIN32__GUI__TOOLBAR:
+            Toolbar_onPostCreate(NOTXSCALL myhandle, &perlcs);
+            break;
+        case WIN32__GUI__TAB:
+            TabStrip_onPostCreate(NOTXSCALL myhandle, &perlcs);
+            break;
+        case WIN32__GUI__LISTVIEW:
+            ListView_onPostCreate(NOTXSCALL myhandle, &perlcs);
+            break;
+        case WIN32__GUI__TREEVIEW:
+            TreeView_onPostCreate(NOTXSCALL myhandle, &perlcs);
+            break;
+        case WIN32__GUI__REBAR:
+            Rebar_onPostCreate(NOTXSCALL myhandle, &perlcs);
+            break;
+        case WIN32__GUI__COMBOBOXEX:
+            if(perlcs.hImageList != NULL) {
+                SendMessage(myhandle, CBEM_SETIMAGELIST, 0, (LPARAM) perlcs.hImageList);
+                SetWindowPos(
+                    myhandle, (HWND) NULL,
+                    perlcs.cs.x, perlcs.cs.y, perlcs.cs.cx, perlcs.cs.cy,
+                    SWP_NOZORDER | SWP_NOOWNERZORDER
+                );
+            }
+            break;
+        }
+
+        // #### store a pointer to the Perl object in the window's USERDATA
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("XS(Create): storing GWL_USERDATA...\n");
+#endif
+        if(perlcs.iClass != WIN32__GUI__WINDOW
+        && perlcs.iClass != WIN32__GUI__DIALOG) {
+            // #### POSSIBLE PROBLEM HERE:
+            // #### since we don't provide a MsgLoop function
+            // #### for each control, we can't control WM_DESTROY
+            // #### to deallocate memory for our USERDATA structure.
+            SetWindowLong(myhandle, GWL_USERDATA, (long) perlud);
+        }
+
+        // #### (try to) figure out which MsgLoop procedure to use
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("XS(Create): detecting MsgLoop...\n");
+#endif
+        if(perlcs.hvParent != NULL && perlcs.szWindowName != NULL) {
+            LPPERLWIN32GUI_USERDATA parentud;
+            parentud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(perlcs.cs.hwndParent, GWL_USERDATA);
+            if( ValidUserData(parentud) ) {
+                if(parentud->iClass != WIN32__GUI__WINDOW
+                && parentud->iClass != WIN32__GUI__DIALOG
+                && !(parentud->dwPlStyle & PERLWIN32GUI_CONTAINER)) {
+                    parentud->wndprocPreContainer = (WNDPROC) SetWindowLong(perlcs.cs.hwndParent, GWL_WNDPROC, (LONG) ContainerMsgLoop);
+                    SwitchBit(parentud->dwPlStyle, PERLWIN32GUI_CONTAINER, 1);
+                    SetWindowLong(perlcs.cs.hwndParent, GWL_USERDATA, (LONG) parentud);
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                    printf("XS(Create): changed wndproc for '%s' to ContainerMsgLoop (original=0x%x)\n", parentud->szWindowName, parentud->wndprocPreContainer);
+#endif
+                }
+            }
+        }
+        if(perlcs.dwPlStyle & PERLWIN32GUI_CONTAINER) {
+            perlud->wndprocPreContainer = (WNDPROC) SetWindowLong(myhandle, GWL_WNDPROC, (LONG) ContainerMsgLoop);
+        }
+        if(perlcs.dwPlStyle & PERLWIN32GUI_NEM
+        && (perlcs.iClass == PERLWIN32GUI_CLS_WINDOW
+        ||  perlcs.iClass == PERLWIN32GUI_CLS_DIALOG)) {
+            perlud->wndprocPreNEM = (WNDPROC) SetWindowLong(myhandle, GWL_WNDPROC, (LONG) NEM_WindowMsgLoop);
+            SetWindowLong(myhandle, GWL_USERDATA, (LONG) perlud);
+#ifdef PERLWIN32GUI_STRONGDEBUG
+            printf("XS(Create): changed wndproc for '%s' to NEM_WindowMsgLoop (original=0x%x)\n", perlud->szWindowName, perlud->wndprocPreNEM);
+#endif
+        }
+        if(perlud->dwPlStyle & PERLWIN32GUI_NEM_CHILD) {
+            perlud->wndprocPreNEM = (WNDPROC) SetWindowLong(myhandle, GWL_WNDPROC, (LONG) NEM_ChildMsgLoop);
+            SetWindowLong(myhandle, GWL_USERDATA, (LONG) perlud);
+#ifdef PERLWIN32GUI_STRONGDEBUG
+            printf("XS(Create): changed wndproc for '%s' to NEM_ChildMsgLoop (original=0x%x)\n", perlud->szWindowName, perlud->wndprocPreNEM);
+#endif
+        }
+        if(perlud->dwPlStyle & PERLWIN32GUI_NEM_PARENT
+        && perlcs.cs.hwndParent != NULL) {
+            LPPERLWIN32GUI_USERDATA parentud;
+            parentud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(perlcs.cs.hwndParent, GWL_USERDATA);
+            if( ValidUserData(parentud) ) {
+                if((parentud->iClass == WIN32__GUI__WINDOW
+                ||  parentud->iClass == WIN32__GUI__DIALOG)
+                && !(parentud->dwPlStyle & PERLWIN32GUI_NEM)) {
+                    parentud->wndprocPreNEM = (WNDPROC) SetWindowLong(perlcs.cs.hwndParent, GWL_WNDPROC, (LONG) NEM_WindowMsgLoop);
+                    SwitchBit(parentud->dwPlStyle, PERLWIN32GUI_NEM, 1);
+                    SetWindowLong(perlcs.cs.hwndParent, GWL_USERDATA, (LONG) parentud);
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                    printf("XS(Create): changed wndproc for '%s' to NEM_WindowMsgLoop (original=0x%x)\n", parentud->szWindowName, parentud->wndprocPreNEM);
+#endif
+                }
+            }
+        }
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("XS(Create): DONE!\n");
+#endif
+        XSRETURN_IV((long) myhandle);
+    } else {
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("XS(Create): CreateWindowEx failed, returning undef\n");
+#endif
+        XSRETURN_NO;
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:Change(HANDLE, %OPTIONS)
+    # Change most of the options used when the object was created.
+void
+Change(...)
+PPCODE:
+    HWND handle;
+    PERLWIN32GUI_CREATESTRUCT perlcs;
+    LPPERLWIN32GUI_USERDATA perlud;
+
+    handle = (HWND) handle_From(NOTXSCALL ST(0));
+    perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(handle, GWL_USERDATA);
+
+    ZeroMemory(&perlcs, sizeof(PERLWIN32GUI_CREATESTRUCT));
+    if( ! ValidUserData(perlud) ) {
+        XSRETURN_UNDEF;
+    }
+
+    perlcs.hvSelf = (HV*) SvRV(perlud->svSelf);
+    perlcs.cs.style = GetWindowLong(handle, GWL_STYLE);
+    perlcs.cs.dwExStyle = GetWindowLong(handle, GWL_EXSTYLE);
+    if(perlcs.hvSelf != NULL) {
+        // #### retrieve windows data
+        perlcs.iClass = perlud->iClass;
+        perlcs.hAcc = perlud->hAcc;
+        perlcs.iMinWidth = perlud->iMinWidth;
+        perlcs.iMaxWidth = perlud->iMaxWidth;
+        perlcs.iMinHeight = perlud->iMinHeight;
+        perlcs.iMaxHeight = perlud->iMaxHeight;
+        perlcs.clrForeground = perlud->clrForeground;
+        perlcs.clrBackground = perlud->clrBackground;
+        perlcs.hBackgroundBrush = perlud->hBackgroundBrush;
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("XS(Change): BEFORE dwExStyle = 0x%x\n", perlcs.cs.dwExStyle);
+        printf("XS(Change): BEFORE szClassname = %s\n", perlcs.cs.lpszClass);
+        printf("XS(Change): BEFORE szName = %s\n", perlcs.cs.lpszName);
+        printf("XS(Change): BEFORE dwStyle = 0x%x\n", perlcs.cs.style);
+        printf("XS(Change): BEFORE nX = %d\n", perlcs.cs.x);
+        printf("XS(Change): BEFORE nY = %d\n", perlcs.cs.y);
+        printf("XS(Change): BEFORE nWidth = %d\n", perlcs.cs.cx);
+        printf("XS(Change): BEFORE nHeight = %d\n", perlcs.cs.cy);
+        printf("XS(Change): BEFORE hParent = 0x%x\n", perlcs.cs.hwndParent);
+        printf("XS(Change): BEFORE hMenu = 0x%x\n", perlcs.cs.hMenu);
+        printf("XS(Change): BEFORE hInstance = 0x%x\n", perlcs.cs.hInstance);
+        printf("XS(Change): BEFORE clrForeground = 0x%x\n", perlcs.clrForeground);
+        printf("XS(Change): BEFORE clrBackground = 0x%x\n", perlcs.clrBackground);
+        printf("XS(Change): BEFORE hBackgroundBrush = 0x%x\n", perlcs.hBackgroundBrush);
+#endif
+        // #### parse new window options
+        ParseWindowOptions(NOTXSCALL sp, mark, ax, items, 1, &perlcs);
+
+        // #### default styles for all controls
+        if(perlcs.iClass != WIN32__GUI__WINDOW
+        && perlcs.iClass != WIN32__GUI__DIALOG) {
+            SwitchBit(perlcs.cs.style, WS_CHILD, 1);
+        }
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("XS(Change): AFTER dwExStyle = 0x%x\n", perlcs.cs.dwExStyle);
+        printf("XS(Change): AFTER szClassname = %s\n", perlcs.cs.lpszClass);
+        printf("XS(Change): AFTER szName = %s\n", perlcs.cs.lpszName);
+        printf("XS(Change): AFTER dwStyle = 0x%x\n", perlcs.cs.style);
+        printf("XS(Change): AFTER nX = %d\n", perlcs.cs.x);
+        printf("XS(Change): AFTER nY = %d\n", perlcs.cs.y);
+        printf("XS(Change): AFTER nWidth = %d\n", perlcs.cs.cx);
+        printf("XS(Change): AFTER nHeight = %d\n", perlcs.cs.cy);
+        printf("XS(Change): AFTER hParent = 0x%x\n", perlcs.cs.hwndParent);
+        printf("XS(Change): AFTER hMenu = 0x%x\n", perlcs.cs.hMenu);
+        printf("XS(Change): AFTER hInstance = 0x%x\n", perlcs.cs.hInstance);
+        printf("XS(Change): AFTER clrForeground = 0x%x\n", perlcs.clrForeground);
+        printf("XS(Change): AFTER clrBackground = 0x%x\n", perlcs.clrBackground);
+        printf("XS(Change): AFTER hBackgroundBrush = 0x%x\n", perlcs.hBackgroundBrush);
+#endif
+        // #### Perform changes
+        if(NULL != perlcs.szWindowName) {
+            strcpy( (perlud->szWindowName), perlcs.szWindowName);
+        }
+        perlud->iClass = perlcs.iClass;
+        perlud->hAcc = perlcs.hAcc;
+        perlud->iMinWidth = perlcs.iMinWidth;
+        perlud->iMaxWidth = perlcs.iMaxWidth;
+        perlud->iMinHeight = perlcs.iMinHeight;
+        perlud->iMaxHeight = perlcs.iMaxHeight;
+        perlud->clrForeground = perlcs.clrForeground;
+        perlud->clrBackground = perlcs.clrBackground;
+        perlud->hBackgroundBrush = perlcs.hBackgroundBrush;
+        SetWindowLong(handle, GWL_USERDATA, (long) perlud);
+        if(perlcs.cs.lpszName != NULL)
+            SetWindowText(handle, perlcs.cs.lpszName);
+        SetWindowLong(handle, GWL_STYLE, perlcs.cs.style);
+        SetWindowLong(handle, GWL_EXSTYLE, perlcs.cs.dwExStyle);
+        if(perlcs.cs.x != 0 || perlcs.cs.y != 0)
+            SetWindowPos(handle, (HWND) NULL, perlcs.cs.x, perlcs.cs.y, 0, 0,
+                                 SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOSIZE);
+        if(perlcs.cs.cx != 0 || perlcs.cs.cy != 0)
+            SetWindowPos(handle, (HWND) NULL, 0, 0, perlcs.cs.cx, perlcs.cs.cy,
+                                 SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOMOVE);
+        if(perlcs.cs.hMenu != NULL)
+            SetMenu(handle, perlcs.cs.hMenu);
+        if(perlcs.iClass == WIN32__GUI__LISTVIEW)
+            ListView_SetExtendedListViewStyle(handle, perlcs.cs.dwExStyle);
+        if(perlcs.iClass == WIN32__GUI__CHECKBOX
+        || perlcs.iClass == WIN32__GUI__RADIOBUTTON) {
+            if(perlcs.dwPlStyle & PERLWIN32GUI_SEENCHECKED) {
+                if(perlcs.dwPlStyle & PERLWIN32GUI_CHECKED) {
+                    SendMessage(
+                        handle,
+                        BM_SETCHECK,
+                        (WPARAM) BST_CHECKED,
+                        (LPARAM) 0
+                    );
+                } else {
+                    SendMessage(
+                        handle,
+                        BM_SETCHECK,
+                        (WPARAM) BST_UNCHECKED,
+                        (LPARAM) 0
+                    );
+                }
+            }
+        }
+/* TODO: change class ???
+        if(perlcs.cs.iClass != NULL)
+            SetWindowLong(handle, GWL_
+*/
+        XSRETURN_YES;
+    } else {
+        XSRETURN_NO;
+    }
+
+    ###########################################################################
+    # (@)METHOD:Dialog()
+DWORD
+Dialog(hwnd=NULL)
+    HWND hwnd
+PREINIT:
+    MSG msg;
+    HWND phwnd;
+    HWND thwnd;
+    int stayhere;
+    BOOL fIsDialog;
+    HACCEL acc;
+    LPPERLWIN32GUI_USERDATA perlud;
+CODE:
+    stayhere = 1;
+    fIsDialog = FALSE;
+    while (stayhere) {
+
+        ENTER;
+        SAVETMPS;
+
+        stayhere = GetMessage(&msg, hwnd, 0, 0);
+
+        if(msg.message == WM_EXITLOOP) {
+            stayhere = 0;
+            msg.wParam = (WPARAM) -1;
+        } else {
+            if(stayhere == -1) {
+                stayhere = 0;
+                msg.wParam = (WPARAM) -2; // an error occurred...
+            } else {
+                // #### trace back to the window's parent
+                phwnd = msg.hwnd;
+                while(thwnd = GetParent(phwnd)) {
+                    phwnd = thwnd;
+                }
+                // #### now see if the parent window is a DialogBox
+                fIsDialog = FALSE;
+                acc = NULL;
+                perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(phwnd, GWL_USERDATA);
+                if( ValidUserData(perlud) ) {
+                    fIsDialog = perlud->dwPlStyle & PERLWIN32GUI_DIALOGUI;
+					acc = perlud->hAcc;
+                }
+                if(fIsDialog) {
+                    if(acc != NULL) {
+                        if(!TranslateAccelerator(phwnd, acc, &msg)) {
+                            if(!IsDialogMessage(phwnd, &msg)) {
+                                TranslateMessage(&msg);
+                                DispatchMessage(&msg);
+                            }
+                        }
+                    } else {
+                        if(!IsDialogMessage(phwnd, &msg)) {
+                            TranslateMessage(&msg);
+                            DispatchMessage(&msg);
+                        }
+                    }
+                } else {
+                    if(acc != NULL) {
+                        if(!TranslateAccelerator(phwnd, acc, &msg)) {
+                            TranslateMessage(&msg);
+                            DispatchMessage(&msg);
+                        }
+                    } else {
+                        TranslateMessage(&msg);
+                        DispatchMessage(&msg);
+                    }
+                }
+            }
+        }
+
+        FREETMPS;
+        LEAVE;
+
+    }
+    RETVAL = msg.wParam;
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:DoEvents()
+DWORD
+DoEvents(hwnd=NULL)
+    HWND hwnd
+PREINIT:
+    MSG msg;
+    HWND phwnd;
+    HWND thwnd;
+    int stayhere;
+    BOOL fIsDialog;
+    HACCEL acc;
+    LPPERLWIN32GUI_USERDATA perlud;
+CODE:
+    stayhere = 1;
+    fIsDialog = FALSE;
+    while(stayhere) {
+        stayhere = PeekMessage(&msg, hwnd, 0, 0, PM_REMOVE);
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("XS(DoEvents): PeekMessage returned %d\n", stayhere);
+#endif
+        if (stayhere) {
+            if(msg.message == WM_EXITLOOP) {
+                stayhere = 0;
+                msg.wParam = (WPARAM) -1;
+            } else  {
+                // #### trace back to the window's parent
+                phwnd = msg.hwnd;
+                while(thwnd = GetParent(phwnd)) {
+                    phwnd = thwnd;
+                }
+                // #### now see if the parent window is a DialogBox
+                fIsDialog = FALSE;
+                acc = NULL;
+                perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(phwnd, GWL_USERDATA);
+                if( ValidUserData(perlud) ) {
+                    fIsDialog = perlud->dwPlStyle & PERLWIN32GUI_DIALOGUI;
+                    acc = perlud->hAcc;
+                }
+
+                if(acc && TranslateAccelerator(phwnd, acc, &msg)) {
+                    continue;
+                }
+
+                if(fIsDialog && IsDialogMessage(phwnd, &msg)) {
+                    continue;
+                }
+
+                TranslateMessage(&msg);
+                DispatchMessage(&msg);
+            }
+        }
+        else
+            msg.wParam = (WPARAM) 0;
+    }
+    RETVAL = msg.wParam;
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)INTERNAL:oldDialog()
+DWORD
+oldDialog(...)
+PREINIT:
+    HWND hwnd;
+    MSG msg;
+    int stayhere = 1;
+CODE:
+    if(items > 0) {
+        hwnd = (HWND) handle_From(NOTXSCALL ST(0));
+    } else {
+        hwnd = NULL;
+    }
+
+    while (stayhere) {
+        stayhere = GetMessage(&msg, hwnd, 0, 0);
+        if(msg.message == WM_EXITLOOP) {
+            stayhere = 0;
+            msg.wParam = (WPARAM) -1;
+        } else {
+            if(stayhere == -1) {
+                stayhere = 0;
+                msg.wParam = (WPARAM) -2; // an error occurred...
+            } else {
+                TranslateMessage(&msg);
+                DispatchMessage(&msg);
+            }
+        }
+    }
+    RETVAL = (long)msg.wParam;
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)INTERNAL:LoadCursorFromFile(FILENAME)
+HCURSOR
+LoadCursorFromFile(filename)
+    LPCTSTR filename
+CODE:
+    RETVAL = LoadCursorFromFile(filename);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)INTERNAL:LoadImage(FILENAME, [TYPE, X, Y, FLAGS])
+HBITMAP
+LoadImage(filename,iType=IMAGE_BITMAP,iX=0,iY=0,iFlags=LR_LOADFROMFILE)
+    LPCTSTR filename
+    UINT iType
+    int iX
+    int iY
+    UINT iFlags
+CODE:
+    RETVAL = (HBITMAP) LoadImage((HINSTANCE) NULL, filename, iType, iX, iY, iFlags);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)INTERNAL:DestroyIcon()
+BOOL
+DestroyIcon(icon)
+    HICON icon
+CODE:
+    RETVAL = DestroyIcon(icon);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)INTERNAL:DestroyCursor()
+BOOL
+DestroyCursor(cursor)
+    HCURSOR cursor
+CODE:
+    RETVAL = DestroyCursor(cursor);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:SetCursor(CURSOR)
+HCURSOR
+SetCursor(cursor)
+    HCURSOR cursor
+CODE:
+    RETVAL = SetCursor(cursor);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:GetCursor()
+    # Returns the handle of the current cursor.
+HCURSOR
+GetCursor()
+CODE:
+    RETVAL = GetCursor();
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:ChangeCursor(CURSOR)
+HCURSOR
+ChangeCursor(handle, cursor)
+    HWND handle
+    HCURSOR cursor
+CODE:
+    RETVAL = (HCURSOR) SetClassLong(handle, GCL_HCURSOR, (LONG) cursor);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:ChangeIcon(ICON)
+    # Changes the default icon for a window to ICON (a Win32::GUI::Icon
+    # object). Returns the handle of the previous default icon.
+HICON
+ChangeIcon(handle, icon)
+    HWND handle
+    HICON icon
+CODE:
+    SetClassLong(handle, GCL_HICONSM, (LONG) icon);
+    RETVAL = (HICON) SetClassLong(handle, GCL_HICON, (LONG) icon);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:ChangeSmallIcon(ICON)
+    # Changes the default small icon for a window to ICON (a Win32::GUI::Icon
+    # object). Returns the handle of the previous default small icon.
+HICON
+ChangeSmallIcon(handle, icon)
+    HWND handle
+    HICON icon
+CODE:
+    RETVAL = (HICON) SetClassLong(handle, GCL_HICONSM, (LONG) icon);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetClassName()
+void
+GetClassName(handle)
+    HWND handle
+PREINIT:
+    LPTSTR lpClassName;
+    int nMaxCount;
+PPCODE:
+    nMaxCount = 256;
+    lpClassName = (LPTSTR) safemalloc(nMaxCount);
+    if(GetClassName(handle, lpClassName, nMaxCount) > 0) {
+        EXTEND(SP, 1);
+        XST_mPV(0, lpClassName);
+        safefree(lpClassName);
+        XSRETURN(1);
+    } else {
+        safefree(lpClassName);
+        XSRETURN_NO;
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:FindWindow(CLASSNAME, WINDOWNAME)
+    # Returns the handle of the window whose class name and window name match
+    # the specified strings; both strings can be empty. Note that the function
+    # does not search child windows, only top level windows.
+    # If no matching windows is found, the return value is zero.
+HWND
+FindWindow(classname,windowname)
+    LPCTSTR classname
+    LPCTSTR windowname
+CODE:
+    if(strlen(classname) == 0) classname = NULL;
+    if(strlen(windowname) == 0) windowname = NULL;
+    RETVAL = FindWindow(classname, windowname);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetWindowLong(INDEX)
+    # Retrieves a windows property; for more info consult the original API
+    # documentation.
+LONG
+GetWindowLong(handle,index)
+    HWND handle
+    int index
+CODE:
+    RETVAL = GetWindowLong(handle, index);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:SetWindowLong(INDEX, VALUE)
+    # Sets a windows property; for more info consult the original API
+    # documentation.
+LONG
+SetWindowLong(handle,index,value)
+    HWND handle
+    int  index
+    LONG value
+CODE:
+    RETVAL = SetWindowLong(handle, index, value);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetWindow(COMMAND)
+    # Returns handle of the window that has the specified
+    # relationship (given by COMMAND) with the specified window.
+    # Available COMMANDs are:
+    #   GW_CHILD
+    #   GW_HWNDFIRST
+    #   GW_HWNDLAST
+    #   GW_HWNDNEXT
+    #   GW_HWNDPREV
+    #   GW_OWNER
+    #
+    # Example:
+    #     $Button->GetWindow(GW_OWNER);
+HWND
+GetWindow(handle,command)
+    HWND handle
+    UINT command
+CODE:
+    RETVAL = GetWindow(handle, command);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Show([COMMAND])
+BOOL
+Show(handle,command=SW_SHOWNORMAL)
+    HWND handle
+    int command
+CODE:
+    RETVAL = ShowWindow(handle, command);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Hide()
+BOOL
+Hide(handle)
+    HWND handle
+CODE:
+    RETVAL = ShowWindow(handle, SW_HIDE);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Maximize()
+    # Maximizes a window.
+BOOL
+Maximize(handle)
+    HWND handle
+CODE:
+    RETVAL = ShowWindow(handle, SW_SHOWMAXIMIZED);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Update()
+BOOL
+Update(handle)
+    HWND handle
+CODE:
+    RETVAL = UpdateWindow(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:InvalidateRect(...)
+BOOL
+InvalidateRect(handle, ...)
+    HWND handle
+PREINIT:
+    RECT rect;
+    LPRECT lpRect;
+    BOOL bErase;
+CODE:
+    if(items != 2 && items && items != 6) {
+        CROAK("Usage: InvalidateRect(handle, flag);\n   or: InvalidateRect(handle, left, top, right, bottom, [flag]);\n");
+    }
+    if(items == 2) {
+        lpRect = (LPRECT) NULL;
+        bErase = (BOOL) SvIV(ST(1));
+    } else {
+        rect.left   = SvIV(ST(1));
+        rect.top    = SvIV(ST(2));
+        rect.right  = SvIV(ST(3));
+        rect.bottom = SvIV(ST(4));
+        if(items == 5)
+            bErase      = TRUE;
+        else
+            bErase      = (BOOL) SvIV(ST(5));
+        lpRect      = &rect;
+    }
+    RETVAL = InvalidateRect(handle, lpRect, bErase);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)INTERNAL:DestroyWindow()
+BOOL
+DestroyWindow(handle)
+    HWND handle
+CODE:
+    RETVAL = DestroyWindow(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetMessage([MIN, MAX])
+void
+GetMessage(handle,min=0,max=0)
+    HWND handle
+    UINT min
+    UINT max
+PREINIT:
+    MSG msg;
+    BOOL result;
+PPCODE:
+    result = GetMessage(&msg, handle, min, max);
+    if(result == -1) {
+        XSRETURN_UNDEF;
+    } else {
+        EXTEND(SP, 7);
+        XST_mIV(0, result);
+        XST_mIV(1, msg.message);
+        XST_mIV(2, msg.wParam);
+        XST_mIV(3, msg.lParam);
+        XST_mIV(4, msg.time);
+        XST_mIV(5, msg.pt.x);
+        XST_mIV(6, msg.pt.y);
+        XSRETURN(7);
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:GetCursorPos()
+void
+GetCursorPos()
+PREINIT:
+    POINT point;
+PPCODE:
+    if(GetCursorPos(&point)) {
+        EXTEND(SP, 2);
+        XST_mIV(0, point.x);
+        XST_mIV(1, point.y);
+        XSRETURN(2);
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+    ###########################################################################
+    # (@)METHOD:SetCursorPos(X, Y)
+BOOL
+SetCursorPos(x, y)
+    int x
+    int y
+CODE:
+    RETVAL = SetCursorPos(x, y);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:ClipCursor([LEFT, TOP, RIGHT, BOTTOM])
+BOOL
+ClipCursor(left=0, top=0, right=0, bottom=0)
+    LONG left
+    LONG top
+    LONG right
+    LONG bottom
+PREINIT:
+    RECT r;
+CODE:
+    if(items == 0) {
+        RETVAL = ClipCursor(NULL);
+    } else {
+        r.left = left;
+        r.top = top;
+        r.right = right;
+        r.bottom = bottom;
+        RETVAL = ClipCursor(&r);
+    }
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:SendMessage(MSG, WPARAM, LPARAM)
+    # Sends a message to a window.
+LRESULT
+SendMessage(handle,msg,wparam,lparam)
+    HWND handle
+    UINT msg
+    WPARAM wparam
+    LPARAM lparam
+CODE:
+    RETVAL = SendMessage(handle, msg, wparam, lparam);
+OUTPUT:
+    RETVAL
+
+	###########################################################################
+	# (@)METHOD:UnHook(MSG);
+	# Undefines a Window Message hook.
+
+void
+UnHook(handle,msg)
+	HWND handle
+	UINT msg
+PREINIT:
+	LPPERLWIN32GUI_USERDATA perlud;
+	SV** coderef;
+PPCODE:
+	perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(handle, GWL_USERDATA);
+	if(perlud->avHooks != NULL) {
+		coderef = av_fetch(perlud->avHooks, (I32) msg, 0);
+		if(coderef != NULL && SvOK(*coderef)) {
+			av_fetch(perlud->avHooks, (I32) msg, 1);	// undefine it.
+			SvREFCNT_dec(*coderef);
+			XSRETURN_YES;
+		}
+		else {
+			XSRETURN_NO;
+		}
+	}
+	else {
+		XSRETURN_NO;
+	}
+
+    ###########################################################################
+    # (@)METHOD:Hook(MSG,CODEREF)
+    # Assigns a handler to a window message. Returns the previous handler code
+    # reference or undef if no previous perl handler was defined.
+void
+Hook(handle,msg,coderef)
+	HWND handle
+	UINT msg
+	SV* coderef
+PREINIT:
+	LPPERLWIN32GUI_USERDATA perlud;
+	SV** oldcoderef;
+PPCODE:
+	if(SvOK(coderef) && SvROK(coderef) && SvTYPE(SvRV(coderef)) == SVt_PVCV) {
+		// We have a ref and it's a coderef.
+		perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(handle, GWL_USERDATA);
+		if(perlud->avHooks == NULL) {
+			perlud->avHooks = newAV();
+		}
+		oldcoderef = av_fetch(perlud->avHooks, (I32) msg, 0);
+		if(av_store(perlud->avHooks, (I32) msg, coderef) != NULL) {
+			SvREFCNT_inc(coderef);
+		}
+		else {
+			SvREFCNT_dec(coderef);
+		}
+		if(oldcoderef)
+			XPUSHs(*oldcoderef);
+		else
+			XPUSHs(sv_2mortal(newSVnv(0)));
+	}
+
+    ###########################################################################
+    # (@)METHOD:PostMessage(MSG, WPARAM, LPARAM)
+    # Posts a message to a window.
+LRESULT
+PostMessage(handle,msg,wparam,lparam)
+    HWND handle
+    UINT msg
+    WPARAM wparam
+    LPARAM lparam
+CODE:
+    RETVAL = PostMessage(handle, msg, wparam, lparam);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:SendMessageTimeout(MSG, WPARAM, LPARAM, [FLAGS], TIMEOUT)
+    # Sends a message to a window and wait for it to be processed or until the
+    # specified TIMEOUT (number of milliseconds) elapses; returns the result
+    # code of the processed message or undef on errors.
+    # If undef is returned and a call to Win32::GetLastError() returns 0,
+    # then the window timed out processing the message.
+    # The FLAGS parameter is optional, possible values are:
+    #  0 SMTO_NORMAL
+    #    (the calling thread can process other requests while waiting;
+    #    this is the default setting)
+    #  1 SMTO_BLOCK
+    #    (the calling thread does not process other requests)
+    #  2 SMTO_ABORTIFHUNG
+    #    (returns without waiting if the receiving process seems to be "hung")
+void
+SendMessageTimeout(handle,msg,wparam,lparam,flags=SMTO_NORMAL,timeout)
+    HWND handle
+    UINT msg
+    WPARAM wparam
+    LPARAM lparam
+    UINT flags
+    UINT timeout
+PREINIT:
+    DWORD result;
+PPCODE:
+    if(SendMessageTimeout(
+        handle, msg, wparam, lparam, flags, timeout, &result
+    ) == 0) {
+        XSRETURN_NO;
+    } else {
+        XSRETURN_IV(result);
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:PostQuitMessage([EXITCODE])
+    # Sends a quit message to a window, optionally with an EXITCODE;
+    # if no EXITCODE is given, it defaults to 0.
+void
+PostQuitMessage(...)
+PPCODE:
+    int exitcode;
+    if(items > 0)
+        exitcode = SvIV(ST(items-1));
+    else
+        exitcode = 0;
+    PostQuitMessage(exitcode);
+
+
+    ###########################################################################
+    # (@)METHOD:PeekMessage([MIN, MAX, MESSAGE])
+    # Inspects the window's message queue and eventually returns data
+    # about the message it contains; it can optionally check only for message
+    # identifiers in the range MIN..MAX; the last MESSAGE parameter, if
+    # specified, must be an array reference.
+    # If a message is found, the function puts in that array 7 elements
+    # containing:
+    #   - the handle of the window to which the message is addressed
+    #   - the message identifier
+    #   - the wParam argument
+    #   - the lParam argument
+    #   - the time when message occurs
+    #   - the x coordinate at which message occurs
+    #   - the y coordinate at which message occurs
+    #
+BOOL
+PeekMessage(handle, min=0, max=0, message=&PL_sv_undef)
+    HWND handle
+    UINT min
+    UINT max
+    SV* message
+PREINIT:
+    MSG msg;
+CODE:
+    ZeroMemory(&msg, sizeof(msg));
+    RETVAL = PeekMessage(&msg, handle, min, max, PM_NOREMOVE);
+    if(message != &PL_sv_undef) {
+        if(SvROK(message) && SvTYPE(SvRV(message)) == SVt_PVAV) {
+            av_clear((AV*) SvRV(message));
+            av_push((AV*) SvRV(message), newSViv((long) msg.hwnd));
+            av_push((AV*) SvRV(message), newSViv(msg.message));
+            av_push((AV*) SvRV(message), newSViv(msg.wParam));
+            av_push((AV*) SvRV(message), newSViv(msg.lParam));
+            av_push((AV*) SvRV(message), newSViv(msg.time));
+            av_push((AV*) SvRV(message), newSViv(msg.pt.x));
+            av_push((AV*) SvRV(message), newSViv(msg.pt.y));
+        } else {
+            if(PL_dowarn) warn("Win32::GUI: fourth parameter to PeekMessage is not an array reference");
+        }
+    }
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Text([TEXT])
+    # (@)METHOD:Caption([TEXT])
+void
+Text(handle,...)
+    HWND handle
+ALIAS:
+    Win32::GUI::Caption = 1
+PREINIT:
+    char *myBuffer;
+    int myLength;
+PPCODE:
+    if(items > 2) {
+        CROAK("Usage: Text(handle, [value]);\n");
+    }
+    if(items == 1) {
+        myLength = GetWindowTextLength(handle)+1;
+        if(myLength) {
+            myBuffer = (char *) safemalloc(myLength);
+            if(GetWindowText(handle, myBuffer, myLength)) {
+                EXTEND(SP, 1);
+                XST_mPV(0, myBuffer);
+                safefree(myBuffer);
+                XSRETURN(1);
+            }
+            safefree(myBuffer);
+        }
+        XSRETURN_NO;
+    } else {
+        XSRETURN_IV((long) SetWindowText(handle, (LPCTSTR) SvPV_nolen(ST(1))));
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:Move(X, Y)
+BOOL
+Move(handle,x,y)
+    HWND handle
+    int x
+    int y
+CODE:
+    RETVAL = SetWindowPos(handle, (HWND) NULL, x, y, 0, 0,
+                          SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOSIZE);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Resize(X, Y)
+BOOL
+Resize(handle,x,y)
+    HWND handle
+    int x
+    int y
+CODE:
+    RETVAL = SetWindowPos(handle, (HWND) NULL, 0, 0, x, y,
+                          SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOMOVE);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetClientRect()
+void
+GetClientRect(handle)
+    HWND handle
+PREINIT:
+    RECT myRect;
+PPCODE:
+    if(GetClientRect(handle, &myRect)) {
+        EXTEND(SP, 4);
+        XST_mIV(0, myRect.left);
+        XST_mIV(1, myRect.top);
+        XST_mIV(2, myRect.right);
+        XST_mIV(3, myRect.bottom);
+        XSRETURN(4);
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:GetWindowRect()
+void
+GetWindowRect(handle)
+    HWND handle
+PREINIT:
+    RECT myRect;
+PPCODE:
+    if(GetWindowRect(handle, &myRect)) {
+        EXTEND(SP, 4);
+        XST_mIV(0, myRect.left);
+        XST_mIV(1, myRect.top);
+        XST_mIV(2, myRect.right);
+        XST_mIV(3, myRect.bottom);
+        XSRETURN(4);
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:Width([WIDTH])
+void
+Width(handle,...)
+    HWND handle
+PREINIT:
+    RECT myRect;
+PPCODE:
+    if(items > 2) {
+        croak("Usage: Width(handle, [value]);\n");
+    }
+
+    if(!GetWindowRect(handle, &myRect)) XSRETURN_NO;
+
+    if(items == 1) {
+        EXTEND(SP, 1);
+        XST_mIV(0, (myRect.right-myRect.left));
+        XSRETURN(1);
+    } else {
+        if(SetWindowPos(handle, (HWND) NULL, 0, 0,
+                        (int) SvIV(ST(1)),
+                        (int) (myRect.bottom-myRect.top),
+                        SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOMOVE)) {
+            XSRETURN_YES;
+        } else {
+            XSRETURN_NO;
+        }
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:Height([HEIGHT])
+void
+Height(handle,...)
+    HWND handle
+PREINIT:
+    RECT myRect;
+PPCODE:
+    if(items > 2) {
+        croak("Usage: Height(handle, [value]);\n");
+    }
+
+    if(!GetWindowRect(handle, &myRect)) XSRETURN_NO;
+
+    if(items == 1) {
+        EXTEND(SP, 1);
+        XST_mIV(0, (myRect.bottom-myRect.top));
+        XSRETURN(1);
+    } else {
+        if(SetWindowPos(handle, (HWND) NULL, 0, 0,
+                        (int) (myRect.right-myRect.left),
+                        (int) SvIV(ST(1)),
+                        SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOMOVE)) {
+            XSRETURN_YES;
+        } else {
+            XSRETURN_NO;
+        }
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:Left([LEFT])
+void
+Left(handle,...)
+    HWND handle
+PREINIT:
+    RECT myRect;
+    HWND parent;
+    POINT myPt;
+PPCODE:
+    if(items > 2) {
+        croak("Usage: Left(handle, [value]);\n");
+    }
+    if(!GetWindowRect(handle, &myRect)) XSRETURN_NO;
+    myPt.x = myRect.left;
+    myPt.y = myRect.top;
+    parent = GetParent(handle);
+    if (parent) ScreenToClient(parent, &myPt);
+    if(items == 1) {
+        EXTEND(SP, 1);
+        XST_mIV(0, myPt.x);
+        XSRETURN(1);
+    } else {
+        if(SetWindowPos(
+            handle, (HWND) NULL,
+            (int) SvIV(ST(1)), (int) myPt.y,
+            0, 0,
+            SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOSIZE
+        )) {
+            XSRETURN_YES;
+        } else {
+            XSRETURN_NO;
+        }
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:Top([TOP])
+void
+Top(handle,...)
+    HWND handle
+PREINIT:
+    RECT myRect;
+    HWND parent;
+    POINT myPt;
+PPCODE:
+    if(items > 2) {
+        croak("Usage: Top(handle, [value]);\n");
+    }
+    if(!GetWindowRect(handle, &myRect)) XSRETURN_NO;
+    myPt.x = myRect.left;
+    myPt.y = myRect.top;
+    parent = GetParent(handle);
+    if (parent) ScreenToClient(parent, &myPt);
+    if(items == 1) {
+        EXTEND(SP, 1);
+        XST_mIV(0, myPt.y);
+        XSRETURN(1);
+    } else {
+        if(SetWindowPos(
+            handle, (HWND) NULL,
+            (int) myPt.x, (int) SvIV(ST(1)),
+            0, 0,
+            SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOSIZE
+        )) {
+            XSRETURN_YES;
+        } else {
+            XSRETURN_NO;
+        }
+    }
+
+    ###########################################################################
+    # (@)METHOD:AbsLeft()
+int
+AbsLeft(handle)
+    HWND handle
+PREINIT:
+    RECT myRect;
+CODE:
+    if(!GetWindowRect(handle, &myRect)) {
+        RETVAL = -1;
+    } else {
+        RETVAL = myRect.left;
+    }
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:AbsTop()
+int
+AbsTop(handle)
+    HWND handle
+PREINIT:
+    RECT myRect;
+CODE:
+    if(!GetWindowRect(handle, &myRect)) {
+        RETVAL = -1;
+    } else {
+        RETVAL = myRect.top;
+    }
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:ScreenToClient(X, Y)
+void
+ScreenToClient(handle,x,y)
+    HWND handle
+    int x
+    int y
+PREINIT:
+    POINT myPt;
+PPCODE:
+    myPt.x = x;
+    myPt.y = y;
+    ScreenToClient(handle, &myPt);
+    EXTEND(SP, 2);
+    XST_mIV(0, myPt.x);
+    XST_mIV(1, myPt.y);
+    XSRETURN(2);
+
+
+    ###########################################################################
+    # (@)METHOD:ScaleWidth()
+DWORD
+ScaleWidth(handle)
+    HWND handle
+PREINIT:
+    RECT myRect;
+CODE:
+    if(GetClientRect(handle, &myRect)) {
+        RETVAL = myRect.right;
+    } else {
+        RETVAL = 0;
+    }
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:ScaleHeight()
+DWORD
+ScaleHeight(handle)
+    HWND handle
+PREINIT:
+    RECT myRect;
+CODE:
+    if(GetClientRect(handle, &myRect)) {
+        RETVAL = myRect.bottom;
+    } else {
+        RETVAL = 0;
+    }
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:BringWindowToTop()
+BOOL
+BringWindowToTop(handle)
+    HWND handle
+CODE:
+    RETVAL = BringWindowToTop(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:ArrangeIconicWindows()
+    # Arranges all the minimized child windows of the specified parent window.
+UINT
+ArrangeIconicWindows(handle)
+    HWND handle
+CODE:
+    RETVAL = ArrangeIconicWindows(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetDesktopWindow()
+    # Returns the handle of the desktop window.
+HWND
+GetDesktopWindow(...)
+CODE:
+   RETVAL = GetDesktopWindow();
+OUTPUT:
+   RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetForegroundWindow()
+    # Returns the handle of the foreground window.
+HWND
+GetForegroundWindow(...)
+CODE:
+   RETVAL = GetForegroundWindow();
+OUTPUT:
+   RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:SetForegroundWindow()
+    # Brings the window to the foreground.
+BOOL
+SetForegroundWindow(handle)
+    HWND handle
+CODE:
+    RETVAL = SetForegroundWindow(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:IsZoomed()
+BOOL
+IsZoomed(handle)
+    HWND handle
+CODE:
+    RETVAL = IsZoomed(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:IsIconic()
+    # Returns TRUE if the window is minimized, FALSE otherwise.
+BOOL
+IsIconic(handle)
+    HWND handle
+CODE:
+    RETVAL = IsIconic(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:IsWindow()
+BOOL
+IsWindow(handle)
+    HWND handle
+CODE:
+    RETVAL = IsWindow(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:IsVisible()
+BOOL
+IsVisible(handle)
+    HWND handle
+CODE:
+    RETVAL = IsWindowVisible(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:IsEnabled()
+BOOL
+IsEnabled(handle)
+    HWND handle
+CODE:
+    RETVAL = IsWindowEnabled(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Enable([FLAG])
+BOOL
+Enable(handle,flag=TRUE)
+    HWND handle
+    BOOL flag
+CODE:
+    RETVAL = EnableWindow(handle, flag);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Disable()
+BOOL
+Disable(handle)
+    HWND handle
+CODE:
+    RETVAL = EnableWindow(handle, FALSE);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:OpenIcon()
+    # (@)METHOD:Restore()
+BOOL
+OpenIcon(handle)
+    HWND handle
+ALIAS:
+    Win32::GUI::Restore = 1
+CODE:
+    RETVAL = OpenIcon(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:CloseWindow()
+    # (@)METHOD:Minimize()
+BOOL
+CloseWindow(handle)
+    HWND handle
+ALIAS:
+    Win32::GUI::Minimize = 1
+CODE:
+    RETVAL = CloseWindow(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:WindowFromPoint(X, Y)
+HWND
+WindowFromPoint(x,y)
+    LONG x
+    LONG y
+PREINIT:
+    POINT myPoint;
+CODE:
+    myPoint.x = x;
+    myPoint.y = y;
+    RETVAL = WindowFromPoint(myPoint);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetTopWindow()
+    # Returns the handle of the foreground window.
+HWND
+GetTopWindow(handle)
+    HWND handle
+CODE:
+    RETVAL = GetTopWindow(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetActiveWindow()
+    # Returns the handle of the active window.
+HWND
+GetActiveWindow(...)
+CODE:
+    RETVAL = GetActiveWindow();
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetDlgItem(ID)
+    # Returns the handle of a control in the dialog box given its ID.
+HWND
+GetDlgItem(handle,identifier)
+    HWND handle
+    int identifier
+CODE:
+    RETVAL = GetDlgItem(handle, identifier);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetFocus()
+    # Returns the handle of the window that has the keyboard focus.
+HWND
+GetFocus(...)
+CODE:
+    RETVAL = GetFocus();
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:SetFocus()
+    # Activates a window.
+HWND
+SetFocus(handle)
+    HWND handle
+CODE:
+    RETVAL = SetFocus(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:SetCapture()
+    # Assigns the mouse capture to a window.
+HWND
+SetCapture(handle)
+    HWND handle
+CODE:
+    RETVAL = SetCapture(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:ReleaseCapture()
+    # Releases the mouse capture.
+BOOL
+ReleaseCapture(...)
+CODE:
+    RETVAL = ReleaseCapture();
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetWindowThreadProcessId()
+    # Returns a two elements array containing the thread and the process
+    # identifier for the specified window.
+void
+GetWindowThreadProcessId(handle)
+    HWND handle
+PREINIT:
+    DWORD tid;
+    DWORD pid;
+PPCODE:
+    tid = GetWindowThreadProcessId(handle, &pid);
+    EXTEND(SP, 2);
+    XST_mIV(0, tid);
+    XST_mIV(1, pid);
+    XSRETURN(2);
+
+
+    ###########################################################################
+    # (@)METHOD:AttachThreadInput(FROM, TO, [FLAG])
+BOOL
+AttachThreadInput(from,to,flag=TRUE)
+    DWORD from
+    DWORD to
+    BOOL flag
+CODE:
+    RETVAL = AttachThreadInput(from, to, flag);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetTextExtentPoint32(STRING, [FONT])
+    # Returns a two elements array containing the x and y size of the
+    # specified STRING in the window (eventually with the speficied FONT), or
+    # undef on errors.
+void
+GetTextExtentPoint32(handle,string,font=NULL)
+    HWND handle
+    char * string
+    HFONT font
+PREINIT:
+    STRLEN cbString;
+    char *szString;
+    HDC hdc;
+    SIZE mySize;
+PPCODE:
+    szString = SvPV(ST(1), cbString);
+    hdc = GetDC(handle);
+#ifdef PERLWIN32GUI_DEBUG
+    printf("XS(GetTextExtentPoint32).font=0x%x\n", font);
+    printf("XS(GetTextExtentPoint32).string='%s'\n", string);
+#endif
+    if(font) SelectObject(hdc, (HGDIOBJ) font);
+    if(GetTextExtentPoint32(hdc, szString, (int)cbString, &mySize)) {
+        EXTEND(SP, 2);
+        XST_mIV(0, mySize.cx);
+        XST_mIV(1, mySize.cy);
+        ReleaseDC(handle, hdc);
+        XSRETURN(2);
+    } else {
+        ReleaseDC(handle, hdc);
+        XSRETURN_UNDEF;
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:TrackPopupMenu(MENU, X, Y, [FLAGS])
+BOOL
+TrackPopupMenu(handle,hmenu,x,y,flags=TPM_LEFTALIGN|TPM_TOPALIGN|TPM_LEFTBUTTON)
+    HWND handle
+    HMENU hmenu
+    int x
+    int y
+    UINT flags
+CODE:
+    SetForegroundWindow(handle);
+    RETVAL = TrackPopupMenu(hmenu, flags, x, y, 0, handle, (CONST RECT*) NULL);
+    SetForegroundWindow(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)INTERNAL:SetTimer(HANDLE, ID, ELAPSE)
+UINT
+SetTimer(handle,id,elapse)
+    HWND handle
+    UINT id
+    UINT elapse
+CODE:
+    RETVAL = SetTimer(handle, id, elapse, NULL);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)INTERNAL:KillTimer(HANDLE, ID)
+UINT
+KillTimer(handle,id)
+    HWND handle
+    UINT id
+CODE:
+    RETVAL = KillTimer(handle, id);
+OUTPUT:
+    RETVAL
+
+    # void
+    # EnumChilds(handle)
+    #     HWND handle
+    # PREINIT:
+    #     UINT number;
+    # PPCODE:
+    #     if(EnumChildWindows(handle, EnumChildsProc, (LPARAM) &number))
+    #         XSRETURN(number);
+    #     else
+    #         XSRETURN_NO;
+
+
+    ###########################################################################
+    # (@)METHOD:GetEffectiveClientRect(HANDLE, ID)
+void
+GetEffectiveClientRect(handle,...)
+    HWND handle
+PREINIT:
+    LPINT controls;
+    int i, c;
+    RECT r;
+PPCODE:
+    c = 0;
+    controls = (LPINT) safemalloc(sizeof(INT)*items*2);
+    for(i=1;i<items;i++) {
+        controls[c++] = 1;
+        controls[c++] = (INT) SvIV(ST(i));
+    }
+    controls[c++] = 0;
+    controls[c++] = 0;
+    GetEffectiveClientRect(handle, &r, controls);
+    EXTEND(SP, 4);
+    XST_mIV(0, r.left);
+    XST_mIV(1, r.top);
+    XST_mIV(2, r.right);
+    XST_mIV(3, r.bottom);
+    XSRETURN(4);
+
+
+    ###########################################################################
+    # (@)METHOD:DialogUI(HANDLE, [FLAG])
+void
+DialogUI(handle,...)
+    HWND handle
+PREINIT:
+    LPPERLWIN32GUI_USERDATA perlud;
+PPCODE:
+    if(items > 2) {
+        CROAK("Usage: DialogUI(handle, [value]);\n");
+    }
+
+    perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(handle, GWL_USERDATA);
+    if( ! ValidUserData(perlud) ) {
+        XSRETURN_UNDEF;
+    } else {
+        if(items == 1) {
+            XSRETURN_IV( (long) perlud->dwPlStyle & PERLWIN32GUI_DIALOGUI );
+        } else {
+            SwitchBit(perlud->dwPlStyle, PERLWIN32GUI_DIALOGUI, SvIV(ST(1)));
+            SetWindowLong( handle, GWL_USERDATA, (long) perlud );
+            XSRETURN_IV( (long) perlud->dwPlStyle & PERLWIN32GUI_DIALOGUI );
+        }
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:TrackMouse([TIMEOUT, EVENTS])
+BOOL
+TrackMouse(handle, timeout=HOVER_DEFAULT, events=TME_HOVER|TME_LEAVE)
+    HWND handle
+    DWORD timeout
+    DWORD events
+PREINIT:
+    TRACKMOUSEEVENT tme;
+CODE:
+    tme.cbSize = sizeof(TRACKMOUSEEVENT);
+    tme.hwndTrack = handle;
+    tme.dwFlags = events;
+    tme.dwHoverTime = timeout;
+    RETVAL = TrackMouseEvent( &tme );
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:UntrackMouse()
+BOOL
+UntrackMouse(handle)
+    HWND handle
+PREINIT:
+    TRACKMOUSEEVENT tme;
+CODE:
+    tme.cbSize = sizeof(TRACKMOUSEEVENT);
+    tme.hwndTrack = handle;
+    tme.dwFlags = TME_QUERY;
+    tme.dwHoverTime = 0;
+    if(TrackMouseEvent( &tme )) {
+        tme.dwFlags = tme.dwFlags | TME_CANCEL;
+        RETVAL = TrackMouseEvent( &tme );
+    } else {
+        RETVAL = FALSE;
+    }
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:DoModal()
+BOOL
+DoModal(handle)
+    HWND handle
+PREINIT:
+    int nWindows;
+    LPPERLWIN32GUI_USERDATA perlud;
+    LPPERLWIN32GUI_WINPROCS winprocs;
+    AV* windows;
+    int i;
+    MSG msg;
+    HWND phwnd;
+    HWND thwnd;
+    int stayhere;
+    BOOL fIsDialog;
+    HACCEL acc;
+CODE:
+    nWindows = 0;
+    EnumWindows( (WNDENUMPROC) CountMyWindowsProc, (LPARAM) &nWindows);
+    printf("XS(DoModal): nWindows=%d\n", nWindows);
+    winprocs = (LPPERLWIN32GUI_WINPROCS) safemalloc(sizeof(PERLWIN32GUI_WINPROCS) * nWindows);
+    windows = newAV();
+    EnumWindows( (WNDENUMPROC) EnumMyWindowsProc, (LPARAM) windows);
+    for(i=0; i<av_len(windows); i++) {
+		thwnd = (HWND)(DWORD)SvIV(*(av_fetch(windows, i, 0)));
+        if(thwnd != handle) {
+            printf("XS(DoModal): windows[%d] = 0x%x\n", i, thwnd);
+            winprocs[i].hWnd = (HWND) thwnd;
+            winprocs[i].wndProc = (WNDPROC) GetWindowLong(thwnd, GWL_WNDPROC);
+            SetWindowLong(thwnd, GWL_WNDPROC, (LONG) InactiveMsgLoop);
+            perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(thwnd, GWL_USERDATA);
+            if( ValidUserData(perlud) ) {
+                perlud->Modal = handle;
+            }
+        }
+    }
+
+    ShowWindow(handle, SW_SHOWNORMAL);
+    BringWindowToTop(handle);
+    SetForegroundWindow(handle);
+
+    stayhere = 1;
+    fIsDialog = FALSE;
+    while (stayhere) {
+
+        ENTER;
+        SAVETMPS;
+
+        stayhere = GetMessage(&msg, handle, 0, 0);
+
+        if(msg.message == WM_EXITLOOP) {
+            stayhere = 0;
+            msg.wParam = (WPARAM) -1;
+        } else {
+            if(stayhere == -1) {
+                stayhere = 0;
+                msg.wParam = (WPARAM) -2; // an error occurred...
+            } else {
+                // trace back to the window's parent
+                phwnd = msg.hwnd;
+                while(thwnd = GetParent(phwnd)) {
+                    phwnd = thwnd;
+                }
+                // now see if the parent window is a DialogBox
+                fIsDialog = FALSE;
+                acc = NULL;
+                perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(phwnd, GWL_USERDATA);
+                if( ValidUserData(perlud) ) {
+                    fIsDialog = perlud->dwPlStyle & PERLWIN32GUI_DIALOGUI;
+					acc = perlud->hAcc;
+                }
+                if(fIsDialog) {
+                    if(acc != NULL) {
+                        if(!TranslateAccelerator(phwnd, acc, &msg)) {
+                            if(!IsDialogMessage(phwnd, &msg)) {
+                                TranslateMessage(&msg);
+                                DispatchMessage(&msg);
+                            }
+                        }
+                    } else {
+                        if(!IsDialogMessage(phwnd, &msg)) {
+                            TranslateMessage(&msg);
+                            DispatchMessage(&msg);
+                        }
+                    }
+                } else {
+                    if(acc != NULL) {
+                        if(!TranslateAccelerator(phwnd, acc, &msg)) {
+                            TranslateMessage(&msg);
+                            DispatchMessage(&msg);
+                        }
+                    } else {
+                        TranslateMessage(&msg);
+                        DispatchMessage(&msg);
+                    }
+                }
+            }
+        }
+
+        FREETMPS;
+        LEAVE;
+
+    }
+    RETVAL = msg.wParam;
+
+    ShowWindow(handle, SW_HIDE);
+
+    for(i=0; i<av_len(windows); i++) {
+        if(thwnd != handle) {
+            SetWindowLong(winprocs[i].hWnd, GWL_WNDPROC, (LONG) winprocs[i].wndProc);
+            perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(winprocs[i].hWnd, GWL_USERDATA);
+            if( ValidUserData(perlud) ) {
+                perlud->Modal = NULL;
+            }
+        }
+    }
+    safefree(winprocs);
+OUTPUT:
+    RETVAL
+
+    # TODO: GetIconInfo
+
+    ###########################################################################
+    # DC-related functions (2D window graphic...)
+    ###########################################################################
+
+
+    ###########################################################################
+    # (@)METHOD:PlayEnhMetaFile(FILENAME)
+int
+PlayEnhMetaFile(handle,filename)
+    HWND handle
+    LPCTSTR filename
+PREINIT:
+    HV* self;
+    HDC hdc;
+    SV** tmp;
+    HENHMETAFILE hmeta;
+    RECT rect;
+CODE:
+    self = (HV*) SvRV(ST(0));
+    tmp = hv_fetch_mg(NOTXSCALL self, "-DC", 3, 0);
+    if(tmp == NULL) {
+        RETVAL = -1;
+    } else {
+        hdc = (HDC)(DWORD)SvIV(*tmp);
+        if(hmeta = GetEnhMetaFile(filename)) {
+            GetClientRect(handle, &rect);
+            RETVAL = PlayEnhMetaFile(hdc, hmeta, &rect);
+            DeleteEnhMetaFile(hmeta);
+        } else {
+#ifdef PERLWIN32GUI_DEBUG
+                printf("XS(PlayEnhMetaFile): GetEnhMetaFile failed, error = %d\n", GetLastError());
+#endif
+            RETVAL = 0;
+        }
+    }
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:PlayWinMetaFile(FILENAME)
+int
+PlayWinMetaFile(handle,filename)
+    HWND handle
+    LPCTSTR filename
+PREINIT:
+    HDC hdc;
+    HMETAFILE hwinmeta;
+    HENHMETAFILE hmeta;
+    RECT rect;
+    UINT size;
+    LPVOID data;
+CODE:
+#ifdef PERLWIN32GUI_DEBUG
+    printf("XS(PlayWinMetaFile): filename = '%s'\n", filename);
+#endif
+    SetLastError(0);
+    hwinmeta = GetMetaFile(filename);
+#ifdef PERLWIN32GUI_DEBUG
+    printf("XS(PlayWinMetaFile): hwinmeta = 0x%x\n", hwinmeta);
+    printf("XS(PlayWinMetaFile): GetLastError = %ld\n", GetLastError());
+#endif
+    size = GetMetaFileBitsEx(hwinmeta, 0, NULL);
+#ifdef PERLWIN32GUI_DEBUG
+    printf("XS(PlayWinMetaFile): size = %d\n", size);
+#endif
+    data = (LPVOID) safemalloc(size);
+    GetMetaFileBitsEx(hwinmeta, size, data);
+    hmeta = SetWinMetaFileBits(size, (CONST BYTE *) data, NULL, NULL);
+#ifdef PERLWIN32GUI_DEBUG
+    printf("XS(PlayWinMetaFile): hmeta = 0x%x\n", hmeta);
+#endif
+    hdc = GetDC(handle);
+    GetClientRect(handle, &rect);
+    SetLastError(0);
+    RETVAL = PlayEnhMetaFile(hdc, hmeta, &rect);
+#ifdef PERLWIN32GUI_DEBUG
+    printf("XS(PlayWinMetaFile): GetLastError after PlayEnhMetaFile = %d\n", GetLastError());
+#endif
+    DeleteEnhMetaFile(hmeta);
+    ReleaseDC(handle, hdc);
+    safefree(data);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:CreateEnhMetaFile(FILENAME, [DESCRIPTION])
+HDC
+CreateEnhMetaFile(handle, filename, description=NULL)
+    HWND handle
+    LPCTSTR filename
+    LPCTSTR description
+PREINIT:
+    HV* self;
+    HDC hdc;
+    SV** tmp;
+    RECT rect;
+    int iWidthMM, iHeightMM, iWidthPels, iHeightPels;
+CODE:
+    self = (HV*) SvRV(ST(0));
+    tmp = hv_fetch_mg(NOTXSCALL self, "-DC", 3, 0);
+    if(tmp == NULL) {
+        RETVAL = 0;
+    } else {
+        hdc = (HDC)(DWORD)SvIV(*tmp);
+        iWidthMM = GetDeviceCaps(hdc, HORZSIZE);
+        iHeightMM = GetDeviceCaps(hdc, VERTSIZE);
+        iWidthPels = GetDeviceCaps(hdc, HORZRES);
+        iHeightPels = GetDeviceCaps(hdc, VERTRES);
+        GetClientRect(handle, &rect);
+        rect.left = (rect.left * iWidthMM * 100)/iWidthPels;
+        rect.top = (rect.top * iHeightMM * 100)/iHeightPels;
+        rect.right = (rect.right * iWidthMM * 100)/iWidthPels;
+        rect.bottom = (rect.bottom * iHeightMM * 100)/iHeightPels;
+        RETVAL = CreateEnhMetaFile(hdc, filename, &rect, description);
+    }
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:CloseEnhMetaFile()
+HENHMETAFILE
+CloseEnhMetaFile(hdc)
+    HDC hdc
+CODE:
+    RETVAL = CloseEnhMetaFile(hdc);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:DeleteEnhMetaFile(HANDLE)
+BOOL
+DeleteEnhMetaFile(hmeta)
+    HENHMETAFILE hmeta
+CODE:
+    RETVAL = DeleteEnhMetaFile(hmeta);
+OUTPUT:
+    RETVAL
+
+
+    #HDC GetOrInitDC(SV* obj) {
+    #    CPerl *pPerl;
+    #    HDC hdc;
+    #    HWND hwnd;
+    #    SV** obj_dc;
+    #    SV** obj_hwnd;
+    #
+    #    pPerl = theperl;
+    #
+    #    obj_dc = hv_fetch((HV*)SvRV(obj), "dc", 2, 0);
+    #    if(obj_dc != NULL) {
+    #        __DEBUG("!XS(GetOrInitDC): obj{dc} = %ld\n", SvIV(*obj_dc));
+    #        return (HDC)(DWORD)SvIV(*obj_dc);
+    #    } else {
+    #        obj_hwnd = hv_fetch((HV*)SvRV(obj), "handle", 6, 0);
+    #        hwnd = (HWND)(DWORD)SvIV(*obj_hwnd);
+    #        hdc = GetDC(hwnd);
+    #        __DEBUG("!XS(GetOrInitDC): GetDC = %ld\n", hdc);
+    #        hv_store((HV*) SvRV(obj), "dc", 2, newSViv((long) hdc), 0);
+    #        return hdc;
+    #    }
+    #}
+    #
+    #
+    #XS(XS_Win32__GUI_DrawText) {
+    #
+    #    dXSARGS;
+    #    if(items < 4 || items > 7) {
+    #        CROAK("usage: DrawText($handle, $text, $left, $top, [$width, $height, $format]);\n");
+    #    }
+    #
+    #    HDC hdc = GetOrInitDC(ST(0));
+    #    RECT myRect;
+    #
+    #    strlen cbString;
+    #    char *szString = SvPV(ST(1), cbString);
+    #
+    #    myRect.left   = (LONG) SvIV(ST(2));
+    #    myRect.top    = (LONG) SvIV(ST(3));
+    #
+    #    if(items >4) {
+    #        myRect.right  = (LONG) SvIV(ST(4));
+    #        myRect.bottom = (LONG) SvIV(ST(5));
+    #    } else {
+    #        SIZE mySize;
+    #        GetTextExtentPoint(hdc, szString, (int)cbString, &mySize);
+    #        myRect.right  = myRect.left + (UINT) mySize.cx;
+    #        myRect.bottom = myRect.top  + (UINT) mySize.cy;
+    #    }
+    #
+    #    UINT uFormat = DT_LEFT;
+    #
+    #    if(items == 7) {
+    #        uFormat = (UINT) SvIV(ST(6));
+    #    }
+    #
+    #    BOOL result = DrawText(hdc,
+    #                           szString,
+    #                           cbString,
+    #                           &myRect,
+    #                           uFormat);
+    #    XSRETURN_IV((long) result);
+    #}
+    #
+    #
+    #
+    #
+    #XS(XS_Win32__GUI_ReleaseDC) {
+    #
+    #    dXSARGS;
+    #    if(items != 1) {
+    #        CROAK("usage: ReleaseDC($handle);\n");
+    #    }
+    #
+    #    HWND hwnd = (HWND) handle_From(NOTXSCALL ST(0));
+    #    HDC hdc = GetOrInitDC(ST(0));
+    #
+    #    ReleaseDC(hwnd, hdc);
+    #    hv_delete((HV*) SvRV(ST(0)), "dc", 2, 0);
+    #
+    #    XSRETURN_NO;
+    #}
+    #
+    #
+
+long
+TextOut(handle, x, y, text)
+    HWND handle
+    int x
+    int y
+    char * text
+PREINIT:
+    HV* self;
+    HDC hdc;
+    SV** tmp;
+    STRLEN textlen;
+CODE:
+    self = (HV*) SvRV(ST(0));
+    tmp = hv_fetch_mg(NOTXSCALL self, "-DC", 3, 0);
+    if(tmp == NULL) {
+        RETVAL = -1;
+    } else {
+        hdc = (HDC)(DWORD)SvIV(*tmp);
+        textlen = strlen(text);
+        RETVAL = (long) TextOut(hdc, x, y, text, textlen);
+    }
+OUTPUT:
+    RETVAL
+
+long
+SetTextColor(handle, color)
+    HWND handle
+    COLORREF color
+PREINIT:
+    HV* self;
+    HDC hdc;
+    SV** tmp;
+CODE:
+    self = (HV*) SvRV(ST(0));
+    tmp = hv_fetch_mg(NOTXSCALL self, "-DC", 3, 0);
+    if(tmp == NULL) {
+        RETVAL = -1;
+    } else {
+        hdc = (HDC)(DWORD)SvIV(*tmp);
+        RETVAL = SetTextColor(hdc, color);
+    }
+OUTPUT:
+    RETVAL
+
+long
+GetTextColor(handle)
+    HWND handle
+PREINIT:
+    HV* self;
+    HDC hdc;
+    SV** tmp;
+CODE:
+    self = (HV*) SvRV(ST(0));
+    tmp = hv_fetch_mg(NOTXSCALL self, "-DC", 3, 0);
+    if(tmp == NULL) {
+        RETVAL = -1;
+    } else {
+        hdc = (HDC)(DWORD)SvIV(*tmp);
+        RETVAL = GetTextColor(hdc);
+    }
+OUTPUT:
+    RETVAL
+
+long
+SetBkMode(handle, mode)
+    HWND handle
+    int mode
+PREINIT:
+    HV* self;
+    HDC hdc;
+    SV** tmp;
+CODE:
+    self = (HV*) SvRV(ST(0));
+    tmp = hv_fetch_mg(NOTXSCALL self, "-DC", 3, 0);
+    if(tmp == NULL) {
+        RETVAL = -1;
+    } else {
+        hdc = (HDC)(DWORD)SvIV(*tmp);
+        RETVAL = (long) SetBkMode(hdc, mode);
+    }
+OUTPUT:
+    RETVAL
+
+int
+GetBkMode(handle)
+    HWND handle
+PREINIT:
+    HV* self;
+    HDC hdc;
+    SV** tmp;
+CODE:
+    self = (HV*) SvRV(ST(0));
+    tmp = hv_fetch_mg(NOTXSCALL self, "-DC", 3, 0);
+    if(tmp == NULL) {
+        RETVAL = -1;
+    } else {
+        hdc = (HDC)(DWORD)SvIV(*tmp);
+        RETVAL = GetBkMode(hdc);
+    }
+OUTPUT:
+    RETVAL
+
+long
+MoveTo(handle, x, y)
+    HWND handle
+    int x
+    int y
+PREINIT:
+    HV* self;
+    HDC hdc;
+    SV** tmp;
+CODE:
+    self = (HV*) SvRV(ST(0));
+    tmp = hv_fetch_mg(NOTXSCALL self, "-DC", 3, 0);
+    if(tmp == NULL) {
+        RETVAL = -1;
+    } else {
+        hdc = (HDC)(DWORD)SvIV(*tmp);
+        RETVAL = MoveToEx(hdc, x, y, NULL);
+    }
+OUTPUT:
+    RETVAL
+
+long
+Circle(handle, x, y, width, height=-1)
+    HWND handle
+    int x
+    int y
+    int width
+    int height
+PREINIT:
+    HV* self;
+    HDC hdc;
+    SV** tmp;
+CODE:
+    self = (HV*) SvRV(ST(0));
+    tmp = hv_fetch_mg(NOTXSCALL self, "-DC", 3, 0);
+    if(tmp == NULL) {
+        RETVAL = -1;
+    } else {
+        hdc = (HDC)(DWORD)SvIV(*tmp);
+        if(height == -1) {
+            width *= 2;
+            height = width;
+        }
+        RETVAL = (long) Arc(hdc, x, y, width-x, height-y, 0, 0, 0, 0);
+    }
+OUTPUT:
+    RETVAL
+
+
+long
+LineTo(handle, x, y)
+    HWND handle
+    int x
+    int y
+PREINIT:
+    HV* self;
+    HDC hdc;
+    SV** tmp;
+CODE:
+    self = (HV*) SvRV(ST(0));
+    tmp = hv_fetch_mg(NOTXSCALL self, "-DC", 3, 0);
+    if(tmp == NULL) {
+        RETVAL = -1;
+    } else {
+        hdc = (HDC)(DWORD)SvIV(*tmp);
+        RETVAL = LineTo(hdc, x, y);
+    }
+OUTPUT:
+    RETVAL
+
+    #}
+    #
+    #XS(XS_Win32__GUI_DrawEdge) {
+    #
+    #    dXSARGS;
+    #    if(items != 7) {
+    #        CROAK("usage: DrawEdge($handle, $left, $top, $width, $height, $edge, $flags);\n");
+    #    }
+    #
+    #    HDC hdc = GetOrInitDC(ST(0));
+    #    RECT myRect;
+    #    myRect.left   = (LONG) SvIV(ST(1));
+    #    myRect.top    = (LONG) SvIV(ST(2));
+    #    myRect.right  = (LONG) SvIV(ST(3));
+    #    myRect.bottom = (LONG) SvIV(ST(4));
+    #
+    #    XSRETURN_IV((long) DrawEdge(hdc,
+    #                           &myRect,
+    #                           (UINT) SvIV(ST(5)),
+    #                           (UINT) SvIV(ST(6))));
+    #}
+
+void
+BeginPaint(...)
+PPCODE:
+    HV* self;
+    HWND hwnd;
+    HDC hdc;
+    int i;
+    PAINTSTRUCT ps;
+    char tmprgb[16];
+    self = (HV*) SvRV(ST(0));
+    hwnd = (HWND)(DWORD)SvIV(*hv_fetch(self, "-handle", 7, 0));
+    if(hwnd) {
+        if(hdc = BeginPaint(hwnd, &ps)) {
+            hv_store(self, "-DC", 3, newSViv((long) hdc), 0);
+            hv_store(self, "-ps.hdc", 7, newSViv((long) ps.hdc), 0);
+            hv_store(self, "-ps.fErase", 10, newSViv((long) ps.fErase), 0);
+            hv_store(self, "-ps.rcPaint.left", 16, newSViv((long) ps.rcPaint.left), 0);
+            hv_store(self, "-ps.rcPaint.top", 15, newSViv((long) ps.rcPaint.top), 0);
+            hv_store(self, "-ps.rcPaint.right", 17, newSViv((long) ps.rcPaint.right), 0);
+            hv_store(self, "-ps.rcPaint.bottom", 18, newSViv((long) ps.rcPaint.bottom), 0);
+            hv_store(self, "-ps.fRestore", 12, newSViv((long) ps.fRestore), 0);
+            hv_store(self, "-ps.fIncUpdate", 14, newSViv((long) ps.fIncUpdate), 0);
+            for(i=0;i<=31;i++) {
+                sprintf(tmprgb, "-ps.rgbReserved%02d", i);
+                hv_store(self, tmprgb, 17, newSViv((long) ps.rgbReserved[i]), 0);
+            }
+            XSRETURN_YES;
+        } else {
+            XSRETURN_NO;
+        }
+    } else {
+        XSRETURN_NO;
+    }
+
+void
+EndPaint(...)
+PPCODE:
+    HV* self;
+    HWND hwnd;
+    SV** tmp;
+    int i;
+    PAINTSTRUCT ps;
+    char tmprgb[16];
+    BOOL result;
+
+    self = (HV*) SvRV(ST(0));
+    if(self) {
+        tmp = hv_fetch(self, "-handle", 7, 0);
+        if(tmp == NULL) XSRETURN_NO;
+        hwnd = (HWND)(DWORD)SvIV(*tmp);
+        tmp = hv_fetch(self, "-ps.hdc", 7, 0);
+        if(tmp == NULL) XSRETURN_NO;
+        ps.hdc = (HDC)(DWORD)SvIV(*tmp);
+        tmp = hv_fetch(self, "-ps.fErase", 10, 0);
+        if(tmp == NULL) XSRETURN_NO;
+        ps.fErase = (BOOL) SvIV(*tmp);
+        tmp = hv_fetch(self, "-ps.rcPaint.left", 16, 0);
+        if(tmp == NULL) XSRETURN_NO;
+        ps.rcPaint.left = (LONG) SvIV(*tmp);
+        tmp = hv_fetch(self, "-ps.rcPaint.top", 15, 0);
+        if(tmp == NULL) XSRETURN_NO;
+        ps.rcPaint.top = (LONG) SvIV(*tmp);
+        tmp = hv_fetch(self, "-ps.rcPaint.right", 17, 0);
+        if(tmp == NULL) XSRETURN_NO;
+        ps.rcPaint.right = (LONG) SvIV(*tmp);
+        tmp = hv_fetch(self, "-ps.rcPaint.bottom", 18, 0);
+        if(tmp == NULL) XSRETURN_NO;
+        ps.rcPaint.bottom = (LONG) SvIV(*tmp);
+        tmp = hv_fetch(self, "-ps.fRestore", 12, 0);
+        if(tmp == NULL) XSRETURN_NO;
+        ps.fRestore = (BOOL) SvIV(*tmp);
+        tmp = hv_fetch(self, "-ps.fIncUpdate", 14, 0);
+        if(tmp == NULL) XSRETURN_NO;
+        ps.fIncUpdate = (BOOL) SvIV(*tmp);
+        for(i=0;i<=31;i++) {
+            sprintf(tmprgb, "-ps.rgbReserved%02d", i);
+            tmp = hv_fetch(self, tmprgb, 17, 0);
+            if(tmp == NULL) XSRETURN_NO;
+            ps.rgbReserved[i] = (BYTE) SvIV(*tmp);
+        }
+        result = EndPaint(hwnd, &ps);
+        hv_delete(self, "-DC", 3, 0);
+        hv_delete(self, "-ps.hdc", 7, 0);
+        hv_delete(self, "-ps.fErase", 10, 0);
+        hv_delete(self, "-ps.rcPaint.left", 16, 0);
+        hv_delete(self, "-ps.rcPaint.top", 15, 0);
+        hv_delete(self, "-ps.rcPaint.right", 17, 0);
+        hv_delete(self, "-ps.rcPaint.bottom", 18, 0);
+        hv_delete(self, "-ps.fRestore", 12, 0);
+        hv_delete(self, "-ps.fIncUpdate", 14, 0);
+        for(i=0;i<=31;i++) {
+            sprintf(tmprgb, "-ps.rgbReserved%02d", i);
+            hv_delete(self, tmprgb, 17, 0);
+        }
+        XSRETURN_IV((long) result);
+    } else {
+        XSRETURN_NO;
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:SaveBMP(handle)
+    # (preliminary) Saves the window content to a BMP file.
+void
+SaveBMP(handle)
+    HWND handle
+PREINIT:
+    HDC hdc;
+    HDC hdc2;
+    RECT cr;
+    HANDLE hf;
+    BITMAP bmp;
+    HBITMAP hbmp;
+    PBITMAPINFO pbmi;
+    PBITMAPINFOHEADER pbih;
+    BITMAPFILEHEADER hdr;
+    WORD cClrBits;
+    LONG width, height;
+    LPBYTE lpBits;
+    BYTE *hp;
+    DWORD cb;
+    DWORD dwTmp;
+    DWORD dwTotal;
+    DWORD MAXWRITE;
+PPCODE:
+    hdc = GetDC(handle);
+    GetClientRect(handle, &cr);
+    width = cr.right - cr.left;
+    height = cr.bottom - cr.top;
+    MAXWRITE = 2048;
+
+    hdc2 = CreateCompatibleDC(hdc);
+    hbmp = CreateCompatibleBitmap(hdc, width, height);
+    SelectObject(hdc2, hbmp);
+    BitBlt(hdc2, 0, 0, width, height, hdc, 0, 0, SRCCOPY);
+    if (!GetObject(hbmp, sizeof(BITMAP), (LPSTR)&bmp)) {
+        XSRETURN_NO;
+    }
+
+    cClrBits = (WORD)(bmp.bmPlanes * bmp.bmBitsPixel);
+    if (cClrBits == 1)       cClrBits = 1;
+    else if (cClrBits <= 4)  cClrBits = 4;
+    else if (cClrBits <= 8)  cClrBits = 8;
+    else if (cClrBits <= 16) cClrBits = 16;
+    else if (cClrBits <= 24) cClrBits = 24;
+    else                     cClrBits = 32;
+
+    if (cClrBits != 24)
+        pbmi = (PBITMAPINFO) LocalAlloc(LPTR, sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * (2^cClrBits));
+    else
+        pbmi = (PBITMAPINFO) LocalAlloc(LPTR, sizeof(BITMAPINFOHEADER));
+
+    pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+    pbmi->bmiHeader.biWidth = bmp.bmWidth;
+    pbmi->bmiHeader.biHeight = bmp.bmHeight;
+    pbmi->bmiHeader.biPlanes = bmp.bmPlanes;
+    pbmi->bmiHeader.biBitCount = bmp.bmBitsPixel;
+    if (cClrBits < 24) pbmi->bmiHeader.biClrUsed = 2^cClrBits;
+    pbmi->bmiHeader.biCompression = BI_RGB;
+    pbmi->bmiHeader.biSizeImage = (pbmi->bmiHeader.biWidth + 7) /8
+                                  * pbmi->bmiHeader.biHeight
+                                  * cClrBits;
+    pbmi->bmiHeader.biClrImportant = 0;
+
+    pbih = (PBITMAPINFOHEADER) pbmi;
+
+    lpBits = (LPBYTE) GlobalAlloc(GMEM_FIXED, pbih->biSizeImage);
+
+    if (!GetDIBits(hdc2, hbmp, 0, (WORD) pbih->biHeight, lpBits, pbmi, DIB_RGB_COLORS)) {
+        XSRETURN_NO;
+    }
+
+    hf = CreateFile("SaveBMP.bmp",
+                    GENERIC_READ | GENERIC_WRITE,
+                    (DWORD) 0,
+                    (LPSECURITY_ATTRIBUTES) NULL,
+                    CREATE_ALWAYS,
+                    FILE_ATTRIBUTE_NORMAL,
+                    (HANDLE) NULL);
+    if(hf == INVALID_HANDLE_VALUE) {
+        XSRETURN_NO;
+    }
+    hdr.bfType = 0x4d42;        // #### 0x42 = "B" 0x4d = "M"
+
+    // #### Compute the size of the entire file
+    hdr.bfSize = (DWORD) (sizeof(BITMAPFILEHEADER) +
+                 pbih->biSize + pbih->biClrUsed
+                 * sizeof(RGBQUAD) + pbih->biSizeImage);
+    hdr.bfReserved1 = 0;
+    hdr.bfReserved2 = 0;
+
+    // #### Compute the offset to the array of color indices
+    hdr.bfOffBits = (DWORD) sizeof(BITMAPFILEHEADER) +
+                    pbih->biSize + pbih->biClrUsed
+                    * sizeof (RGBQUAD);
+    // #### Copy the BITMAPFILEHEADER into the .BMP file
+    if (!WriteFile(hf, (LPVOID) &hdr, sizeof(BITMAPFILEHEADER),
+       (LPDWORD) &dwTmp, (LPOVERLAPPED) NULL)) {
+       XSRETURN_NO;
+    }
+    // #### Copy the BITMAPINFOHEADER and RGBQUAD array into the file
+    if (!WriteFile(hf, (LPVOID) pbih, sizeof(BITMAPINFOHEADER)
+                  + pbih->biClrUsed * sizeof (RGBQUAD),
+                  (LPDWORD) &dwTmp, (LPOVERLAPPED) NULL)) {
+        XSRETURN_NO;
+    }
+    // #### Copy the array of color indices into the .BMP file
+    dwTotal = cb = pbih->biSizeImage;     hp = lpBits;
+    while (cb > MAXWRITE)  {
+        if (!WriteFile(hf, (LPSTR) hp, MAXWRITE,
+                          (LPDWORD) &dwTmp, (LPOVERLAPPED) NULL)) {
+            XSRETURN_NO;
+        }
+        cb -= MAXWRITE;
+        hp += MAXWRITE;
+    }
+    if (!WriteFile(hf, (LPSTR) hp, (int) cb,
+        (LPDWORD) &dwTmp, (LPOVERLAPPED) NULL)) {
+        XSRETURN_NO;
+    }
+    if (!CloseHandle(hf)) {
+        XSRETURN_NO;
+    }
+
+    // #### Free memory
+    GlobalFree((HGLOBAL)lpBits);
+    DeleteDC(hdc2);
+    ReleaseDC(handle, hdc);
+    DeleteObject(hbmp);
+    XSRETURN_YES;
+
+
+    ###########################################################################
+    # Common Dialog Boxes
+    ###########################################################################
+
+
+    ###########################################################################
+    # (@)METHOD:MessageBox([HANDLE], TEXT, [CAPTION], [TYPE])
+int
+MessageBox(handle=NULL, text, caption=NULL, type=MB_ICONWARNING|MB_OK)
+    HWND handle
+    LPCTSTR text
+    LPCTSTR caption
+    UINT type
+CODE:
+    RETVAL = MessageBox(handle, text, caption, type);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:GetOpenFileName(%OPTIONS)
+    # Allowed %OPTIONS are:
+    #  -owner => WINDOW
+    #      Identifies the window that owns the dialog box.
+    #  -title => STRING
+    #      The title for the dialog
+    #  -directory => STRING
+    #      Specifies the initial directory
+    #  -file => STRING
+    #      Specifies a name that will appear on the dialog's edit field
+    #  -filter => ARRAY REFERENCE
+    #      Specifies an array containing pairs of filter strings.
+    #      The first string in each pair is a display string that describes the filter
+    #      (for example, "Text Files"), and the second string specifies the filter pattern
+    #      (for example, "*.TXT"). To specify multiple filter patterns for a single display
+    #      string, use a semicolon to separate the patterns (for example, "*.TXT;*.DOC;*.BAK").
+    #      A pattern string can be a combination of valid filename characters and the asterisk (*)
+    #      wildcard character. Do not include spaces in the pattern string.
+	#  -defaultextention => STRING
+	#      Contains the default extension. GetOpenFileName append this extension to the filename if the user
+	#      fails to type an extension. This string can be any length, but only the first three characters are
+	#      appended. The string should not contain a period (.).
+    #  -defaultfilter => NUMBER
+    #      Specifies the index of the currently selected filter in the File Types control.
+    #      The first pair of strings has an index value of 0, the second pair 1, and so on.
+	# Flags :
+	#  -createprompt => 0/1 (default 0)
+	#      If the user specifies a file that does not exist, this flag causes the dialog box to prompt
+	#      the user for permission to create the file. If the user chooses to create the file, the dialog box
+	#      closes and the function returns the specified name; otherwise, the dialog box remains open.
+	#      If you use this flag with the -multisel flag, the dialog box allows the user to specify
+	#      only one nonexistent file.
+    #  -multisel => 0/1 (default 0)
+    #      Allow multiple file selection
+    #      If the user selects more than one file then return filename with full path.
+    #      If the user selects more than one file then return an array with the path
+    #      to the current directory followed by the filenames of the selected files.
+	#  -explorer => 0/1 (default 1)
+	#      Explorer look.
+	#  -extensiondifferent => 0/1 (default 0)
+	#      Specifies that the user can typed a filename extension that differs from the extension specified by -defaultextention.
+	#  -filemustexist => 0/1 (default 0)
+	#      Specifies that the user can type only names of existing files in the File Name entry field.
+	#      If this flag is specified and the user enters an invalid name, the dialog box procedure displays
+	#      a warning in a message box.
+	#  -hidereadonly => 0/1 (default 1)
+	#      Hides the Read Only check box.
+	#      If -hidereadonly is set to 0, the read only statut is return only in array context as last value.
+	#  -nochangedir => 0/1 (default 0)
+	#      Restores the current directory to its original value if the user changed the directory while searching for files.
+	#  -nodeferencelinks => 0/1 (default 0)
+	#      Directs the dialog box to return the path and filename of the selected shortcut (.LNK) file.
+	#      If this value is not given, the dialog box returns the path and filename of the file referenced by the shortcut.
+	#  -nonetwork  => 0/1 (default 0)
+	#      Hides and disables the Network button
+	#  -noreadonlyreturn => 0/1 (default 0)
+	#      Specifies that the returned file does not have the Read Only check box checked and is not in a write-protected directory.
+	#  -pathmustexist => 0/1 (default 0)
+	#      Specifies that the user can type only valid paths and filenames.
+	#      If this flag is used and the user types an invalid path and filename in the File Name entry field, the dialog box function displays a warning in a message box.
+	#  -readonly => 0/1 (default 0)
+	# 	   Causes the Read Only check box to be checked initially when the dialog box is created.
+	#
+void
+GetOpenFileName(...)
+PPCODE:
+    OPENFILENAME ofn;
+    BOOL retval;
+    int i, next_i;
+    char filename[MAX_PATH];
+    char *option;
+    char *filter;
+
+    ZeroMemory(&ofn, sizeof(OPENFILENAME));
+    ofn.lStructSize = sizeof(OPENFILENAME);
+    ofn.hwndOwner = NULL;
+    ofn.lpstrFilter = NULL;
+    ofn.lpstrCustomFilter = NULL;
+    ofn.nFilterIndex = 0;
+    ofn.lpstrFileTitle = NULL;
+    ofn.lpstrInitialDir = NULL;
+    ofn.lpstrTitle = NULL;
+    ofn.lpstrDefExt = NULL;
+    ofn.lpTemplateName = NULL;
+    ofn.Flags = OFN_HIDEREADONLY | OFN_EXPLORER;
+    filename[0] = 0;
+    ofn.lpstrFile = filename;
+    ofn.nMaxFile = MAX_PATH;
+
+    next_i = -1;
+    for(i = 0; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-owner") == 0) {
+                next_i = i + 1;
+                ofn.hwndOwner = (HWND) handle_From(NOTXSCALL ST(next_i));
+            } else if(strcmp(option, "-title") == 0) {
+                next_i = i + 1;
+                ofn.lpstrTitle = SvPV_nolen(ST(next_i));
+            } else if(strcmp(option, "-directory") == 0) {
+                next_i = i + 1;
+                ofn.lpstrInitialDir = SvPV_nolen(ST(next_i));
+            } else if(strcmp(option, "-defaultextention") == 0 ) {
+                next_i = i + 1;
+                ofn.lpstrDefExt = SvPV_nolen(ST(next_i));
+            } else if(strcmp(option, "-file") == 0) {
+                next_i = i + 1;
+                strcpy(filename, SvPV_nolen(ST(next_i)));
+            } else if(strcmp(option, "-filter") == 0) {
+                next_i = i + 1;
+                if(SvROK(ST(next_i)) && SvTYPE(SvRV(ST(next_i))) == SVt_PVAV) {
+                    AV* filters;
+                    SV** t;
+                    int i, filterlen = 0;
+                    char *fpointer;
+                    filters = (AV*)SvRV(ST(next_i));
+                    for(i=0; i<=av_len(filters); i++) {
+                        t = av_fetch(filters, i, 0);
+                        if(t != NULL) {
+                            filterlen += SvCUR(*t) + 1;
+                        }
+                    }
+                    filterlen += 2;
+                    filter = (char *) safemalloc(filterlen);
+                    fpointer = filter;
+                    for(i=0; i<=av_len(filters); i++) {
+                        t = av_fetch(filters, i, 0);
+                        if(t != NULL) {
+                            strcpy(fpointer, SvPV_nolen(*t));
+                            fpointer += SvCUR(*t);
+                            *fpointer++ = 0;
+                        }
+                    }
+                    *fpointer = 0;
+                    ofn.lpstrFilter = (LPCTSTR) filter;
+                } else {
+                    if(PL_dowarn) warn("Win32::GUI: argument to -filter is not an array reference!");
+                }
+            } else if(strcmp(option, "-defaultfilter") == 0 ) {
+                next_i = i + 1;
+                ofn.nFilterIndex = SvIV(ST(next_i)) + 1;
+	        } else if(strcmp(option, "-flags") == 0) {
+                next_i = i + 1;
+                ofn.Flags = SvIV(ST(next_i));
+            } else BitmaskOption( "-multisel", ofn.Flags, OFN_ALLOWMULTISELECT )
+			} else BitmaskOption( "-createprompt", ofn.Flags, OFN_CREATEPROMPT )
+            } else BitmaskOption( "-explorer", ofn.Flags, OFN_EXPLORER )
+			} else BitmaskOption( "-extensiondifferent", ofn.Flags, OFN_EXTENSIONDIFFERENT )
+			} else BitmaskOption( "-filemustexist", ofn.Flags, OFN_FILEMUSTEXIST )
+            } else BitmaskOption( "-hidereadonly", ofn.Flags, OFN_HIDEREADONLY )
+			} else BitmaskOption( "-nochangedir", ofn.Flags, OFN_NOCHANGEDIR )
+			} else BitmaskOption( "-nodeferencelinks", ofn.Flags, OFN_NODEREFERENCELINKS )
+            } else BitmaskOption( "-nonetwork", ofn.Flags, OFN_NONETWORKBUTTON )
+			} else BitmaskOption( "-noreadonlyreturn", ofn.Flags, OFN_NOREADONLYRETURN )
+			} else BitmaskOption( "-pathmustexist", ofn.Flags, OFN_PATHMUSTEXIST )
+			} else BitmaskOption( "-readonly", ofn.Flags, OFN_READONLY )
+            }
+        } else {
+            next_i = -1;
+        }
+    }
+
+    retval = GetOpenFileName(&ofn);
+
+	if(ofn.lpstrFilter != NULL) safefree((void *)filter);
+
+    if(retval) {
+      if (ofn.Flags & OFN_ALLOWMULTISELECT) {
+         i = 0;
+         char * ptr = (char *) ofn.lpstrFile;
+
+         // Count files
+         while (*ptr) {
+           i ++;
+           ptr += strlen(ptr) + 1;
+         }
+
+		 if ( !(ofn.Flags & OFN_HIDEREADONLY) )
+			i++;
+
+         EXTEND(SP, i);
+
+         i = 0;
+         ptr = (char *) ofn.lpstrFile;
+         while (*ptr) {
+            XST_mPV(i, ptr);
+            i ++;
+            ptr += strlen(ptr) + 1;
+         }
+
+		 if ( !(ofn.Flags & OFN_HIDEREADONLY) ) {
+			XST_mIV( i, (ofn.Flags & OFN_READONLY) );
+			i ++;
+		 }
+
+         XSRETURN(i);
+      }
+	  else {
+	    if ((ofn.Flags & OFN_HIDEREADONLY) || GIMME_V == G_SCALAR)
+		{
+        EXTEND(SP, 1);
+        XST_mPV( 0, ofn.lpstrFile);
+        XSRETURN(1);
+		}
+		else {
+			EXTEND(SP, 2);
+			XST_mPV( 0, ofn.lpstrFile);
+			XST_mIV( 1, (ofn.Flags & OFN_READONLY) );
+			XSRETURN(2);
+		}
+	  }
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:GetSaveFileName(%OPTIONS)
+    # Allowed %OPTIONS are:
+    #  -owner => WINDOW
+    #      Identifies the window that owns the dialog box.
+    #  -title => STRING
+    #      The title for the dialog
+    #  -directory => STRING
+    #      Specifies the initial directory
+    #  -file => STRING
+    #      Specifies a name that will appear on the dialog's edit field
+    #  -filter => ARRAY REFERENCE
+    #      Specifies an array containing pairs of filter strings.
+    #      The first string in each pair is a display string that describes the filter
+    #      (for example, "Text Files"), and the second string specifies the filter pattern
+    #      (for example, "*.TXT"). To specify multiple filter patterns for a single display
+    #      string, use a semicolon to separate the patterns (for example, "*.TXT;*.DOC;*.BAK").
+    #      A pattern string can be a combination of valid filename characters and the asterisk (*)
+    #      wildcard character. Do not include spaces in the pattern string.
+	#  -defaultextention => STRING
+	#      Contains the default extension. GetSaveFileName append this extension to the filename if the user
+	#      fails to type an extension. This string can be any length, but only the first three characters are
+	#      appended. The string should not contain a period (.).
+    #  -defaultfilter => NUMBER
+    #      Specifies the index of the currently selected filter in the File Types control.
+    #      The first pair of strings has an index value of 0, the second pair 1, and so on.
+	# Flags :
+	#  -createprompt => 0/1 (default 0)
+	#      If the user specifies a file that does not exist, this flag causes the dialog box to prompt
+	#      the user for permission to create the file. If the user chooses to create the file, the dialog box
+	#      closes and the function returns the specified name; otherwise, the dialog box remains open.
+	#      If you use this flag with the -multisel flag, the dialog box allows the user to specify
+	#      only one nonexistent file.
+	#  -explorer => 0/1 (default 1)
+	#      Explorer look.
+	#  -extensiondifferent => 0/1 (default 0)
+	#      Specifies that the user can typed a filename extension that differs from the extension specified by -defaultextention.
+	#  -filemustexist => 0/1 (default 0)
+	#      Specifies that the user can type only names of existing files in the File Name entry field.
+	#      If this flag is specified and the user enters an invalid name, the dialog box procedure displays
+	#      a warning in a message box.
+	#  -nochangedir => 0/1 (default 0)
+	#      Restores the current directory to its original value if the user changed the directory while searching for files.
+	#  -nodeferencelinks => 0/1 (default 0)
+	#      Directs the dialog box to return the path and filename of the selected shortcut (.LNK) file.
+	#      If this value is not given, the dialog box returns the path and filename of the file referenced by the shortcut.
+	#  -nonetwork  => 0/1 (default 0)
+	#      Hides and disables the Network button
+	#  -noreadonlyreturn => 0/1 (default 0)
+	#      Specifies that the returned file is not in a write-protected directory.
+	#  -pathmustexist => 0/1 (default 1)
+	#      Specifies that the user can type only valid paths and filenames.
+	#      If this flag is used and the user types an invalid path and filename in the File Name entry field, the dialog box function displays a warning in a message box.
+	#  -overdriveprompt => 0/1 (default 1)
+	#      Generate a message box if the selected file already exists. The user must confirm whether to overwrite the file.
+void
+GetSaveFileName(...)
+PPCODE:
+    OPENFILENAME ofn;
+    BOOL retval;
+    int i, next_i;
+    char filename[MAX_PATH];
+    char *option;
+    char *filter;
+
+    ZeroMemory(&ofn, sizeof(OPENFILENAME));
+    ofn.lStructSize = sizeof(OPENFILENAME);
+    ofn.hwndOwner = NULL;
+    ofn.lpstrFilter = NULL;
+    ofn.lpstrCustomFilter = NULL;
+    ofn.nFilterIndex = 0;
+    ofn.lpstrFileTitle = NULL;
+    ofn.lpstrInitialDir = NULL;
+    ofn.lpstrTitle = NULL;
+    ofn.lpstrDefExt = NULL;
+    ofn.lpTemplateName = NULL;
+    ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_EXPLORER;
+    filename[0] = 0;
+    ofn.lpstrFile = filename;
+    ofn.nMaxFile = MAX_PATH;
+
+    next_i = -1;
+    for(i = 0; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-owner") == 0) {
+                next_i = i + 1;
+                ofn.hwndOwner = (HWND) handle_From(NOTXSCALL ST(next_i));
+            } else if(strcmp(option, "-title") == 0) {
+                next_i = i + 1;
+                ofn.lpstrTitle = SvPV_nolen(ST(next_i));
+            } else if(strcmp(option, "-directory") == 0) {
+                next_i = i + 1;
+                ofn.lpstrInitialDir = SvPV_nolen(ST(next_i));
+            } else if(strcmp(option, "-defaultextention") == 0 ) {
+                next_i = i + 1;
+                ofn.lpstrDefExt = SvPV_nolen(ST(next_i));
+            } else if(strcmp(option, "-file") == 0) {
+                next_i = i + 1;
+                strcpy(filename, SvPV_nolen(ST(next_i)));
+            } else if(strcmp(option, "-filter") == 0) {
+                next_i = i + 1;
+                if(SvROK(ST(next_i)) && SvTYPE(SvRV(ST(next_i))) == SVt_PVAV) {
+                    AV* filters;
+                    SV** t;
+                    int i, filterlen = 0;
+                    char *fpointer;
+                    filters = (AV*)SvRV(ST(next_i));
+                    for(i=0; i<=av_len(filters); i++) {
+                        t = av_fetch(filters, i, 0);
+                        if(t != NULL) {
+                            filterlen += SvCUR(*t) + 1;
+                        }
+                    }
+                    filterlen += 2;
+                    filter = (char *) safemalloc(filterlen);
+                    fpointer = filter;
+                    for(i=0; i<=av_len(filters); i++) {
+                        t = av_fetch(filters, i, 0);
+                        if(t != NULL) {
+                            strcpy(fpointer, SvPV_nolen(*t));
+                            fpointer += SvCUR(*t);
+                            *fpointer++ = 0;
+                        }
+                    }
+                    *fpointer = 0;
+                    ofn.lpstrFilter = (LPCTSTR) filter;
+                } else {
+                    if(PL_dowarn) warn("Win32::GUI: argument to -filter is not an array reference!");
+                }
+            } else if(strcmp(option, "-defaultfilter") == 0 ) {
+                next_i = i + 1;
+                ofn.nFilterIndex = SvIV(ST(next_i)) + 1;
+	        } else if(strcmp(option, "-flags") == 0) {
+                next_i = i + 1;
+                ofn.Flags = SvIV(ST(next_i));
+			} else BitmaskOption( "-createprompt", ofn.Flags, OFN_CREATEPROMPT )
+            } else BitmaskOption( "-explorer", ofn.Flags, OFN_EXPLORER )
+			} else BitmaskOption( "-extensiondifferent", ofn.Flags, OFN_EXTENSIONDIFFERENT )
+			} else BitmaskOption( "-filemustexist", ofn.Flags, OFN_FILEMUSTEXIST )
+			} else BitmaskOption( "-nochangedir", ofn.Flags, OFN_NOCHANGEDIR )
+			} else BitmaskOption( "-nodeferencelinks", ofn.Flags, OFN_NODEREFERENCELINKS )
+            } else BitmaskOption( "-nonetwork", ofn.Flags, OFN_NONETWORKBUTTON )
+			} else BitmaskOption( "-noreadonlyreturn", ofn.Flags, OFN_NOREADONLYRETURN )
+			} else BitmaskOption( "-pathmustexist", ofn.Flags, OFN_PATHMUSTEXIST )
+			} else BitmaskOption( "-overdriveprompt", ofn.Flags, OFN_OVERWRITEPROMPT )
+            }
+        } else {
+            next_i = -1;
+        }
+    }
+    retval = GetSaveFileName(&ofn);
+    if(retval) {
+        EXTEND(SP, 1);
+        XST_mPV( 0, ofn.lpstrFile);
+        if(ofn.lpstrFilter != NULL) safefree((void *)filter);
+        XSRETURN(1);
+    } else {
+        if(ofn.lpstrFilter != NULL) safefree((void *)filter);
+        XSRETURN_UNDEF;
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:BrowseForFolder(%OPTIONS)
+void
+BrowseForFolder(...)
+PPCODE:
+    BROWSEINFO bi;
+    LPITEMIDLIST retval;
+    LPITEMIDLIST pidl;
+    LPSHELLFOLDER pDesktopFolder;
+    OLECHAR olePath[MAX_PATH];
+    ULONG chEaten;
+    HRESULT hr;
+    int i, next_i;
+    char folder[MAX_PATH];
+    char *option;
+    ZeroMemory(&bi, sizeof(BROWSEINFO));
+    bi.pszDisplayName = folder;
+    next_i = -1;
+    for(i = 0; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-owner") == 0) {
+                next_i = i + 1;
+                bi.hwndOwner = (HWND) handle_From(NOTXSCALL ST(next_i));
+            } else if(strcmp(option, "-title") == 0) {
+                next_i = i + 1;
+                bi.lpszTitle = SvPV_nolen(ST(next_i));
+            } else BitmaskOption("-computeronly", bi.ulFlags, BIF_BROWSEFORCOMPUTER)
+            } else BitmaskOption("-domainonly", bi.ulFlags, BIF_DONTGOBELOWDOMAIN)
+            } else BitmaskOption("-driveonly", bi.ulFlags, BIF_RETURNFSANCESTORS)
+            } else BitmaskOption("-editbox", bi.ulFlags, BIF_EDITBOX)
+            } else BitmaskOption("-folderonly", bi.ulFlags, BIF_RETURNONLYFSDIRS)
+            } else BitmaskOption("-includefiles", bi.ulFlags, BIF_BROWSEINCLUDEFILES)
+            } else BitmaskOption("-printeronly", bi.ulFlags, BIF_BROWSEFORPRINTER)
+            } else if(strcmp(option, "-directory") == 0) {
+                next_i = i + 1;
+                bi.lParam = (LPARAM) SvPV_nolen(ST(next_i));
+                bi.lpfn = BrowseForFolderProc;
+            } else if(strcmp(option, "-root") == 0) {
+                next_i = i + 1;
+                if(SvIOK(ST(next_i))) {
+					bi.pidlRoot = (LPCITEMIDLIST)(DWORD)SvIV(ST(next_i));
+                } else {
+                    SHGetDesktopFolder(&pDesktopFolder);
+                    MultiByteToWideChar(
+                        CP_ACP,
+                        MB_PRECOMPOSED,
+                        SvPV_nolen(ST(next_i)), -1,
+                        olePath, MAX_PATH
+                    );
+                    hr = pDesktopFolder->ParseDisplayName(
+                    // hr = IShellFolder::ParseDisplayName(
+                        NULL,
+                        NULL,
+                        olePath,
+                        &chEaten,
+                        &pidl,
+                        NULL
+                    );
+                    if(FAILED(hr)) {
+                        if(PL_dowarn) warn("Win32::GUI::BrowseForFolder: can't get ITEMIDLIST for -root!\n");
+                        pDesktopFolder->Release();
+                        XSRETURN_UNDEF;
+                    } else {
+                        bi.pidlRoot = pidl;
+                        pDesktopFolder->Release();
+                    }
+                }
+            }
+        } else {
+            next_i = -1;
+        }
+    }
+    retval = SHBrowseForFolder(&bi);
+    if(retval != NULL) {
+        if(SHGetPathFromIDList(retval, folder)) {
+            EXTEND(SP, 1);
+            XST_mPV( 0, folder);
+            XSRETURN(1);
+        } else {
+            XSRETURN_UNDEF;
+        }
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:ChooseColor(%OPTIONS)
+    # Allowed %OPTIONS are:
+    #  -owner
+    #  -color
+void
+ChooseColor(...)
+PPCODE:
+    CHOOSECOLOR cc;
+    COLORREF lpCustColors[16];
+    BOOL retval;
+    int i, next_i;
+    char * option;
+
+    ZeroMemory(&cc, sizeof(CHOOSECOLOR));
+    cc.lStructSize = sizeof(CHOOSECOLOR);
+    cc.hwndOwner = NULL;
+    cc.lpCustColors = lpCustColors;
+    cc.lpTemplateName = NULL;
+    cc.Flags = 0;
+    cc.rgbResult = 0;
+
+    next_i = -1;
+    for(i = 0; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-owner") == 0) {
+                next_i = i + 1;
+                cc.hwndOwner = (HWND) handle_From(NOTXSCALL ST(next_i));
+            } else if(strcmp(option, "-color") == 0) {
+                next_i = i + 1;
+                cc.rgbResult = (COLORREF) SvCOLORREF(NOTXSCALL ST(next_i));
+                cc.Flags = cc.Flags | CC_RGBINIT;
+            }
+        } else {
+            next_i = -1;
+        }
+    }
+
+    retval = ChooseColor(&cc);
+
+    if(retval) {
+        EXTEND(SP, 1);
+        XST_mIV(0, cc.rgbResult);
+        XSRETURN(1);
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:ChooseFont(%OPTIONS)
+    # Allowed %OPTIONS are:
+    #  -owner
+    #  -size
+    #  -height
+    #  -width
+    #  -escapement
+    #  -orientation
+    #  -weight
+    #  -bold
+    #  -italic
+    #  -underline
+    #  -strikeout
+    #  -charset
+    #  -outputprecision
+    #  -clipprecision
+    #  -quality
+    #  -family
+    #  -name
+    #  -face (== -name)
+    #  -color
+    #  -ttonly
+    #  -fixedonly
+    #  -effects
+    #  -script
+    #  -minsize
+    #  -maxsize
+void
+ChooseFont(...)
+PPCODE:
+    CHOOSEFONT cf;
+    static LOGFONT lf;
+    BOOL retval;
+    int i, next_i;
+    char *option;
+
+    ZeroMemory(&cf, sizeof(CHOOSEFONT));
+    cf.lStructSize = sizeof(CHOOSEFONT);
+    cf.hwndOwner = NULL;
+    cf.lpLogFont = &lf;
+    cf.lpTemplateName = NULL;
+    cf.Flags = CF_SCREENFONTS;
+
+    next_i = -1;
+    for(i = 0; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-owner") == 0) {
+                next_i = i + 1;
+                cf.hwndOwner = (HWND) handle_From(NOTXSCALL ST(next_i));
+            }
+            if(strcmp(option, "-size") == 0) {
+                next_i = i + 1;
+                cf.iPointSize = SvIV(ST(next_i));
+            }
+            if(strcmp(option, "-height") == 0) {
+                HDC hDisplay;
+                hDisplay = CreateDC("DISPLAY", NULL, NULL, NULL);
+                next_i = i + 1;
+                lf.lfHeight = -MulDiv(SvIV(ST(next_i)), GetDeviceCaps(hDisplay, LOGPIXELSY), 72);
+                DeleteDC(hDisplay);
+                SwitchBit(cf.Flags, CF_INITTOLOGFONTSTRUCT, 1);
+
+            }
+            if(strcmp(option, "-width") == 0) {
+                next_i = i + 1;
+                lf.lfWidth = SvIV(ST(next_i));
+                SwitchBit(cf.Flags, CF_INITTOLOGFONTSTRUCT, 1);
+            }
+            if(strcmp(option, "-escapement") == 0) {
+                next_i = i + 1;
+                lf.lfEscapement = SvIV(ST(next_i));
+                SwitchBit(cf.Flags, CF_INITTOLOGFONTSTRUCT, 1);
+            }
+            if(strcmp(option, "-orientation") == 0) {
+                next_i = i + 1;
+                lf.lfOrientation = SvIV(ST(next_i));
+                SwitchBit(cf.Flags, CF_INITTOLOGFONTSTRUCT, 1);
+            }
+            if(strcmp(option, "-weight") == 0) {
+                next_i = i + 1;
+                lf.lfWeight = (int) SvIV(ST(next_i));
+                SwitchBit(cf.Flags, CF_INITTOLOGFONTSTRUCT, 1);
+            }
+            if(strcmp(option, "-bold") == 0) {
+                next_i = i + 1;
+                if(SvIV(ST(next_i)) != 0) lf.lfWeight = 700;
+                SwitchBit(cf.Flags, CF_INITTOLOGFONTSTRUCT, 1);
+            }
+            if(strcmp(option, "-italic") == 0) {
+                next_i = i + 1;
+                lf.lfItalic = (BYTE) SvIV(ST(next_i));
+                SwitchBit(cf.Flags, CF_INITTOLOGFONTSTRUCT, 1);
+            }
+            if(strcmp(option, "-underline") == 0) {
+                next_i = i + 1;
+                lf.lfUnderline = (BYTE) SvIV(ST(next_i));
+                SwitchBit(cf.Flags, CF_INITTOLOGFONTSTRUCT, 1);
+            }
+            if(strcmp(option, "-strikeout") == 0) {
+                next_i = i + 1;
+                lf.lfStrikeOut = (BYTE) SvIV(ST(next_i));
+                SwitchBit(cf.Flags, CF_INITTOLOGFONTSTRUCT, 1);
+            }
+            if(strcmp(option, "-charset") == 0) {
+                next_i = i + 1;
+                lf.lfCharSet = (BYTE) SvIV(ST(next_i));
+                SwitchBit(cf.Flags, CF_INITTOLOGFONTSTRUCT, 1);
+            }
+            if(strcmp(option, "-outputprecision") == 0) {
+                next_i = i + 1;
+                lf.lfOutPrecision = (BYTE) SvIV(ST(next_i));
+                SwitchBit(cf.Flags, CF_INITTOLOGFONTSTRUCT, 1);
+            }
+            if(strcmp(option, "-clipprecision") == 0) {
+                next_i = i + 1;
+                lf.lfClipPrecision = (BYTE) SvIV(ST(next_i));
+                SwitchBit(cf.Flags, CF_INITTOLOGFONTSTRUCT, 1);
+            }
+            if(strcmp(option, "-quality") == 0) {
+                next_i = i + 1;
+                lf.lfQuality = (BYTE) SvIV(ST(next_i));
+                SwitchBit(cf.Flags, CF_INITTOLOGFONTSTRUCT, 1);
+            }
+            if(strcmp(option, "-family") == 0) {
+                next_i = i + 1;
+                lf.lfPitchAndFamily = (BYTE) SvIV(ST(next_i));
+                SwitchBit(cf.Flags, CF_INITTOLOGFONTSTRUCT, 1);
+            }
+            if(strcmp(option, "-name") == 0
+            || strcmp(option, "-face") == 0) {
+                next_i = i + 1;
+                strncpy(lf.lfFaceName, SvPV_nolen(ST(next_i)), 32);
+                SwitchBit(cf.Flags, CF_INITTOLOGFONTSTRUCT, 1);
+            }
+            if(strcmp(option, "-color") == 0) {
+                next_i = i + 1;
+                cf.rgbColors = (DWORD) SvCOLORREF(NOTXSCALL ST(next_i));
+                SwitchBit(cf.Flags, CF_EFFECTS, 1);
+            }
+            if(strcmp(option, "-ttonly") == 0) {
+                next_i = i + 1;
+                SwitchBit(cf.Flags, CF_TTONLY, SvIV(ST(next_i)));
+            }
+            if(strcmp(option, "-fixedonly") == 0) {
+                next_i = i + 1;
+                SwitchBit(cf.Flags, CF_FIXEDPITCHONLY, SvIV(ST(next_i)));
+            }
+            if(strcmp(option, "-effects") == 0) {
+                next_i = i + 1;
+                SwitchBit(cf.Flags, CF_EFFECTS, SvIV(ST(next_i)));
+            }
+            if(strcmp(option, "-script") == 0) {
+                next_i = i + 1;
+                if(SvIV(ST(next_i)) == 0) {
+                    SwitchBit(cf.Flags, CF_NOSCRIPTSEL, 1);
+                } else {
+                    SwitchBit(cf.Flags, CF_NOSCRIPTSEL, 0);
+                }
+            }
+            if(strcmp(option, "-minsize") == 0) {
+                next_i = i + 1;
+                cf.nSizeMin = SvIV(ST(next_i));
+                SwitchBit(cf.Flags, CF_LIMITSIZE, 1);
+            }
+            if(strcmp(option, "-maxsize") == 0) {
+                next_i = i + 1;
+                cf.nSizeMax = SvIV(ST(next_i));
+                SwitchBit(cf.Flags, CF_LIMITSIZE, 1);
+            }
+
+
+        } else {
+            next_i = -1;
+        }
+    }
+    retval = ChooseFont(&cf);
+    if(retval) {
+        HDC hDisplay;
+        hDisplay = CreateDC("DISPLAY", NULL, NULL, NULL);
+        lf.lfHeight = -MulDiv(lf.lfHeight, 72, GetDeviceCaps(hDisplay, LOGPIXELSY));
+        DeleteDC(hDisplay);
+
+        EXTEND(SP, 18);
+        XST_mPV( 0, "-name");
+        XST_mPV( 1, lf.lfFaceName);
+        XST_mPV( 2, "-height");
+        XST_mIV( 3, lf.lfHeight);
+        XST_mPV( 4, "-width");
+        XST_mIV( 5, lf.lfWidth);
+        XST_mPV( 6, "-weight");
+        XST_mIV( 7, lf.lfWeight);
+        XST_mPV( 8, "-size");
+        XST_mIV( 9, cf.iPointSize);
+        XST_mPV(10, "-italic");
+        XST_mIV(11, lf.lfItalic);
+        XST_mPV(12, "-underline");
+        XST_mIV(13, lf.lfUnderline);
+        XST_mPV(14, "-strikeout");
+        XST_mIV(15, lf.lfStrikeOut);
+        XST_mPV(16, "-color");
+        XST_mIV(17, cf.rgbColors);
+        // XST_mPV(18, "-style");
+        // XST_mPV(19, cf.lpszStyle);
+        // XSRETURN(20);
+        XSRETURN(18);
+    } else
+        XSRETURN_UNDEF;
+
+
+    ###########################################################################
+    # (@)METHOD:CommDlgExtendedError()
+    # Returns the common dialog library error code.
+DWORD
+CommDlgExtendedError(...)
+CODE:
+    RETVAL = CommDlgExtendedError();
+OUTPUT:
+    RETVAL
+
+
+HGDIOBJ
+SelectObject(handle,hgdiobj)
+    HWND handle
+    HGDIOBJ hgdiobj
+CODE:
+    RETVAL = SelectObject((HDC)handle, hgdiobj);
+OUTPUT:
+    RETVAL
+
+BOOL
+DeleteObject(hgdiobj)
+    HGDIOBJ hgdiobj
+CODE:
+    RETVAL = DeleteObject(hgdiobj);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetStockObject(OBJECT)
+HGDIOBJ
+GetStockObject(object)
+    int object
+CODE:
+    RETVAL = GetStockObject(object);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetSystemMetrics(INDEX)
+int
+GetSystemMetrics(index)
+    int index
+CODE:
+    RETVAL = GetSystemMetrics(index);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)INTERNAL:CreateMenu()
+HMENU
+CreateMenu(...)
+CODE:
+    RETVAL = CreateMenu();
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)INTERNAL:CreatePopupMenu()
+HMENU
+CreatePopupMenu(...)
+CODE:
+    RETVAL = CreatePopupMenu();
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:SetMenu(MENU)
+    # Associates the specified MENU to a window.
+BOOL
+SetMenu(handle,menu)
+    HWND handle
+    HMENU menu
+CODE:
+    RETVAL = SetMenu(handle, menu);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetMenu()
+HMENU
+GetMenu(handle)
+    HWND handle
+CODE:
+    RETVAL = GetMenu(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:DrawMenuBar()
+BOOL
+DrawMenuBar(handle)
+    HWND handle
+CODE:
+    RETVAL = DrawMenuBar(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)INTERNAL:DestroyMenu(HANDLE)
+BOOL
+DestroyMenu(hmenu)
+    HMENU hmenu
+CODE:
+    RETVAL = DestroyMenu(hmenu);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetFontName()
+LPTSTR
+GetFontName(handle)
+    HWND handle
+PREINIT:
+    HDC hdc;
+    char facename[256];
+CODE:
+    hdc = GetDC(handle);
+    if(GetTextFace(hdc, 256, facename)) {
+        RETVAL = (LPTSTR) facename;
+    } else {
+        RETVAL = "";
+    }
+    ReleaseDC(handle, hdc);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)INTERNAL:CreateAcceleratorTable(ID, KEY, FLAG, ...)
+HACCEL
+CreateAcceleratorTable(...)
+PREINIT:
+    LPACCEL acc;
+    int a, c, i;
+CODE:
+    a = items/3;
+    acc = (LPACCEL) safemalloc(a * sizeof(ACCEL));
+    c = 0;
+    for(i=0; i<items; i+=3) {
+        acc[c].cmd   = (WORD) SvIV(ST(i));
+        acc[c].key   = (WORD) SvIV(ST(i+1));
+        acc[c].fVirt = (BYTE) SvIV(ST(i+2));
+        c++;
+    }
+    RETVAL = CreateAcceleratorTable(acc, a);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)INTERNAL:DestroyAcceleratorTable(HANDLE)
+BOOL
+DestroyAcceleratorTable(handle)
+    HACCEL handle;
+CODE:
+    RETVAL = DestroyAcceleratorTable(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:EnumMyWindows()
+void
+EnumMyWindows()
+PREINIT:
+    AV* ary;
+    int i;
+PPCODE:
+    ary = newAV();
+    EnumWindows( (WNDENUMPROC) EnumMyWindowsProc, (LPARAM) ary);
+    for(i=0; i<av_len(ary); i++) {
+        printf("XS(EnumMyWindows): ary[%d] = %ld\n", i, SvIV(*(av_fetch(ary, i, 0))));
+        XST_mIV(i, SvIV(*(av_fetch(ary, i, 0))));
+    }
+    /* SvREFCNT_dec((SV*)ary); */
+    XSRETURN(i);
+
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::Menu
+    ###########################################################################
+
+MODULE = Win32::GUI     PACKAGE = Win32::GUI::Menu
+
+    ###########################################################################
+    # (@)INTERNAL:DESTROY(HANDLE)
+BOOL
+DESTROY(handle)
+    HMENU handle
+CODE:
+    RETVAL = DestroyMenu(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::MenuButton
+    ###########################################################################
+
+MODULE = Win32::GUI     PACKAGE = Win32::GUI::MenuButton
+
+    ###########################################################################
+    # (@)INTERNAL:InsertMenuItem(HANDLE, %OPTIONS)
+void
+InsertMenuItem(...)
+PREINIT:
+    MENUITEMINFO mii;
+    LPPERLWIN32GUI_MENUITEMDATA perlmid;
+    UINT myItem;
+    BOOL RETVAL;
+PPCODE:
+    ZeroMemory(&mii, sizeof(MENUITEMINFO));
+    mii.cbSize = sizeof(MENUITEMINFO);
+    myItem = 0;
+    Newz(0, perlmid, 1, PERLWIN32GUI_MENUITEMDATA);
+    perlmid->dwSize = sizeof(PERLWIN32GUI_MENUITEMDATA);
+    perlmid->svCode = newSVsv(&PL_sv_undef);
+    ParseMenuItemOptions(NOTXSCALL sp, mark, ax, items, 1, &mii, perlmid, &myItem);
+    mii.hbmpChecked = NULL;
+    mii.hbmpUnchecked = NULL;
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    printf("XS(InsertMenuItem) doing InsertMenuItem (HMENU=0x%x)...\n", handle_From(NOTXSCALL ST(0)));
+#endif
+    RETVAL = InsertMenuItem(
+        (HMENU) handle_From(NOTXSCALL ST(0)),
+        myItem,
+        FALSE,
+        &mii
+    );
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    printf("XS(InsertMenuItem) done InsertMenuItem (RETVAL=%d)\n", RETVAL);
+#endif
+    XSRETURN_IV(RETVAL);
+
+
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::MenuItem
+    ###########################################################################
+
+MODULE = Win32::GUI     PACKAGE = Win32::GUI::MenuItem
+
+    ###########################################################################
+    # (@)METHOD:Change(%OPTIONS)
+    # Change most of the options used when the object was created.
+void
+Change(...)
+PPCODE:
+    MENUITEMINFO myMII;
+    LPPERLWIN32GUI_MENUITEMDATA perlmid;
+    UINT myItem;
+    HMENU hMenu;
+    SV** parentmenu;
+    char tmpmenutext[1024];
+    if(SvROK(ST(0))) {
+        parentmenu = hv_fetch((HV*)SvRV((ST(0))), "-menu", 5, 0);
+        if(parentmenu != NULL) {
+            hMenu = (HMENU)(DWORD)SvIV(*parentmenu);
+            myItem = SvIV(*(hv_fetch((HV*)SvRV(ST(0)), "-id", 3, 0)));
+        } else {
+            hMenu = (HMENU) handle_From(NOTXSCALL ST(0));
+        }
+    }
+#ifdef PERLWIN32GUI_DEBUG
+        printf("XS(MenuItem::Change): hMenu=0x%x, myItem=%d\n", hMenu, myItem);
+#endif
+    ZeroMemory(&myMII, sizeof(MENUITEMINFO));
+    myMII.cbSize = sizeof(MENUITEMINFO);
+    myMII.fMask = MIIM_STATE | MIIM_SUBMENU | MIIM_TYPE | MIIM_DATA;
+    myMII.dwTypeData = tmpmenutext;
+    myMII.cch = 1024;
+    if(GetMenuItemInfo(hMenu, myItem, FALSE, &myMII)) {
+        perlmid = (LPPERLWIN32GUI_MENUITEMDATA) myMII.dwItemData;
+        myMII.fMask = 0;
+        ParseMenuItemOptions(NOTXSCALL sp, mark, ax, items, 1, &myMII, perlmid, &myItem);
+        myMII.hbmpChecked = NULL;
+        myMII.hbmpUnchecked = NULL;
+        XSRETURN_IV(
+            SetMenuItemInfo(hMenu, myItem, FALSE, &myMII)
+        );
+    } else
+        XSRETURN_UNDEF;
+
+
+    ###########################################################################
+    # (@)METHOD:Checked(...)
+void
+Checked(...)
+PPCODE:
+    MENUITEMINFO myMII;
+    int i;
+    UINT myItem;
+    HMENU hMenu;
+    SV** parentmenu;
+
+    if(SvROK(ST(0))) {
+        parentmenu = hv_fetch((HV*)SvRV((ST(0))), "-menu", 5, 0);
+        if(parentmenu != NULL) {
+            hMenu = (HMENU)(DWORD)SvIV(*parentmenu);
+            myItem = SvIV(*(hv_fetch((HV*)SvRV(ST(0)), "-id", 3, 0)));
+            i = 1;
+        } else {
+            hMenu = (HMENU) handle_From(NOTXSCALL ST(0));
+            myItem = SvIV(ST(1));
+            i = 2;
+        }
+    }
+    ZeroMemory(&myMII, sizeof(MENUITEMINFO));
+    myMII.cbSize = sizeof(MENUITEMINFO);
+    myMII.fMask = MIIM_STATE;
+    if(GetMenuItemInfo(hMenu, myItem, FALSE, &myMII)) {
+        if(items > i) {
+            myMII.fMask = MIIM_STATE;
+            SwitchBit(myMII.fState, MFS_CHECKED, SvIV(ST(i)));
+            XSRETURN_IV(
+                SetMenuItemInfo(hMenu, myItem, FALSE, &myMII)
+            );
+        } else {
+            XSRETURN_IV((myMII.fState & MFS_CHECKED) ? 1 : 0);
+        }
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:Enabled(...)
+void
+Enabled(...)
+PPCODE:
+    MENUITEMINFO myMII;
+    int i, x;
+    UINT myItem;
+    HMENU hMenu;
+    SV** parentmenu;
+
+    if(SvROK(ST(0))) {
+        parentmenu = hv_fetch((HV*)SvRV((ST(0))), "-menu", 5, 0);
+        if(parentmenu != NULL) {
+            hMenu = (HMENU)(DWORD)SvIV(*parentmenu);
+            myItem = SvIV(*(hv_fetch((HV*)SvRV(ST(0)), "-id", 3, 0)));
+            i = 1;
+        } else {
+            hMenu = (HMENU) handle_From(NOTXSCALL ST(0));
+            myItem = SvIV(ST(1));
+            i = 2;
+        }
+    }
+    ZeroMemory(&myMII, sizeof(MENUITEMINFO));
+    myMII.cbSize = sizeof(MENUITEMINFO);
+    myMII.fMask = MIIM_STATE;
+    if(GetMenuItemInfo(hMenu, myItem, FALSE, &myMII)) {
+        if(items > i) {
+            myMII.fMask = MIIM_STATE;
+            x = (SvIV(ST(i))) ? 0 : 1;
+            SwitchBit(myMII.fState, MFS_DISABLED, x);
+            XSRETURN_IV(
+                SetMenuItemInfo(hMenu, myItem, FALSE, &myMII)
+            );
+        } else {
+            XSRETURN_IV((myMII.fState & MFS_DISABLED) ? 0 : 1);
+        }
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::DialogBox
+    ###########################################################################
+
+MODULE = Win32::GUI     PACKAGE = Win32::GUI::DialogBox
+
+    # DWORD
+    # Dialog(...)
+    # PPCODE:
+    #     HWND hwnd;
+    #     MSG msg;
+    #     int stayhere;
+    #     stayhere = 1;
+    #
+    #     if(items > 0) {
+    #         hwnd = (HWND) handle_From(NOTXSCALL ST(0));
+    #     } else {
+    #         hwnd = NULL;
+    #     }
+    #
+    #     while (stayhere) {
+    #         stayhere = GetMessage(&msg, hwnd, 0, 0);
+    #         if(msg.message == WM_EXITLOOP) {
+    #             stayhere = 0;
+    #             msg.wParam = (WPARAM)-1;
+    #         } else {
+    #             if(stayhere == -1) {
+    #                 stayhere = 0;
+    #                 msg.wParam = (WPARAM)-2; // an error occurred...
+    #             } else {
+    #                 if(!IsDialogMessage(hwnd, &msg)) {
+    #                     TranslateMessage(&msg);
+    #                     DispatchMessage(&msg);
+    #                 }
+    #             }
+    #         }
+    #     }
+    #     XSRETURN_IV((long) msg.wParam);
+
+
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::Combobox
+    ###########################################################################
+
+MODULE = Win32::GUI     PACKAGE = Win32::GUI::Combobox
+
+
+    ###########################################################################
+    # (@)METHOD:AddString(STRING)
+    # Adds an item at the end of the control's list.
+LRESULT
+AddString(handle,string)
+    HWND handle
+    LPCTSTR string
+CODE:
+    RETVAL = SendMessage(handle, CB_ADDSTRING, 0, (LPARAM) string);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:Add(STRING, STRING .. STRING)
+    # Adds one or more items at the end of the control's list.
+void
+Add(handle,...)
+    HWND handle
+PREINIT:
+    int i;
+CODE:
+    for(i = 1; i < items; i++) {
+        SendMessage(handle, CB_ADDSTRING, 0, (LPARAM) (LPCTSTR) SvPV_nolen(ST(i)));
+    }
+
+    ###########################################################################
+    # (@)METHOD:InsertItem(STRING, [INDEX])
+    # Inserts an item at the specified zero-based INDEX in the Combobox,
+    # or adds it at the end if INDEX is not specified.
+LRESULT
+InsertItem(handle,string,index=-1)
+    HWND handle
+    LPCTSTR string
+    long index
+CODE:
+    RETVAL = SendMessage(handle, CB_INSERTSTRING, (WPARAM) index, (LPARAM) string);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:GetString(INDEX)
+    # Returns the string at the specified zero-based INDEX in the Combobox.
+void
+GetString(handle,index)
+    HWND handle
+    WPARAM index
+PREINIT:
+    STRLEN cbString;
+    char *szString;
+PPCODE:
+    cbString = SendMessage(handle, CB_GETLBTEXTLEN, index, 0);
+    if(cbString != LB_ERR) {
+        szString = (char *) safemalloc(cbString);
+        if(SendMessage(handle, CB_GETLBTEXT,
+                       index, (LPARAM) (LPCTSTR) szString) != LB_ERR) {
+            EXTEND(SP, 1);
+            XST_mPV(0, szString);
+            safefree(szString);
+            XSRETURN(1);
+        } else {
+            safefree(szString);
+            XSRETURN_UNDEF;
+        }
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+    ###########################################################################
+    # (@)METHOD:ItemHeight([HEIGHT])
+    # Gets or sets the items height in a Combobox.
+LRESULT
+ItemHeight(handle,height=-1)
+    HWND handle
+    long height
+CODE:
+    if(items == 1) {
+        RETVAL = SendMessage(handle, LB_GETITEMHEIGHT, 0, 0);
+    } else {
+        RETVAL = SendMessage(handle, LB_SETITEMHEIGHT, 0, MAKELPARAM(height, 0));
+    }
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:FirstVisibleItem([INDEX])
+LRESULT
+FirstVisibleItem(handle,index=-1)
+    HWND handle
+    long index
+CODE:
+    if(items == 1)
+        RETVAL = SendMessage(handle, CB_GETTOPINDEX, 0, 0);
+    else
+        RETVAL = SendMessage(handle, CB_SETTOPINDEX, (WPARAM) index, 0);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:FindString(STRING, [INDEX])
+LRESULT
+FindString(handle,string,index=-1)
+    HWND handle
+    LPCTSTR string
+    long index
+CODE:
+    RETVAL = SendMessage(handle, CB_FINDSTRING, (WPARAM) index, (LPARAM) string);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:FindStringExact(STRING, [INDEX])
+LRESULT
+FindStringExact(handle,string,index=-1)
+    HWND handle
+    LPCTSTR string
+    long index
+CODE:
+    RETVAL = SendMessage(handle, CB_FINDSTRINGEXACT, (WPARAM) index, (LPARAM) string);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::UpDown
+    ###########################################################################
+
+MODULE = Win32::GUI     PACKAGE = Win32::GUI::UpDown
+
+
+    ###########################################################################
+    # (@)METHOD:Base([VALUE])
+    # Gets or sets the radix base for the UpDown control; VALUE can be
+    # either 10 or 16 for decimal or hexadecimal base numbering.
+LRESULT
+Base(handle,base=0)
+    HWND handle
+    WPARAM base
+CODE:
+    if(items == 1)
+        RETVAL = SendMessage(handle, UDM_GETBASE, 0, 0);
+    else
+        RETVAL = SendMessage(handle, UDM_SETBASE, base, 0);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Pos([VALUE])
+    # Gets or sets the current position of the UpDown control.
+LRESULT
+Pos(handle,pos=-1)
+    HWND handle
+    short pos
+CODE:
+    if(items == 1)
+        RETVAL = SendMessage(handle, UDM_GETPOS, 0, 0);
+    else
+        RETVAL = SendMessage(handle, UDM_SETPOS, 0, (LPARAM) MAKELONG(pos, 0));
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Range([MIN, MAX])
+    # Gets or sets the range for the UpDown control; if no parameter is given,
+    # returns a two element array containing the MIN and MAX range values,
+    # otherwise sets them to the given values.
+    # If MAX is lower than MIN, the UpDown control function is reversed, eg.
+    # the up button decrements the value and the down button increments it
+void
+Range(handle,min=-1,max=-1)
+    HWND handle
+    short min
+    short max
+PREINIT:
+    LRESULT range;
+PPCODE:
+    if(items == 1) {
+        range = SendMessage(handle, UDM_GETRANGE, 0, 0);
+        XST_mIV(0, HIWORD(range));
+        XST_mIV(1, LOWORD(range));
+        XSRETURN(2);
+    } else {
+        SendMessage(handle, UDM_SETRANGE, 0, (LPARAM) MAKELONG(max, min));
+        XSRETURN_YES;
+    }
+
+    ###########################################################################
+    # (@)METHOD:Buddy([OBJECT])
+    # Gets or sets the buddy window for the UpDown control.
+HV*
+Buddy(handle,buddy=NULL)
+    HWND handle
+    HWND buddy
+PREINIT:
+    HWND oldbuddy;
+CODE:
+    if(items == 1) {
+        oldbuddy = (HWND) SendMessage(handle, UDM_GETBUDDY, 0, 0);
+        RETVAL = (HV*) GetWindowLong(oldbuddy, GWL_USERDATA);
+    } else {
+        oldbuddy = (HWND) SendMessage(handle, UDM_SETBUDDY, (WPARAM) buddy, 0);
+        RETVAL = (HV*) GetWindowLong(oldbuddy, GWL_USERDATA);
+    }
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::Tooltip
+    ###########################################################################
+
+MODULE = Win32::GUI     PACKAGE = Win32::GUI::Tooltip
+
+
+    ###########################################################################
+    # (@)METHOD:Add(...)
+BOOL
+Add(handle,...)
+    HWND handle
+PREINIT:
+    int i, next_i;
+    char * option;
+    TOOLINFO ti;
+CODE:
+    ZeroMemory(&ti, sizeof(TOOLINFO));
+    ti.cbSize = sizeof(TOOLINFO);
+    ti.hwnd = (HWND) GetWindowLong(handle, GWL_HWNDPARENT);
+    next_i = -1;
+    for(i = 1; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                printf("XS(Tooltip::Add): got option '%s'\n", option);
+#endif
+            if(strcmp(option, "-text") == 0) {
+                next_i = i + 1;
+                ti.lpszText = SvPV_nolen(ST(next_i));
+            } else if(strcmp(option, "-window") == 0) {
+                next_i = i + 1;
+                ti.uId = (UINT) handle_From(NOTXSCALL ST(next_i));
+                ti.uFlags |= TTF_IDISHWND;
+            } else if(strcmp(option, "-flags") == 0) {
+                next_i = i + 1;
+                ti.uFlags = SvIV(ST(next_i));
+            }
+        }
+    }
+    RETVAL = SendMessage(handle, TTM_ADDTOOL, 0, (LPARAM) &ti);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:Count()
+    # Returns the number of tools in the Tooltip.
+LRESULT
+Count(handle)
+    HWND handle
+CODE:
+    RETVAL = SendMessage(handle, TTM_GETTOOLCOUNT, 0, 0);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::Header
+    ###########################################################################
+
+MODULE = Win32::GUI     PACKAGE = Win32::GUI::Header
+
+
+    ###########################################################################
+    # (@)METHOD:InsertItem(%OPTIONS)
+    # Inserts a new item in the Header control. Returns the newly created
+    # item zero-based index or -1 on errors.
+    # %OPTIONS can be:
+    #   -index => position
+    #   -image => index of an image from the associated ImageList
+    #   -bitmap => Win32::GUI::Bitmap object
+    #   -width => pixels
+    #   -height => pixels
+    #   -text => string
+    #   -align => left|center|right
+LRESULT
+InsertItem(handle,...)
+    HWND handle
+PREINIT:
+    HDITEM Item;
+    int index;
+CODE:
+    ZeroMemory(&Item, sizeof(HDITEM));
+    index = Header_GetItemCount(handle) + 1;
+    Item.fmt = HDF_LEFT;
+    SwitchBit(Item.mask, HDI_FORMAT, 1);
+    ParseHeaderItemOptions(NOTXSCALL sp, mark, ax, items, 1, &Item, &index);
+    RETVAL = Header_InsertItem(handle, index, &Item);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:DeleteItem(INDEX)
+    # Deletes the zero-based INDEX item from the Header.
+LRESULT
+DeleteItem(handle,index)
+    HWND handle
+    int index
+CODE:
+    RETVAL = Header_DeleteItem(handle, index);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:Count()
+    # Returns the number of items in the Header control.
+int
+Count(handle)
+    HWND handle
+CODE:
+    RETVAL = Header_GetItemCount(handle);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:ItemRect(INDEX)
+    # Returns a four element array defining the rectangle of the specified
+    # zero-based INDEX item; the array contains (left, top, right, bottom).
+    # If not succesful returns undef.
+void
+ItemRect(handle,index)
+    HWND handle
+    int index
+PREINIT:
+    RECT rect;
+CODE:
+    if(Header_GetItemRect(handle, index, &rect)) {
+        EXTEND(SP, 4);
+        XST_mIV(0, rect.left);
+        XST_mIV(1, rect.top);
+        XST_mIV(2, rect.right);
+        XST_mIV(3, rect.bottom);
+        XSRETURN(4);
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+    ###########################################################################
+    # (@)METHOD:ChangeItem(INDEX, %OPTIONS)
+    # Changes the options for an item in the Header control. Returns nonzero
+    # if successful, zero otherwise.
+    # For a list of the available options see InsertItem().
+BOOL
+ChangeItem(handle,index,...)
+    HWND handle
+    int index
+PREINIT:
+    HDITEM Item;
+CODE:
+    ZeroMemory(&Item, sizeof(HDITEM));
+    if(Header_GetItem(handle, index, &Item)) {
+        ParseHeaderItemOptions(NOTXSCALL sp, mark, ax, items, 1, &Item, &index);
+        SwitchBit(Item.mask, HDI_FORMAT, 1);
+        RETVAL = Header_SetItem(handle, index, &Item);
+    } else {
+        RETVAL = 0;
+    }
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:HitTest(X, Y)
+    # Checks if the specified point is on an Header item;
+    # it returns the index of the found item or -1 if none was found.
+    # If called in an array context, it returns an additional value containing
+    # more info about the position of the specified point.
+void
+HitTest(handle,x,y)
+    HWND handle
+    LONG x
+    LONG y
+PREINIT:
+    HD_HITTESTINFO ht;
+PPCODE:
+	ZeroMemory(&ht, sizeof(HD_HITTESTINFO));
+    ht.pt.x = x;
+    ht.pt.y = y;
+    if(SendMessage(handle, HDM_HITTEST, 0, (LPARAM) &ht) == -1) {
+        XSRETURN_IV(-1);
+    } else {
+        if(GIMME == G_ARRAY) {
+            EXTEND(SP, 2);
+            XST_mIV(0, (long) ht.iItem);
+            XST_mIV(1, (long) ht.flags);
+            XSRETURN(2);
+        } else {
+            XSRETURN_IV((long) ht.iItem);
+        }
+    }
+
+    ###########################################################################
+    # (@)METHOD:Clear()
+    # Deletes all items from the control.
+
+    ###########################################################################
+    # (@)METHOD:Reset()
+    # See Clear().
+BOOL
+Clear(handle)
+    HWND handle
+ALIAS:
+    Win32::GUI::Header::Reset = 1
+PREINIT:
+    int i;
+CODE:
+    RETVAL = TRUE;
+    for(i = Header_GetItemCount(handle); i > 0; i--) {
+        if(!Header_DeleteItem(handle, i)) RETVAL = FALSE;
+    }
+OUTPUT:
+    RETVAL
+
+
+    # TODO: ItemInfo
+
+
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::ComboboxEx
+    ###########################################################################
+
+MODULE = Win32::GUI     PACKAGE = Win32::GUI::ComboboxEx
+
+
+    ###########################################################################
+    # (@)METHOD:InsertItem(%OPTIONS)
+    # Inserts a new item in the ComboboxEx control. Returns the newly created
+    # item zero-based index or -1 on errors.
+    # %OPTIONS can be:
+    #   -index => position (-1 for the end of the list)
+    #   -image => index of an image from the associated ImageList
+    #   -selectedimage => index of an image from the associated ImageList
+    #   -text => string
+    #   -indent => indentation spaces (1 space == 10 pixels)
+LRESULT
+InsertItem(handle,...)
+    HWND handle
+PREINIT:
+    COMBOBOXEXITEM Item;
+CODE:
+    ZeroMemory(&Item, sizeof(COMBOBOXEXITEM));
+    Item.iItem = -1;
+    ParseComboboxExItemOptions(NOTXSCALL sp, mark, ax, items, 1, &Item);
+    RETVAL = SendMessage(handle, CBEM_INSERTITEM, 0, (LPARAM) &Item);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::DateTime
+    ###########################################################################
+
+MODULE = Win32::GUI     PACKAGE = Win32::GUI::DateTime
+
+
+    ###########################################################################
+    # (@)METHOD:GetDate()
+    # (preliminary) Returns the date in the DateTime control in a three
+    # elements array (day, month, year).
+void
+GetDate(handle)
+    HWND handle
+PREINIT:
+    SYSTEMTIME st;
+PPCODE:
+    if(DateTime_GetSystemtime(handle, &st) == GDT_VALID) {
+        EXTEND(SP, 3);
+        XST_mIV(0, st.wDay);
+        XST_mIV(1, st.wMonth);
+        XST_mIV(2, st.wYear);
+        XSRETURN(3);
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+    ###########################################################################
+    # (@)METHOD:SetDate(DAY, MONTH, YEAR)
+    # (preliminary) Sets the date in the DateTime control in a three
+    # elements array (day, month, year).
+BOOL
+SetDate(handle, day, mon, year)
+    HWND handle
+    int day
+    int mon
+    int year
+PREINIT:
+    SYSTEMTIME st;
+CODE:
+    ZeroMemory(&st, sizeof(SYSTEMTIME));
+    st.wDay   = day;
+    st.wMonth = mon;
+    st.wYear  = year;
+    RETVAL = DateTime_SetSystemtime(handle, GDT_VALID, &st);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:GetTime()
+    # (preliminary) Returns the time in the DateTime control in a four
+    # elements array (hour, min, sec, msec).
+void
+GetTime(handle)
+    HWND handle
+PREINIT:
+    SYSTEMTIME st;
+PPCODE:
+    if(DateTime_GetSystemtime(handle, &st) == GDT_VALID) {
+        EXTEND(SP, 4);
+        XST_mIV(0, st.wHour);
+        XST_mIV(1, st.wMinute);
+        XST_mIV(2, st.wSecond);
+        XST_mIV(3, st.wMilliseconds);
+        XSRETURN(4);
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+    ###########################################################################
+    # (@)METHOD:SetTime(HOUR, MIN, SEC, [MSEC=0])
+    # (preliminary) Sets the time in the DateTime control in a four
+    # elements array (hour, min, sec, [msec=0]).
+BOOL
+SetTime(handle, hour, min, sec, msec=0)
+    HWND handle
+    int hour
+    int min
+    int sec
+    int msec
+PREINIT:
+    SYSTEMTIME st;
+CODE:
+    ZeroMemory(&st, sizeof(SYSTEMTIME));
+    st.wHour   = hour;
+    st.wMinute = min;
+    st.wSecond = sec;
+    st.wMilliseconds = msec;
+    RETVAL = DateTime_SetSystemtime(handle, GDT_VALID, &st);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:GetDateTime()
+    # (preliminary) Returns the date and time in the DateTime control in a eight
+    # elements array (year, month, day, dayofweek, hour, minute, second, millisecond).
+void
+GetDateTime(handle)
+    HWND handle
+PREINIT:
+    SYSTEMTIME st;
+PPCODE:
+    if(DateTime_GetSystemtime(handle, &st) == GDT_VALID) {
+        EXTEND(SP, 8);
+        XST_mIV(0, st.wYear);
+        XST_mIV(1, st.wMonth);
+        XST_mIV(2, st.wDay);
+        XST_mIV(3, st.wDayOfWeek);
+        XST_mIV(4, st.wHour);
+        XST_mIV(5, st.wMinute);
+        XST_mIV(6, st.wSecond);
+        XST_mIV(7, st.wMilliseconds);
+        XSRETURN(8);
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+    ###########################################################################
+    # (@)METHOD:SetDateTime(YEAR,MON, DAY, HOUR, MIN, SEC, [MSEC=0])
+    # (preliminary) Sets the date time in the DateTime control
+BOOL
+SetDateTime(handle, year, mon, day, hour, min, sec, msec=0)
+    HWND handle
+    int year
+    int mon
+    int day
+    int hour
+    int min
+    int sec
+    int msec
+PREINIT:
+    SYSTEMTIME st;
+CODE:
+    ZeroMemory(&st, sizeof(SYSTEMTIME));
+    st.wYear   = year;
+    st.wDay    = day;
+    st.wMonth  = mon;
+    st.wHour   = hour;
+    st.wMinute = min;
+    st.wSecond = sec;
+    st.wMilliseconds = msec;
+
+    RETVAL = DateTime_SetSystemtime(handle, GDT_VALID, &st);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:SetNone(handle)
+    # (preliminary) Set none state in the DateTime control (control check box was
+    #  selected)..
+void
+SetNone(handle)
+    HWND handle
+PPCODE:
+    DateTime_SetSystemtime(handle, GDT_NONE, NULL);
+
+    ###########################################################################
+    # (@)METHOD:IsNone()
+    # (preliminary) Test if the DateTime control is None (control check box was
+    #  not selected).
+BOOL
+IsNone(handle)
+    HWND handle
+PREINIT:
+    SYSTEMTIME st;
+CODE:
+    RETVAL = (DateTime_GetSystemtime(handle, &st) == GDT_NONE);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:Format(FORMAT)
+    # (preliminary) Sets the format for the DateTime control to the specified
+    # string. More info [TBD].
+BOOL
+Format(handle, format = NULL)
+    HWND handle
+    LPCTSTR format
+CODE:
+    RETVAL = DateTime_SetFormat(handle, format);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::Brush
+    ###########################################################################
+
+MODULE = Win32::GUI     PACKAGE = Win32::GUI::Brush
+
+
+    ###########################################################################
+    # (@)INTERNAL:Create(%OPTIONS)
+void
+Create(...)
+PREINIT:
+    LOGBRUSH lb;
+    char *option;
+    int i, next_i;
+PPCODE:
+    ZeroMemory(&lb, sizeof(LOGBRUSH));
+    if(items == 1) {
+        lb.lbStyle = BS_SOLID;
+        lb.lbColor = SvCOLORREF(NOTXSCALL ST(0));
+    } else {
+        next_i = -1;
+        for(i = 0; i < items; i++) {
+            if(next_i == -1) {
+                option = SvPV_nolen(ST(i));
+                if(strcmp(option, "-pattern") == 0) {
+                    next_i = i + 1;
+                    lb.lbStyle = BS_PATTERN;
+                    lb.lbHatch = (LONG) handle_From(NOTXSCALL ST(next_i));
+                } else if(strcmp(option, "-hatch") == 0) {
+                    next_i = i + 1;
+                    lb.lbStyle = BS_HATCHED;
+                    lb.lbHatch = (LONG) SvIV(ST(next_i));
+                } else if(strcmp(option, "-color") == 0) {
+                    next_i = i + 1;
+                    lb.lbColor = SvCOLORREF(NOTXSCALL ST(next_i));
+                } else if(strcmp(option, "-system") == 0) {
+                    next_i = i + 1;
+                    XSRETURN_IV((long) GetSysColorBrush(SvIV(ST(next_i))));
+                }
+            } else {
+                next_i = -1;
+            }
+        }
+    }
+    XSRETURN_IV((long) CreateBrushIndirect(&lb));
+
+    ###########################################################################
+    # (@)METHOD:Info()
+    # Returns an associative array of information about the Brush object, with
+    # the same options given when creating the Brush.
+void
+Info(handle)
+    HBRUSH handle
+PREINIT:
+    LOGBRUSH brush;
+PPCODE:
+    ZeroMemory(&brush, sizeof(LOGBRUSH));
+    if(GetObject((HGDIOBJ) handle, sizeof(LOGBRUSH), &brush)) {
+        if(brush.lbStyle & BS_PATTERN) {
+            EXTEND(SP, 4);
+            XST_mPV( 0, "-pattern");
+            XST_mIV( 1, brush.lbHatch);
+            XST_mPV( 2, "-color");
+            XST_mIV( 3, brush.lbColor);
+            XSRETURN(4);
+        } else if(brush.lbStyle & BS_HATCHED) {
+            EXTEND(SP, 4);
+            XST_mPV( 0, "-hatch");
+            XST_mIV( 1, brush.lbHatch);
+            XST_mPV( 2, "-color");
+            XST_mIV( 3, brush.lbColor);
+            XSRETURN(4);
+        } else {
+            EXTEND(SP, 6);
+            XST_mPV( 0, "-style");
+            XST_mIV( 1, brush.lbStyle);
+            XST_mPV( 2, "-hatch");
+            XST_mIV( 3, brush.lbHatch);
+            XST_mPV( 4, "-color");
+            XST_mIV( 5, brush.lbColor);
+            XSRETURN(6);
+        }
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+    ###########################################################################
+    # (@)INTERNAL:DESTROY(HANDLE)
+BOOL
+DESTROY(handle)
+    HBRUSH handle
+CODE:
+    RETVAL = DeleteObject((HGDIOBJ) handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::Pen
+    ###########################################################################
+
+MODULE = Win32::GUI     PACKAGE = Win32::GUI::Pen
+
+
+    ###########################################################################
+    # (@)INTERNAL:Create(%OPTIONS)
+void
+Create(...)
+PPCODE:
+    int penstyle;
+    int penwidth;
+    COLORREF pencolor;
+    char *option;
+    int i, next_i;
+    penstyle = PS_SOLID;
+    penwidth = 0;
+    pencolor = RGB(0, 0, 0);
+    if(items == 1) {
+        pencolor = SvCOLORREF(NOTXSCALL ST(0));
+    } else {
+        next_i = -1;
+        for(i = 0; i < items; i++) {
+            if(next_i == -1) {
+                option = SvPV_nolen(ST(i));
+                if(strcmp(option, "-style") == 0) {
+                    next_i = i + 1;
+                    penstyle = (int) SvIV(ST(next_i));
+                }
+                if(strcmp(option, "-width") == 0) {
+                    next_i = i + 1;
+                    penwidth = (int) SvIV(ST(next_i));
+                }
+                if(strcmp(option, "-color") == 0) {
+                    next_i = i + 1;
+                    pencolor = SvCOLORREF(NOTXSCALL ST(next_i));
+                }
+            } else {
+                next_i = -1;
+            }
+        }
+    }
+    XSRETURN_IV((long) CreatePen(penstyle, penwidth, pencolor));
+
+    ###########################################################################
+    # (@)METHOD:Info()
+    # Returns an associative array of information about the Pen object, with
+    # the same options given when creating the Pen.
+void
+Info(handle)
+    HPEN handle
+PREINIT:
+    LOGPEN pen;
+PPCODE:
+    ZeroMemory(&pen, sizeof(LOGPEN));
+    if(GetObject((HGDIOBJ) handle, sizeof(LOGPEN), &pen)) {
+        EXTEND(SP, 6);
+        XST_mPV( 0, "-style");
+        XST_mIV( 1, pen.lopnStyle);
+        XST_mPV( 2, "-width");
+        XST_mIV( 3, pen.lopnWidth.x);
+        XST_mPV( 4, "-color");
+        XST_mIV( 5, pen.lopnColor);
+        XSRETURN(6);
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+    ###########################################################################
+    # (@)INTERNAL:DESTROY(HANDLE)
+BOOL
+DESTROY(handle)
+    HPEN handle
+CODE:
+    RETVAL = DeleteObject((HGDIOBJ) handle);
+    OUTPUT:
+    RETVAL
+
+
+BOOT:
+    {
+        INITCOMMONCONTROLSEX icce;
+	MY_CXT_INIT;
+        icce.dwSize = sizeof(INITCOMMONCONTROLSEX);
+        icce.dwICC = ICC_ANIMATE_CLASS | ICC_BAR_CLASSES | ICC_COOL_CLASSES
+                   | ICC_LISTVIEW_CLASSES | ICC_PROGRESS_CLASS
+                   | ICC_TAB_CLASSES | ICC_TREEVIEW_CLASSES
+                   | ICC_UPDOWN_CLASS | ICC_USEREX_CLASSES
+                   | ICC_DATE_CLASSES;
+        if(!InitCommonControlsEx(&icce)) {
+            warn("Win32::GUI: Unable to init common controls!\n");
+        }
+    }
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/GUI_Constants.cpp perl-libwin32-0.191/GUI/GUI_Constants.cpp
--- libwin32-0.191/GUI/GUI_Constants.cpp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/GUI_Constants.cpp	2004-01-12 16:46:39.937500000 -0800
@@ -0,0 +1,1811 @@
+/*
+###########################################################################
+# Win32::GUI Constants
+# $Id: GUI_Constants.cpp,v 1.3 2003/12/28 07:17:43 caelum Exp $
+###########################################################################
+*/
+#include "GUI.h"
+
+DWORD
+constant(NOTXSPROC char *name, int arg) {
+    errno = 0;
+    switch (*name) {
+
+    case 'A':
+        break;
+    case 'B':
+        if (strEQ(name, "BS_3STATE"))
+            #ifdef BS_3STATE
+                return BS_3STATE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_AUTO3STATE"))
+            #ifdef BS_AUTO3STATE
+                return BS_AUTO3STATE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_AUTOCHECKBOX"))
+            #ifdef BS_AUTOCHECKBOX
+                return BS_AUTOCHECKBOX;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_AUTORADIOBUTTON"))
+            #ifdef BS_AUTORADIOBUTTON
+                return BS_AUTORADIOBUTTON;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_CHECKBOX"))
+            #ifdef BS_CHECKBOX
+                return BS_CHECKBOX;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_DEFPUSHBUTTON"))
+            #ifdef BS_DEFPUSHBUTTON
+                return BS_DEFPUSHBUTTON;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_GROUPBOX"))
+            #ifdef BS_GROUPBOX
+                return BS_GROUPBOX;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_LEFTTEXT"))
+            #ifdef BS_LEFTTEXT
+                return BS_LEFTTEXT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_NOTIFY"))
+            #ifdef BS_NOTIFY
+                return BS_NOTIFY;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_OWNERDRAW"))
+            #ifdef BS_OWNERDRAW
+                return BS_OWNERDRAW;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_PUSHBUTTON"))
+            #ifdef BS_PUSHBUTTON
+                return BS_PUSHBUTTON;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_RADIOBUTTON"))
+            #ifdef BS_RADIOBUTTON
+                return BS_RADIOBUTTON;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_USERBUTTON"))
+            #ifdef BS_USERBUTTON
+                return BS_USERBUTTON;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_BITMAP"))
+            #ifdef BS_BITMAP
+                return BS_BITMAP;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_BOTTOM"))
+            #ifdef BS_BOTTOM
+                return BS_BOTTOM;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_CENTER"))
+            #ifdef BS_CENTER
+                return BS_CENTER;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_ICON"))
+            #ifdef BS_ICON
+                return BS_ICON;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_LEFT"))
+            #ifdef BS_LEFT
+                return BS_LEFT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_MULTILINE"))
+            #ifdef BS_MULTILINE
+                return BS_MULTILINE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_RIGHT"))
+            #ifdef BS_RIGHT
+                return BS_RIGHT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_RIGHTBUTTON"))
+            #ifdef BS_RIGHTBUTTON
+                return BS_RIGHTBUTTON;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_TEXT"))
+            #ifdef BS_TEXT
+                return BS_TEXT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_TOP"))
+            #ifdef BS_TOP
+                return BS_TOP;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "BS_VCENTER"))
+            #ifdef BS_VCENTER
+                return BS_VCENTER;
+            #else
+                goto not_there;
+            #endif
+
+        break;
+    case 'C':
+        if (strEQ(name, "COLOR_3DFACE"))
+            #ifdef COLOR_3DFACE
+                return COLOR_3DFACE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_ACTIVEBORDER"))
+            #ifdef COLOR_ACTIVEBORDER
+                return COLOR_ACTIVEBORDER;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_ACTIVECAPTION"))
+            #ifdef COLOR_ACTIVECAPTION
+                return COLOR_ACTIVECAPTION;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_APPWORKSPACE"))
+            #ifdef COLOR_APPWORKSPACE
+                return COLOR_APPWORKSPACE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_BACKGROUND"))
+            #ifdef COLOR_BACKGROUND
+                return COLOR_BACKGROUND;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_BTNFACE"))
+            #ifdef COLOR_BTNFACE
+                return COLOR_BTNFACE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_BTNSHADOW"))
+            #ifdef COLOR_BTNSHADOW
+                return COLOR_BTNSHADOW;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_BTNTEXT"))
+            #ifdef COLOR_BTNTEXT
+                return COLOR_BTNTEXT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_CAPTIONTEXT"))
+            #ifdef COLOR_CAPTIONTEXT
+                return COLOR_CAPTIONTEXT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_GRAYTEXT"))
+            #ifdef COLOR_GRAYTEXT
+                return COLOR_GRAYTEXT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_HIGHLIGHT"))
+            #ifdef COLOR_HIGHLIGHT
+                return COLOR_HIGHLIGHT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_HIGHLIGHTTEXT"))
+            #ifdef COLOR_HIGHLIGHTTEXT
+                return COLOR_HIGHLIGHTTEXT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_INACTIVEBORDER"))
+            #ifdef COLOR_INACTIVEBORDER
+                return COLOR_INACTIVEBORDER;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_INACTIVECAPTION"))
+            #ifdef COLOR_INACTIVECAPTION
+                return COLOR_INACTIVECAPTION;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_MENU"))
+            #ifdef COLOR_MENU
+                return COLOR_MENU;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_MENUTEXT"))
+            #ifdef COLOR_MENUTEXT
+                return COLOR_MENUTEXT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_SCROLLBAR"))
+            #ifdef COLOR_SCROLLBAR
+                return COLOR_SCROLLBAR;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_WINDOW"))
+            #ifdef COLOR_WINDOW
+                return COLOR_WINDOW;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_WINDOWFRAME"))
+            #ifdef COLOR_WINDOWFRAME
+                return COLOR_WINDOWFRAME;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "COLOR_WINDOWTEXT"))
+            #ifdef COLOR_WINDOWTEXT
+                return COLOR_WINDOWTEXT;
+            #else
+                goto not_there;
+            #endif
+        break;
+    case 'D':
+        if (strEQ(name, "DS_3DLOOK"))
+            #ifdef DS_3DLOOK
+                return DS_3DLOOK;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "DS_ABSALIGN"))
+            #ifdef DS_ABSALIGN
+                return DS_ABSALIGN;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "DS_CENTER"))
+            #ifdef DS_CENTER
+                return DS_CENTER;
+            #else
+                goto not_there;
+            #endif
+       if (strEQ(name, "DS_CENTERMOUSE"))
+            #ifdef DS_CENTERMOUSE
+                return DS_CENTERMOUSE;
+            #else
+                goto not_there;
+            #endif
+       if (strEQ(name, "DS_CONTEXTHELP"))
+            #ifdef DS_CONTEXTHELP
+                return DS_CONTEXTHELP;
+            #else
+                goto not_there;
+            #endif
+       if (strEQ(name, "DS_CONTROL"))
+            #ifdef DS_CONTROL
+                return DS_CONTROL;
+            #else
+                goto not_there;
+            #endif
+       if (strEQ(name, "DS_FIXEDSYS"))
+            #ifdef DS_FIXEDSYS
+                return DS_FIXEDSYS;
+            #else
+                goto not_there;
+            #endif
+       if (strEQ(name, "DS_LOCALEDIT"))
+            #ifdef DS_LOCALEDIT
+                return DS_LOCALEDIT;
+            #else
+                goto not_there;
+            #endif
+       if (strEQ(name, "DS_MODALFRAME"))
+            #ifdef DS_MODALFRAME
+                return DS_MODALFRAME;
+            #else
+                goto not_there;
+            #endif
+       if (strEQ(name, "DS_NOFAILCREATE"))
+            #ifdef DS_NOFAILCREATE
+                return DS_NOFAILCREATE;
+            #else
+                goto not_there;
+            #endif
+       if (strEQ(name, "DS_NOIDLEMSG"))
+            #ifdef DS_NOIDLEMSG
+                return DS_NOIDLEMSG;
+            #else
+                goto not_there;
+            #endif
+       if (strEQ(name, "DS_RECURSE"))
+            #ifdef DS_RECURSE
+                return DS_RECURSE;
+            #else
+                goto not_there;
+            #endif
+       if (strEQ(name, "DS_SETFONT"))
+            #ifdef DS_SETFONT
+                return DS_SETFONT;
+            #else
+                goto not_there;
+            #endif
+       if (strEQ(name, "DS_SETFOREGROUND"))
+            #ifdef DS_SETFOREGROUND
+                return DS_SETFOREGROUND;
+            #else
+                goto not_there;
+            #endif
+       if (strEQ(name, "DS_SYSMODAL"))
+            #ifdef DS_SYSMODAL
+                return DS_SYSMODAL;
+            #else
+                goto not_there;
+            #endif
+
+        if (strEQ(name, "DTS_UPDOWN"))
+            #ifdef DS_SYSMODAL
+                return DTS_UPDOWN;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "DTS_SHOWNONE"))
+            #ifdef DS_SYSMODAL
+                return DTS_SHOWNONE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "DTS_SHORTDATEFORMAT"))
+            #ifdef DS_SYSMODAL
+                return DTS_SHORTDATEFORMAT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "DTS_LONGDATEFORMAT"))
+            #ifdef DS_SYSMODAL
+                return DTS_LONGDATEFORMAT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "DTS_TIMEFORMAT"))
+            #ifdef DS_SYSMODAL
+                return DTS_TIMEFORMAT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "DTS_APPCANPARSE"))
+            #ifdef DS_SYSMODAL
+                return DTS_APPCANPARSE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "DTS_RIGHTALIGN"))
+            #ifdef DS_SYSMODAL
+                return DTS_RIGHTALIGN;
+            #else
+                goto not_there;
+            #endif
+        break;
+    case 'E':
+        if (strEQ(name, "ES_AUTOHSCROLL"))
+            #ifdef ES_AUTOHSCROLL
+                return ES_AUTOHSCROLL;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "ES_AUTOVSCROLL"))
+            #ifdef ES_AUTOVSCROLL
+                return ES_AUTOVSCROLL;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "ES_CENTER"))
+            #ifdef ES_CENTER
+                return ES_CENTER;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "ES_LEFT"))
+            #ifdef ES_LEFT
+                return ES_LEFT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "ES_LOWERCASE"))
+            #ifdef ES_LOWERCASE
+                return ES_LOWERCASE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "ES_MULTILINE"))
+            #ifdef ES_MULTILINE
+                return ES_MULTILINE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "ES_NOHIDESEL"))
+            #ifdef ES_NOHIDESEL
+                return ES_NOHIDESEL;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "ES_NUMBER"))
+            #ifdef ES_NUMBER
+                return ES_NUMBER;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "ES_OEMCONVERT"))
+            #ifdef ES_OEMCONVERT
+                return ES_OEMCONVERT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "ES_PASSWORD"))
+            #ifdef ES_PASSWORD
+                return ES_PASSWORD;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "ES_READONLY"))
+            #ifdef ES_READONLY
+                return ES_READONLY;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "ES_RIGHT"))
+            #ifdef ES_RIGHT
+                return ES_RIGHT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "ES_UPPERCASE"))
+            #ifdef ES_UPPERCASE
+                return ES_UPPERCASE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "ES_WANTRETURN"))
+            #ifdef ES_WANTRETURN
+                return ES_WANTRETURN;
+            #else
+                goto not_there;
+            #endif
+        break;
+    case 'F':
+        break;
+    case 'G':
+        if (strEQ(name, "GW_CHILD"))
+            #ifdef GW_CHILD
+                return GW_CHILD;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "GW_HWNDFIRST"))
+            #ifdef GW_HWNDFIRST
+                return GW_HWNDFIRST;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "GW_HWNDLAST"))
+            #ifdef GW_HWNDLAST
+                return GW_HWNDLAST;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "GW_HWNDNEXT"))
+            #ifdef GW_HWNDNEXT
+                return GW_HWNDNEXT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "GW_HWNDPREV"))
+            #ifdef GW_HWNDPREV
+                return GW_HWNDPREV;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "GW_OWNER"))
+            #ifdef GW_OWNER
+                return GW_OWNER;
+            #else
+                goto not_there;
+            #endif
+        break;
+    case 'H':
+        break;
+    case 'I':
+        if (strEQ(name, "IMAGE_BITMAP"))
+            #ifdef IMAGE_BITMAP
+                return IMAGE_BITMAP;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "IMAGE_CURSOR"))
+            #ifdef IMAGE_CURSOR
+                return IMAGE_CURSOR;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "IMAGE_ICON"))
+            #ifdef IMAGE_ICON
+                return IMAGE_ICON;
+            #else
+                goto not_there;
+            #endif
+        break;
+    case 'J':
+        break;
+    case 'K':
+        break;
+    case 'L':
+        if (strEQ(name, "LR_DEFAULTCOLOR"))
+            #ifdef LR_DEFAULTCOLOR
+                return LR_DEFAULTCOLOR;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "LR_MONOCHROME"))
+            #ifdef LR_MONOCHROME
+                return LR_MONOCHROME;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "LR_COLOR"))
+            #ifdef LR_COLOR
+                return LR_COLOR;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "LR_COPYRETURNORG"))
+            #ifdef LR_COPYRETURNORG
+                return LR_COPYRETURNORG;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "LR_COPYDELETEORG"))
+            #ifdef LR_COPYDELETEORG
+                return LR_COPYDELETEORG;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "LR_LOADFROMFILE"))
+            #ifdef LR_LOADFROMFILE
+                return LR_LOADFROMFILE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "LR_LOADTRANSPARENT"))
+            #ifdef LR_LOADTRANSPARENT
+                return LR_LOADTRANSPARENT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "LR_DEFAULTSIZE"))
+            #ifdef LR_DEFAULTSIZE
+                return LR_DEFAULTSIZE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "LR_LOADMAP3DCOLORS"))
+            #ifdef LR_LOADMAP3DCOLORS
+                return LR_LOADMAP3DCOLORS;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "LR_CREATEDIBSECTION"))
+            #ifdef LR_CREATEDIBSECTION
+                return LR_CREATEDIBSECTION;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "LR_COPYFROMRESOURCE"))
+            #ifdef LR_COPYFROMRESOURCE
+                return LR_COPYFROMRESOURCE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "LR_SHARED"))
+            #ifdef LR_SHARED
+                return LR_SHARED;
+            #else
+                goto not_there;
+            #endif
+        break;
+    case 'M':
+        if (strEQ(name, "MB_ABORTRETRYIGNORE"))
+            #ifdef MB_ABORTRETRYIGNORE
+                return MB_ABORTRETRYIGNORE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_OK"))
+            #ifdef MB_OK
+                return MB_OK;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_OKCANCEL"))
+            #ifdef MB_OKCANCEL
+                return MB_OKCANCEL;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_RETRYCANCEL"))
+            #ifdef MB_RETRYCANCEL
+                return MB_RETRYCANCEL;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_YESNO"))
+            #ifdef MB_YESNO
+                return MB_YESNO;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_YESNOCANCEL"))
+            #ifdef MB_YESNOCANCEL
+                return MB_YESNOCANCEL;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_ICONEXCLAMATION"))
+            #ifdef MB_ICONEXCLAMATION
+                return MB_ICONEXCLAMATION;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_ICONWARNING"))
+            #ifdef MB_ICONWARNING
+                return MB_ICONWARNING;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_ICONINFORMATION"))
+            #ifdef MB_ICONINFORMATION
+                return MB_ICONINFORMATION;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_ICONASTERISK"))
+            #ifdef MB_ICONASTERISK
+                return MB_ICONASTERISK;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_ICONQUESTION"))
+            #ifdef MB_ICONQUESTION
+                return MB_ICONQUESTION;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_ICONSTOP"))
+            #ifdef MB_ICONSTOP
+                return MB_ICONSTOP;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_ICONERROR"))
+            #ifdef MB_ICONERROR
+                return MB_ICONERROR;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_ICONHAND"))
+            #ifdef MB_ICONHAND
+                return MB_ICONHAND;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_DEFBUTTON1"))
+            #ifdef MB_DEFBUTTON1
+                return MB_DEFBUTTON1;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_DEFBUTTON2"))
+            #ifdef MB_DEFBUTTON2
+                return MB_DEFBUTTON2;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_DEFBUTTON3"))
+            #ifdef MB_DEFBUTTON3
+                return MB_DEFBUTTON3;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_DEFBUTTON4"))
+            #ifdef MB_DEFBUTTON4
+                return MB_DEFBUTTON4;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_APPLMODAL"))
+            #ifdef MB_APPLMODAL
+                return MB_APPLMODAL;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_SYSTEMMODAL"))
+            #ifdef MB_SYSTEMMODAL
+                return MB_SYSTEMMODAL;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_TASKMODAL"))
+            #ifdef MB_TASKMODAL
+                return MB_TASKMODAL;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_DEFAULT_DESKTOP_ONLY"))
+            #ifdef MB_DEFAULT_DESKTOP_ONLY
+                return MB_DEFAULT_DESKTOP_ONLY;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_HELP"))
+            #ifdef MB_HELP
+                return MB_HELP;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_RIGHT"))
+            #ifdef MB_RIGHT
+                return MB_RIGHT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_RTLREADING"))
+            #ifdef MB_RTLREADING
+                return MB_RTLREADING;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_SETFOREGROUND"))
+            #ifdef MB_SETFOREGROUND
+                return MB_SETFOREGROUND;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_TOPMOST"))
+            #ifdef MB_TOPMOST
+                return MB_TOPMOST;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_SERVICE_NOTIFICATION"))
+            #ifdef MB_SERVICE_NOTIFICATION
+                return MB_SERVICE_NOTIFICATION;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MB_SERVICE_NOTIFICATION_NT3X"))
+            #ifdef MB_SERVICE_NOTIFICATION_NT3X
+                return MB_SERVICE_NOTIFICATION_NT3X;
+            #else
+                goto not_there;
+            #endif
+
+        if (strEQ(name, "MF_POPUP"))
+            #ifdef MF_POPUP
+                return MF_POPUP;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "MF_STRING"))
+            #ifdef MF_STRING
+                return MF_STRING;
+            #else
+                goto not_there;
+            #endif
+
+        break;
+    case 'N':
+        break;
+    case 'O':
+        break;
+    case 'P':
+        break;
+    case 'Q':
+        break;
+    case 'R':
+        break;
+    case 'S':
+        if (strEQ(name, "SM_ARRANGE"))
+            #ifdef SM_ARRANGE
+                return SM_ARRANGE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CLEANBOOT"))
+            #ifdef SM_CLEANBOOT
+                return SM_CLEANBOOT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CMOUSEBUTTONS"))
+            #ifdef SM_CMOUSEBUTTONS
+                return SM_CMOUSEBUTTONS;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXBORDER"))
+            #ifdef SM_CXBORDER
+                return SM_CXBORDER;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYBORDER"))
+            #ifdef SM_CYBORDER
+                return SM_CYBORDER;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXCURSOR"))
+            #ifdef SM_CXCURSOR
+                return SM_CXCURSOR;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYCURSOR"))
+            #ifdef SM_CYCURSOR
+                return SM_CYCURSOR;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXDLGFRAME"))
+            #ifdef SM_CXDLGFRAME
+                return SM_CXDLGFRAME;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYDLGFRAME"))
+            #ifdef SM_CYDLGFRAME
+                return SM_CYDLGFRAME;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXDOUBLECLK"))
+            #ifdef SM_CXDOUBLECLK
+                return SM_CXDOUBLECLK;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYDOUBLECLK"))
+            #ifdef SM_CYDOUBLECLK
+                return SM_CYDOUBLECLK;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXDRAG"))
+            #ifdef SM_CXDRAG
+                return SM_CXDRAG;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYDRAG"))
+            #ifdef SM_CYDRAG
+                return SM_CYDRAG;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXEDGE"))
+            #ifdef SM_CXEDGE
+                return SM_CXEDGE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYEDGE"))
+            #ifdef SM_CYEDGE
+                return SM_CYEDGE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXFIXEDFRAME"))
+            #ifdef SM_CXFIXEDFRAME
+                return SM_CXFIXEDFRAME;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYFIXEDFRAME"))
+            #ifdef SM_CYFIXEDFRAME
+                return SM_CYFIXEDFRAME;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXFRAME"))
+            #ifdef SM_CXFRAME
+                return SM_CXFRAME;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYFRAME"))
+            #ifdef SM_CYFRAME
+                return SM_CYFRAME;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXFULLSCREEN"))
+            #ifdef SM_CXFULLSCREEN
+                return SM_CXFULLSCREEN;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYFULLSCREEN"))
+            #ifdef SM_CYFULLSCREEN
+                return SM_CYFULLSCREEN;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXHSCROLL"))
+            #ifdef SM_CXHSCROLL
+                return SM_CXHSCROLL;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYHSCROLL"))
+            #ifdef SM_CYHSCROLL
+                return SM_CYHSCROLL;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXHTHUMB"))
+            #ifdef SM_CXHTHUMB
+                return SM_CXHTHUMB;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXICON"))
+            #ifdef SM_CXICON
+                return SM_CXICON;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYICON"))
+            #ifdef SM_CYICON
+                return SM_CYICON;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXICONSPACING"))
+            #ifdef SM_CXICONSPACING
+                return SM_CXICONSPACING;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYICONSPACING"))
+            #ifdef SM_CYICONSPACING
+                return SM_CYICONSPACING;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXMAXIMIZED"))
+            #ifdef SM_CXMAXIMIZED
+                return SM_CXMAXIMIZED;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYMAXIMIZED"))
+            #ifdef SM_CYMAXIMIZED
+                return SM_CYMAXIMIZED;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXMAXTRACK"))
+            #ifdef SM_CXMAXTRACK
+                return SM_CXMAXTRACK;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYMAXTRACK"))
+            #ifdef SM_CYMAXTRACK
+                return SM_CYMAXTRACK;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXMENUCHECK"))
+            #ifdef SM_CXMENUCHECK
+                return SM_CXMENUCHECK;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYMENUCHECK"))
+            #ifdef SM_CYMENUCHECK
+                return SM_CYMENUCHECK;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXMENUSIZE"))
+            #ifdef SM_CXMENUSIZE
+                return SM_CXMENUSIZE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYMENUSIZE"))
+            #ifdef SM_CYMENUSIZE
+                return SM_CYMENUSIZE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXMIN"))
+            #ifdef SM_CXMIN
+                return SM_CXMIN;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYMIN"))
+            #ifdef SM_CYMIN
+                return SM_CYMIN;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXMINIMIZED"))
+            #ifdef SM_CXMINIMIZED
+                return SM_CXMINIMIZED;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYMINIMIZED"))
+            #ifdef SM_CYMINIMIZED
+                return SM_CYMINIMIZED;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXMINSPACING"))
+            #ifdef SM_CXMINSPACING
+                return SM_CXMINSPACING;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYMINSPACING"))
+            #ifdef SM_CYMINSPACING
+                return SM_CYMINSPACING;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXMINTRACK"))
+            #ifdef SM_CXMINTRACK
+                return SM_CXMINTRACK;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYMINTRACK"))
+            #ifdef SM_CYMINTRACK
+                return SM_CYMINTRACK;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXSCREEN"))
+            #ifdef SM_CXSCREEN
+                return SM_CXSCREEN;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYSCREEN"))
+            #ifdef SM_CYSCREEN
+                return SM_CYSCREEN;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXSIZE"))
+            #ifdef SM_CXSIZE
+                return SM_CXSIZE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYSIZE"))
+            #ifdef SM_CYSIZE
+                return SM_CYSIZE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXSIZEFRAME"))
+            #ifdef SM_CXSIZEFRAME
+                return SM_CXSIZEFRAME;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYSIZEFRAME"))
+            #ifdef SM_CYSIZEFRAME
+                return SM_CYSIZEFRAME;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXSMICON"))
+            #ifdef SM_CXSMICON
+                return SM_CXSMICON;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYSMICON"))
+            #ifdef SM_CYSMICON
+                return SM_CYSMICON;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXSMSIZE"))
+            #ifdef SM_CXSMSIZE
+                return SM_CXSMSIZE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYSMSIZE"))
+            #ifdef SM_CYSMSIZE
+                return SM_CYSMSIZE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CXVSCROLL"))
+            #ifdef SM_CXVSCROLL
+                return SM_CXVSCROLL;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYVSCROLL"))
+            #ifdef SM_CYVSCROLL
+                return SM_CYVSCROLL;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYCAPTION"))
+            #ifdef SM_CYCAPTION
+                return SM_CYCAPTION;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYKANJIWINDOW"))
+            #ifdef SM_CYKANJIWINDOW
+                return SM_CYKANJIWINDOW;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYMENU"))
+            #ifdef SM_CYMENU
+                return SM_CYMENU;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYSMCAPTION"))
+            #ifdef SM_CYSMCAPTION
+                return SM_CYSMCAPTION;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_CYVTHUMB"))
+            #ifdef SM_CYVTHUMB
+                return SM_CYVTHUMB;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_DBCSENABLED"))
+            #ifdef SM_DBCSENABLED
+                return SM_DBCSENABLED;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_DEBUG"))
+            #ifdef SM_DEBUG
+                return SM_DEBUG;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_MENUDROPALIGNMENT"))
+            #ifdef SM_MENUDROPALIGNMENT
+                return SM_MENUDROPALIGNMENT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_MIDEASTENABLED"))
+            #ifdef SM_MIDEASTENABLED
+                return SM_MIDEASTENABLED;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_MOUSEPRESENT"))
+            #ifdef SM_MOUSEPRESENT
+                return SM_MOUSEPRESENT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_MOUSEWHEELPRESENT"))
+            #ifdef SM_MOUSEWHEELPRESENT
+                return SM_MOUSEWHEELPRESENT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_NETWORK"))
+            #ifdef SM_NETWORK
+                return SM_NETWORK;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_PENWINDOWS"))
+            #ifdef SM_PENWINDOWS
+                return SM_PENWINDOWS;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_SECURE"))
+            #ifdef SM_SECURE
+                return SM_SECURE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_SHOWSOUNDS"))
+            #ifdef SM_SHOWSOUNDS
+                return SM_SHOWSOUNDS;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_SLOWMACHINE"))
+            #ifdef SM_SLOWMACHINE
+                return SM_SLOWMACHINE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "SM_SWAPBUTTON"))
+            #ifdef SM_SWAPBUTTON
+                return SM_SWAPBUTTON;
+            #else
+                goto not_there;
+            #endif
+        break;
+    case 'T':
+         if (strEQ(name, "TPM_LEFTBUTTON"))
+             #ifdef TPM_LEFTBUTTON
+                 return TPM_LEFTBUTTON;
+             #else
+                 goto not_there;
+             #endif
+         if (strEQ(name, "TPM_RIGHTBUTTON"))
+             #ifdef TPM_RIGHTBUTTON
+                 return TPM_RIGHTBUTTON;
+             #else
+                 goto not_there;
+             #endif
+         if (strEQ(name, "TPM_LEFTALIGN"))
+             #ifdef TPM_LEFTALIGN
+                 return TPM_LEFTALIGN;
+             #else
+                 goto not_there;
+             #endif
+         if (strEQ(name, "TPM_CENTERALIGN"))
+             #ifdef TPM_CENTERALIGN
+                 return TPM_CENTERALIGN;
+             #else
+                 goto not_there;
+             #endif
+         if (strEQ(name, "TPM_RIGHTALIGN"))
+             #ifdef TPM_RIGHTALIGN
+                 return TPM_RIGHTALIGN;
+             #else
+                 goto not_there;
+             #endif
+         if (strEQ(name, "TPM_TOPALIGN"))
+             #ifdef TPM_TOPALIGN
+                 return TPM_TOPALIGN;
+             #else
+                 goto not_there;
+             #endif
+         if (strEQ(name, "TPM_VCENTERALIGN"))
+             #ifdef TPM_VCENTERALIGN
+                 return TPM_VCENTERALIGN;
+             #else
+                 goto not_there;
+             #endif
+         if (strEQ(name, "TPM_BOTTOMALIGN"))
+             #ifdef TPM_BOTTOMALIGN
+                 return TPM_BOTTOMALIGN;
+             #else
+                 goto not_there;
+             #endif
+         if (strEQ(name, "TPM_HORIZONTAL"))
+             #ifdef TPM_HORIZONTAL
+                 return TPM_HORIZONTAL;
+             #else
+                 goto not_there;
+             #endif
+         if (strEQ(name, "TPM_VERTICAL"))
+             #ifdef TPM_VERTICAL
+                 return TPM_VERTICAL;
+             #else
+                 goto not_there;
+             #endif
+         if (strEQ(name, "TMP_NONOTIFY"))
+             #ifdef TMP_NONOTIFY
+                 return TMP_NONOTIFY;
+             #else
+                 goto not_there;
+             #endif
+         if (strEQ(name, "TPM_RETURNCMD"))
+             #ifdef TPM_RETURNCMD
+                 return TPM_RETURNCMD;
+             #else
+                 goto not_there;
+             #endif
+         if (strEQ(name, "TPM_RECURSE"))
+             #ifdef TPM_RECURSE
+                 return TPM_RECURSE;
+             #else
+                 goto not_there;
+             #endif
+        break;
+    case 'U':
+        break;
+    case 'V':
+        break;
+    case 'W':
+
+        if (strEQ(name, "WIN32__GUI__WINDOW"))
+            return WIN32__GUI__WINDOW;
+        else if (strEQ(name, "WIN32__GUI__DIALOG"))
+            return WIN32__GUI__DIALOG;
+        else if (strEQ(name, "WIN32__GUI__STATIC"))
+            return WIN32__GUI__STATIC;
+        else if (strEQ(name, "WIN32__GUI__BUTTON"))
+            return WIN32__GUI__BUTTON;
+        else if (strEQ(name, "WIN32__GUI__EDIT"))
+            return WIN32__GUI__EDIT;
+        else if (strEQ(name, "WIN32__GUI__LISTBOX"))
+            return WIN32__GUI__LISTBOX;
+        else if (strEQ(name, "WIN32__GUI__COMBOBOX"))
+            return WIN32__GUI__COMBOBOX;
+        else if (strEQ(name, "WIN32__GUI__CHECKBOX"))
+            return WIN32__GUI__CHECKBOX;
+        else if (strEQ(name, "WIN32__GUI__RADIOBUTTON"))
+            return WIN32__GUI__RADIOBUTTON;
+        else if (strEQ(name, "WIN32__GUI__TOOLBAR"))
+            return WIN32__GUI__TOOLBAR;
+        else if (strEQ(name, "WIN32__GUI__PROGRESS"))
+            return WIN32__GUI__PROGRESS;
+        else if (strEQ(name, "WIN32__GUI__STATUS"))
+            return WIN32__GUI__STATUS;
+        else if (strEQ(name, "WIN32__GUI__TAB"))
+            return WIN32__GUI__TAB;
+        else if (strEQ(name, "WIN32__GUI__RICHEDIT"))
+            return WIN32__GUI__RICHEDIT;
+        else if (strEQ(name, "WIN32__GUI__LISTVIEW"))
+            return WIN32__GUI__LISTVIEW;
+        else if (strEQ(name, "WIN32__GUI__TREEVIEW"))
+            return WIN32__GUI__TREEVIEW;
+        else if (strEQ(name, "WIN32__GUI__TRACKBAR"))
+            return WIN32__GUI__TRACKBAR;
+        else if (strEQ(name, "WIN32__GUI__UPDOWN"))
+            return WIN32__GUI__UPDOWN;
+        else if (strEQ(name, "WIN32__GUI__TOOLTIP"))
+            return WIN32__GUI__TOOLTIP;
+        else if (strEQ(name, "WIN32__GUI__ANIMATION"))
+            return WIN32__GUI__ANIMATION;
+        else if (strEQ(name, "WIN32__GUI__REBAR"))
+            return WIN32__GUI__REBAR;
+        else if (strEQ(name, "WIN32__GUI__HEADER"))
+            return WIN32__GUI__HEADER;
+        else if (strEQ(name, "WIN32__GUI__COMBOBOXEX"))
+            return WIN32__GUI__COMBOBOXEX;
+        else if (strEQ(name, "WIN32__GUI__DTPICK"))
+            return WIN32__GUI__DTPICK;
+        else if (strEQ(name, "WIN32__GUI__GRAPHIC"))
+            return WIN32__GUI__GRAPHIC;
+        else if (strEQ(name, "WIN32__GUI__GROUPBOX"))
+            return WIN32__GUI__GROUPBOX;
+        else if (strEQ(name, "WIN32__GUI__SPLITTER"))
+            return WIN32__GUI__SPLITTER;
+        else if (strEQ(name, "WIN32__GUI__MDICLIENT"))
+            return WIN32__GUI__MDICLIENT;
+        if (strEQ(name, "WM_CREATE"))
+            #ifdef WM_CREATE
+                return WM_CREATE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WM_DESTROY"))
+            #ifdef WM_DESTROY
+                return WM_DESTROY;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WM_MOVE"))
+            #ifdef WM_MOVE
+                return WM_MOVE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WM_SIZE"))
+            #ifdef WM_SIZE
+                return WM_SIZE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WM_ACTIVATE"))
+            #ifdef WM_ACTIVATE
+                return WM_ACTIVATE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WM_SETFOCUS"))
+            #ifdef WM_SETFOCUS
+                return WM_SETFOCUS;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WM_KILLFOCUS"))
+            #ifdef WM_KILLFOCUS
+                return WM_KILLFOCUS;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WM_ENABLE"))
+            #ifdef WM_ENABLE
+                return WM_ENABLE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WM_SETREDRAW"))
+            #ifdef WM_SETREDRAW
+                return WM_SETREDRAW;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WM_COMMAND"))
+            #ifdef WM_COMMAND
+                return WM_COMMAND;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WM_KEYDOWN"))
+            #ifdef WM_KEYDOWN
+                return WM_KEYDOWN;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WM_SETCURSOR"))
+            #ifdef WM_SETCURSOR
+                return WM_SETCURSOR;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WM_KEYUP"))
+            #ifdef WM_KEYUP
+                return WM_KEYUP;
+            #else
+                goto not_there;
+            #endif
+
+        if (strEQ(name, "WS_BORDER"))
+            #ifdef WS_BORDER
+                return WS_BORDER;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_CAPTION"))
+            #ifdef WS_CAPTION
+                return WS_CAPTION;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_CHILD"))
+            #ifdef WS_CHILD
+                return WS_CHILD;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_CHILDWINDOW"))
+            #ifdef WS_CHILDWINDOW
+                return WS_CHILDWINDOW;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_CLIPCHILDREN"))
+            #ifdef WS_CLIPCHILDREN
+                return WS_CLIPCHILDREN;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_CLIPSIBLINGS"))
+            #ifdef WS_CLIPSIBLINGS
+                return WS_CLIPSIBLINGS;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_DISABLED"))
+            #ifdef WS_DISABLED
+                return WS_DISABLED;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_DLGFRAME"))
+            #ifdef WS_DLGFRAME
+                return WS_DLGFRAME;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_GROUP"))
+            #ifdef WS_GROUP
+                return WS_GROUP;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_HSCROLL"))
+            #ifdef WS_HSCROLL
+                return WS_HSCROLL;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_ICONIC"))
+            #ifdef WS_ICONIC
+                return WS_ICONIC;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_MAXIMIZE"))
+            #ifdef WS_MAXIMIZE
+                return WS_MAXIMIZE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_MAXIMIZEBOX"))
+            #ifdef WS_MAXIMIZEBOX
+                return WS_MAXIMIZEBOX;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_MINIMIZE"))
+            #ifdef WS_MINIMIZE
+                return WS_MINIMIZE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_MINIMIZEBOX"))
+            #ifdef WS_MINIMIZEBOX
+                return WS_MINIMIZEBOX;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_OVERLAPPED"))
+            #ifdef WS_OVERLAPPED
+                return WS_OVERLAPPED;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_OVERLAPPEDWINDOW"))
+            #ifdef WS_OVERLAPPEDWINDOW
+                return WS_OVERLAPPEDWINDOW;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_POPUP"))
+            #ifdef WS_POPUP
+                return WS_POPUP;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_POPUPWINDOW"))
+            #ifdef WS_POPUPWINDOW
+                return WS_POPUPWINDOW;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_SIZEBOX"))
+            #ifdef WS_SIZEBOX
+                return WS_SIZEBOX;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_SYSMENU"))
+            #ifdef WS_SYSMENU
+                return WS_SYSMENU;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_TABSTOP"))
+            #ifdef WS_TABSTOP
+                return WS_TABSTOP;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_THICKFRAME"))
+            #ifdef WS_THICKFRAME
+                return WS_THICKFRAME;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_TILED"))
+            #ifdef WS_TILED
+                return WS_TILED;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_TILEDWINDOW"))
+            #ifdef WS_TILEDWINDOW
+                return WS_TILEDWINDOW;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_VISIBLE"))
+            #ifdef WS_VISIBLE
+                return WS_VISIBLE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_VSCROLL"))
+            #ifdef WS_VSCROLL
+                return WS_VSCROLL;
+            #else
+                goto not_there;
+            #endif
+
+
+        if (strEQ(name, "WS_EX_ACCEPTFILES"))
+            #ifdef WS_EX_ACCEPTFILES
+                return WS_EX_ACCEPTFILES;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_APPWINDOW"))
+            #ifdef WS_EX_APPWINDOW
+                return WS_EX_APPWINDOW;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_CLIENTEDGE"))
+            #ifdef WS_EX_CLIENTEDGE
+                return WS_EX_CLIENTEDGE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_CONTEXTHELP"))
+            #ifdef WS_EX_CONTEXTHELP
+                return WS_EX_CONTEXTHELP;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_CONTROLPARENT"))
+            #ifdef WS_EX_CONTROLPARENT
+                return WS_EX_CONTROLPARENT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_DLGMODALFRAME"))
+            #ifdef WS_EX_DLGMODALFRAME
+                return WS_EX_DLGMODALFRAME;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_LEFT"))
+            #ifdef WS_EX_LEFT
+                return WS_EX_LEFT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_LEFTSCROLLBAR"))
+            #ifdef WS_EX_LEFTSCROLLBAR
+                return WS_EX_LEFTSCROLLBAR;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_LTRREADING"))
+            #ifdef WS_EX_LTRREADING
+                return WS_EX_LTRREADING;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_MDICHILD"))
+            #ifdef WS_EX_MDICHILD
+                return WS_EX_MDICHILD;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_NOPARENTNOTIFY"))
+            #ifdef WS_EX_NOPARENTNOTIFY
+                return WS_EX_NOPARENTNOTIFY;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_OVERLAPPEDWINDOW"))
+            #ifdef WS_EX_OVERLAPPEDWINDOW
+                return WS_EX_OVERLAPPEDWINDOW;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_PALETTEWINDOW"))
+            #ifdef WS_EX_PALETTEWINDOW
+                return WS_EX_PALETTEWINDOW;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_RIGHT"))
+            #ifdef WS_EX_RIGHT
+                return WS_EX_RIGHT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_RIGHTSCROLLBAR"))
+            #ifdef WS_EX_RIGHTSCROLLBAR
+                return WS_EX_RIGHTSCROLLBAR;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_RTLREADING"))
+            #ifdef WS_EX_RTLREADING
+                return WS_EX_RTLREADING;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_STATICEDGE"))
+            #ifdef WS_EX_STATICEDGE
+                return WS_EX_STATICEDGE;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_TOOLWINDOW"))
+            #ifdef WS_EX_TOOLWINDOW
+                return WS_EX_TOOLWINDOW;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_TOPMOST"))
+            #ifdef WS_EX_TOPMOST
+                return WS_EX_TOPMOST;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_TRANSPARENT"))
+            #ifdef WS_EX_TRANSPARENT
+                return WS_EX_TRANSPARENT;
+            #else
+                goto not_there;
+            #endif
+        if (strEQ(name, "WS_EX_WINDOWEDGE"))
+            #ifdef WS_EX_WINDOWEDGE
+                return WS_EX_WINDOWEDGE;
+            #else
+                goto not_there;
+            #endif
+        break;
+    case 'X':
+        break;
+    case 'Y':
+        break;
+    case 'Z':
+        break;
+    }
+    errno = EINVAL;
+    return 0;
+
+not_there:
+    errno = ENOENT;
+    return 0;
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/GUI_Events.cpp perl-libwin32-0.191/GUI/GUI_Events.cpp
--- libwin32-0.191/GUI/GUI_Events.cpp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/GUI_Events.cpp	2004-01-12 16:46:39.953125000 -0800
@@ -0,0 +1,516 @@
+	/*
+    ###########################################################################
+    # event processing routines
+	#
+	# $Id: GUI_Events.cpp,v 1.3 2003/12/28 07:17:43 caelum Exp $
+	#
+    ###########################################################################
+	*/
+
+#include "GUI.h"
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:ProcessEventError(Name, *PerlResult)
+     # Pops up a message box in case of error within an event;
+     # returns TRUE if errors were, FALSE otherwise, and sets PerlResult
+     # according to user's click (CANCEL == -1),
+     */
+BOOL ProcessEventError(NOTXSPROC char *Name, int* PerlResult) {
+    if(strncmp(Name, "main::", 6) == 0) Name += 6;
+    if(SvTRUE(ERRSV)) {
+        MessageBeep(MB_ICONASTERISK);
+        *PerlResult = MessageBox(
+            NULL,
+            SvPV_nolen(ERRSV),
+            Name,
+            MB_ICONERROR | MB_OKCANCEL
+        );
+        if(*PerlResult == IDCANCEL) {
+            *PerlResult = -1;
+        }
+        return TRUE;
+    } else {
+        return FALSE;
+    }
+}
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:DoEvent_Generic(name)
+     # Calls an event without arguments;
+     # Name must be pre-filled.
+     */
+int DoEvent_Generic(NOTXSPROC char *Name) {
+    int PerlResult;
+    int count;
+    PerlResult = 1;
+#ifdef PERLWIN32GUI_DEBUG
+    printf("!XS(DoEvent_Generic): EVENT: %s\n", Name);
+#endif
+    if(perl_get_cv(Name, FALSE) != NULL) {
+        dSP;
+        ENTER;
+        SAVETMPS;
+        PUSHMARK(SP);
+        PUTBACK;
+        count = perl_call_pv(Name, G_EVAL|G_NOARGS);
+        SPAGAIN;
+        if(!ProcessEventError(NOTXSCALL Name, &PerlResult)) {
+            if(count > 0) PerlResult = POPi;
+        }
+        PUTBACK;
+        FREETMPS;
+        LEAVE;
+    }
+#ifdef PERLWIN32GUI_DEBUG
+    printf("!XS(DoEvent_Generic): returning %d\n", PerlResult);
+#endif
+    return PerlResult;
+}
+
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:DoEvent_Long(name,arg)
+     # Same as above, but with a long argument.
+     */
+int DoEvent_Long(NOTXSPROC char *Name, long argh) {
+    int PerlResult;
+    int count;
+    PerlResult = 1;
+#ifdef PERLWIN32GUI_DEBUG
+    printf("!XS(DoEvent_Long): EVENT: %s\n", Name);
+#endif
+    if(perl_get_cv(Name, FALSE) != NULL) {
+        dSP;
+        ENTER ;
+        SAVETMPS;
+        PUSHMARK(SP) ;
+        XPUSHs(sv_2mortal(newSViv(argh)));
+        PUTBACK ;
+        count = perl_call_pv(Name, G_EVAL|G_ARRAY);
+        SPAGAIN ;
+        if(!ProcessEventError(NOTXSCALL Name, &PerlResult)) {
+            if(count > 0) PerlResult = POPi;
+        }
+        PUTBACK ;
+        FREETMPS ;
+        LEAVE ;
+    }
+    return PerlResult;
+}
+
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:DoEvent_TwoLongs(name,arg1,arg2)
+     # Same as above, but with two long arguments.
+     */
+int DoEvent_TwoLongs(NOTXSPROC char *Name, long argone, long argtwo) {
+    int PerlResult;
+    int count;
+    PerlResult = 1;
+#ifdef PERLWIN32GUI_DEBUG
+    printf("!XS(DoEvent_TwoLongs): EVENT: %s\n", Name);
+#endif
+    if(perl_get_cv(Name, FALSE) != NULL) {
+        dSP;
+        ENTER ;
+        SAVETMPS;
+        PUSHMARK(SP) ;
+        XPUSHs(sv_2mortal(newSViv(argone)));
+        XPUSHs(sv_2mortal(newSViv(argtwo)));
+        PUTBACK ;
+        count = perl_call_pv(Name, G_EVAL|G_ARRAY);
+        SPAGAIN ;
+        if(!ProcessEventError(NOTXSCALL Name, &PerlResult)) {
+            if(count > 0) PerlResult = POPi;
+        }
+        PUTBACK ;
+        FREETMPS ;
+        LEAVE ;
+    }
+    return PerlResult;
+}
+
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:DoEvent_ButtonClick(name, wparam)
+     # calls a toolbar's WM_COMMAND event
+     # adds "_ButtonClick" to Name
+     */
+int DoEvent_ButtonClick(NOTXSPROC char *Name, WPARAM wParam) {
+    int PerlResult;
+    int count;
+    PerlResult = 1;
+    strcat(Name, "_ButtonClick");
+#ifdef PERLWIN32GUI_DEBUG
+    printf("!XS(DoEvent_ButtonClick): EVENT: %s\n", Name);
+#endif
+    if(perl_get_cv(Name, FALSE) != NULL) {
+        dSP;
+        ENTER ;
+        SAVETMPS;
+        PUSHMARK(SP) ;
+        XPUSHs(sv_2mortal(newSViv(LOWORD(wParam))));
+        PUTBACK ;
+        count = perl_call_pv(Name, G_EVAL|G_ARRAY);
+        SPAGAIN ;
+        if(!ProcessEventError(NOTXSCALL Name, &PerlResult)) {
+            if(count > 0) PerlResult = POPi;
+        }
+        PUTBACK ;
+        FREETMPS ;
+        LEAVE ;
+    }
+    return PerlResult;
+}
+
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:DoEvent_ListView(name, lparam)
+     # calls a listview's item event
+     */
+int DoEvent_ListView(NOTXSPROC char *Name, LPARAM lParam) {
+    int PerlResult;
+    int count;
+    LPNM_LISTVIEW lv_notify;
+    long argh;
+    PerlResult = 1;
+    lv_notify = (LPNM_LISTVIEW) lParam;
+    switch(lv_notify->hdr.code) {
+    case LVN_ITEMCHANGED:
+        strcat(Name, "_ItemClick");
+        argh = (long) lv_notify->iItem;
+        break;
+    case LVN_COLUMNCLICK:
+        strcat(Name, "_ColumnClick");
+        argh = (long) lv_notify->iSubItem;
+        break;
+    }
+#ifdef PERLWIN32GUI_DEBUG
+    printf("!XS(DoEvent_ListView): EVENT: %s\n", Name);
+#endif
+    if(perl_get_cv(Name, FALSE) != NULL) {
+        dSP;
+        ENTER ;
+        SAVETMPS;
+        PUSHMARK(SP) ;
+        XPUSHs(sv_2mortal(newSViv(argh)));
+        PUTBACK ;
+        count = perl_call_pv(Name, G_EVAL|G_ARRAY);
+        SPAGAIN ;
+        if(!ProcessEventError(NOTXSCALL Name, &PerlResult)) {
+            if(count > 0) PerlResult = POPi;
+        }
+        PUTBACK ;
+        FREETMPS ;
+        LEAVE ;
+    }
+    return PerlResult;
+}
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:DoEvent_TreeView(name, lparam)
+     # calls a treeview's node event
+     */
+int DoEvent_TreeView(NOTXSPROC char *Name, LPARAM lParam) {
+    int PerlResult;
+    int count;
+    LPNM_TREEVIEW tv_notify;
+    PerlResult = 1;
+    tv_notify = (LPNM_TREEVIEW) lParam;
+    switch(tv_notify->hdr.code) {
+    case TVN_SELCHANGED:
+        strcat(Name, "_NodeClick");
+        break;
+    case TVN_ITEMEXPANDED:
+        if(tv_notify->action == TVE_COLLAPSE)
+            strcat(Name, "_Collapse");
+        else
+            strcat(Name, "_Expand");
+        break;
+    case TVN_ITEMEXPANDING:
+        if(tv_notify->action == TVE_COLLAPSE)
+            strcat(Name, "_Collapsing");
+        else
+            strcat(Name, "_Expanding");
+        break;
+    }
+#ifdef PERLWIN32GUI_DEBUG
+    printf("!XS(DoEvent_TreeView): EVENT: %s\n", Name);
+#endif
+	if(perl_get_cv(Name, FALSE) != NULL) {
+        dSP;
+        ENTER ;
+        SAVETMPS;
+        PUSHMARK(SP) ;
+        XPUSHs(sv_2mortal(newSViv((long) tv_notify->itemNew.hItem)));
+        PUTBACK ;
+        count = perl_call_pv(Name, G_EVAL|G_ARRAY);
+        SPAGAIN ;
+        if(!ProcessEventError(NOTXSCALL Name, &PerlResult)) {
+            if(count > 0) PerlResult = POPi;
+        }
+        PUTBACK ;
+        FREETMPS ;
+        LEAVE ;
+    }
+    return PerlResult;
+}
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:DoEvent_MouseMove(name, lparam, wparam)
+     # calls a WM_MOUSEMOVE event
+     # adds "_MouseMove" to Name
+     */
+int DoEvent_MouseMove(NOTXSPROC char *Name, WPARAM wParam, LPARAM lParam) {
+    int PerlResult;
+    int count;
+    PerlResult = 1;
+    strcat(Name, "_MouseMove");
+#ifdef PERLWIN32GUI_DEBUG
+    printf("!XS(DoEvent_MouseMove): EVENT: %s\n", Name);
+#endif
+    if(perl_get_cv(Name, FALSE) != NULL) {
+        dSP;
+        ENTER ;
+        SAVETMPS;
+        PUSHMARK(SP) ;
+        XPUSHs(sv_2mortal(newSViv(wParam)));
+        XPUSHs(sv_2mortal(newSViv(LOWORD(lParam))));
+        XPUSHs(sv_2mortal(newSViv(HIWORD(lParam))));
+        PUTBACK ;
+        count = perl_call_pv(Name, G_EVAL|G_ARRAY);
+        SPAGAIN ;
+        if(!ProcessEventError(NOTXSCALL Name, &PerlResult)) {
+            if(count > 0) PerlResult = POPi;
+        }
+        PUTBACK ;
+        FREETMPS ;
+        LEAVE ;
+    }
+    return PerlResult;
+}
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:DoEvent_MouseButton(name, wparam, lparam)
+     # calls a WM_(L/R)BUTTON(UP/DOWN) event
+     # Name must be pre-filled
+     */
+int DoEvent_MouseButton(NOTXSPROC char *Name, WPARAM wParam, LPARAM lParam) {
+    int PerlResult;
+    int count;
+    PerlResult = 1;
+#ifdef PERLWIN32GUI_DEBUG
+    printf("!XS(DoEvent_MouseButton): EVENT: %s\n", Name);
+#endif
+    if(perl_get_cv(Name, FALSE) != NULL) {
+        dSP;
+        ENTER ;
+        SAVETMPS;
+        PUSHMARK(SP) ;
+        XPUSHs(sv_2mortal(newSViv(wParam)));
+        XPUSHs(sv_2mortal(newSViv(LOWORD(lParam))));
+        XPUSHs(sv_2mortal(newSViv(HIWORD(lParam))));
+        PUTBACK ;
+        count = perl_call_pv(Name, G_EVAL|G_ARRAY);
+        SPAGAIN ;
+        if(!ProcessEventError(NOTXSCALL Name, &PerlResult)) {
+            if(count > 0) PerlResult = POPi;
+        }
+        PUTBACK ;
+        FREETMPS ;
+        LEAVE ;
+    }
+    return PerlResult;
+}
+
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:DoEvent_NeetText(name, id)
+     # calls a TTN_NEEDTEXT event ("callback"?)
+     # adds "_NeedText" to Name
+     */
+char * DoEvent_NeedText(NOTXSPROC char *Name, UINT id) {
+    int PerlResult;
+    static char *textneeded;
+    SV* svt;
+    int count;
+    strcat(Name, "_NeedText");
+    if(textneeded != NULL) {
+        safefree(textneeded);
+        textneeded = NULL;
+    }
+#ifdef PERLWIN32GUI_DEBUG
+    printf("!XS(DoEvent_NeedText): EVENT: %s\n", Name);
+#endif
+    if(perl_get_cv(Name, FALSE) != NULL) {
+        dSP;
+        ENTER ;
+        SAVETMPS;
+        PUSHMARK(SP) ;
+        XPUSHs(sv_2mortal(newSViv(id)));
+        PUTBACK ;
+        count = perl_call_pv(Name, G_EVAL|G_ARRAY);
+        SPAGAIN ;
+        if(!ProcessEventError(NOTXSCALL Name, &PerlResult)) {
+            if(count > 0) {
+                svt = POPs;
+                textneeded = (char *) safemalloc(sv_len(svt));
+                strcpy(textneeded, SvPV_nolen(svt));
+            } else {
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                printf("!XS(DoEvent_NeedText): sub returned nothing\n");
+#endif
+            }
+        }
+        PUTBACK ;
+        FREETMPS ;
+        LEAVE ;
+    }
+#ifdef PERLWIN32GUI_DEBUG
+    printf("!XS(DoEvent_NeedText): returning '%s'\n", textneeded);
+#endif
+    return textneeded;
+}
+
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:DoEvent_NEM(perlud, event_id, name, ...)
+     */
+int DoEvent_NEM(
+	NOTXSPROC
+	LPPERLWIN32GUI_USERDATA perlud,
+	int iEventId,
+	char *Name,
+	...
+) {
+    int PerlResult;
+    int count;
+    int argtype;
+    SV** event;
+    va_list args;
+    va_start( args, Name );
+    PerlResult = -2;
+	if( ValidUserData(perlud) ) {
+#ifdef PERLWIN32GUI_STRONGDEBUG
+	    printf("!XS(DoEvent_NEM) window='%s', event='%s', event_id=0x%x, event_mask=0x%x\n", perlud->szWindowName, Name, iEventId, perlud->dwEventMask);
+#endif
+		if(perlud->dwEventMask & iEventId) {
+			event = hv_fetch( (perlud->hvEvents), Name, strlen(Name), 0);
+			if(event != NULL) {
+#ifdef PERLWIN32GUI_STRONGDEBUG
+			    printf("!XS(DoEvent_NEM) CV found (%s)\n", SvPV_nolen(*event));
+#endif
+				PerlResult = 0;
+
+				dSP;
+				ENTER;
+				SAVETMPS;
+				PUSHMARK(SP);
+				XPUSHs(perlud->svSelf);
+				argtype = va_arg( args, int );
+				while(argtype != -1) {
+					switch(argtype) {
+					case PERLWIN32GUI_ARGTYPE_INT:
+						XPUSHs(sv_2mortal(newSViv(va_arg( args, int ))));
+						break;
+					case PERLWIN32GUI_ARGTYPE_LONG:
+						XPUSHs(sv_2mortal(newSViv(va_arg( args, long ))));
+						break;
+					case PERLWIN32GUI_ARGTYPE_WORD:
+						XPUSHs(sv_2mortal(newSViv(va_arg( args, int))));
+						break;
+					case PERLWIN32GUI_ARGTYPE_STRING:
+						XPUSHs(sv_2mortal(newSVpv(va_arg( args, char * ), 0)));
+						break;
+					default:
+						warn("Win32::GUI: WARNING! unknown argument type (%d) to event '%s'", argtype, Name);
+						break;
+					}
+					argtype = va_arg( args, int );
+				}
+				va_end( args );
+				PUTBACK;
+				count = call_sv(*event, G_EVAL|G_ARRAY);
+				SPAGAIN;
+				if(!ProcessEventError(NOTXSCALL Name, &PerlResult)) {
+					if(count > 0) PerlResult = POPi;
+				}
+				PUTBACK;
+				FREETMPS;
+				LEAVE;
+			}
+		}
+    }
+    va_end(args);
+    return PerlResult;
+}
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:DoEvent_NEM_Menu(nID)
+     */
+int DoEvent_NEM_Menu(
+	NOTXSPROC
+	HWND hwnd,
+	int nID,
+	...
+) {
+    int PerlResult;
+    int count;
+	SV* event;
+    PerlResult = -2;
+
+	event = &PL_sv_undef;
+	MENUITEMINFO mii;
+	HMENU hmenu;
+	LPPERLWIN32GUI_MENUITEMDATA perlmid;
+	ZeroMemory(&mii, sizeof(MENUITEMINFO));
+	mii.cbSize = sizeof(MENUITEMINFO);
+	mii.fMask = MIIM_DATA;
+	/* HEURISTIC: assume the message was from the window's own menu */
+	hmenu = GetMenu(hwnd);
+	/* HEURISTIC: no, it wasn't, search in Perl's global hash  */
+	if(hmenu == NULL) hmenu = GetMenuFromID( NOTXSCALL nID );
+	/* HEURISTIC: if we can get to the item, it's ok, otherwise search in Perl's global hash  */
+    if(GetMenuItemInfo( hmenu, nID, 0, &mii ) == 0) {
+		hmenu = GetMenuFromID( NOTXSCALL nID );
+	}
+    if(GetMenuItemInfo( hmenu, nID, 0, &mii )) {
+		perlmid = (LPPERLWIN32GUI_MENUITEMDATA) mii.dwItemData;
+		if(perlmid != NULL && perlmid->dwSize == sizeof(PERLWIN32GUI_MENUITEMDATA)) {
+			event = perlmid->svCode;
+		}
+	}
+
+	if( event != &PL_sv_undef ) {
+#ifdef PERLWIN32GUI_STRONGDEBUG
+	    printf("!XS(DoEvent_NEM_Menu) CV found (%s)\n", SvPV_nolen(event));
+#endif
+		dSP;
+		ENTER;
+		SAVETMPS;
+		PUSHMARK(SP);
+/*		XPUSHs(perlmid->svSelf); */
+		PUTBACK;
+		count = call_sv(event, G_EVAL|G_ARRAY);
+		SPAGAIN;
+		if(!ProcessEventError(NOTXSCALL "", &PerlResult)) {
+			if(count > 0) PerlResult = POPi;
+		}
+		PUTBACK;
+		FREETMPS;
+		LEAVE;
+	}
+	return PerlResult;
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/GUI_Helpers.cpp perl-libwin32-0.191/GUI/GUI_Helpers.cpp
--- libwin32-0.191/GUI/GUI_Helpers.cpp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/GUI_Helpers.cpp	2004-01-12 16:46:39.968750000 -0800
@@ -0,0 +1,588 @@
+	/*
+    ###########################################################################
+    # helper routines
+	#
+	# $Id: GUI_Helpers.cpp,v 1.3 2003/12/28 07:17:43 caelum Exp $
+	#
+    ###########################################################################
+	*/
+
+#include "GUI.h"
+
+#ifdef PERL_OBJECT
+	CPerl *
+	PERL_OBJECT_FROM_WINDOW(HWND hwnd) {
+		LPPERLWIN32GUI_USERDATA perlud;
+
+		perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(hwnd, GWL_USERDATA);
+		if( ValidUserData(perlud) ) {
+			return perlud->pPerl;
+		} else {
+			return NULL;
+		}
+	}
+#endif
+
+SV *
+SV_SELF_FROM_WINDOW(HWND hwnd) {
+	LPPERLWIN32GUI_USERDATA perlud;
+
+	perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(hwnd, GWL_USERDATA);
+	if( ValidUserData(perlud) ) {
+		return perlud->svSelf;
+	} else {
+		return NULL;
+	}
+}
+
+static void
+hv_magic_check (NOTXSPROC HV *hv, bool *needs_copy, bool *needs_store)
+{
+    MAGIC *mg = SvMAGIC(hv);
+    *needs_copy = FALSE;
+    *needs_store = TRUE;
+    while (mg) {
+	if (isUPPER(mg->mg_type)) {
+	    *needs_copy = TRUE;
+	    switch (mg->mg_type) {
+	    case 'P':
+	    case 'S':
+		*needs_store = FALSE;
+	    }
+	}
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    printf("!XS(hv_magic_check) magic='%c' needs_store='%d'\n", mg->mg_type, *needs_store);
+#endif
+	mg = mg->mg_moremagic;
+    }
+}
+
+SV**
+hv_fetch_mg(NOTXSPROC HV *hv, char *key, U32 klen, I32 lval) {
+	SV** tempsv;
+	tempsv = hv_fetch(hv, key, klen, lval);
+	if(SvMAGICAL(hv)) mg_get(*tempsv);
+	return tempsv;
+}
+
+SV**
+hv_store_mg(NOTXSPROC HV *hv, char *key, U32 klen, SV* val, U32 hash) {
+	SV** tempsv;
+	tempsv = hv_store(hv, key, klen, val, hash);
+	if(SvMAGICAL(hv)) mg_set(val);
+	return tempsv;
+}
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:handle_From(SV*)
+     # gets the handle from either the blessed object
+     # or the SV passed
+     */
+HWND handle_From(NOTXSPROC SV *pSv) {
+    HWND hReturn = 0;
+    char szKey[] = "-handle";
+
+    if(NULL != pSv)  {
+        if( SvROK(pSv)) {
+            SV **pHv;
+            pHv = hv_fetch_mg(NOTXSCALL (HV*)(int)SvRV(pSv), szKey, strlen(szKey), 0);
+            if(pHv != NULL) {
+                hReturn = (HWND)(int)SvIV(*pHv);
+            }
+        } else {
+            hReturn = (HWND)(int)SvIV(pSv);
+        }
+    }
+    return(hReturn);
+}
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:classname_From(SV*)
+     # gets the window class name from either the blessed object
+     # or the SV passed
+     */
+char *classname_From(NOTXSPROC SV *pSv) {
+    char *pszName = NULL;
+    char szKey[] = "-name";
+
+    if(NULL != pSv) {
+        if(SvROK(pSv)) {
+            SV **pHv;
+            pHv = hv_fetch_mg(NOTXSCALL (HV*) SvRV(pSv), szKey, strlen(szKey), 0);
+            if(pHv != NULL) {
+                pszName = SvPV_nolen(*pHv);
+            }
+        } else {
+            pszName = SvPV_nolen(pSv);
+        }
+    }
+    return(pszName);
+}
+
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:SvCOLORREF(SV*)
+     # returns a COLORREF from either a numerical value
+     # or a color expressed as [RR, GG, BB]
+     # or a color expressed in HTML notation (#RRGGBB)
+     */
+COLORREF SvCOLORREF(NOTXSPROC SV* c) {
+    SV** t;
+    int r;
+    int g;
+    int b;
+    char html_color[8];
+    char html_color_component[3];
+
+	ZeroMemory(html_color, 8);
+	ZeroMemory(html_color_component, 3);
+    r = 0;
+    g = 0;
+    b = 0;
+    if(SvROK(c) && SvTYPE(SvRV(c)) == SVt_PVAV) {
+        t = av_fetch((AV*)SvRV(c), 0, 0);
+        if(t != NULL) {
+            r = SvIV(*t);
+        }
+        t = av_fetch((AV*)SvRV(c), 1, 0);
+        if(t!= NULL) {
+            g = SvIV(*t);
+        }
+        t = av_fetch((AV*)SvRV(c), 2, 0);
+        if(t != NULL) {
+            b = SvIV(*t);
+        }
+        return RGB((BYTE) r, (BYTE) g, (BYTE) b);
+    } else {
+		if(SvPOK(c)) {
+			strncpy(html_color, SvPV_nolen(c), 7);
+			if(strncmp(html_color, "#", 1) == 0) {
+				strncpy(html_color_component, html_color+1, 2);
+				*(html_color_component+2) = 0;
+				sscanf(html_color_component, "%x", &r);
+				strncpy(html_color_component, html_color+3, 2);
+				*(html_color_component+2) = 0;
+				sscanf(html_color_component, "%x", &g);
+				strncpy(html_color_component, html_color+5, 2);
+				*(html_color_component+2) = 0;
+				sscanf(html_color_component, "%x", &b);
+				return RGB((BYTE) r, (BYTE) g, (BYTE) b);
+			} else {
+        		return (COLORREF) SvIV(c);
+			}
+		} else {
+        	return (COLORREF) SvIV(c);
+		}
+    }
+}
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:CreateTooltip(parent)
+     */
+HWND CreateTooltip(
+    NOTXSPROC
+	HV* parent
+) {
+    HWND hTooltip;
+	HWND hParent;
+	SV** t;
+
+	t = hv_fetch_mg(NOTXSCALL parent, "-handle", 7, 0);
+	if(t != NULL) {
+		hParent = (HWND)(int)SvIV(*t);
+	} else {
+		return NULL;
+	}
+
+	hTooltip = CreateWindowEx(
+		0, TOOLTIPS_CLASS, NULL,
+		WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
+		CW_USEDEFAULT, CW_USEDEFAULT,
+		CW_USEDEFAULT, CW_USEDEFAULT,
+    	hParent, NULL, NULL,
+    	NULL
+    );
+	if(hTooltip != NULL) {
+		SetWindowPos(
+			hTooltip, HWND_TOPMOST,0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE
+		);
+		hv_store_mg(NOTXSCALL parent, "-tooltip", 8, newSViv((long) hTooltip), 0);
+	}
+	return hTooltip;
+}
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:CalcControlSize(*perlcs, add_x, add_y)
+     # Used by some control to automatically set width and height at creation
+     # time.
+     */
+void CalcControlSize(
+    NOTXSPROC
+    LPPERLWIN32GUI_CREATESTRUCT perlcs,
+    int add_x,
+    int add_y
+) {
+    SIZE mySize;
+    HDC hdc;
+    SV** font;
+    HFONT hfont;
+    if(perlcs->cs.lpszName != NULL) {
+        if(perlcs->cs.cx == 0 || perlcs->cs.cy == 0) {
+            hdc = GetDC(perlcs->cs.hwndParent);
+            if(perlcs->hFont != NULL) {
+                hfont = perlcs->hFont;
+            } else {
+                hfont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
+                if(perlcs->hvParent != NULL) {
+                    font = hv_fetch_mg(NOTXSCALL perlcs->hvParent, "-font", 5, FALSE);
+                    if(font != NULL && SvOK(*font)) {
+                        hfont = (HFONT) handle_From(NOTXSCALL *font);
+                    }
+                }
+            }
+            SelectObject(hdc, hfont);
+            if(GetTextExtentPoint32(
+                hdc, perlcs->cs.lpszName, strlen(perlcs->cs.lpszName), &mySize
+            )) {
+                if(perlcs->cs.cx == 0) perlcs->cs.cx = mySize.cx + add_x;
+                if(perlcs->cs.cy == 0) perlcs->cs.cy = mySize.cy + add_y;
+            }
+            ReleaseDC(perlcs->cs.hwndParent, hdc);
+        }
+    }
+}
+
+
+
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:GetObjectName(hwnd, *name)
+     # Gets the object's name;
+     # returns FALSE if no name found.
+     */
+BOOL GetObjectName(NOTXSPROC HWND hwnd, char *Name) {
+	LPPERLWIN32GUI_USERDATA perlud;
+	perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(hwnd, GWL_USERDATA);
+	if( ValidUserData(perlud) ) {
+		if(NULL != perlud->szWindowName) {
+			strcat(Name, (char *) perlud->szWindowName);
+			return TRUE;
+		} else {
+			return FALSE;
+		}
+	} else {
+		return FALSE;
+	}
+	/*
+	HV* self;
+    SV** name;
+    self = HV_SELF_FROM_WINDOW(hwnd);
+    if(self == NULL) return FALSE;
+    name = hv_fetch_mg(NOTXSCALL self, "-name", 5, FALSE);
+    if(name == NULL) return FALSE;
+    strcat(Name, (char *) SvPV_nolen(*name));
+    return TRUE;
+	*/
+}
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:GetObjectNameAndClass(hwnd, *name, *class)
+     # Gets the object's name AND class (integer);
+     # returns FALSE if no name found.
+     */
+BOOL GetObjectNameAndClass(NOTXSPROC HWND hwnd, char *Name, int *obj_class) {
+	LPPERLWIN32GUI_USERDATA perlud;
+	perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(hwnd, GWL_USERDATA);
+	if( ValidUserData(perlud) ) {
+		if(NULL != perlud->szWindowName) {
+			strcat(Name, (char *) perlud->szWindowName);
+			*obj_class = perlud->iClass;
+			return TRUE;
+		} else {
+			return FALSE;
+		}
+	} else {
+		return FALSE;
+	}
+	/*
+	HV* self;
+    SV** name;
+    SV** type;
+    self = HV_SELF_FROM_WINDOW(hwnd);
+    if(self == NULL) return FALSE;
+    name = hv_fetch_mg(NOTXSCALL self, "-name", 5, FALSE);
+    if(name == NULL) return FALSE;
+    strcat(Name, (char *) SvPV_nolen(*name));
+    type = hv_fetch_mg(NOTXSCALL self, "-type", 5, FALSE);
+    if(type == NULL) return FALSE;
+    *obj_class = SvIV(*type);
+    return TRUE;
+	*/
+}
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:GetMenuFromID(ID, *name)
+     # Gets the menu handle (HMENU) from the ID, searching in Perl's global
+	 # %Win32::GUI::Menus hash; returns NULL if the handle is not found.
+     */
+HMENU GetMenuFromID(NOTXSPROC int nID) {
+	HV* hash;
+    SV** handle;
+    char temp[80];
+    hash = perl_get_hv("Win32::GUI::Menus", FALSE);
+    itoa(nID, temp, 10);
+    handle = hv_fetch(hash, temp, strlen(temp), FALSE);
+    if(handle == NULL) return NULL;
+    return (HMENU)(int)SvIV(*handle);
+}
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:GetMenuName(ID, *name)
+     # Gets the menu name from the ID;
+     # returns FALSE if no name found.
+     */
+BOOL GetMenuName(NOTXSPROC HWND hwnd, int nID, char *Name) {
+	MENUITEMINFO mii;
+	HMENU hmenu;
+	LPPERLWIN32GUI_MENUITEMDATA perlmid;
+	ZeroMemory(&mii, sizeof(MENUITEMINFO));
+	mii.cbSize = sizeof(MENUITEMINFO);
+	mii.fMask = MIIM_DATA;
+	/* HEURISTIC: assume the message was from the window's own menu */
+	hmenu = GetMenu(hwnd);
+	/* HEURISTIC: no, it wasn't, search in Perl's global hash  */
+	if(hmenu == NULL) hmenu = GetMenuFromID( NOTXSCALL nID );
+	/* HEURISTIC: if we can get to the item, it's ok, otherwise search in Perl's global hash  */
+    if(GetMenuItemInfo( hmenu, nID, 0, &mii ) == 0) {
+		hmenu = GetMenuFromID( NOTXSCALL nID );
+	}
+    if(GetMenuItemInfo( hmenu, nID, 0, &mii )) {
+		perlmid = (LPPERLWIN32GUI_MENUITEMDATA) mii.dwItemData;
+		if(perlmid != NULL && perlmid->dwSize == sizeof(PERLWIN32GUI_MENUITEMDATA)) {
+			strcat(Name, perlmid->szName);
+			return TRUE;
+		} else {
+			return FALSE;
+		}
+	} else {
+		return FALSE;
+	}
+	/*
+	HV* hash;
+    SV** obj;
+    SV** name;
+    char temp[80];
+    hash = perl_get_hv("Win32::GUI::Menus", FALSE);
+    itoa(nID, temp, 10);
+    obj = hv_fetch_mg(NOTXSCALL hash, temp, strlen(temp), FALSE);
+    if(obj == NULL) return FALSE;
+    name = hv_fetch_mg(NOTXSCALL  ( (HV*) SvRV(*obj)), "-name", 5, FALSE);
+    if(name == NULL) return FALSE;
+    strcat(Name, (char *) SvPV_nolen(*name));
+    return TRUE;
+	*/
+}
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:GetAcceleratorName(ID, *name)
+     # Gets the accelerator name from the ID;
+     # returns FALSE if no name found.
+     */
+BOOL GetAcceleratorName(NOTXSPROC int nID, char *Name) {
+    HV* hash;
+    SV** name;
+    char temp[80];
+    hash = perl_get_hv("Win32::GUI::Accelerators", FALSE);
+    itoa(nID, temp, 10);
+    name = hv_fetch_mg(NOTXSCALL hash, temp, strlen(temp), FALSE);
+    if(name == NULL) return FALSE;
+    strcat(Name, (char *) SvPV_nolen(*name));
+    return TRUE;
+}
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:GetTimerName(hwnd, id, *name)
+     # Gets the timer name;
+     # returns FALSE if no name found.
+     */
+BOOL GetTimerName(NOTXSPROC HWND hwnd, UINT nID, char *Name) {
+    HV*  parent;
+    SV** name;
+    SV** robjarray;
+    HV*  objarray;
+    SV** robj;
+    HV*  obj;
+    char temp[80];
+    parent = HV_SELF_FROM_WINDOW(hwnd);
+    if(parent == NULL) return FALSE;
+    itoa(nID, temp, 10);
+    robjarray = hv_fetch_mg(NOTXSCALL parent, "-timers", 7, FALSE);
+    if(robjarray == NULL) return FALSE;
+    objarray = (HV*) SvRV(*robjarray);
+    robj = hv_fetch_mg(NOTXSCALL objarray, temp, strlen(temp), FALSE);
+    if(robj == NULL) return FALSE;
+    obj = (HV*) SvRV(*robj);
+    if(obj == NULL) return FALSE;
+    name = hv_fetch_mg(NOTXSCALL obj, "-name", 5, FALSE);
+    if(name == NULL) return FALSE;
+    strcat(Name, (char *) SvPV_nolen(*name));
+    return TRUE;
+}
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:GetNotifyIconName(hwnd, id, *name)
+     # Gets the NotifyIcon name;
+     # returns FALSE if no name found.
+     */
+BOOL GetNotifyIconName(NOTXSPROC HWND hwnd, UINT nID, char *Name) {
+    HV*  parent;
+    SV** name;
+    SV** robjarray;
+    HV*  objarray;
+    SV** robj;
+    HV*  obj;
+    char temp[80];
+    parent = HV_SELF_FROM_WINDOW(hwnd);
+    if(parent == NULL) return FALSE;
+    itoa(nID, temp, 10);
+    robjarray = hv_fetch_mg(NOTXSCALL parent, "-notifyicons", 12, FALSE);
+    if(robjarray == NULL) return FALSE;
+    objarray = (HV*) SvRV(*robjarray);
+    robj = hv_fetch_mg(NOTXSCALL objarray, temp, strlen(temp), FALSE);
+    if(robj == NULL) return FALSE;
+    obj = (HV*) SvRV(*robj);
+    name = hv_fetch_mg(NOTXSCALL obj, "-name", 5, FALSE);
+    if(name == NULL) return FALSE;
+    strcat(Name, (char *) SvPV_nolen(*name));
+    return TRUE;
+}
+
+
+DWORD CALLBACK RichEditSave(DWORD dwCookie, LPBYTE pbBuff, LONG cb, LONG FAR *pcb) {
+    HANDLE hfile;
+    hfile = (HANDLE) dwCookie;
+    WriteFile(hfile, (LPCVOID) pbBuff, (DWORD) cb, (LPDWORD) pcb, NULL);
+    return(0);
+}
+
+DWORD CALLBACK RichEditLoad(DWORD dwCookie, LPBYTE pbBuff, LONG cb, LONG FAR *pcb) {
+    HANDLE hfile;
+    hfile = (HANDLE) dwCookie;
+    ReadFile(hfile, (LPVOID) pbBuff, (DWORD) cb, (LPDWORD) pcb, NULL);
+    return(0);
+}
+
+int CALLBACK BrowseForFolderProc(HWND hWnd, UINT uMsg, LPARAM lParam, LPARAM lpData) {
+	UNREFERENCED_PARAMETER(lParam);
+
+	if (uMsg == BFFM_INITIALIZED && lpData != 0) {
+		SendMessage(hWnd, BFFM_SETSELECTION, TRUE, lpData);
+	}
+	return(0);
+}
+
+/*
+BOOL EnumChildsProc(HWND hwnd, LPARAM lParam) {
+#ifdef PERL_OBJECT
+    CPerl *pPerl = PERL_OBJECT_FROM_WINDOW(hwnd);
+#endif
+    XPUSHs(HV_SELF_FROM_WINDOW(hwnd));
+    ((UINT)*lParam)++;
+    return TRUE;
+}
+*/
+    /*
+     ##########################################################################
+     # (@)INTERNAL:AdjustSplitterCoord(self, x)
+     */
+int AdjustSplitterCoord(NOTXSPROC LPPERLWIN32GUI_USERDATA perlud, int x, HWND phwnd) {
+	int min, max;
+	int adjusted;
+	RECT rc;
+	adjusted = x;
+	min = -1;
+	min = perlud->iMinWidth;
+	if(min == -1) min = 0;
+	GetClientRect(phwnd, &rc);
+	max = -1;
+	max = perlud->iMaxWidth;
+	if(max == -1) max = rc.right;
+	if(adjusted < min) adjusted = min;
+	if(adjusted > max) adjusted = max;
+	return(adjusted);
+}
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:DrawSplitter(hwnd)
+     */
+void DrawSplitter(NOTXSPROC HWND hwnd) {
+	RECT rc;
+	HDC hdc;
+	HBRUSH oldBrush;
+	HPEN oldPen;
+
+	hdc = GetDC(hwnd);
+	oldBrush = (HBRUSH) SelectObject(hdc, GetStockObject(GRAY_BRUSH));
+	oldPen   = (HPEN)   SelectObject(hdc, GetStockObject(NULL_PEN));
+	GetClientRect(hwnd, &rc);
+	PatBlt(hdc, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, DSTINVERT);
+	if(oldBrush != NULL) SelectObject(hdc, oldBrush);
+	if(oldPen   != NULL) SelectObject(hdc, oldPen  );
+	ReleaseDC(hwnd, hdc);
+}
+
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:EnumMyWindowsProc(hwnd, lparam)
+     */
+BOOL CALLBACK EnumMyWindowsProc(HWND hwnd, LPARAM lparam) {
+#ifdef PERL_OBJECT
+	CPerl *pPerl = PERL_OBJECT_FROM_WINDOW(hwnd);
+#endif
+	AV* ary;
+	DWORD pid;
+	DWORD style;
+	ary = (AV*) lparam;
+	GetWindowThreadProcessId(hwnd, &pid);
+	if(pid == GetCurrentProcessId()) {
+		style = (DWORD) GetWindowLong(hwnd, GWL_STYLE);
+		if(!(style & GW_CHILD)) {
+			av_push(ary, newSViv((long)hwnd));
+		}
+	}
+	return TRUE;
+}
+
+    /*
+     ##########################################################################
+     # (@)INTERNAL:CountMyWindowsProc(hwnd, lparam)
+     # specialized version of EnumMyWindowsProc for DoModal
+     */
+BOOL CALLBACK CountMyWindowsProc(HWND hwnd, LPARAM lparam) {
+	DWORD pid;
+	DWORD style;
+	int * i;
+	i = (int *) lparam;
+	GetWindowThreadProcessId(hwnd, &pid);
+	if(pid == GetCurrentProcessId()) {
+		style = (DWORD) GetWindowLong(hwnd, GWL_STYLE);
+		if(!(style & GW_CHILD)) {
+			*i += 1;
+		}
+	}
+	return TRUE;
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/GUI_MessageLoops.cpp perl-libwin32-0.191/GUI/GUI_MessageLoops.cpp
--- libwin32-0.191/GUI/GUI_MessageLoops.cpp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/GUI_MessageLoops.cpp	2004-01-12 16:46:39.984375000 -0800
@@ -0,0 +1,2427 @@
+        /*
+    ###########################################################################
+    # message loops
+    #
+    # $Id: GUI_MessageLoops.cpp,v 1.4 2003/12/28 07:17:43 caelum Exp $
+    #
+    ###########################################################################
+        */
+
+#include "GUI.h"
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:CommonMsgLoop(hwnd, uMsg, wParam, lParam)
+    # this is the message loop (WndProc) that process common messages
+    # (eventmodel independent)
+    */
+LRESULT CommonMsgLoop(NOTXSPROC HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    printf("!XS(CommonMsgLoop) got (0x%x, 0x%x, 0x%x, 0x%x)\n", hwnd, uMsg, wParam, lParam);
+#endif
+    switch(uMsg) {
+
+    case WM_CTLCOLOREDIT:
+    case WM_CTLCOLORSTATIC:
+    case WM_CTLCOLORBTN:
+    case WM_CTLCOLORLISTBOX:
+        {
+            LPPERLWIN32GUI_USERDATA perlud;
+
+            /*
+            if(uMsg == WM_CTLCOLORSTATIC
+            && GetWindowLong((HWND) lParam, GWL_STYLE) & SS_SIMPLE) {
+            FREETMPS;
+            LEAVE;
+            return FALSE;
+            }
+            */
+
+            perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong((HWND) lParam, GWL_USERDATA);
+            if( ! ValidUserData(perlud) ) {
+                HBRUSH defBrush;
+                switch(uMsg) {
+                case WM_CTLCOLOREDIT:
+                case WM_CTLCOLORLISTBOX:
+                    defBrush = GetSysColorBrush(COLOR_WINDOW);
+                    break;
+                default:
+                    defBrush = GetSysColorBrush(COLOR_BTNFACE);
+                    break;
+                }
+                return ((LRESULT) defBrush);
+            }
+
+            if(uMsg == WM_CTLCOLORSTATIC) SetBkMode((HDC) wParam, TRANSPARENT);
+            if(perlud->clrForeground != CLR_INVALID) {
+                SetTextColor((HDC) wParam, perlud->clrForeground);
+            }
+            if(perlud->clrBackground != CLR_INVALID) {
+                SetBkColor((HDC) wParam, perlud->clrBackground);
+                return ((LRESULT) perlud->hBackgroundBrush);
+            } else {
+                HBRUSH defBrush;
+                switch(uMsg) {
+                case WM_CTLCOLOREDIT:
+                case WM_CTLCOLORLISTBOX:
+                    defBrush = GetSysColorBrush(COLOR_WINDOW);
+                    break;
+                default:
+                    defBrush = GetSysColorBrush(COLOR_BTNFACE);
+                    break;
+                }
+                return ((LRESULT) defBrush);
+            }
+        }
+        break;
+
+    case WM_GETMINMAXINFO:
+        {
+            LPMINMAXINFO minmax;
+            LPPERLWIN32GUI_USERDATA perlud;
+            perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(hwnd, GWL_USERDATA);
+            if( ValidUserData(perlud) ) {
+                minmax = (LPMINMAXINFO) lParam;
+                if(perlud->iMinWidth != -1) minmax->ptMinTrackSize.x = (LONG) perlud->iMinWidth;
+                if(perlud->iMaxWidth != -1) minmax->ptMaxTrackSize.x = (LONG) perlud->iMaxWidth;
+                if(perlud->iMinHeight != -1) minmax->ptMinTrackSize.y = (LONG) perlud->iMinHeight;
+                if(perlud->iMaxHeight != -1) minmax->ptMaxTrackSize.y = (LONG) perlud->iMaxHeight;
+                return 0;
+            }
+        }
+        break;
+
+    case WM_SETCURSOR:
+        {
+            WORD nHitTest = LOWORD( lParam );
+            if( nHitTest == HTCLIENT ) {  // only diddle cursor in client areas
+                LPPERLWIN32GUI_USERDATA perlud;
+                perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong((HWND) wParam, GWL_USERDATA);
+                if( ValidUserData(perlud) && perlud->hCursor != NULL ) {
+                    SetCursor( perlud->hCursor );
+                    return TRUE;
+                }
+            }
+            break;
+        }
+    }
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    printf("!XS(CommonMsgLoop) returning DefWindowProc\n");
+#endif
+    return DefWindowProc(hwnd, uMsg, wParam, lParam);
+}
+
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:NEM_WindowMsgLoop(hwnd, uMsg, wParam, lParam)
+    # message loop for the New Event Model (NEM)
+    */
+LRESULT CALLBACK NEM_WindowMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+    LPPERLWIN32GUI_USERDATA perlud;
+    LPPERLWIN32GUI_USERDATA childud;
+    WNDPROC wndprocOriginal;
+	char TimerName[MAX_EVENT_NAME] = "";
+    int PerlResult = 1;
+
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    printf("!XS(NEM_WindowMsgLoop) got (0x%x, 0x%x, 0x%x, 0x%x)\n", hwnd, uMsg, wParam, lParam);
+#endif
+    if(uMsg == WM_CREATE || uMsg == WM_NCCREATE) {
+        perlud = (LPPERLWIN32GUI_USERDATA) ((CREATESTRUCT *) lParam)->lpCreateParams;
+        if(perlud!= NULL) {
+            SetWindowLong(hwnd, GWL_USERDATA, (long) perlud);
+        }
+#ifdef PERLWIN32GUI_STRONGDEBUG
+		printf("!XS(NEM_WindowMsgLoop) returning DefWindowProc (WM_CREATE)\n");
+#endif
+        return DefWindowProc(hwnd, uMsg, wParam, lParam);
+    }
+    
+    perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(hwnd, GWL_USERDATA);
+    if( ! ValidUserData(perlud) ) {
+#ifdef PERLWIN32GUI_STRONGDEBUG
+	    printf("!XS(NEM_WindowMsgLoop) returning DefWindowProc (perlud not valid)\n");
+#endif
+		return DefWindowProc(hwnd, uMsg, wParam, lParam);
+    }
+
+#ifdef PERL_OBJECT
+    CPerl *pPerl;
+    pPerl = perlud->pPerl;
+#endif
+
+    if(uMsg == WM_DESTROY) {
+        if (perlud) safefree(perlud);
+#ifdef PERLWIN32GUI_STRONGDEBUG
+		printf("!XS(NEM_WindowMsgLoop) returning DefWindowProc (WM_DESTROY)\n");
+#endif
+		return DefWindowProc(hwnd, uMsg, wParam, lParam);
+    }
+
+    switch(uMsg) {
+
+	case WM_TIMER:
+		if(perlud->dwPlStyle & PERLWIN32GUI_NEM) {
+			if(GetTimerName(NOTXSCALL hwnd, wParam, TimerName)) {
+		        PerlResult = DoEvent_NEM(NOTXSCALL perlud, PERLWIN32GUI_NEM_TIMER, "Timer", PERLWIN32GUI_ARGTYPE_STRING, TimerName, -1);
+		    }
+		    else {
+			    PerlResult = 0;
+		    }
+	    }
+        break;
+    case WM_ACTIVATE:
+        if(perlud->dwPlStyle & PERLWIN32GUI_NEM) {
+            if(LOWORD(wParam) == WA_INACTIVE) {
+                PerlResult = DoEvent_NEM(NOTXSCALL perlud, PERLWIN32GUI_NEM_DEACTIVATE, "Deactivate", -1 );
+            } else {
+                PerlResult = DoEvent_NEM(NOTXSCALL perlud, PERLWIN32GUI_NEM_ACTIVATE, "Activate", -1 );
+            }
+        }
+        break;
+
+    case WM_SYSCOMMAND:
+        if(perlud->dwPlStyle & PERLWIN32GUI_NEM) {
+            switch(wParam & 0xFFF0) {
+            case SC_CLOSE:
+                PerlResult = DoEvent_NEM(NOTXSCALL perlud, PERLWIN32GUI_NEM_TERMINATE, "Terminate", -1 );
+                break;
+            case SC_MINIMIZE:
+                PerlResult = DoEvent_NEM(NOTXSCALL perlud, PERLWIN32GUI_NEM_MINIMIZE, "Minimize", -1 );
+                break;
+            case SC_MAXIMIZE:
+                PerlResult = DoEvent_NEM(NOTXSCALL perlud, PERLWIN32GUI_NEM_MAXIMIZE, "Maximize", -1 );
+                break;
+            }
+        }
+        break;
+
+    case WM_SIZE:
+        if(perlud->dwPlStyle & PERLWIN32GUI_NEM) {
+            PerlResult = DoEvent_NEM(NOTXSCALL perlud, PERLWIN32GUI_NEM_RESIZE, "Resize", -1 );
+        }
+        break;
+
+    case WM_COMMAND:
+        if(HIWORD(wParam) == 0 && lParam == 0) {
+            // menu command processing
+#ifdef PERLWIN32GUI_STRONGDEBUG
+            printf("!XS(NEM_WindowMsgLoop) got WM_COMMAND for a menu...\n");
+#endif
+            PerlResult = DoEvent_NEM_Menu(NOTXSCALL hwnd, LOWORD(wParam));
+        } else if(HIWORD(wParam) == 1 && lParam == 0) {
+            // accelerator processing
+            /*
+#ifdef PERLWIN32GUI_STRONGDEBUG
+            printf("!XS(WindowMsgLoop) got WM_COMMAND for an accelerator...\n");
+#endif
+            if(GetAcceleratorName(NOTXSCALL LOWORD(wParam), Name)) {
+            PerlResult = DoEvent_NEM_Acc(NOTXSCALL accud);
+            }
+            */
+        } else {
+
+            childud = (LPPERLWIN32GUI_USERDATA) GetWindowLong((HWND) lParam, GWL_USERDATA);
+            if( ValidUserData(childud) && (childud->dwPlStyle & PERLWIN32GUI_NEM) ) {
+                switch(childud->iClass) {
+                case PERLWIN32GUI_CLS_BUTTON:
+                case PERLWIN32GUI_CLS_CHECKBOX:
+                case PERLWIN32GUI_CLS_RADIOBUTTON:
+                    switch(HIWORD(wParam)) {
+                    case BN_SETFOCUS:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_GOTFOCUS, "GotFocus", -1 );
+                        break;
+                    case BN_KILLFOCUS:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_LOSTFOCUS, "LostFocus", -1 );
+                        break;
+                    case BN_DBLCLK:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_DBLCLICK, "DblClick", -1 );
+                        break;
+                    case BN_CLICKED:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_CLICK, "Click", -1 );
+                        break;
+                    }
+                    break;                   
+                case PERLWIN32GUI_CLS_LISTBOX:
+                    switch(HIWORD(wParam)) {
+                    case LBN_SETFOCUS:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_GOTFOCUS, "GotFocus", -1 );
+                        break;
+                    case LBN_KILLFOCUS:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_LOSTFOCUS, "LostFocus", -1 );
+                        break;
+                    case LBN_DBLCLK:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_DBLCLICK, "DblClick", -1 );
+                        break;
+                    case LBN_SELCHANGE:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_CLICK, "Click", -1 );
+                        break;
+                    }
+                    break;
+                case PERLWIN32GUI_CLS_EDIT:
+                case PERLWIN32GUI_CLS_RICHEDIT:
+                    switch(HIWORD(wParam)) {
+                    case EN_SETFOCUS:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_GOTFOCUS, "GotFocus", -1 );
+                        break;
+                    case EN_KILLFOCUS:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_LOSTFOCUS, "LostFocus", -1 );
+                        break;
+                    case EN_CHANGE:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_CHANGE, "Change", -1 );
+                        break;
+                    }
+                    break;
+                case PERLWIN32GUI_CLS_STATIC:
+                    switch(HIWORD(wParam)) {
+                    case STN_CLICKED:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_CLICK, "Click", -1 );
+                        break;
+                    case STN_DBLCLK:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_DBLCLICK, "DblClick", -1 );
+                        break;
+                    }
+                    break;
+                case PERLWIN32GUI_CLS_COMBOBOX:
+                    switch(HIWORD(wParam)) {
+                    case CBN_SETFOCUS:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_GOTFOCUS, "GotFocus", -1 );
+                        break;
+                    case CBN_KILLFOCUS:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_LOSTFOCUS, "LostFocus", -1 );
+                        break;
+                    case CBN_DBLCLK:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_DBLCLICK, "DblClick", -1 );
+                        break;
+                    case CBN_SELCHANGE:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_CLICK, "Change", -1 );
+                        break;
+                    }
+                    break;
+                case PERLWIN32GUI_CLS_TOOLBAR:
+                    PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_BUTTONCLICK, "ButtonClick",
+                        PERLWIN32GUI_ARGTYPE_WORD, LOWORD(wParam), -1
+                        );
+                    break;
+                }
+            }
+        }
+        break;
+        case WM_NOTIFY:
+	    {
+            LPNMHDR notify;
+            notify = (LPNMHDR) lParam;
+            childud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(notify->hwndFrom, GWL_USERDATA);
+            if( ValidUserData(childud) && (childud->dwPlStyle & PERLWIN32GUI_NEM) ) {
+                switch(childud->iClass) {
+                case PERLWIN32GUI_CLS_LISTVIEW:
+			    {
+                    LPNM_LISTVIEW lv_notify;
+                    lv_notify = (LPNM_LISTVIEW) lParam;
+#ifdef PERLWIN32GUI_STRONDEBUG
+                    printf("!XS(NEM_WindowMsgLoop) WM_NOTIFY on ListView, code=0x%d\n", notify->code);
+#endif
+                    switch(notify->code) {
+                    case LVN_ITEMCHANGED:
+                        if(lv_notify->uChanged & LVIF_STATE
+                            && lv_notify->uNewState & LVIS_SELECTED) {
+                            PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_ITEMCLICK, "ItemClick",
+                                PERLWIN32GUI_ARGTYPE_INT, lv_notify->iItem, -1
+                                );
+                        }
+                        if(lv_notify->uChanged & LVIF_STATE
+                            && (lv_notify->uOldState & LVIS_STATEIMAGEMASK) != (lv_notify->uNewState & LVIS_STATEIMAGEMASK)) {
+                            PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_ITEMCHECK, "ItemCheck",
+                                PERLWIN32GUI_ARGTYPE_INT, lv_notify->iItem, -1
+                                );
+                        }
+                        break;
+                    case LVN_COLUMNCLICK:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_COLUMNCLICK, "ColumnClick",
+                            PERLWIN32GUI_ARGTYPE_INT, lv_notify->iSubItem, -1
+                            );
+                        break;
+                    case LVN_KEYDOWN:
+				    {
+                        LV_KEYDOWN FAR * lv_keydown;
+                        lv_keydown = (LV_KEYDOWN FAR *) lParam;
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_KEYDOWN, "KeyDown",
+                            PERLWIN32GUI_ARGTYPE_WORD, lv_keydown->wVKey, -1
+                            );
+                        break;
+                    }
+				}
+                    break;
+			    }
+                case PERLWIN32GUI_CLS_TREEVIEW:
+			    {
+                    LPNM_TREEVIEW tv_notify;
+                    tv_notify = (LPNM_TREEVIEW) lParam;
+                    switch(notify->code) {
+                    case TVN_ITEMEXPANDED:
+                        if(tv_notify->action == TVE_COLLAPSE) {
+                            PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_COLLAPSE, "Collapse",
+                                PERLWIN32GUI_ARGTYPE_LONG, tv_notify->itemNew.hItem, -1
+                                );
+                        } else {
+                            PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_EXPAND, "Expand",
+                                PERLWIN32GUI_ARGTYPE_LONG, tv_notify->itemNew.hItem, -1
+                                );
+                        }
+                        break;
+                    case TVN_ITEMEXPANDING:
+                        if(tv_notify->action == TVE_COLLAPSE) {
+                            PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_COLLAPSING, "Collapsing",
+                                PERLWIN32GUI_ARGTYPE_LONG, tv_notify->itemNew.hItem, -1
+                                );
+                        } else {
+                            PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_EXPANDING, "Expanding",
+                                PERLWIN32GUI_ARGTYPE_LONG, tv_notify->itemNew.hItem, -1
+                                );
+                        }
+                        FREETMPS;
+                        LEAVE;
+                        if(PerlResult == 0) return TRUE;
+                        else                return FALSE;
+                        break;
+                    case TVN_SELCHANGED:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_NODECLICK, "NodeClick",
+                            PERLWIN32GUI_ARGTYPE_LONG, tv_notify->itemNew.hItem, -1
+                            );
+                        break;
+                    case TVN_KEYDOWN:
+		    {
+                        TV_KEYDOWN FAR * tv_keydown;
+                        tv_keydown = (TV_KEYDOWN FAR *) lParam;
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_KEYDOWN, "KeyDown",
+                            PERLWIN32GUI_ARGTYPE_WORD, tv_keydown->wVKey, -1
+                            );
+                        break;
+                    }
+                }
+                    break;
+		            }
+                case PERLWIN32GUI_CLS_TAB:
+                    switch(notify->code) {
+                    case TCN_SELCHANGING:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_CHANGING, "Changing", -1);
+                        FREETMPS;
+                        LEAVE;
+                        if(PerlResult == 0) return TRUE;
+                        else                return FALSE;
+                        break;
+                    case TCN_SELCHANGE:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_CHANGE, "Change", -1);
+                        break;
+                    }
+                    break;
+                    
+                case PERLWIN32GUI_CLS_TOOLTIP:
+                    switch(notify->code) {
+                    case TTN_NEEDTEXT:
+		    {
+                        LPTOOLTIPTEXT lptt;
+                        lptt = (LPTOOLTIPTEXT) lParam;
+                        lptt->lpszText = (LPTSTR) DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_NEEDTEXT, "NeedText",
+                            PERLWIN32GUI_ARGTYPE_INT, lptt->hdr.idFrom, -1
+                            );
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                        printf("!XS(NEM_WindowMsgLoop): TTN_NEEDTEXT got '%s'\n", lptt->lpszText);
+#endif
+                        PerlResult = 1;
+                        break;
+                    }
+                }
+                    break;
+                        
+                case PERLWIN32GUI_CLS_REBAR:
+                    switch(notify->code) {
+                    case RBN_HEIGHTCHANGE:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_HEIGHTCHANGE, "HeightChange", -1);
+                        break;
+                    }
+                    break;
+                    
+                case PERLWIN32GUI_CLS_HEADER:
+		{
+                    LPNMHEADER nmh;
+                    nmh = (LPNMHEADER) lParam;
+                    switch(notify->code) {
+                    case HDN_BEGINTRACK:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_BEGINTRACK, "BeginTrack",
+                            PERLWIN32GUI_ARGTYPE_INT, nmh->iItem,
+                            PERLWIN32GUI_ARGTYPE_INT, nmh->pitem->cxy,
+                            -1
+                            );
+                        if(PerlResult == 0) return TRUE;
+                        else                return FALSE;
+                        break;
+                    case HDN_ENDTRACK:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_ENDTRACK, "EndTrack",
+                            PERLWIN32GUI_ARGTYPE_INT, nmh->iItem,
+                            PERLWIN32GUI_ARGTYPE_INT, nmh->pitem->cxy,
+                            -1
+                            );
+                        if(PerlResult == 0) return TRUE;
+                        else                return FALSE;
+                        break;
+                    case HDN_TRACK:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_TRACK, "Track",
+                            PERLWIN32GUI_ARGTYPE_INT, nmh->iItem,
+                            PERLWIN32GUI_ARGTYPE_INT, nmh->pitem->cxy,
+                            -1
+                            );
+                        if(PerlResult == 0) return TRUE;
+                        else                return FALSE;
+                        break;
+                    case HDN_DIVIDERDBLCLICK:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_DIVIDERDBLCLICK, "DividerDblClick",
+                            PERLWIN32GUI_ARGTYPE_INT, nmh->iItem,
+                            -1
+                            );
+                        break;
+                    case HDN_ITEMCLICK:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_ITEMCLICK, "ItemClick",
+                            PERLWIN32GUI_ARGTYPE_INT, nmh->iItem,
+                            -1
+                            );
+                        break;
+                    case HDN_ITEMDBLCLICK:
+                        PerlResult = DoEvent_NEM(NOTXSCALL childud, PERLWIN32GUI_NEM_ITEMDBLCLICK, "ItemDblClick",
+                            PERLWIN32GUI_ARGTYPE_INT, nmh->iItem,
+                            -1
+                            );
+                        break;
+                    }
+                    break;
+                }
+            }
+		}
+        break;
+    }
+    
+    if(perlud->avHooks != NULL) {
+       	I32 count;
+    	SV** perlsub;
+
+        perlsub = av_fetch(perlud->avHooks, (I32) uMsg, 0);
+        if(perlsub != NULL && SvOK(*perlsub)) {
+            dSP;
+            ENTER;
+            SAVETMPS;
+            PUSHMARK(SP);
+            XPUSHs(perlud->svSelf);
+            XPUSHs(sv_2mortal(newSViv(wParam)));
+            XPUSHs(sv_2mortal(newSViv(lParam)));
+            PUTBACK;
+            count = call_sv(*perlsub, G_ARRAY|G_EVAL);
+            SPAGAIN;
+            if(count > 0) PerlResult = POPi;
+            PUTBACK;
+            FREETMPS;
+            LEAVE;
+        }
+    }
+
+    if(PerlResult == -1) {
+        PostMessage(hwnd, WM_EXITLOOP, (WPARAM) -1, 0);
+        return 0;
+    } else if(PerlResult == 0) {
+        return 0;
+    } else if(PerlResult == -2) { /* DoEvent_NEM did not find a suitable event */
+        if(perlud->iEventModel == PERLWIN32GUI_EM_BOTH) {
+            if(perlud->wndprocPreNEM != NULL) {
+                wndprocOriginal = perlud->wndprocPreNEM;
+				return CallWindowProc(wndprocOriginal, hwnd, uMsg, wParam, lParam);
+            } else {
+                return CommonMsgLoop(NOTXSCALL hwnd, uMsg, wParam, lParam);
+            }
+        } else {
+            return CommonMsgLoop(NOTXSCALL hwnd, uMsg, wParam, lParam);
+        }
+    } else {
+        return CommonMsgLoop(NOTXSCALL hwnd, uMsg, wParam, lParam);
+    }
+}
+}
+
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:NEM_ChildMsgLoop(hwnd, uMsg, wParam, lParam)
+    # message loop for the New Event Model (NEM)
+    */
+LRESULT CALLBACK NEM_ChildMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+    LPPERLWIN32GUI_USERDATA perlud;
+    WNDPROC wndprocOriginal;
+    int PerlResult = 1;
+    
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    printf("!XS(NEM_ChildMsgLoop) got (0x%x, 0x%x, 0x%x, 0x%x)\n", hwnd, uMsg, wParam, lParam);
+#endif
+    if(uMsg == WM_CREATE || uMsg == WM_NCCREATE) {
+        perlud = (LPPERLWIN32GUI_USERDATA) ((CREATESTRUCT *) lParam)->lpCreateParams;
+        if(perlud!= NULL) {
+            SetWindowLong(hwnd, GWL_USERDATA, (long) perlud);
+        }
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("!XS(NEM_ChildMsgLoop) returning DefWindowProc (WM_CREATE)\n");
+#endif
+        return DefWindowProc(hwnd, uMsg, wParam, lParam);
+    }
+    
+    perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(hwnd, GWL_USERDATA);
+    if( ! ValidUserData(perlud) ) {
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("!XS(NEM_ChildMsgLoop) returning DefWindowProc (perlud not valid)\n");
+#endif
+        return DefWindowProc(hwnd, uMsg, wParam, lParam);
+    }
+#ifdef PERL_OBJECT
+    CPerl *pPerl;
+    pPerl = perlud->pPerl;
+#endif
+    
+    if(uMsg == WM_DESTROY) {
+        if (perlud) safefree(perlud);
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("!XS(NEM_ChildMsgLoop) returning DefWindowProc (WM_DESTROY)\n");
+#endif
+        return DefWindowProc(hwnd, uMsg, wParam, lParam);
+    }
+    
+    switch(uMsg) {
+    case WM_MOUSEMOVE:
+        PerlResult = DoEvent_NEM(NOTXSCALL perlud, PERLWIN32GUI_NEM_MOUSEMOVE, "MouseMove",
+            PERLWIN32GUI_ARGTYPE_LONG, LOWORD(lParam),
+            PERLWIN32GUI_ARGTYPE_LONG, HIWORD(lParam),
+            PERLWIN32GUI_ARGTYPE_LONG, wParam,
+            -1);
+        break;
+    case WM_LBUTTONDOWN:
+        PerlResult = DoEvent_NEM(NOTXSCALL perlud, PERLWIN32GUI_NEM_MOUSEDOWN, "MouseDown",
+            PERLWIN32GUI_ARGTYPE_LONG, LOWORD(lParam),
+            PERLWIN32GUI_ARGTYPE_LONG, HIWORD(lParam),
+            PERLWIN32GUI_ARGTYPE_LONG, wParam,
+            -1);
+        break;
+    case WM_LBUTTONUP:
+        PerlResult = DoEvent_NEM(NOTXSCALL perlud, PERLWIN32GUI_NEM_MOUSEUP, "MouseUp",
+            PERLWIN32GUI_ARGTYPE_LONG, LOWORD(lParam),
+            PERLWIN32GUI_ARGTYPE_LONG, HIWORD(lParam),
+            PERLWIN32GUI_ARGTYPE_LONG, wParam,
+            -1);
+        break;
+    case WM_KEYDOWN:
+        PerlResult = DoEvent_NEM(NOTXSCALL perlud, PERLWIN32GUI_NEM_KEYDOWN, "KeyDown",
+            PERLWIN32GUI_ARGTYPE_LONG, lParam,
+            PERLWIN32GUI_ARGTYPE_LONG, wParam,
+            -1);
+        break;
+    case WM_KEYUP:
+        PerlResult = DoEvent_NEM(NOTXSCALL perlud, PERLWIN32GUI_NEM_KEYDOWN, "KeyUp",
+            PERLWIN32GUI_ARGTYPE_LONG, lParam,
+            PERLWIN32GUI_ARGTYPE_LONG, wParam,
+            -1);
+        break;
+    }
+
+    if(perlud->avHooks != NULL) {
+       	I32 count;
+    	SV** perlsub;
+
+        perlsub = av_fetch(perlud->avHooks, (I32) uMsg, 0);
+		if(perlsub != NULL && SvOK(*perlsub)) {
+			dSP;
+			ENTER;
+			SAVETMPS;
+			PUSHMARK(SP);
+			XPUSHs(perlud->svSelf);
+			XPUSHs(sv_2mortal(newSViv(wParam)));
+			XPUSHs(sv_2mortal(newSViv(lParam)));
+			PUTBACK;
+			count = call_sv(*perlsub, G_ARRAY|G_EVAL);
+			SPAGAIN;
+			if(count > 0) PerlResult = POPi;
+			PUTBACK;
+			FREETMPS;
+			LEAVE;
+		}
+	}
+
+    if(PerlResult == 0) {
+        return 0;
+    } else {
+        if(perlud->wndprocPreNEM != NULL) {
+            wndprocOriginal = perlud->wndprocPreNEM;
+#ifdef PERLWIN32GUI_STRONGDEBUG
+            printf("!XS(NEM_ChildMsgLoop) calling wndprocOriginal\n");
+#endif
+			return CallWindowProc(wndprocOriginal, hwnd, uMsg, wParam, lParam);
+        } else {
+#ifdef PERLWIN32GUI_STRONGDEBUG
+            printf("!XS(NEM_ChildMsgLoop) returning DefWindowProc (wndprocOriginal not valid)\n");
+#endif
+            return DefWindowProc(hwnd, uMsg, wParam, lParam);
+        }
+    }
+}
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:ContainerMsgLoop(hwnd, uMsg, wParam, lParam)
+    */
+LRESULT CALLBACK ContainerMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+    HWND hwndParent;
+    LPPERLWIN32GUI_USERDATA perlud;
+    WNDPROC wndprocOriginal;
+    
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    printf("!XS(ContainerMsgLoop) got (0x%x, 0x%x, 0x%x, 0x%x)\n", hwnd, uMsg, wParam, lParam);
+#endif
+    
+    if(uMsg == WM_COMMAND || uMsg == WM_NOTIFY) {
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("!XS(ContainerMsgLoop) got WM_COMMAND/WM_NOTIFY, forwarding to parent...\n");
+#endif
+        hwndParent = (HWND) GetWindowLong(hwnd, GWL_HWNDPARENT);
+        SendMessage(hwndParent, uMsg, wParam, lParam);
+        return 0;
+    } else {
+        perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(hwnd, GWL_USERDATA);
+        if( ValidUserData(perlud) && (perlud->wndprocPreContainer != NULL) ) {
+            wndprocOriginal = perlud->wndprocPreContainer;
+#ifdef PERLWIN32GUI_STRONGDEBUG
+            printf("!XS(ContainerMsgLoop) perlud was valid, forwarding to wndprocOriginal(0x%x)...\n", wndprocOriginal);
+#endif
+			return CallWindowProc(wndprocOriginal, hwnd, uMsg, wParam, lParam);
+        } else {
+#ifdef PERLWIN32GUI_STRONGDEBUG
+            printf("!XS(ContainerMsgLoop) perlud was not valid, forwarding to DefWindowProc...\n");
+#endif
+            return DefWindowProc(hwnd, uMsg, wParam, lParam);
+        }
+    }
+}
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:SplitterMsgLoop(hwnd, uMsg, wParam, lParam)
+    # message loop for Win32::GUI::Splitter objects
+    */
+LRESULT CALLBACK SplitterMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+    int PerlResult = 1;
+    char Name[MAX_EVENT_NAME];
+    BOOL tracking, horizontal;
+    POINT pt;
+    HWND phwnd;
+    RECT rc;
+    LPPERLWIN32GUI_USERDATA perlud;
+    
+    perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(hwnd, GWL_USERDATA);
+    if( !ValidUserData(perlud) ) {
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("!XS(SplitterMsgLoop) returning DefWindowProc (perlud not valid)\n");
+#endif
+        return DefWindowProc(hwnd, uMsg, wParam, lParam);
+    }
+    
+#ifdef PERL_OBJECT
+    CPerl *pPerl;
+    pPerl = perlud->pPerl;
+#endif
+    
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    printf("!XS(SplitterMsgLoop) got (0x%x, 0x%x, 0x%x, 0x%x)\n", hwnd, uMsg, wParam, lParam);
+#endif
+    
+    if(uMsg == WM_DESTROY) {
+        if(perlud) safefree( perlud );
+        return DefWindowProc(hwnd, uMsg, wParam, lParam);
+    }
+    
+    strcpy(Name, "main::");
+    if(GetObjectName(NOTXSCALL hwnd, Name)) {
+        switch(uMsg) {
+        case WM_MOUSEMOVE:
+            tracking = perlud->dwPlStyle & PERLWIN32GUI_TRACKING;
+            if(tracking) {
+                horizontal = perlud->dwPlStyle & PERLWIN32GUI_HORIZONTAL;
+                if(horizontal) {
+                    phwnd = GetParent(hwnd);
+                    GetCursorPos(&pt);
+                    ScreenToClient(phwnd, &pt);
+                    pt.y = AdjustSplitterCoord(NOTXSCALL perlud, pt.y, phwnd);
+                    DrawSplitter(NOTXSCALL hwnd);
+                    GetWindowRect(hwnd, &rc);
+                    ScreenToClient(phwnd, (POINT*)&rc);
+                    SetWindowPos(hwnd, NULL, rc.left, pt.y, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
+                    DrawSplitter(NOTXSCALL hwnd);
+                } else {
+                    phwnd = GetParent(hwnd);
+                    GetCursorPos(&pt);
+                    ScreenToClient(phwnd, &pt);
+                    pt.x = AdjustSplitterCoord(NOTXSCALL perlud, pt.x, phwnd);
+                    DrawSplitter(NOTXSCALL hwnd);
+                    GetWindowRect(hwnd, &rc);
+                    ScreenToClient(phwnd, (POINT*)&rc);
+                    SetWindowPos(hwnd, NULL, pt.x, rc.top, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
+                    DrawSplitter(NOTXSCALL hwnd);
+                }
+            }
+            break;
+        case WM_LBUTTONDOWN:
+            SwitchBit(perlud->dwPlStyle, PERLWIN32GUI_TRACKING, 1);
+            SetWindowLong(hwnd, GWL_USERDATA, (LONG) perlud);
+            horizontal = perlud->dwPlStyle & PERLWIN32GUI_HORIZONTAL;
+            if(horizontal) {
+                phwnd = GetParent(hwnd);
+                GetCursorPos(&pt);
+                ScreenToClient(phwnd, &pt);
+                pt.y = AdjustSplitterCoord(NOTXSCALL perlud, pt.y, phwnd);
+                DrawSplitter(NOTXSCALL hwnd);
+                SetCapture(hwnd);
+            } else {
+                phwnd = GetParent(hwnd);
+                GetCursorPos(&pt);
+                ScreenToClient(phwnd, &pt);
+                pt.x = AdjustSplitterCoord(NOTXSCALL perlud, pt.x, phwnd);
+                DrawSplitter(NOTXSCALL hwnd);
+                SetCapture(hwnd);
+            }
+            break;
+        case WM_LBUTTONUP:
+            tracking = perlud->dwPlStyle & PERLWIN32GUI_TRACKING;
+            if(tracking) {
+                horizontal = perlud->dwPlStyle & PERLWIN32GUI_HORIZONTAL;
+                /*
+                * (@)EVENT:Release(COORD)
+                * Sent when the Splitter is released after being
+                * dragged to a new location (identified by the
+                * COORD parameter).
+                * (@)APPLIES_TO:Splitter
+                */
+                if(horizontal) {
+                    phwnd = GetParent(hwnd);
+                    GetCursorPos(&pt);
+                    ScreenToClient(phwnd, &pt);
+                    pt.y = AdjustSplitterCoord(NOTXSCALL perlud, pt.y, phwnd);
+                    DrawSplitter(NOTXSCALL hwnd);
+                    strcat(Name, "_Release");
+                    PerlResult = DoEvent_Long(NOTXSCALL Name, (long) pt.y);
+                } else {
+                    phwnd = GetParent(hwnd);
+                    GetCursorPos(&pt);
+                    ScreenToClient(phwnd, &pt);
+                    pt.x = AdjustSplitterCoord(NOTXSCALL perlud, pt.x, phwnd);
+                    DrawSplitter(NOTXSCALL hwnd);
+                    strcat(Name, "_Release");
+                    PerlResult = DoEvent_Long(NOTXSCALL Name, (long) pt.x);
+                }
+            }
+            SwitchBit(perlud->dwPlStyle, PERLWIN32GUI_TRACKING, 0);
+            SetWindowLong(hwnd, GWL_USERDATA, (LONG) perlud);
+            ReleaseCapture();
+            break;
+        }
+    }
+    if(PerlResult == 0) {
+        return 0;
+    } else {
+        return DefWindowProc(hwnd, uMsg, wParam, lParam);
+    }
+}
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:ButtonMsgLoop(hwnd, uMsg, wParam, lParam)
+    # message loop for subclassed Win32::GUI::Button objects
+    */
+LRESULT CALLBACK ButtonMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+    dMY_CXT;
+#ifdef PERL_OBJECT
+    CPerl *pPerl;
+    pPerl = PERL_OBJECT_FROM_WINDOW(hwnd);
+	if(pPerl == NULL) return MY_CXT.DefButtonProc(hwnd, uMsg, wParam, lParam);
+#endif
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    printf("!XS(ButtonMsgLoop) got (0x%x, 0x%x, 0x%x, 0x%x)\n", hwnd, uMsg, wParam, lParam);
+#endif
+    int PerlResult;
+    char Name[MAX_EVENT_NAME];
+    PerlResult = 1;
+    strcpy(Name, "main::");
+    if(GetObjectName(NOTXSCALL hwnd, Name)) {
+        switch(uMsg) {
+        case WM_MOUSEMOVE:
+            PerlResult = DoEvent_MouseMove(NOTXSCALL Name, wParam, lParam);
+            break;
+        case WM_MOUSEHOVER:
+            strcat((char *) Name, "_MouseOver");
+            PerlResult = DoEvent_Generic(NOTXSCALL Name);
+            if(PerlResult) {
+                TRACKMOUSEEVENT tme;
+                tme.cbSize = sizeof(TRACKMOUSEEVENT);
+                tme.hwndTrack = hwnd;
+                tme.dwFlags = TME_QUERY;
+                if(TrackMouseEvent( &tme )) {
+                    TrackMouseEvent( &tme );
+                }
+            }
+            break;
+        case WM_MOUSELEAVE:
+            strcat((char *) Name, "_MouseOut");
+            PerlResult = DoEvent_Generic(NOTXSCALL Name);
+            if(PerlResult) {
+                TRACKMOUSEEVENT tme;
+                tme.cbSize = sizeof(TRACKMOUSEEVENT);
+                tme.hwndTrack = hwnd;
+                tme.dwFlags = TME_QUERY;
+                if(TrackMouseEvent( &tme )) {
+                    TrackMouseEvent( &tme );
+                }
+            }
+            break;
+
+            // to implement:
+            // MouseUp
+            // MouseDown
+            // KeyPress
+        }
+    }
+    if(PerlResult == 0) {
+        return 0;
+    } else {
+        return MY_CXT.DefButtonProc(hwnd, uMsg, wParam, lParam);
+    }
+}
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:ListboxMsgLoop(hwnd, uMsg, wParam, lParam)
+    # message loop for subclassed Win32::GUI::Listbox objects
+    */
+LRESULT CALLBACK ListboxMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+    dMY_CXT;
+#ifdef PERL_OBJECT
+    CPerl *pPerl;
+    pPerl = PERL_OBJECT_FROM_WINDOW(hwnd);
+	if(pPerl == NULL) return MY_CXT.DefListboxProc(hwnd, uMsg, wParam, lParam);
+#endif
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    printf("!XS(ListboxMsgLoop) got (0x%x, 0x%x, 0x%x, 0x%x)\n", hwnd, uMsg, wParam, lParam);
+#endif
+    int PerlResult;
+    char Name[MAX_EVENT_NAME];
+    PerlResult = 1;
+    strcpy((char *) Name, "main::");
+    if(GetObjectName(NOTXSCALL hwnd, Name)) {
+        switch(uMsg) {
+        case WM_MOUSEMOVE:
+            PerlResult = DoEvent_MouseMove(NOTXSCALL Name, wParam, lParam);
+            break;
+        case WM_MOUSEHOVER:
+            strcat((char *) Name, "_MouseOver");
+            PerlResult = DoEvent_Generic(NOTXSCALL Name);
+            if(PerlResult) {
+                TRACKMOUSEEVENT tme;
+                tme.cbSize = sizeof(TRACKMOUSEEVENT);
+                tme.hwndTrack = hwnd;
+                tme.dwFlags = TME_QUERY;
+                if(TrackMouseEvent( &tme )) {
+                    TrackMouseEvent( &tme );
+                }
+            }
+            break;
+        case WM_MOUSELEAVE:
+            strcat((char *) Name, "_MouseOut");
+            PerlResult = DoEvent_Generic(NOTXSCALL Name);
+            if(PerlResult) {
+                TRACKMOUSEEVENT tme;
+                tme.cbSize = sizeof(TRACKMOUSEEVENT);
+                tme.hwndTrack = hwnd;
+                tme.dwFlags = TME_QUERY;
+                if(TrackMouseEvent( &tme )) {
+                    TrackMouseEvent( &tme );
+                }
+            }
+            break;
+
+            // to implement:
+            // MouseUp
+            // MouseDown
+            // KeyPress
+        }
+    }
+    if(PerlResult == 0) {
+        return 0;
+    } else {
+        return MY_CXT.DefListboxProc(hwnd, uMsg, wParam, lParam);
+    }
+
+}
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:RichEditMsgLoop(hwnd, uMsg, wParam, lParam)
+    # message loop for subclassed Win32::GUI::RichEdit objects
+    */
+LRESULT CALLBACK RichEditMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+    dMY_CXT;
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    printf("!XS(RichEditMsgLoop) got (0x%x, 0x%x, 0x%x, 0x%x)\n", hwnd, uMsg, wParam, lParam);
+#endif
+#ifdef PERL_OBJECT
+    CPerl *pPerl;
+    pPerl = PERL_OBJECT_FROM_WINDOW(hwnd);
+	if(pPerl == NULL) return MY_CXT.DefRichEditProc(hwnd, uMsg, wParam, lParam);
+#endif
+    int PerlResult;
+    char Name[MAX_EVENT_NAME];
+    PerlResult = 1;
+    strcpy((char *) Name, "main::");
+    if(GetObjectName(NOTXSCALL hwnd, Name)) {
+        switch(uMsg) {
+        case WM_MOUSEMOVE:
+            PerlResult = DoEvent_MouseMove(NOTXSCALL Name, wParam, lParam);
+            break;
+        case WM_LBUTTONDOWN:
+            strcat((char *) Name, "_LButtonDown");
+            PerlResult = DoEvent_MouseButton(NOTXSCALL Name, wParam, lParam);
+            break;
+        case WM_LBUTTONUP:
+            strcat((char *) Name, "_LButtonUp");
+            PerlResult = DoEvent_MouseButton(NOTXSCALL Name, wParam, lParam);
+            break;
+        case WM_RBUTTONDOWN:
+            strcat((char *) Name, "_RButtonDown");
+            PerlResult = DoEvent_MouseButton(NOTXSCALL Name, wParam, lParam);
+            break;
+        case WM_RBUTTONUP:
+            strcat((char *) Name, "_RButtonUp");
+            PerlResult = DoEvent_MouseButton(NOTXSCALL Name, wParam, lParam);
+            break;
+        case WM_CHAR:
+            strcat(Name, "_KeyPress");
+            PerlResult = DoEvent_Long(NOTXSCALL Name, wParam);
+            break;
+        case WM_MOUSEHOVER:
+            strcat((char *) Name, "_MouseOver");
+            PerlResult = DoEvent_Generic(NOTXSCALL Name);
+            if(PerlResult) {
+                TRACKMOUSEEVENT tme;
+                tme.cbSize = sizeof(TRACKMOUSEEVENT);
+                tme.hwndTrack = hwnd;
+                tme.dwFlags = TME_QUERY;
+                if(TrackMouseEvent( &tme )) {
+                    TrackMouseEvent( &tme );
+                }
+            }
+            break;
+        case WM_MOUSELEAVE:
+            strcat((char *) Name, "_MouseOut");
+            PerlResult = DoEvent_Generic(NOTXSCALL Name);
+            if(PerlResult) {
+                TRACKMOUSEEVENT tme;
+                tme.cbSize = sizeof(TRACKMOUSEEVENT);
+                tme.hwndTrack = hwnd;
+                tme.dwFlags = TME_QUERY;
+                if(TrackMouseEvent( &tme )) {
+                    TrackMouseEvent( &tme );
+                }
+            }
+            break;
+
+            // to implement:
+            // MouseUp
+            // MouseDown
+        }
+    }
+    if(PerlResult == 0) {
+        return 0;
+    } else {
+        return MY_CXT.DefRichEditProc(hwnd, uMsg, wParam, lParam);
+    }
+
+}
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:TabStripMsgLoop(hwnd, uMsg, wParam, lParam)
+    # message loop for subclassed Win32::GUI::TabStrip objects
+    */
+LRESULT CALLBACK TabStripMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+    dMY_CXT;
+    // a TabStrip acts like a container, so we simply
+    // redirect the messages to our parent and call the default Proc.
+    HWND hwndParent;
+    
+    if(uMsg == WM_COMMAND || uMsg == WM_NOTIFY) {
+        hwndParent = (HWND) GetWindowLong(hwnd, GWL_HWNDPARENT);
+        SendMessage(hwndParent, uMsg, wParam, lParam);
+        return 0;
+    } else {
+        return MY_CXT.DefTabStripProc(hwnd, uMsg, wParam, lParam);
+    }
+}
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:GraphicMsgLoop(hwnd, uMsg, wParam, lParam)
+    # message loop for Win32::GUI::Graphic objects
+    */
+LRESULT CALLBACK GraphicMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+#ifdef PERL_OBJECT
+    CPerl *pPerl;
+    pPerl = PERL_OBJECT_FROM_WINDOW(hwnd);
+    if(pPerl == NULL) return DefWindowProc(hwnd, uMsg, wParam, lParam);
+#endif
+
+    int PerlResult;
+    int count;
+    char Name[MAX_EVENT_NAME];
+    SV* newdc;
+    
+    PerlResult = 1;
+    
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    printf("!XS(GraphicMsgLoop) got (0x%x, 0x%x, 0x%x, 0x%x)\n", hwnd, uMsg, wParam, lParam);
+#endif
+    if(uMsg == WM_PAINT) {
+        strcpy((char *) Name, "main::");
+        if(GetObjectName(NOTXSCALL hwnd, Name)) {
+#ifdef PERLWIN32GUI_STRONGDEBUG
+            printf("!XS(GraphicMsgLoop) name=%s\n", Name);
+#endif
+            strcat((char *) Name, "_Paint");
+            if(perl_get_cv(Name, FALSE) != NULL) {
+                /*
+                * (@)EVENT:Paint()
+                * Sent when the Graphic object needs to be repainted.
+                * Note that you need to use GetDC() to get the DC
+                * of the Graphic object where you do your paint
+                * work, and then Validate() the DC to inform Windows
+                * that you painted the DC area (otherwise it will
+                * continue to call the Paint event continuously).
+                * Example:
+                *   sub Graphic_Paint {
+                *       my $DC = $Window->Graphic->GetDC();
+                *       $DC->MoveTo(0, 0);
+                *       $DC->LineTo(100, 100);
+                *       $DC->Validate();
+                *   }
+                * (@)APPLIES_TO:Graphic
+                */
+                
+                /*
+                self = HV_SELF_FROM_WINDOW(hwnd);
+                storing = newSViv((long) GetDC(hwnd));
+                hv_store_mg(NOTXSCALL self, "-handle", 7, storing, 0);
+                storing = newSViv((long) hwnd);
+                hv_store_mg(NOTXSCALL self, "-window", 7, storing, 0);
+                */
+                
+                dSP;
+                ENTER;
+                SAVETMPS;
+                PUSHMARK(SP);
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                printf("!XS(GraphicMsgLoop) pushing parameters...\n");
+#endif
+                XPUSHs(sv_2mortal(newSVpv("Win32::GUI::DC", 0)));
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                printf("!XS(GraphicMsgLoop) done parameter 1...\n");
+#endif
+                XPUSHs(SV_SELF_FROM_WINDOW(hwnd));
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                printf("!XS(GraphicMsgLoop) done parameter 2...\n");
+#endif
+                PUTBACK ;
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                printf("!XS(GraphicMsgLoop) doing perl_call...\n");
+#endif
+                count = perl_call_pv("Win32::GUI::DC::new", 0);
+                SPAGAIN ;
+                newdc = newSVsv(POPs);
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                printf("!XS(GraphicMsgLoop) perl_call got(%d): %s\n", count, SvPV_nolen(newdc));
+#endif
+                PUTBACK;
+                FREETMPS;
+                LEAVE;
+                
+                ENTER;
+                SAVETMPS;
+                PUSHMARK(SP);
+                XPUSHs(sv_2mortal(newdc));
+                // XPUSHs(sv_2mortal(newdc));
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                printf("!XS(GraphicMsgLoop) doing perl_call_pv...\n");
+#endif
+                PUTBACK;
+                count = perl_call_pv(Name, G_EVAL|G_ARRAY);
+                SPAGAIN;
+                if(!ProcessEventError(NOTXSCALL Name, &PerlResult)) {
+                    if(count > 0) PerlResult = POPi;
+                }
+                PUTBACK;
+                FREETMPS;
+                LEAVE;
+                /*
+                storing = newSViv((long) hwnd);
+                hv_store_mg(NOTXSCALL self, "-handle", 7, storing, 0);
+                */
+            }
+        }
+        return PerlResult;
+    } else {
+        return DefWindowProc(hwnd, uMsg, wParam, lParam);
+    }
+}
+
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:InteractiveGraphicMsgLoop(hwnd, uMsg, wParam, lParam)
+    # message loop for Win32::GUI::Graphic objects (with -interactive => 1
+    # option).
+    */
+LRESULT CALLBACK InteractiveGraphicMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+#ifdef PERL_OBJECT
+    CPerl *pPerl;
+    pPerl = PERL_OBJECT_FROM_WINDOW(hwnd);
+    if(pPerl == NULL) return DefWindowProc(hwnd, uMsg, wParam, lParam);
+#endif
+    int PerlResult;
+    int count;
+    char Name[MAX_EVENT_NAME];
+    SV* newdc;
+    
+    PerlResult = 1;
+    
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    printf("!XS(InteractiveGraphicMsgLoop) got (0x%x, 0x%x, 0x%x, 0x%x)\n", hwnd, uMsg, wParam, lParam);
+#endif
+    
+    strcpy((char *) Name, "main::");
+    
+    if(GetObjectName(NOTXSCALL hwnd, Name)) {
+        switch(uMsg) {
+        case WM_PAINT:
+            strcat((char *) Name, "_Paint");
+            if(perl_get_cv(Name, FALSE) != NULL) {
+                /*
+                * (@)EVENT:Paint()
+                * Sent when the Graphic object needs to be repainted.
+                * Note that you need to use GetDC() to get the DC
+                * of the Graphic object where you do your paint
+                * work, and then Validate() the DC to inform Windows
+                * that you painted the DC area (otherwise it will
+                * continue to call the Paint event continuously).
+                * Example:
+                *   sub Graphic_Paint {
+                *       my $DC = $Window->Graphic->GetDC();
+                *       $DC->MoveTo(0, 0);
+                *       $DC->LineTo(100, 100);
+                *       $DC->Validate();
+                *   }
+                * (@)APPLIES_TO:Graphic
+                */
+                dSP;
+                ENTER;
+                SAVETMPS;
+                PUSHMARK(SP);
+                XPUSHs(sv_2mortal(newSVpv("Win32::GUI::DC", 0)));
+                XPUSHs(SV_SELF_FROM_WINDOW(hwnd));
+                PUTBACK ;
+                count = perl_call_pv("Win32::GUI::DC::new", 0);
+                SPAGAIN ;
+                newdc = newSVsv(POPs);
+                PUTBACK;
+                FREETMPS;
+                LEAVE;
+                
+                ENTER;
+                SAVETMPS;
+                PUSHMARK(SP);
+                XPUSHs(sv_2mortal(newdc));
+                PUTBACK;
+                count = perl_call_pv(Name, G_EVAL|G_ARRAY);
+                SPAGAIN;
+                if(!ProcessEventError(NOTXSCALL Name, &PerlResult)) {
+                    if(count > 0) PerlResult = POPi;
+                }
+                PUTBACK;
+                FREETMPS;
+                LEAVE;
+            }
+            break;
+        case WM_MOUSEMOVE:
+            PerlResult = DoEvent_MouseMove(NOTXSCALL Name, wParam, lParam);
+            break;
+        case WM_LBUTTONDOWN:
+            strcat((char *) Name, "_LButtonDown");
+            PerlResult = DoEvent_MouseButton(NOTXSCALL Name, wParam, lParam);
+            break;
+        case WM_LBUTTONUP:
+            strcat((char *) Name, "_LButtonUp");
+            PerlResult = DoEvent_MouseButton(NOTXSCALL Name, wParam, lParam);
+            break;
+        case WM_RBUTTONDOWN:
+            strcat((char *) Name, "_RButtonDown");
+            PerlResult = DoEvent_MouseButton(NOTXSCALL Name, wParam, lParam);
+            break;
+        case WM_RBUTTONUP:
+            strcat((char *) Name, "_RButtonUp");
+            PerlResult = DoEvent_MouseButton(NOTXSCALL Name, wParam, lParam);
+            break;
+        case WM_MOUSEHOVER:
+            strcat((char *) Name, "_MouseOver");
+            PerlResult = DoEvent_Generic(NOTXSCALL Name);
+            if(PerlResult) {
+                TRACKMOUSEEVENT tme;
+                tme.cbSize = sizeof(TRACKMOUSEEVENT);
+                tme.hwndTrack = hwnd;
+                tme.dwFlags = TME_QUERY;
+                if(TrackMouseEvent( &tme )) {
+                    TrackMouseEvent( &tme );
+                }
+            }
+            break;
+        case WM_MOUSELEAVE:
+            strcat((char *) Name, "_MouseOut");
+            PerlResult = DoEvent_Generic(NOTXSCALL Name);
+            if(PerlResult) {
+                TRACKMOUSEEVENT tme;
+                tme.cbSize = sizeof(TRACKMOUSEEVENT);
+                tme.hwndTrack = hwnd;
+                tme.dwFlags = TME_QUERY;
+                if(TrackMouseEvent( &tme )) {
+                    TrackMouseEvent( &tme );
+                }
+            }
+            break;
+        }
+    }
+    if(PerlResult == -1) {
+        PostMessage(hwnd, WM_EXITLOOP, (WPARAM) -1, 0);
+        return 0;
+    } else {
+        if(PerlResult == 0) {
+            return 0;
+        } else {
+            return DefWindowProc(hwnd, uMsg, wParam, lParam);
+        }
+    }
+}
+
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:WindowMsgLoop(hwnd, uMsg, wParam, lParam)
+    # this is the main message loop (WndProc)
+    */
+LRESULT CALLBACK WindowMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+    int PerlResult = 1;
+    char Name[MAX_EVENT_NAME];
+    int obj_class;
+    LPNMHDR notify;
+    LPNM_TREEVIEW tv_notify;
+    TV_KEYDOWN FAR * tv_keydown;
+    LPPERLWIN32GUI_USERDATA perlud;
+    
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    printf("!XS(WindowMsgLoop) got (0x%x, 0x%x, 0x%x, 0x%x)\n", hwnd, uMsg, wParam, lParam);
+#endif
+    if(uMsg == WM_CREATE || uMsg == WM_NCCREATE) {
+        perlud = (LPPERLWIN32GUI_USERDATA) ((CREATESTRUCT *) lParam)->lpCreateParams;
+        if(perlud!= NULL) {
+            SetWindowLong(hwnd, GWL_USERDATA, (long) perlud);
+        }
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("!XS(WindowMsgLoop) returning DefWindowProc (WM_CREATE)\n");
+#endif
+        return DefWindowProc(hwnd, uMsg, wParam, lParam);
+    }
+    
+    perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(hwnd, GWL_USERDATA);
+    if( !ValidUserData(perlud) ) {
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("!XS(WindowMsgLoop) returning DefWindowProc (perlud not valid)\n");
+#endif
+        return DefWindowProc(hwnd, uMsg, wParam, lParam);
+    }
+    
+#ifdef PERL_OBJECT
+    CPerl *pPerl;
+    pPerl = perlud->pPerl;
+#endif
+    
+    if(uMsg == WM_DESTROY) {
+        if (perlud) safefree(perlud);
+#ifdef PERLWIN32GUI_STRONGDEBUG
+        printf("!XS(WindowMsgLoop) returning DefWindowProc (WM_DESTROY)\n");
+#endif
+        return DefWindowProc(hwnd, uMsg, wParam, lParam);
+    }
+
+    dSP;
+    ENTER;
+    SAVETMPS;
+
+    strcpy(Name, "main::");
+
+    switch(uMsg) {
+    case WM_ACTIVATE:
+        if(GetObjectName(NOTXSCALL hwnd, Name)) {
+            if(LOWORD(wParam) == WA_INACTIVE) {
+                /*
+                 * (@)EVENT:Deactivate()
+                 * Sent when the window is deactivated.
+                 * (@)APPLIES_TO:Window, DialogBox
+                 */
+                strcat(Name, "_Deactivate");
+            } else {
+                /*
+                 * (@)EVENT:Activate()
+                 * Sent when the window is activated.
+                 * (@)APPLIES_TO:Window, DialogBox
+                 */
+                strcat(Name, "_Activate");
+            }
+            PerlResult = DoEvent_Generic(NOTXSCALL Name);
+        }
+        break;
+
+    case WM_SYSCOMMAND:
+        if(GetObjectName(NOTXSCALL hwnd, Name)) {
+            switch(wParam & 0xFFF0) {
+            case SC_CLOSE:
+                /*
+                 * (@)EVENT:Terminate()
+                 * Sent when the window is closed.
+                 * The event should return -1 to terminate the interaction
+                 * and return control to the perl script; see Dialog().
+                 * (@)APPLIES_TO:Window, DialogBox
+                 */
+                strcat(Name, "_Terminate");
+                PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                break;
+            case SC_MINIMIZE:
+                /*
+                 * (@)EVENT:Minimize()
+                 * Sent when the window is minimized.
+                 * (@)APPLIES_TO:Window, DialogBox
+                 */
+                strcat(Name, "_Minimize");
+                PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                break;
+            case SC_MAXIMIZE:
+                /*
+                 * (@)EVENT:Maximize()
+                 * Sent when the window is maximized.
+                 * (@)APPLIES_TO:Window, DialogBox
+                 */
+                strcat(Name, "_Maximize");
+                PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                break;
+            }
+        }
+        break;
+
+    case WM_SIZE:
+        if(GetObjectName(NOTXSCALL hwnd, Name)) {
+            /*
+             * (@)EVENT:Resize()
+             * Sent when the window is resized.
+             * (@)APPLIES_TO:Window, DialogBox
+             */
+            strcat(Name, "_Resize");
+            PerlResult = DoEvent_Generic(NOTXSCALL Name);
+        }
+        break;
+
+    case WM_COMMAND:
+        if(HIWORD(wParam) == 0 && lParam == 0) {
+            // menu command processing
+#ifdef PERLWIN32GUI_STRONGDEBUG
+            printf("!XS(WindowMsgLoop) got WM_COMMAND for a menu...\n");
+#endif
+            if(GetMenuName(NOTXSCALL hwnd, LOWORD(wParam), Name)) {
+                /*
+                * (@)EVENT:Click()
+                * Sent when the users choose a menu point.
+                * (@)APPLIES_TO:Menu
+                */
+                strcat(Name, "_Click");
+                PerlResult = DoEvent_Generic(NOTXSCALL Name);
+            }
+        } else if(HIWORD(wParam) == 1 && lParam == 0) {
+            // accelerator processing
+#ifdef PERLWIN32GUI_STRONGDEBUG
+            printf("!XS(WindowMsgLoop) got WM_COMMAND for an accelerator...\n");
+#endif
+            if(GetAcceleratorName(NOTXSCALL LOWORD(wParam), Name)) {
+                /*
+                * (@)EVENT:Click()
+                * Sent when the users triggers an Accelerator object.
+                * (@)APPLIES_TO:AcceleratorTable
+                */
+                strcat(Name, "_Click");
+                PerlResult = DoEvent_Generic(NOTXSCALL Name);
+            }
+        } else {
+#ifdef PERLWIN32GUI_STRONGDEBUG
+            printf("!XS(WindowMsgLoop) got WM_COMMAND, doing GetObjectNameAndClass...\n");
+#endif
+            if(GetObjectNameAndClass(NOTXSCALL (HWND) lParam, Name, &obj_class)) {
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                printf("!XS(WindowMsgLoop) GetObjectNameAndClass succeeded (Name=%s, class=%d)...\n", Name, obj_class);
+#endif
+                switch(obj_class) {
+
+                case WIN32__GUI__BUTTON:
+                case WIN32__GUI__CHECKBOX:
+                case WIN32__GUI__RADIOBUTTON:
+                    switch(HIWORD(wParam)) {
+                    case BN_SETFOCUS:
+                        /*
+                         * (@)EVENT:GotFocus()
+                         * Sent when the control is activated.
+                         * (@)APPLIES_TO:Button, Checkbox, RadioButton
+                         */
+                        strcat((char *) Name, "_GotFocus");
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    case BN_KILLFOCUS:
+                        /*
+                         * (@)EVENT:LostFocus()
+                         * Sent when the control is deactivated.
+                         * (@)APPLIES_TO:Button, Checkbox, RadioButton
+                         */
+                        strcat((char *) Name, "_LostFocus");
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    case BN_CLICKED:
+                        /*
+                         * (@)EVENT:Click()
+                         * Sent when the control is selected (eg.
+                         * the button pushed, the checkbox checked, etc.).
+                         * (@)APPLIES_TO:Button, Checkbox, RadioButton
+                         */
+                        strcat((char *) Name, "_Click");
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    case BN_DBLCLK:
+                        /*
+                         * (@)EVENT:DblClick()
+                         * Sent when the user double clicks on the control.
+                         * (@)APPLIES_TO:Button, Checkbox, RadioButton
+                         */
+                        strcat((char *) Name, "_DblClick");
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    case BN_PUSHED:
+                        /*
+                         * (@)EVENT:MouseDown()
+                         * Sent when the user down clicks on the control.
+                         * (@)APPLIES_TO:Button, Checkbox, RadioButton
+                         */
+                        strcat((char *) Name, "_MouseDown");
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    case BN_UNPUSHED:
+                        /*
+                         * (@)EVENT:MouseUp()
+                         * Sent when the user releases a down click on the control.
+                         * (@)APPLIES_TO:Button, Checkbox, RadioButton
+                         */
+                        strcat((char *) Name, "_MouseUp");
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    default:
+                        strcat((char *) Name, "_Anonymous");
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                        printf("!XS(WindowMsgLoop): BUTTON WM_COMMAND NotifyCode=%d\n", HIWORD(wParam));
+#endif
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    }
+                    break;
+
+                case WIN32__GUI__LISTBOX:
+                    switch(HIWORD(wParam)) {
+                    case LBN_SETFOCUS:
+                        /*
+                         * (@)EVENT:GotFocus()
+                         * Sent when the control is activated.
+                         * (@)APPLIES_TO:Listbox
+                         */
+                        strcat((char *) Name, "_GotFocus");
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    case LBN_KILLFOCUS:
+                        /*
+                         * (@)EVENT:LostFocus()
+                         * Sent when the control is deactivated.
+                         * (@)APPLIES_TO:Listbox
+                         */
+                        strcat((char *) Name, "_LostFocus");
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    case LBN_SELCHANGE:
+                        /*
+                         * (@)EVENT:Click()
+                         * (@)APPLIES_TO:Listbox
+                         */
+                        strcat((char *) Name, "_Click");
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    case LBN_DBLCLK:
+                        /*
+                         * (@)EVENT:DblClick()
+                         * Sent when the user double clicks on the control.
+                         * (@)APPLIES_TO:Listbox
+                         */
+                        strcat((char *) Name, "_DblClick");
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    default:
+                        strcat((char *) Name, "_Anonymous");
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                        printf("!XS(WindowMsgLoop): LISTBOX WM_COMMAND NotifyCode=%d\n", HIWORD(wParam));
+#endif
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    }
+                    break;
+
+                case WIN32__GUI__EDIT:
+                case WIN32__GUI__RICHEDIT:
+                    switch(HIWORD(wParam)) {
+                    case EN_SETFOCUS:
+                        /*
+                         * (@)EVENT:GotFocus()
+                         * Sent when the control is activated.
+                         * (@)APPLIES_TO:Textfield, RichEdit
+                         */
+                        strcat((char *) Name, "_GotFocus");
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    case EN_KILLFOCUS:
+                        /*
+                         * (@)EVENT:LostFocus()
+                         * Sent when the control is deactivated.
+                         * (@)APPLIES_TO:Textfield, RichEdit
+                         */
+                        strcat((char *) Name, "_LostFocus");
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    case EN_CHANGE:
+                        /*
+                         * (@)EVENT:Change()
+                         * Sent when the text in the field is changed by the user.
+                         * (@)APPLIES_TO:Textfield, RichEdit
+                         */
+                        strcat((char *) Name, "_Change");
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    default:
+                        strcat((char *) Name, "_Anonymous");
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                        printf("!XS(WindowMsgLoop): EDIT WM_COMMAND NotifyCode=%d\n", HIWORD(wParam));
+#endif
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    }
+                    break;
+
+                case WIN32__GUI__STATIC:
+                    switch(HIWORD(wParam)) {
+                    case STN_CLICKED:
+                        /*
+                         * (@)EVENT:Click()
+                         * (@)APPLIES_TO:Label
+                         */
+                        strcat((char *) Name, "_Click");
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    case STN_DBLCLK:
+                        /*
+                         * (@)EVENT:DblClick()
+                         * (@)APPLIES_TO:Label
+                         */
+                        strcat((char *) Name, "_DblClick");
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    default:
+                        strcat((char *) Name, "_Anonymous");
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                        printf("!XS(WindowMsgLoop): STATIC WM_COMMAND NotifyCode=%d\n", HIWORD(wParam));
+#endif
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    }
+                    break;
+
+                case WIN32__GUI__COMBOBOX:
+                case WIN32__GUI__COMBOBOXEX:
+                    switch(HIWORD(wParam)) {
+                    case CBN_SETFOCUS:
+                        /*
+                         * (@)EVENT:GotFocus()
+                         * Sent when the control is activated.
+                         * (@)APPLIES_TO:Combobox, ComboboxEx
+                         */
+                        strcat((char *) Name, "_GotFocus");
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    case CBN_KILLFOCUS:
+                        /*
+                         * (@)EVENT:LostFocus()
+                         * Sent when the control is deactivated.
+                         * (@)APPLIES_TO:Combobox, ComboboxEx
+                         */
+                        strcat((char *) Name, "_LostFocus");
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                                        case CBN_SELCHANGE:
+                        /*
+                         * (@)EVENT:Change()
+                         * Sent when the user selects an item from the Combobox
+                         * (@)APPLIES_TO:Combobox, ComboboxEx
+                         */
+                        strcat((char *) Name, "_Change");
+                        PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                        break;
+                    default:
+                        strcat((char *) Name, "_Anonymous");
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                        printf("!XS(WindowMsgLoop): COMBOBOX WM_COMMAND NotifyCode=%d\n", HIWORD(wParam));
+#endif
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                        printf("!XS(WindowMsgLoop): COMBOBOX WM_COMMAND hWnd=0x%x\n", lParam);
+#endif
+                        PerlResult = DoEvent_Long(NOTXSCALL Name, HIWORD(wParam));
+                        break;
+                    }
+                    break;
+
+                case WIN32__GUI__TOOLBAR:
+                    /*
+                     * (@)EVENT:ButtonClick(INDEX)
+                     * Sent when the user presses a button of the Toolbar
+                     * the INDEX argument identifies the zero-based index of
+                     * the pressed button
+                     * (@)APPLIES_TO:Toolbar
+                     */
+                    strcat((char *) Name, "_ButtonClick");
+                    PerlResult = DoEvent_Long(NOTXSCALL Name, LOWORD(wParam));
+                    break;
+
+                }
+            }
+        }
+        break;
+
+
+    case WM_NOTIFY:
+        notify = (LPNMHDR) lParam;
+        if(GetObjectNameAndClass(NOTXSCALL notify->hwndFrom, Name, &obj_class)) {
+            switch(obj_class) {
+
+            case WIN32__GUI__TOOLBAR:
+                {
+                    LPTBNOTIFY tbn;
+                    tbn = (LPTBNOTIFY) lParam;
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                    printf("!XS(WindowMsgLoop): TOOLBAR WM_NOTIFY Code=%ud\n", tbn->hdr.code);
+#endif
+                }
+                break;
+
+            case WIN32__GUI__LISTVIEW:
+                {
+                    LPNM_LISTVIEW lv_notify;
+                    lv_notify = (LPNM_LISTVIEW) lParam;
+                    switch(notify->code) {
+                    case LVN_ITEMCHANGED:
+                        if(lv_notify->uChanged & LVIF_STATE
+                            && lv_notify->uNewState & LVIS_SELECTED) {
+                            /*
+                             * (@)EVENT:ItemClick(ITEM)
+                             * Sent when the user selects an item in the ListView;
+                             * ITEM specifies the zero-based index of the selected item.
+                             * (@)APPLIES_TO:ListView
+                             */
+                            strcat((char *) Name, "_ItemClick");
+                            PerlResult = DoEvent_Long(NOTXSCALL Name, lv_notify->iItem);
+                        }
+                        if(lv_notify->uChanged & LVIF_STATE
+                            && (lv_notify->uOldState & LVIS_STATEIMAGEMASK) != (lv_notify->uNewState & LVIS_STATEIMAGEMASK)) {
+                            /*
+                             * (@)EVENT:ItemCheck(ITEM)
+                             * Sent when the user changes the checkbox of an item in the ListView;
+                             * ITEM specifies the zero-based index of the selected item.
+                             * (@)APPLIES_TO:ListView
+                             */
+                            strcat((char *) Name, "_ItemCheck");
+                            PerlResult = DoEvent_Long(NOTXSCALL Name, lv_notify->iItem);
+                        }
+
+                        break;
+                    case LVN_COLUMNCLICK:
+                        /*
+                         * (@)EVENT:ColumnClick(ITEM)
+                         * Sent when the user clicks on a column header in the
+                         * ListView; ITEM specifies the one-based index of the
+                         * selected column.
+                         * (@)APPLIES_TO:ListView
+                         */
+                        strcat((char *) Name, "_ColumnClick");
+                        PerlResult = DoEvent_Long(NOTXSCALL Name, lv_notify->iSubItem);
+                        break;
+                    case LVN_KEYDOWN:
+                        {
+                            LV_KEYDOWN FAR * lv_keydown;
+                            lv_keydown = (LV_KEYDOWN FAR *) lParam;
+                            /*
+                             * (@)EVENT:KeyDown(KEY)
+                             * Sent when the user presses a key while the ListView
+                             * control has focus; KEY is the ASCII code of the
+                             * key being pressed.
+                             * (@)APPLIES_TO:ListView
+                             */
+                            strcat((char *) Name, "_KeyDown");
+                            PerlResult = DoEvent_Long(NOTXSCALL Name, lv_keydown->wVKey);
+                        }
+                        break;
+                    }
+                }
+                break;
+
+            case WIN32__GUI__TREEVIEW:
+                tv_notify = (LPNM_TREEVIEW) lParam;
+                switch(notify->code) {
+                case TVN_ITEMEXPANDED:
+                    if(tv_notify->action == TVE_COLLAPSE)
+                        /*
+                         * (@)EVENT:Collapse(NODE)
+                         * Sent when the user closes the specified NODE of the TreeView.
+                         * (@)APPLIES_TO:TreeView
+                         */
+                        strcat(Name, "_Collapse");
+                    else
+                        /*
+                         * (@)EVENT:Expand(NODE)
+                         * Sent when the user opens the specified NODE of the TreeView.
+                         * (@)APPLIES_TO:TreeView
+                         */
+                        strcat(Name, "_Expand");
+                    PerlResult = DoEvent_Long(NOTXSCALL Name, (long) tv_notify->itemNew.hItem);
+                    break;
+
+                case TVN_ITEMEXPANDING:
+                    if(tv_notify->action == TVE_COLLAPSE)
+                        /*
+                         * (@)EVENT:Collapsing(NODE)
+                         * Sent when the user is about to close the
+                         * specified NODE of the TreeView.
+                         * The event should return 0 to prevent the
+                         * action, 1 to allow it.
+                         * (@)APPLIES_TO:TreeView
+                         */
+                        strcat(Name, "_Collapsing");
+                    else
+                        /*
+                         * (@)EVENT:Expanding(NODE)
+                         * Sent when the user is about to open the
+                         * specified NODE of the TreeView
+                         * The event should return 0 to prevent the
+                         * action, 1 to allow it.
+                         * (@)APPLIES_TO:TreeView
+                         */
+                        strcat(Name, "_Expanding");
+                    PerlResult = DoEvent_Long(NOTXSCALL Name, (long) tv_notify->itemNew.hItem);
+                    FREETMPS;
+                    LEAVE;
+                    if(PerlResult == 0) return TRUE;
+                    else                return FALSE;
+                    break;
+
+                case TVN_SELCHANGED:
+                    /*
+                     * (@)EVENT:NodeClick(NODE)
+                     * Sent when the user clicks on the specified NODE of the TreeView.
+                     * (@)APPLIES_TO:TreeView
+                     */
+                    strcat(Name, "_NodeClick");
+                    PerlResult = DoEvent_Long(NOTXSCALL Name, (long) tv_notify->itemNew.hItem);
+                    break;
+
+                case TVN_KEYDOWN:
+                    /*
+                     * (@)EVENT:KeyDown(KEY)
+                     * Sent when the user presses a key while the TreeView
+                     * control has focus; KEY is the ASCII code of the
+                     * key being pressed.
+                     * (@)APPLIES_TO:TreeView
+                     */
+                    tv_keydown = (TV_KEYDOWN FAR *) lParam;
+                    strcat((char *) Name, "_KeyDown");
+                    PerlResult = DoEvent_Long(NOTXSCALL Name, tv_keydown->wVKey);
+                    break;
+                }
+                break;
+
+            case WIN32__GUI__TAB:
+                switch(notify->code) {
+                case TCN_SELCHANGING:
+                    /*
+                     * (@)EVENT:Changing()
+                     * Sent before the current selection changes.
+                     * Use SelectedItem() to determine the
+                     * current selection.
+                     * The event should return 0 to prevent
+                     * the selection changing, 1 to allow it.
+                     * (@)APPLIES_TO:TabStrip
+                     */
+                    strcat((char *) Name, "_Changing");
+                    PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                    FREETMPS;
+                    LEAVE;
+                    if(PerlResult == 0) return TRUE;
+                    else                return FALSE;
+                    break;
+                case TCN_SELCHANGE:
+                    /*
+                     * (@)EVENT:Change()
+                     * Sent when the current
+                     * selection has changed. Use SelectedItem()
+                     * to determine the current selection.
+                     * (@)APPLIES_TO:TabStrip
+                     */
+                    strcat((char *) Name, "_Change");
+                    PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                    break;
+                }
+                break;
+
+            case WIN32__GUI__TOOLTIP:
+                if(((LPNMHDR)lParam)->code == TTN_NEEDTEXT) {
+                    /*
+                     * (@)EVENT:NeedText(ID)
+                     * (@)APPLIES_TO:Tooltip
+                     */
+                    LPTOOLTIPTEXT lptt;
+                    lptt = (LPTOOLTIPTEXT) lParam;
+                    lptt->lpszText = (LPTSTR) DoEvent_NeedText(NOTXSCALL Name, lptt->hdr.idFrom);
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                    printf("!XS(WindowMsgLoop): TTN_NEEDTEXT got '%s'\n", lptt->lpszText);
+#endif
+                    PerlResult = 1;
+                }
+                break;
+
+            case WIN32__GUI__REBAR:
+                if(((LPNMHDR)lParam)->code == RBN_HEIGHTCHANGE) {
+                    /*
+                     * (@)EVENT:HeightChange()
+                     * Sent when the height of the Rebar control has changed.
+                     * (@)APPLIES_TO:Rebar
+                     */
+                    strcat((char *) Name, "_HeightChange");
+                    PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                }
+                break;
+
+            case WIN32__GUI__HEADER:
+                if(((LPNMHDR)lParam)->code == HDN_BEGINTRACK) {
+                    /*
+                     * (@)EVENT:BeginTrack(INDEX, WIDTH)
+                     * Sent when a divider of the Header control
+                     * is being moved; the event must return 0 to
+                     * prevent moving the divider, 1 to allow it.
+                     * Passes the zero-based INDEX
+                     * of the item being resized and its current
+                     * WIDTH.
+                     * (@)APPLIES_TO:Header
+                     */
+                    LPNMHEADER nmh;
+                    nmh = (LPNMHEADER) lParam;
+                    strcat((char *) Name, "_BeginTrack");
+                    PerlResult = DoEvent_TwoLongs(
+                        NOTXSCALL Name,
+                        nmh->iItem,
+                        nmh->pitem->cxy
+                    );
+                    FREETMPS;
+                    LEAVE;
+                    if(PerlResult == 0) return TRUE;
+                    else                return FALSE;
+                } else if(((LPNMHDR)lParam)->code == HDN_ENDTRACK) {
+                    /*
+                     * (@)EVENT:EndTrack(INDEX, WIDTH)
+                     * Sent when a divider of the Header control
+                     * has been moved. Passes the zero-based INDEX
+                     * of the item being resized and its current
+                     * WIDTH.
+                     * (@)APPLIES_TO:Header
+                     */
+                    LPNMHEADER nmh;
+                    nmh = (LPNMHEADER) lParam;
+                    strcat((char *) Name, "_EndTrack");
+                    PerlResult = DoEvent_TwoLongs(
+                        NOTXSCALL Name,
+                        nmh->iItem,
+                        nmh->pitem->cxy
+                    );
+                } else if(((LPNMHDR)lParam)->code == HDN_TRACK) {
+                    /*
+                     * (@)EVENT:Track(INDEX, WIDTH)
+                     * Sent while a divider of the Header control
+                     * is being moved; the event must return 1 to
+                     * continue moving the divider, 0 to end its
+                     * movement.
+                     * Passes the zero-based INDEX
+                     * of the item being resized and its current
+                     * WIDTH.
+                     * (@)APPLIES_TO:Header
+                     */
+                    LPNMHEADER nmh;
+                    nmh = (LPNMHEADER) lParam;
+                    strcat((char *) Name, "_Track");
+                    PerlResult = DoEvent_TwoLongs(
+                        NOTXSCALL Name,
+                        nmh->iItem,
+                        nmh->pitem->cxy
+                    );
+                    FREETMPS;
+                    LEAVE;
+                    if(PerlResult == 0) return TRUE;
+                    else                return FALSE;
+                } else if(((LPNMHDR)lParam)->code == HDN_DIVIDERDBLCLICK) {
+                    /*
+                     * (@)EVENT:DividerDblClick(INDEX)
+                     * Sent when the user double-clicked on a
+                     * divider of the Header control.
+                     * (@)APPLIES_TO:Header
+                     */
+                    LPNMHEADER nmh;
+                    nmh = (LPNMHEADER) lParam;
+                    strcat((char *) Name, "_DividerDblClick");
+                    PerlResult = DoEvent_Long(NOTXSCALL Name, nmh->iItem);
+                } else if(((LPNMHDR)lParam)->code == HDN_ITEMCLICK) {
+                    /*
+                     * (@)EVENT:ItemClick(INDEX)
+                     * Sent when the user clicked on a Header
+                     * item.
+                     * (@)APPLIES_TO:Header
+                     */
+                    LPNMHEADER nmh;
+                    nmh = (LPNMHEADER) lParam;
+                    strcat((char *) Name, "_ItemClick");
+                    PerlResult = DoEvent_Long(NOTXSCALL Name, nmh->iItem);
+                } else if(((LPNMHDR)lParam)->code == HDN_ITEMDBLCLICK) {
+                    /*
+                     * (@)EVENT:ItemDblClick(INDEX)
+                     * Sent when the user double-clicked on a Header
+                     * item.
+                     * (@)APPLIES_TO:Header
+                     */
+                    LPNMHEADER nmh;
+                    nmh = (LPNMHEADER) lParam;
+                    strcat((char *) Name, "_ItemDblClick");
+                    PerlResult = DoEvent_Long(NOTXSCALL Name, nmh->iItem);
+                }
+                break;
+
+            }
+            /*
+             * ###############################################
+             * standard notifications (true for all controls?)
+             * ###############################################
+             */
+            switch(notify->code) {
+            case NM_CLICK:
+                /*
+                 * (@)EVENT:Click()
+                 * (@)APPLIES_TO:*
+                 */
+                strcat((char *) Name, "_Click");
+                PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                break;
+            case NM_RCLICK:
+                /*
+                 * (@)EVENT:RightClick()
+                 * (@)APPLIES_TO:*
+                 */
+                strcat((char *) Name, "_RightClick");
+                PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                break;
+            case NM_DBLCLK:
+                /*
+                 * (@)EVENT:DblClick()
+                 * (@)APPLIES_TO:*
+                 */
+                strcat((char *) Name, "_DblClick");
+                PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                break;
+            case NM_RDBLCLK:
+                /*
+                 * (@)EVENT:DblRightClick()
+                 * (@)APPLIES_TO:*
+                 */
+                strcat((char *) Name, "_DblRightClick");
+                PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                break;
+            case NM_SETFOCUS:
+                /*
+                 * (@)EVENT:GotFocus()
+                 * (@)APPLIES_TO:*
+                 */
+                strcat((char *) Name, "_GotFocus");
+                PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                break;
+            case NM_KILLFOCUS:
+                /*
+                 * (@)EVENT:LostFocus()
+                 * (@)APPLIES_TO:*
+                 */
+                strcat((char *) Name, "_LostFocus");
+                PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                break;
+            }
+        }
+        break;
+
+    case WM_TIMER:
+        /* (@)EVENT:Timer() */
+        if(GetTimerName(NOTXSCALL hwnd, wParam, Name)) {
+            strcat((char *) Name, "_Timer");
+            PerlResult = DoEvent_Generic(NOTXSCALL Name);
+        } else {
+            PerlResult = 0;
+        }
+        break;
+
+    case WM_HSCROLL:
+    case WM_VSCROLL:
+        if(GetObjectNameAndClass(NOTXSCALL (HWND) lParam, Name, &obj_class)) {
+            switch(obj_class) {
+            case WIN32__GUI__TRACKBAR:
+                /*
+                 * (@)EVENT:Scroll()
+                 * Sent when the user moves the slider handle.
+                 * (@)APPLIES_TO:Slider
+                 */
+                strcat((char *) Name, "_Scroll");
+                PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                break;
+            case WIN32__GUI__UPDOWN:
+                /*
+                 * (@)EVENT:Scroll()
+                 * Sent when the user presses either the up or down button
+                 * of the UpDown control.
+                 * (@)APPLIES_TO:UpDown
+                 */
+                strcat((char *) Name, "_Scroll");
+                PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                break;
+            }
+        }
+        break;
+
+    case WM_MOUSEHOVER:
+        if(GetObjectName(NOTXSCALL hwnd, Name)) {
+            strcat((char *) Name, "_MouseOver");
+            PerlResult = DoEvent_Generic(NOTXSCALL Name);
+            if(PerlResult) {
+                TRACKMOUSEEVENT tme;
+                tme.cbSize = sizeof(TRACKMOUSEEVENT);
+                tme.hwndTrack = hwnd;
+                tme.dwFlags = TME_QUERY;
+                if(TrackMouseEvent( &tme )) {
+                    TrackMouseEvent( &tme );
+                }
+            }
+        }
+        break;
+    case WM_MOUSELEAVE:
+        if(GetObjectName(NOTXSCALL hwnd, Name)) {
+            strcat((char *) Name, "_MouseOut");
+            PerlResult = DoEvent_Generic(NOTXSCALL Name);
+            if(PerlResult) {
+                TRACKMOUSEEVENT tme;
+                tme.cbSize = sizeof(TRACKMOUSEEVENT);
+                tme.hwndTrack = hwnd;
+                tme.dwFlags = TME_QUERY;
+                if(TrackMouseEvent( &tme )) {
+                    TrackMouseEvent( &tme );
+                }
+            }
+        }
+        break;
+
+/*
+    case WM_MOUSEMOVE:
+    case WM_LBUTTONDOWN:
+    case WM_LBUTTONUP:
+    case WM_RBUTTONDOWN:
+    case WM_RBUTTONUP:
+        {
+            HV* self;
+            SV** rtts;
+            AV* tts;
+            I32 ttsi;
+            SV** rtt;
+            HWND tt;
+            MSG ttmsg;
+            self = HV_SELF_FROM_WINDOW(hwnd);
+            if(self != NULL) {
+                rtts = hv_fetch_mg(NOTXSCALL self, "-tooltips", 9, FALSE);
+                if(rtts != NULL && SvOK(*rtts)) {
+                        if(SvROK(*rtts) && SvTYPE(SvRV(*rtts)) == SVt_PVAV) {
+                            tts = (AV*) SvRV(*rtts);
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                                printf("!XS(WindowMsgLoop): found -tooltips (%d)...\n", av_len(tts));
+#endif
+                            for(ttsi=0;ttsi<av_len(tts);ttsi++) {
+                                rtt = av_fetch(tts, ttsi, 0);
+                                if(rtt != NULL) {
+                                    tt = (HWND) SvIV(*rtt);
+#ifdef PERLWIN32GUI_STRONGDEBUG
+                                        printf("!XS(WindowMsgLoop): relaying to tooltip 0x%x...\n", tt);
+#endif
+                                    ttmsg.hwnd = hwnd;
+                                ttmsg.lParam = lParam;
+                                ttmsg.wParam = wParam;
+                                ttmsg.message = uMsg;
+                                SendMessage(tt, TTM_RELAYEVENT, 0, (LPARAM) &ttmsg);
+                                }
+                        }
+                    }
+                }
+            }
+        }
+        break;
+*/
+    case WM_NOTIFYICON:
+        if(GetNotifyIconName(NOTXSCALL hwnd, (UINT) wParam, Name)) {
+            switch(lParam) {
+            case WM_LBUTTONDOWN:
+                /*
+                 * (@)EVENT:Click()
+                 * Sent when the user clicks the left mouse button on
+                 * a NotifyIcon.
+                 * (@)APPLIES_TO:NotifyIcon
+                 */
+                strcat(Name, "_Click");
+                PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                break;
+            case WM_RBUTTONDOWN:
+                /*
+                 * (@)EVENT:RightClick()
+                 * Sent when the user clicks the right mouse button on
+                 * a NotifyIcon.
+                 * (@)APPLIES_TO:NotifyIcon
+                 */
+                strcat(Name, "_RightClick");
+                PerlResult = DoEvent_Generic(NOTXSCALL Name);
+                break;
+            default:
+                /*
+                 * (@)EVENT:MouseEvent(MSG)
+                 * Sent when the user performs a mouse event on
+                 * a NotifyIcon; MSG is the message code.
+                 * (@)APPLIES_TO:NotifyIcon
+                 */
+                strcat(Name, "_MouseEvent");
+                PerlResult = DoEvent_Long(NOTXSCALL Name, (long)lParam);
+                break;
+            }
+        }
+        break;
+
+        case WM_DROPFILES:
+            if(GetObjectName(NOTXSCALL hwnd, Name)) {
+                /*
+                 * (@)EVENT:DropFiles(DROP_HANDLE)
+                 * Sent when the window receives dropped files.
+                 * (@)APPLIES_TO:Window, DialogBox
+                 */
+                strcat(Name, "_DropFiles");
+                PerlResult = DoEvent_Long(NOTXSCALL Name, UINT(wParam));
+            }
+            break;
+        }
+        FREETMPS;
+        LEAVE;
+
+    if(PerlResult == -1) {
+        PostMessage(hwnd, WM_EXITLOOP, (WPARAM) -1, 0);
+        return 0;
+    } else {
+        if(PerlResult == 0) {
+            return 0;
+        } else {
+            return CommonMsgLoop(NOTXSCALL hwnd, uMsg, wParam, lParam);
+        }
+    }
+}
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:MsgLoop(hwnd, uMsg, wParam, lParam)
+    # obsolete (?) Win32::GUI::Window message loop
+    */
+LRESULT CALLBACK MsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
+
+#ifdef PERL_OBJECT
+    CPerl *pPerl = PERL_OBJECT_FROM_WINDOW(hwnd);
+#endif
+
+    HV* cb_hash;
+    SV** cb_ref;
+    int PerlResult = 1;
+    char temp[80];
+    int send_to = 0;
+    // 0 = DefWindowProc
+    // 1 = function: perl_call_sv(cb_ref...
+    // 2 = function or DefWindowProc
+
+    dSP;
+
+    ENTER ;
+    SAVETMPS;
+
+    PUSHMARK(SP) ;
+    EXTEND(SP,4) ;
+    PUSHs(sv_2mortal(newSViv((long)hwnd)));
+    PUSHs(sv_2mortal(newSViv((long)uMsg)));
+    PUSHs(sv_2mortal(newSViv((long)wParam)));
+    PUSHs(sv_2mortal(newSViv((long)lParam)));
+    PUTBACK ;
+
+    if(uMsg == WM_COMMAND) {
+
+        if(lParam == 0) {
+            // Menu Option
+            if(HIWORD(wParam) == 0) {
+                cb_hash = perl_get_hv("Win32::GUI::menucallbacks", FALSE);
+                ltoa((long) LOWORD(wParam), temp, 10);
+                if(hv_exists(cb_hash, temp, strlen(temp))) {
+                    cb_ref = hv_fetch(cb_hash, temp, strlen(temp), FALSE);
+                    send_to = 1; // cb_ref
+                } else {
+                    send_to = 2;
+                }
+            } else {
+                send_to = 2; // ...hwnd or Def
+            }
+        } else {
+            cb_hash = perl_get_hv("Win32::GUI::callbacks", FALSE);
+            ltoa((long)lParam, temp, 10);
+            if(hv_exists(cb_hash, temp, strlen(temp))) {
+                cb_ref = hv_fetch(cb_hash, temp, strlen(temp), FALSE);
+                send_to = 1; // cb_ref
+            } else {
+                send_to = 2; // ...hwnd or Def
+            }
+        }
+    } else if(uMsg == WM_NOTIFY) {
+        LPNMHDR nmhdr = (LPNMHDR) lParam;
+        HWND hwnd = nmhdr->hwndFrom;
+        UINT id = nmhdr->idFrom;
+        UINT code = nmhdr->code;
+        cb_hash = perl_get_hv("Win32::GUI::callbacks", FALSE);
+        ltoa((long)hwnd, temp, 10);
+        if(hv_exists(cb_hash, temp, strlen(temp))) {
+            cb_ref = hv_fetch(cb_hash, temp, strlen(temp), FALSE);
+            send_to = 1; // cb_ref
+        } else {
+            send_to = 2; // ...hwnd or Def
+        }
+    } else {
+        send_to = 2;
+    }
+
+    switch(send_to) {
+    case 2:
+        cb_hash = perl_get_hv("Win32::GUI::callbacks", FALSE);
+        ltoa((long)hwnd, temp, 10);
+        if(hv_exists(cb_hash, temp, strlen(temp))) {
+
+            cb_ref = hv_fetch(cb_hash, temp, strlen(temp), FALSE);
+
+            perl_call_pv((char *)SvPV_nolen(*cb_ref), G_ARRAY);
+
+            SPAGAIN ;
+            PerlResult = POPi;
+            PUTBACK ;
+        }
+        break;
+    case 1:
+        perl_call_pv((char *)SvPV_nolen(*cb_ref), G_ARRAY);
+        SPAGAIN ;
+        PerlResult = POPi;
+        PUTBACK ;
+        break;
+    }
+    FREETMPS ;
+    LEAVE ;
+
+    if(PerlResult == -1) {
+#ifdef PERLWIN32GUI_DEBUG
+        printf("!XS(MsgLoop): posting WM_EXITLOOP to 0x%x...\n", hwnd);
+#endif
+        PostMessage(hwnd, WM_EXITLOOP, (WPARAM) -1, 0);
+        return 0;
+    } else {
+        if(PerlResult == 0) {
+            return 0;
+        } else {
+            return DefWindowProc(hwnd, uMsg, wParam, lParam);
+        }
+    }
+}
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:InactiveMsgLoop(hwnd, uMsg, wParam, lParam)
+    # called by DoModal
+    */
+LRESULT CALLBACK InactiveMsgLoop(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+    LPPERLWIN32GUI_USERDATA perlud;
+    
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    printf("!XS(InactiveMsgLoop) got (0x%x, 0x%x, 0x%x, 0x%x)\n", hwnd, uMsg, wParam, lParam);
+#endif
+    
+    perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(hwnd, GWL_USERDATA);
+    if( ValidUserData(perlud) ) {
+        if(uMsg == WM_ACTIVATE && LOWORD(wParam) == WA_ACTIVE) {
+#ifdef PERL_OBJECT
+            CPerl *pPerl;
+            pPerl = perlud->pPerl;
+#endif
+            SendMessage(perlud->Modal, WM_ACTIVATE, wParam, (LPARAM) perlud->Modal);
+            return 0;
+        }
+    }
+    return DefWindowProc(hwnd, uMsg, wParam, lParam);
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/GUI_Options.cpp perl-libwin32-0.191/GUI/GUI_Options.cpp
--- libwin32-0.191/GUI/GUI_Options.cpp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/GUI_Options.cpp	2004-01-12 16:46:40.000000000 -0800
@@ -0,0 +1,1111 @@
+	/*
+    ###########################################################################
+    # options parsing routines
+	#
+	# $Id: GUI_Options.cpp,v 1.3 2003/12/28 07:17:43 caelum Exp $
+	#
+    ###########################################################################
+	*/
+
+#include "GUI.h"
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:ParseNEMEvent(*perlcs, char *name, SV event)
+    */
+void ParseNEMEvent(
+    NOTXSPROC
+    LPPERLWIN32GUI_CREATESTRUCT perlcs,
+	char *name,
+	SV* event
+) {
+    dTHR;
+	SV* newval;
+	int	eventID;
+	int styleModifier;
+
+	eventID = 0;
+#ifdef PERLWIN32GUI_STRONGDEBUG
+	printf("!XS(ParseNEMEvent) got NEM name '%s'\n", name);
+#endif
+	if(strcmp(name, "MouseMove") == 0) {
+		eventID = PERLWIN32GUI_NEM_MOUSEMOVE;
+		styleModifier = PERLWIN32GUI_NEM_CHILD;
+	} else if(strcmp(name, "MouseDown") == 0) {
+		eventID = PERLWIN32GUI_NEM_MOUSEDOWN;
+		styleModifier = PERLWIN32GUI_NEM_CHILD;
+	} else if(strcmp(name, "MouseUp") == 0) {
+		eventID = PERLWIN32GUI_NEM_MOUSEUP;
+		styleModifier = PERLWIN32GUI_NEM_CHILD;
+	} else if(strcmp(name, "KeyDown") == 0) {
+		eventID = PERLWIN32GUI_NEM_KEYDOWN;
+		styleModifier = PERLWIN32GUI_NEM_CHILD;
+	} else if(strcmp(name, "KeyUp") == 0) {
+		eventID = PERLWIN32GUI_NEM_KEYUP;
+		styleModifier = PERLWIN32GUI_NEM_CHILD;
+	} else if(strcmp(name, "Timer") == 0) {
+		eventID = PERLWIN32GUI_NEM_TIMER;
+		styleModifier = PERLWIN32GUI_NEM_CHILD;
+	}
+	else {
+		switch(perlcs->iClass) {
+
+		case PERLWIN32GUI_CLS_WINDOW:
+		case PERLWIN32GUI_CLS_DIALOG:
+			if(strcmp(name, "Deactivate") == 0) {
+				eventID = PERLWIN32GUI_NEM_DEACTIVATE;
+			} else if(strcmp(name, "Activate") == 0) {
+				eventID = PERLWIN32GUI_NEM_ACTIVATE;
+			} else if(strcmp(name, "Terminate") == 0) {
+				eventID = PERLWIN32GUI_NEM_TERMINATE;
+			} else if(strcmp(name, "Minimize") == 0) {
+				eventID = PERLWIN32GUI_NEM_MINIMIZE;
+			} else if(strcmp(name, "Maximize") == 0) {
+				eventID = PERLWIN32GUI_NEM_MAXIMIZE;
+			} else if(strcmp(name, "Resize") == 0) {
+				eventID = PERLWIN32GUI_NEM_RESIZE;
+			} else {
+				if(PL_dowarn) {
+					warn("Win32::GUI: Unrecognized event name '%s' in -names!", name);
+				}
+			}
+			break;
+
+		case PERLWIN32GUI_CLS_BUTTON:
+		case PERLWIN32GUI_CLS_CHECKBOX:
+		case PERLWIN32GUI_CLS_RADIOBUTTON:
+			if(strcmp(name, "GotFocus") == 0) {
+				eventID = PERLWIN32GUI_NEM_GOTFOCUS;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "LostFocus") == 0) {
+				eventID = PERLWIN32GUI_NEM_LOSTFOCUS;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "DblClick") == 0) {
+				eventID = PERLWIN32GUI_NEM_DBLCLICK;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "Click") == 0) {
+				eventID = PERLWIN32GUI_NEM_CLICK;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else {
+				if(PL_dowarn) {
+					warn("Win32::GUI: Unrecognized event name '%s'!", name);
+				}
+			}
+			break;
+
+		case PERLWIN32GUI_CLS_LISTBOX:
+			if(strcmp(name, "GotFocus") == 0) {
+				eventID = PERLWIN32GUI_NEM_GOTFOCUS;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "LostFocus") == 0) {
+				eventID = PERLWIN32GUI_NEM_LOSTFOCUS;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "DblClick") == 0) {
+				eventID = PERLWIN32GUI_NEM_DBLCLICK;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "Click") == 0) {
+				eventID = PERLWIN32GUI_NEM_CLICK;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else {
+				if(PL_dowarn) {
+					warn("Win32::GUI: Unrecognized event name '%s'!", name);
+				}
+			}
+			break;
+
+		case PERLWIN32GUI_CLS_EDIT:
+		case PERLWIN32GUI_CLS_RICHEDIT:
+			if(strcmp(name, "GotFocus") == 0) {
+				eventID = PERLWIN32GUI_NEM_GOTFOCUS;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "LostFocus") == 0) {
+				eventID = PERLWIN32GUI_NEM_LOSTFOCUS;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "Change") == 0) {
+				eventID = PERLWIN32GUI_NEM_CHANGE;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else {
+				if(PL_dowarn) {
+					warn("Win32::GUI: Unrecognized event name '%s'!", name);
+				}
+			}
+			break;
+
+		case PERLWIN32GUI_CLS_STATIC:
+			if(strcmp(name, "DblClick") == 0) {
+				eventID = PERLWIN32GUI_NEM_DBLCLICK;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "Click") == 0) {
+				eventID = PERLWIN32GUI_NEM_CLICK;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else {
+				if(PL_dowarn) {
+					warn("Win32::GUI: Unrecognized event name '%s'!", name);
+				}
+			}
+			break;
+
+		case PERLWIN32GUI_CLS_COMBOBOX:
+			if(strcmp(name, "GotFocus") == 0) {
+				eventID = PERLWIN32GUI_NEM_GOTFOCUS;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "LostFocus") == 0) {
+				eventID = PERLWIN32GUI_NEM_LOSTFOCUS;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "DblClick") == 0) {
+				eventID = PERLWIN32GUI_NEM_DBLCLICK;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "Change") == 0) {
+				eventID = PERLWIN32GUI_NEM_CHANGE;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else {
+				if(PL_dowarn) {
+					warn("Win32::GUI: Unrecognized event name '%s'!", name);
+				}
+			}
+			break;
+
+		case PERLWIN32GUI_CLS_TOOLBAR:
+			if(strcmp(name, "ButtonClick") == 0) {
+				eventID = PERLWIN32GUI_NEM_BUTTONCLICK;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else {
+				if(PL_dowarn) {
+					warn("Win32::GUI: Unrecognized event name '%s'!", name);
+				}
+			}
+			break;
+
+		case PERLWIN32GUI_CLS_LISTVIEW:
+			if(strcmp(name, "ItemClick") == 0) {
+				eventID = PERLWIN32GUI_NEM_ITEMCLICK;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "ItemCheck") == 0) {
+				eventID = PERLWIN32GUI_NEM_ITEMCHECK;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "ColumnClick") == 0) {
+				eventID = PERLWIN32GUI_NEM_COLUMNCLICK;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "KeyDown") == 0) {
+				eventID = PERLWIN32GUI_NEM_KEYDOWN;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else {
+				if(PL_dowarn) {
+					warn("Win32::GUI: Unrecognized event name '%s'!", name);
+				}
+			}
+			break;
+
+		case PERLWIN32GUI_CLS_TREEVIEW:
+			if(strcmp(name, "NodeClick") == 0) {
+				eventID = PERLWIN32GUI_NEM_NODECLICK;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "Collapse") == 0) {
+				eventID = PERLWIN32GUI_NEM_COLLAPSE;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "Expand") == 0) {
+				eventID = PERLWIN32GUI_NEM_EXPAND;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "Collapsing") == 0) {
+				eventID = PERLWIN32GUI_NEM_COLLAPSING;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "Expanding") == 0) {
+				eventID = PERLWIN32GUI_NEM_EXPANDING;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "KeyDown") == 0) {
+				eventID = PERLWIN32GUI_NEM_KEYDOWN;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else {
+				if(PL_dowarn) {
+					warn("Win32::GUI: Unrecognized event name '%s'!", name);
+				}
+			}
+			break;
+
+		case PERLWIN32GUI_CLS_TAB:
+			if(strcmp(name, "Changing") == 0) {
+				eventID = PERLWIN32GUI_NEM_CHANGING;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "Change") == 0) {
+				eventID = PERLWIN32GUI_NEM_CHANGE;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else {
+				if(PL_dowarn) {
+					warn("Win32::GUI: Unrecognized event name '%s'!", name);
+				}
+			}
+			break;
+
+		case PERLWIN32GUI_CLS_TOOLTIP:
+			if(strcmp(name, "NeedText") == 0) {
+				eventID = PERLWIN32GUI_NEM_NEEDTEXT;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else {
+				if(PL_dowarn) {
+					warn("Win32::GUI: Unrecognized event name '%s'!", name);
+				}
+			}
+			break;
+
+		case PERLWIN32GUI_CLS_REBAR:
+			if(strcmp(name, "HeightChange") == 0) {
+				eventID = PERLWIN32GUI_NEM_HEIGHTCHANGE;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else {
+				if(PL_dowarn) {
+					warn("Win32::GUI: Unrecognized event name '%s'!", name);
+				}
+			}
+			break;
+
+		case PERLWIN32GUI_CLS_HEADER:
+			if(strcmp(name, "BeginTrack") == 0) {
+				eventID = PERLWIN32GUI_NEM_BEGINTRACK;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "EndTrack") == 0) {
+				eventID = PERLWIN32GUI_NEM_ENDTRACK;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "Track") == 0) {
+				eventID = PERLWIN32GUI_NEM_TRACK;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "DividerDblClick") == 0) {
+				eventID = PERLWIN32GUI_NEM_DIVIDERDBLCLICK;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "ItemClick") == 0) {
+				eventID = PERLWIN32GUI_NEM_ITEMCLICK;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else if(strcmp(name, "ItemDblClick") == 0) {
+				eventID = PERLWIN32GUI_NEM_ITEMDBLCLICK;
+				styleModifier = PERLWIN32GUI_NEM_PARENT;
+			} else {
+				if(PL_dowarn) {
+					warn("Win32::GUI: Unrecognized event name '%s'!", name);
+				}
+			}
+			break;
+		}
+	}
+	if(eventID != 0) {
+		if(SvOK(event)) {
+			newval = newSVsv(event);
+			hv_store(perlcs->hvEvents, name, strlen(name), newval, 0);
+			SwitchBit(perlcs->dwEventMask, eventID, 1);
+			if(styleModifier != 0) {
+				SwitchBit(perlcs->dwPlStyle, styleModifier, 1);
+			}
+		} else {
+			/* got undef */
+			SwitchBit(perlcs->dwEventMask, eventID, 0);
+		}
+	}
+#ifdef PERLWIN32GUI_STRONDEBUG
+	printf("!XS(ParseNEMEvent) NEM event mask is 0x%x\n", perlcs->dwEventMask);
+#endif
+}
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:ParseWindowOptions(sp, mark, ax ,items, from_i, *perlcs)
+    */
+void ParseWindowOptions(
+    NOTXSPROC
+    register SV **sp,
+    register SV **mark,
+    I32 ax,
+    I32 items,
+    int from_i,
+    LPPERLWIN32GUI_CREATESTRUCT perlcs
+) {
+    dTHR;
+	int i, next_i;
+    char * option;
+    SV** stored;
+    SV* storing;
+#ifdef PERLWIN32GUI_STRONGDEBUG
+    // printf("!XS(ParseWindowOptions): from_i=%d, items=%d\n", from_i, items);
+#endif
+    next_i = -1;
+    for(i=from_i; i<items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+#ifdef PERLWIN32GUI_STRONGDEBUG
+            printf("!XS(ParseWindowOptions): got option '%s'\n", option);
+#endif
+            if(strcmp(option, "-class") == 0) {
+                next_i = i + 1;
+                perlcs->cs.lpszClass = (LPCTSTR) classname_From(NOTXSCALL ST(next_i));
+            } else if(strcmp(option, "-text") == 0
+            ||        strcmp(option, "-caption") == 0
+            ||        strcmp(option, "-title") == 0) {
+                next_i = i + 1;
+                perlcs->cs.lpszName = (LPCTSTR) SvPV_nolen(ST(next_i));
+            } else if(strcmp(option, "-style") == 0) {
+                next_i = i + 1;
+                perlcs->cs.style = (DWORD) SvIV(ST(next_i));
+                if(PL_dowarn) {
+                    warn("Win32::GUI: the -style option is deprecated!");
+                }
+            } else if(strcmp(option, "-pushstyle") == 0
+            ||        strcmp(option, "-addstyle") == 0) {
+                next_i = i + 1;
+                perlcs->cs.style |= (DWORD) SvIV(ST(next_i));
+            } else if(strcmp(option, "-popstyle") == 0
+            ||        strcmp(option, "-remstyle") == 0
+            ||        strcmp(option, "-notstyle") == 0
+            ||        strcmp(option, "-negstyle") == 0) {
+                next_i = i + 1;
+                perlcs->cs.style &= perlcs->cs.style ^ (DWORD) SvIV(ST(next_i));
+            } else if(strcmp(option, "-exstyle") == 0) {
+                next_i = i + 1;
+                perlcs->cs.dwExStyle = (DWORD) SvIV(ST(next_i));
+                if(PL_dowarn) {
+                    warn("Win32::GUI: the -exstyle option is deprecated!");
+                }
+            } else if(strcmp(option, "-pushexstyle") == 0
+            ||        strcmp(option, "-addexstyle") == 0) {
+                next_i = i + 1;
+                perlcs->cs.dwExStyle |= (DWORD) SvIV(ST(next_i));
+            } else if(strcmp(option, "-popexstyle") == 0
+            ||        strcmp(option, "-remexstyle") == 0
+            ||        strcmp(option, "-notexstyle") == 0
+            ||        strcmp(option, "-negexstyle") == 0) {
+                next_i = i + 1;
+                perlcs->cs.dwExStyle &= perlcs->cs.dwExStyle ^ (DWORD) SvIV(ST(next_i));
+            } else if(strcmp(option, "-left") == 0) {
+                next_i = i + 1;
+                perlcs->cs.x = (int) SvIV(ST(next_i));
+            } else if(strcmp(option, "-top") == 0) {
+                next_i = i + 1;
+                perlcs->cs.y = (int) SvIV(ST(next_i));
+            } else if(strcmp(option, "-width") == 0) {
+                next_i = i + 1;
+                perlcs->cs.cx = (int) SvIV(ST(next_i));
+            } else if(strcmp(option, "-height") == 0) {
+                next_i = i + 1;
+                perlcs->cs.cy = (int) SvIV(ST(next_i));
+            } else if(strcmp(option, "-parent") == 0) {
+                next_i = i + 1;
+                perlcs->cs.hwndParent = (HWND) handle_From(NOTXSCALL ST(next_i));
+                if(SvROK(ST(next_i))) {
+                    perlcs->hvParent = (HV*) SvRV(ST(next_i));
+                }
+            } else if(strcmp(option, "-menu") == 0) {
+                next_i = i + 1;
+                perlcs->cs.hMenu = (HMENU) handle_From(NOTXSCALL ST(next_i));
+            } else if(strcmp(option, "-instance") == 0) {
+                next_i = i + 1;
+                perlcs->cs.hInstance = (HINSTANCE)(int)SvIV(ST(next_i));
+            } else if(strcmp(option, "-name") == 0) {
+                next_i = i + 1;
+                perlcs->szWindowName = SvPV_nolen(ST(next_i));
+            } else if(strcmp(option, "-function") == 0) {
+                next_i = i + 1;
+                perlcs->szWindowFunction = SvPV_nolen(ST(next_i));
+            } else if(strcmp(option, "-font") == 0) {
+                next_i = i + 1;
+                perlcs->hFont = (HFONT) handle_From(NOTXSCALL ST(next_i));
+            } else if(strcmp(option, "-foreground") == 0) {
+                next_i = i + 1;
+                perlcs->clrForeground = SvCOLORREF(NOTXSCALL ST(next_i));
+                storing = newSViv((long) perlcs->clrForeground);
+                stored = hv_store_mg(NOTXSCALL perlcs->hvSelf, "-foreground", 11, storing, 0);
+            } else if(strcmp(option, "-background") == 0) {
+                next_i = i + 1;
+                perlcs->clrBackground = SvCOLORREF(NOTXSCALL ST(next_i));
+                {
+					LOGBRUSH lb;
+					ZeroMemory(&lb, sizeof(LOGBRUSH));
+			        lb.lbStyle = BS_SOLID;
+        			lb.lbColor = perlcs->clrBackground;
+					if(perlcs->hBackgroundBrush != NULL) {
+						DeleteObject((HGDIOBJ) perlcs->hBackgroundBrush);
+					}
+        			perlcs->hBackgroundBrush = CreateBrushIndirect(&lb);
+				}
+                storing = newSViv((long) perlcs->clrBackground);
+				stored = hv_store_mg(NOTXSCALL perlcs->hvSelf, "-background", 11, storing, 0);
+                storing = newSViv((long) perlcs->hBackgroundBrush);
+				stored = hv_store_mg(NOTXSCALL perlcs->hvSelf, "-backgroundbrush", 16, storing, 0);
+            } else if(strcmp(option, "-size") == 0) {
+				next_i = i + 1;
+				if(SvROK(ST(next_i)) && SvTYPE(SvRV(ST(next_i))) == SVt_PVAV) {
+					SV** t;
+					t = av_fetch((AV*)SvRV(ST(next_i)), 0, 0);
+					if(t != NULL) {
+						perlcs->cs.cx = (int) SvIV(*t);
+					}
+					t = av_fetch((AV*)SvRV(ST(next_i)), 1, 0);
+					if(t != NULL) {
+						perlcs->cs.cy = (int) SvIV(*t);
+					}
+				} else {
+					if(PL_dowarn)
+						warn("Win32::GUI: Argument to -size is not an array reference!");
+				}
+            } else if(strcmp(option, "-pos") == 0) {
+				next_i = i + 1;
+				if(SvROK(ST(next_i)) && SvTYPE(SvRV(ST(next_i))) == SVt_PVAV) {
+					SV** t;
+					t = av_fetch((AV*)SvRV(ST(next_i)), 0, 0);
+					if(t != NULL) {
+						perlcs->cs.x = (int) SvIV(*t);
+					}
+					t = av_fetch((AV*)SvRV(ST(next_i)), 1, 0);
+					if(t != NULL) {
+						perlcs->cs.y = (int) SvIV(*t);
+					}
+				} else {
+					if(PL_dowarn)
+						warn("Win32::GUI: Argument to -pos is not an array reference!");
+				}
+            } else if(strcmp(option, "-tip") == 0) {
+				next_i = i + 1;
+				perlcs->szTip = SvPV_nolen(ST(next_i));
+
+            } else if(strcmp(option, "-events") == 0) {
+				next_i = i + 1;
+				{
+					HV* hash;
+					SV* val;
+					char* key;
+					I32 keylen;
+#ifdef PERLWIN32GUI_STRONGDEBUG
+					printf("!XS(ParseWindowOptions): initializing perlcs.hvEvents\n");
+#endif
+					if((LPVOID) perlcs->hvEvents == NULL) {
+						perlcs->hvEvents = newHV();
+						perlcs->dwEventMask = 0;
+					}
+					hash = (HV*) SvRV(ST(next_i));
+					hv_iterinit( hash );
+					while ( val = hv_iternextsv( hash, &key, &keylen ) ) {
+						ParseNEMEvent( NOTXSCALL perlcs, key, val );
+					}
+				}
+				if(perlcs->dwEventMask != 0) {
+					SwitchBit(perlcs->dwPlStyle, PERLWIN32GUI_NEM, 1);
+					if(perlcs->iEventModel == PERLWIN32GUI_EM_BYNAME) {
+						perlcs->iEventModel = PERLWIN32GUI_EM_BYREF;
+					}
+				} else {
+					SwitchBit(perlcs->dwPlStyle, PERLWIN32GUI_NEM, 0);
+					if(perlcs->iEventModel == PERLWIN32GUI_EM_BYREF) {
+						perlcs->iEventModel = PERLWIN32GUI_EM_BYNAME;
+					}
+				}
+            } else if(strcmp(option, "-cursor") == 0) {
+                next_i = i + 1;
+                perlcs->hCursor = (HCURSOR) handle_From(NOTXSCALL ST(next_i));
+
+			} else if(strncmp(option, "-on", 3) == 0
+			&& (char) option[3] >= 'A' && (char) option[3] <= 'Z') {
+				next_i = i + 1;
+				{
+					char *eventname;
+#ifdef PERLWIN32GUI_STRONGDEBUG
+					printf("!XS(ParseWindowOptions): initializing perlcs.hvEvents\n");
+#endif
+					if(perlcs->hvEvents == NULL) {
+						perlcs->hvEvents = newHV();
+						perlcs->dwEventMask = 0;
+					}
+					eventname = option+3;
+#ifdef PERLWIN32GUI_STRONGDEBUG
+					printf("!XS(ParseWindowOptions): calling ParseNEMEvent('%s', '%s')\n", eventname, SvPV_nolen(ST(next_i)));
+#endif
+					ParseNEMEvent( NOTXSCALL perlcs, eventname, ST(next_i) );
+				}
+				if(perlcs->dwEventMask != 0) {
+					SwitchBit(perlcs->dwPlStyle, PERLWIN32GUI_NEM, 1);
+					if(perlcs->iEventModel == PERLWIN32GUI_EM_BYNAME) {
+						perlcs->iEventModel = PERLWIN32GUI_EM_BYREF;
+					}
+				} else {
+					SwitchBit(perlcs->dwPlStyle, PERLWIN32GUI_NEM, 0);
+					if(perlcs->iEventModel == PERLWIN32GUI_EM_BYREF) {
+						perlcs->iEventModel = PERLWIN32GUI_EM_BYNAME;
+					}
+				}
+
+            } else if(strcmp(option, "-eventmodel") == 0) {
+				next_i = i + 1;
+				if(stricmp(SvPV_nolen(ST(next_i)), "byname") == 0) {
+					perlcs->iEventModel = PERLWIN32GUI_EM_BYNAME;
+					SwitchBit(perlcs->dwPlStyle, PERLWIN32GUI_NEM, 0);
+				} else if(stricmp(SvPV_nolen(ST(next_i)), "byref") == 0) {
+					perlcs->iEventModel = PERLWIN32GUI_EM_BYREF;
+					SwitchBit(perlcs->dwPlStyle, PERLWIN32GUI_NEM, 1);
+				} else if(stricmp(SvPV_nolen(ST(next_i)), "both") == 0) {
+					perlcs->iEventModel = PERLWIN32GUI_EM_BOTH;
+					SwitchBit(perlcs->dwPlStyle, PERLWIN32GUI_NEM, 1);
+				} else {
+					if(PL_dowarn) warn("Win32::GUI: Invalid value for -eventmodel!");
+				}
+
+			} else BitmaskOption("-visible", perlcs->cs.style, WS_VISIBLE)
+			} else BitmaskOption("-disabled", perlcs->cs.style, WS_DISABLED)
+			} else BitmaskOption("-group", perlcs->cs.style, WS_GROUP)
+			} else BitmaskOption("-tabstop", perlcs->cs.style, WS_TABSTOP)
+			} else BitmaskOption("-hscroll", perlcs->cs.style, WS_HSCROLL)
+			} else BitmaskOption("-vscroll", perlcs->cs.style, WS_VSCROLL)
+			} else BitmaskOption("-container", perlcs->dwPlStyle, PERLWIN32GUI_CONTAINER)
+			}
+            // ######################
+            // class-specific parsing
+            // ######################
+            switch(perlcs->iClass) {
+
+            case WIN32__GUI__WINDOW:
+            case WIN32__GUI__DIALOG:
+                if(strcmp(option, "-minsize") == 0) {
+                    next_i = i + 1;
+                    if(SvROK(ST(next_i)) && SvTYPE(SvRV(ST(next_i))) == SVt_PVAV) {
+                        SV** t;
+                        t = av_fetch((AV*)SvRV(ST(next_i)), 0, 0);
+                        if(t != NULL) {
+							perlcs->iMinWidth = (int) SvIV(*t);
+                            storing = newSViv((LONG) SvIV(*t));
+                            stored = hv_store_mg(NOTXSCALL perlcs->hvSelf, "-minwidth", 9, storing, 0);
+                        }
+                        t = av_fetch((AV*)SvRV(ST(next_i)), 1, 0);
+                        if(t != NULL) {
+							perlcs->iMinHeight = (int) SvIV(*t);
+                            storing = newSViv((LONG) SvIV(*t));
+                            stored = hv_store_mg(NOTXSCALL perlcs->hvSelf, "-minheight", 10, storing, 0);
+                        }
+                    } else {
+                        if(PL_dowarn)
+                            warn("Win32::GUI: Argument to -minsize is not an array reference!");
+                    }
+                } else if(strcmp(option, "-maxsize") == 0) {
+                    next_i = i + 1;
+                    if(SvROK(ST(next_i)) && SvTYPE(SvRV(ST(next_i))) == SVt_PVAV) {
+                        SV** t;
+                        t = av_fetch((AV*)SvRV(ST(next_i)), 0, 0);
+                        if(t != NULL) {
+							perlcs->iMaxWidth = (int) SvIV(*t);
+                            storing = newSViv((LONG) SvIV(*t));
+                            stored = hv_store_mg(NOTXSCALL perlcs->hvSelf, "-maxwidth", 9, storing, 0);
+                        }
+                        t = av_fetch((AV*)SvRV(ST(next_i)), 1, 0);
+                        if(t != NULL) {
+							perlcs->iMaxHeight = (int) SvIV(*t);
+                            storing = newSViv((LONG) SvIV(*t));
+                            stored = hv_store_mg(NOTXSCALL perlcs->hvSelf, "-maxheight", 10, storing, 0);
+                        }
+                    } else {
+                        if(PL_dowarn)
+                            warn("Win32::GUI: Argument to -maxsize is not an array reference!");
+                    }
+                } else if(strcmp(option, "-minwidth") == 0) {
+                    next_i = i + 1;
+                    perlcs->iMinWidth = (int) SvIV(ST(next_i));
+                    storing = newSViv((LONG) SvIV(ST(next_i)));
+                    stored = hv_store_mg(NOTXSCALL perlcs->hvSelf, "-minwidth", 9, storing, 0);
+                } else if(strcmp(option, "-minheight") == 0) {
+                    next_i = i + 1;
+                    perlcs->iMinHeight = (int) SvIV(ST(next_i));
+                    storing = newSViv((LONG) SvIV(ST(next_i)));
+                    stored = hv_store_mg(NOTXSCALL perlcs->hvSelf, "-minheight", 10, storing, 0);
+                } else if(strcmp(option, "-maxwidth") == 0) {
+                    next_i = i + 1;
+                    perlcs->iMaxWidth = (int) SvIV(ST(next_i));
+                    storing = newSViv((LONG) SvIV(ST(next_i)));
+                    stored = hv_store_mg(NOTXSCALL perlcs->hvSelf, "-maxwidth", 9, storing, 0);
+                } else if(strcmp(option, "-maxheight") == 0) {
+                    next_i = i + 1;
+                    perlcs->iMaxHeight = (int) SvIV(ST(next_i));
+                    storing = newSViv((LONG) SvIV(ST(next_i)));
+                    stored = hv_store_mg(NOTXSCALL perlcs->hvSelf, "-maxheight", 10, storing, 0);
+			    } else BitmaskOption("-topmost", perlcs->cs.dwExStyle, WS_EX_TOPMOST)
+			    } else BitmaskOption("-controlparent", perlcs->cs.dwExStyle, WS_EX_CONTROLPARENT)
+				} else if(strcmp(option, "-hasmaximize") == 0
+				||        strcmp(option, "-maximizebox") == 0) {
+                    next_i = i + 1;
+                    SwitchBit(perlcs->cs.style, WS_MAXIMIZEBOX, SvIV(ST(next_i)));
+				} else if(strcmp(option, "-hasminimize") == 0
+				||        strcmp(option, "-minimizebox") == 0) {
+                    next_i = i + 1;
+                    SwitchBit(perlcs->cs.style, WS_MINIMIZEBOX, SvIV(ST(next_i)));
+				} else if(strcmp(option, "-sizable") == 0
+				||        strcmp(option, "-resizable") == 0) {
+                    next_i = i + 1;
+                    SwitchBit(perlcs->cs.style, WS_THICKFRAME, SvIV(ST(next_i)));
+				} else if(strcmp(option, "-sysmenu") == 0
+				||        strcmp(option, "-menubox") == 0
+				||        strcmp(option, "-controlbox") == 0) {
+					next_i = i + 1;
+					SwitchBit(perlcs->cs.style, WS_SYSMENU, SvIV(ST(next_i)));
+				} else if(strcmp(option, "-helpbutton") == 0
+				||        strcmp(option, "-helpbox") == 0
+				||        strcmp(option, "-hashelp") == 0) {
+                    next_i = i + 1;
+                    SwitchBit(perlcs->cs.dwExStyle, WS_EX_CONTEXTHELP, SvIV(ST(next_i)));
+				} else if(strcmp(option, "-accel") == 0
+				||        strcmp(option, "-accelerators") == 0
+				||        strcmp(option, "-acceleratortable") == 0) {
+					next_i = i + 1;
+					perlcs->hAcc = (HACCEL) handle_From(NOTXSCALL ST(next_i));
+                    storing = newSViv((LONG) handle_From(NOTXSCALL ST(next_i)));
+                    stored = hv_store_mg(NOTXSCALL perlcs->hvSelf, "-accel", 6, storing, 0);
+				} else BitmaskOption("-titlebar", perlcs->cs.style, WS_CAPTION)
+				} else BitmaskOption("-toolwindow", perlcs->cs.dwExStyle, WS_EX_TOOLWINDOW)
+				} else BitmaskOption("-appwindow", perlcs->cs.dwExStyle, WS_EX_APPWINDOW)
+				}
+				break;
+
+            case WIN32__GUI__STATIC:
+				if(Label_onParseOption(NOTXSCALL option, ST(i+1), perlcs)) {
+					next_i = i + 1;
+				}
+                break;
+
+            case WIN32__GUI__EDIT:
+            case WIN32__GUI__RICHEDIT:
+            	if(Textfield_onParseOption(NOTXSCALL option, ST(i+1), perlcs)) {
+					next_i = i + 1;
+				}
+                break;
+
+            case WIN32__GUI__BUTTON:
+            case WIN32__GUI__RADIOBUTTON:
+            case WIN32__GUI__CHECKBOX:
+                if(strcmp(option, "-align") == 0) {
+                    next_i = i + 1;
+                    if(strcmp(SvPV_nolen(ST(next_i)), "left") == 0) {
+                        SwitchBit(perlcs->cs.style, BS_LEFT, 1);
+                        SwitchBit(perlcs->cs.style, BS_CENTER, 0);
+                        SwitchBit(perlcs->cs.style, BS_RIGHT, 0);
+                    } else if(strcmp(SvPV_nolen(ST(next_i)), "center") == 0) {
+                        SwitchBit(perlcs->cs.style, BS_LEFT, 0);
+                        SwitchBit(perlcs->cs.style, BS_CENTER, 1);
+                        SwitchBit(perlcs->cs.style, BS_RIGHT, 0);
+                    } else if(strcmp(SvPV_nolen(ST(next_i)), "right") == 0) {
+                        SwitchBit(perlcs->cs.style, BS_LEFT, 0);
+                        SwitchBit(perlcs->cs.style, BS_CENTER, 0);
+                        SwitchBit(perlcs->cs.style, BS_RIGHT, 1);
+                    } else {
+                        if(PL_dowarn) warn("Win32::GUI: Invalid value for -align!");
+                    }
+                } else if(strcmp(option, "-valign") == 0) {
+                    next_i = i + 1;
+                    if(strcmp(SvPV_nolen(ST(next_i)), "top") == 0) {
+                        SwitchBit(perlcs->cs.style, BS_TOP, 1);
+                        SwitchBit(perlcs->cs.style, BS_BOTTOM, 0);
+                    } else if(strcmp(SvPV_nolen(ST(next_i)), "center") == 0) {
+                        SwitchBit(perlcs->cs.style, BS_TOP, 1);
+                        SwitchBit(perlcs->cs.style, BS_BOTTOM, 1);
+                    } else if(strcmp(SvPV_nolen(ST(next_i)), "bottom") == 0) {
+                        SwitchBit(perlcs->cs.style, BS_TOP, 0);
+                        SwitchBit(perlcs->cs.style, BS_BOTTOM, 1);
+                    } else {
+                        if(PL_dowarn) warn("Win32::GUI: Invalid value for -valign!");
+                    }
+                } else if(strcmp(option, "-ok") == 0) {
+                    next_i = i + 1;
+                    if(SvIV(ST(next_i)) != 0) {
+                        perlcs->cs.hMenu = (HMENU) IDOK;
+                    }
+                } else if(strcmp(option, "-cancel") == 0) {
+                    next_i = i + 1;
+                    if(SvIV(ST(next_i)) != 0) {
+                        perlcs->cs.hMenu = (HMENU) IDCANCEL;
+                    }
+				} else BitmaskOption("-default", perlcs->cs.style, BS_DEFPUSHBUTTON)
+                } else if(strcmp(option, "-bitmap") == 0
+                ||        strcmp(option, "-picture") == 0) {
+                    next_i = i + 1;
+                    SwitchBit(perlcs->cs.style, BS_BITMAP, 1);
+                    perlcs->hImageList = (HIMAGELIST) handle_From(NOTXSCALL ST(next_i));
+                } else if(strcmp(option, "-icon") == 0) {
+                    next_i = i + 1;
+                    SwitchBit(perlcs->cs.style, BS_BITMAP, 1);
+                    perlcs->hImageList = (HIMAGELIST) handle_From(NOTXSCALL ST(next_i));
+                } else if(strcmp(option, "-checked") == 0) {
+                    next_i = i + 1;
+                    SwitchBit(perlcs->dwPlStyle, PERLWIN32GUI_CHECKED, SvIV(ST(next_i)));
+                    SwitchBit(perlcs->dwPlStyle, PERLWIN32GUI_SEENCHECKED, 1);
+                }
+                break;
+
+            case WIN32__GUI__LISTBOX:
+				if(Listbox_onParseOption(NOTXSCALL option, ST(i+1), perlcs)) {
+					next_i = i + 1;
+				}
+                break;
+
+            case WIN32__GUI__TAB:
+				if(TabStrip_onParseOption(NOTXSCALL option, ST(i+1), perlcs)) {
+					next_i = i + 1;
+				}
+                break;
+
+            case WIN32__GUI__TOOLBAR:
+				if(Toolbar_onParseOption(NOTXSCALL option, ST(i+1), perlcs)) {
+					next_i = i + 1;
+				}
+                break;
+
+            case WIN32__GUI__LISTVIEW:
+				if(ListView_onParseOption(NOTXSCALL option, ST(i+1), perlcs)) {
+					next_i = i + 1;
+				}
+                break;
+
+            case WIN32__GUI__TREEVIEW:
+				if(TreeView_onParseOption(NOTXSCALL option, ST(i+1), perlcs)) {
+					next_i = i + 1;
+				}
+                break;
+
+            case WIN32__GUI__TRACKBAR:
+				BitmaskOption("-vertical", perlcs->cs.style, TBS_VERT)
+				} else BitmaskOption("-noticks", perlcs->cs.style, TBS_NOTICKS)
+				} else BitmaskOption("-nothumb", perlcs->cs.style, TBS_NOTHUMB)
+                }
+                break;
+
+            case WIN32__GUI__UPDOWN:
+                if(strcmp(option, "-align") == 0) {
+                    next_i = i + 1;
+                    if(strcmp(SvPV_nolen(ST(next_i)), "left") == 0) {
+                        SwitchBit(perlcs->cs.style, UDS_ALIGNLEFT, 1);
+                        SwitchBit(perlcs->cs.style, UDS_ALIGNRIGHT, 0);
+                    } else if(strcmp(SvPV_nolen(ST(next_i)), "right") == 0) {
+                        SwitchBit(perlcs->cs.style, UDS_ALIGNLEFT, 0);
+                        SwitchBit(perlcs->cs.style, UDS_ALIGNRIGHT, 1);
+                    } else {
+                        if(PL_dowarn) warn("Win32::GUI: Invalid value for -align!");
+                    }
+				} else BitmaskOption("-nothousands", perlcs->cs.style, UDS_NOTHOUSANDS)
+				} else BitmaskOption("-wrap", perlcs->cs.style, UDS_WRAP)
+				} else BitmaskOption("-horizontal", perlcs->cs.style, UDS_HORZ)
+				} else BitmaskOption("-autobuddy", perlcs->cs.style, UDS_AUTOBUDDY)
+				} else BitmaskOption("-setbuddy", perlcs->cs.style, UDS_SETBUDDYINT)
+                }
+                break;
+
+            case WIN32__GUI__ANIMATION:
+				if(Animation_onParseOption(NOTXSCALL option, ST(i+1), perlcs)) {
+					next_i = i + 1;
+				}
+                break;
+
+            case WIN32__GUI__REBAR:
+				if(Rebar_onParseOption(NOTXSCALL option, ST(i+1), perlcs)) {
+					next_i = i + 1;
+				}
+                break;
+
+            case WIN32__GUI__PROGRESS:
+                BitmaskOption("-smooth", perlcs->cs.style, PBS_SMOOTH)
+                } else BitmaskOption("-vertical", perlcs->cs.style, PBS_VERTICAL)
+                }
+                break;
+
+            case WIN32__GUI__HEADER:
+                if(strcmp(option, "-imagelist") == 0) {
+                    next_i = i + 1;
+                    perlcs->hImageList = (HIMAGELIST) handle_From(NOTXSCALL ST(next_i));
+                } else BitmaskOption("-buttons", perlcs->cs.style, HDS_BUTTONS)
+                } else BitmaskOption("-hottrack", perlcs->cs.style, HDS_HOTTRACK)
+                }
+                break;
+
+			case WIN32__GUI__COMBOBOXEX:
+                if(strcmp(option, "-imagelist") == 0) {
+                    next_i = i + 1;
+				    perlcs->hImageList = (HIMAGELIST) handle_From(NOTXSCALL ST(next_i));
+				}
+				break;
+
+            case WIN32__GUI__GRAPHIC:
+                if(strcmp(option, "-interactive") == 0) {
+                    next_i = i + 1;
+                    if(SvIV(ST(next_i))) {
+			        	perlcs->cs.lpszClass = "Win32::GUI::InteractiveGraphic";
+					} else {
+						perlcs->cs.lpszClass = "Win32::GUI::Graphic";
+					}
+				}
+				break;
+
+            case WIN32__GUI__SPLITTER:
+				if(Splitter_onParseOption(NOTXSCALL option, ST(i+1), perlcs)) {
+					next_i = i + 1;
+				}
+				break;
+
+            case WIN32__GUI__DTPICK:
+                if(strcmp(option, "-align") == 0) {
+                    next_i = i + 1;
+                    if(strcmp(SvPV_nolen(ST(next_i)), "left") == 0) {
+                        SwitchBit(perlcs->cs.style, DTS_RIGHTALIGN, 0);
+                    } else if(strcmp(SvPV_nolen(ST(next_i)), "right") == 0) {
+                        SwitchBit(perlcs->cs.style, DTS_RIGHTALIGN, 1);
+                    } else {
+                        if(PL_dowarn) warn("Win32::GUI: Invalid value for -align!");
+                    }
+                } 
+                else if(strcmp(option, "-format") == 0) {
+                    next_i = i + 1;
+                    if(strcmp(SvPV_nolen(ST(next_i)), "shortdate") == 0) {
+                        SwitchBit(perlcs->cs.style, DTS_LONGDATEFORMAT,  0);
+                        SwitchBit(perlcs->cs.style, DTS_TIMEFORMAT,      0);
+                        SwitchBit(perlcs->cs.style, DTS_SHORTDATEFORMAT, 1);
+                    } else if(strcmp(SvPV_nolen(ST(next_i)), "longdate") == 0) {
+                        SwitchBit(perlcs->cs.style, DTS_TIMEFORMAT,      0);
+                        SwitchBit(perlcs->cs.style, DTS_SHORTDATEFORMAT, 0);
+                        SwitchBit(perlcs->cs.style, DTS_LONGDATEFORMAT,  1);
+                    } else if(strcmp(SvPV_nolen(ST(next_i)), "time") == 0) {
+                        SwitchBit(perlcs->cs.style, DTS_LONGDATEFORMAT,  0);
+                        SwitchBit(perlcs->cs.style, DTS_SHORTDATEFORMAT, 0);
+                        SwitchBit(perlcs->cs.style, DTS_TIMEFORMAT,      1);
+                    } else {
+                        if(PL_dowarn) warn("Win32::GUI: Invalid value for -format!");
+                    }
+                } else BitmaskOption("-shownone", perlcs->cs.style, DTS_SHOWNONE)
+                } else BitmaskOption("-updown", perlcs->cs.style, DTS_UPDOWN)
+                }
+                break;
+            }
+        } else {
+            next_i = -1;
+        }
+    }
+}
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:ParseMenuItemOptions(sp, mark, ax, items, from_i, mii, *item)
+    */
+void ParseMenuItemOptions(
+    NOTXSPROC
+    register SV **sp,
+    register SV **mark,
+    I32 ax,
+    I32 items,
+    int from_i,
+    LPMENUITEMINFO mii,
+    LPPERLWIN32GUI_MENUITEMDATA perlmid,
+    UINT* myItem
+) {
+    dTHR;
+	int i, next_i;
+    char * option;
+    unsigned int textlength;
+    next_i = -1;
+#ifdef PERLWIN32GUI_STRONGDEBUG
+	printf("!XS(ParseMenuItemOptions) called with items=%d, from_i=%d\n", items, from_i);
+#endif
+	for(i = from_i; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+#ifdef PERLWIN32GUI_STRONGDEBUG
+			printf("!XS(ParseMenuItemOptions) got option '%s'\n", option);
+#endif
+            if(strcmp(option, "-mask") == 0) {
+                next_i = i + 1;
+                mii->fMask = (UINT) SvIV(ST(next_i));
+            } else if(strcmp(option, "-flag") == 0) {
+                next_i = i + 1;
+                mii->fType = (UINT) SvIV(ST(next_i));
+            } else if(strcmp(option, "-state") == 0) {
+                SwitchBit(mii->fMask, MIIM_STATE, 1);
+                next_i = i + 1;
+                mii->fState = (UINT) SvIV(ST(next_i));
+            } else if(strcmp(option, "-id") == 0) {
+                SwitchBit(mii->fMask, MIIM_ID, 1);
+                next_i = i + 1;
+                mii->wID = (UINT) SvIV(ST(next_i));
+            } else if(strcmp(option, "-submenu") == 0) {
+                SwitchBit(mii->fMask, MIIM_SUBMENU, 1);
+                next_i = i + 1;
+                mii->hSubMenu = (HMENU) handle_From(NOTXSCALL ST(next_i));
+            } else if(strcmp(option, "-text") == 0) {
+                SwitchBit(mii->fMask, MIIM_TYPE, 1);
+                SwitchBit(mii->fType, MFT_STRING, 1);
+                next_i = i + 1;
+                mii->dwTypeData = SvPV(ST(next_i), textlength);
+                mii->cch = textlength;
+            } else if(strcmp(option, "-item") == 0) {
+                next_i = i + 1;
+                *myItem = SvIV(ST(next_i));
+            } else if(strcmp(option, "-separator") == 0) {
+                SwitchBit(mii->fMask, MIIM_TYPE, 1);
+                next_i = i + 1;
+                SwitchBit(mii->fType, MFT_SEPARATOR, SvIV(ST(next_i)));
+            } else if(strcmp(option, "-default") == 0) {
+                SwitchBit(mii->fMask, MIIM_STATE, 1);
+                next_i = i + 1;
+                SwitchBit(mii->fState, MFS_DEFAULT, SvIV(ST(next_i)));
+            } else if(strcmp(option, "-checked") == 0) {
+                SwitchBit(mii->fMask, MIIM_STATE, 1);
+                next_i = i + 1;
+                SwitchBit(mii->fState, MFS_CHECKED, SvIV(ST(next_i)));
+            } else if(strcmp(option, "-enabled") == 0) {
+                SwitchBit(mii->fMask, MIIM_STATE, 1);
+                next_i = i + 1;
+                SwitchBit(mii->fState, MFS_DISABLED, !SvIV(ST(next_i)));
+            } else if(strcmp(option, "-name") == 0) {
+                next_i = i + 1;
+#ifdef PERLWIN32GUI_STRONGDEBUG
+				printf("!XS(ParseMenuItemOptions) got -name => '%s'\n", SvPV_nolen(ST(next_i)));
+#endif
+				strcpy( (perlmid->szName), SvPV_nolen(ST(next_i)) );
+                SwitchBit(mii->fMask, MIIM_DATA, 1);
+				mii->dwItemData = (DWORD) perlmid;
+#ifdef PERLWIN32GUI_STRONGDEBUG
+				printf("!XS(ParseMenuItemOptions) done -name ('%s')\n", perlmid->szName);
+#endif
+            } else if(strcmp(option, "-onClick") == 0) {
+                next_i = i + 1;
+#ifdef PERLWIN32GUI_STRONGDEBUG
+				printf("!XS(ParseMenuItemOptions) got -onClick => '%s'\n", SvPV_nolen(ST(next_i)));
+#endif
+                SwitchBit(mii->fMask, MIIM_DATA, 1);
+				/* perlmid->svCode = newSVsv(ST(next_i)); */
+				sv_setsv(perlmid->svCode, ST(next_i));
+				mii->dwItemData = (DWORD) perlmid;
+#ifdef PERLWIN32GUI_STRONGDEBUG
+				printf("!XS(ParseMenuItemOptions) done -onClick newSVsv\n");
+#endif
+            }
+        } else {
+            next_i = -1;
+        }
+    }
+}
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:ParseHeaderItemOptions(sp, mark, ax ,items, from_i, *hditem, *index)
+    */
+void ParseHeaderItemOptions(
+    NOTXSPROC
+    register SV **sp,
+    register SV **mark,
+    I32 ax,
+    I32 items,
+    int from_i,
+    LPHDITEMA hditem,
+    int * index
+) {
+    dTHR;
+	int i, next_i;
+    char * option;
+    unsigned int tlen;
+
+    next_i = -1;
+    for(i = from_i; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-text") == 0) {
+                next_i = i + 1;
+                hditem->pszText = SvPV(ST(next_i), tlen);
+                hditem->cchTextMax = tlen;
+                SwitchBit(hditem->mask, HDI_TEXT, 1);
+                SwitchBit(hditem->fmt, HDF_STRING, 1);
+            } else if(strcmp(option, "-image") == 0) {
+                next_i = i + 1;
+                hditem->iImage = SvIV(ST(next_i));
+                SwitchBit(hditem->mask, HDI_IMAGE, 1);
+                SwitchBit(hditem->fmt, HDF_IMAGE, 1);
+            } else if(strcmp(option, "-bitmap") == 0) {
+                next_i = i + 1;
+                hditem->hbm = (HBITMAP) handle_From(NOTXSCALL ST(next_i));
+                SwitchBit(hditem->mask, HDI_BITMAP, 1);
+                SwitchBit(hditem->fmt, HDF_BITMAP, 1);
+            } else if(strcmp(option, "-bitmaponright") == 0) {
+                next_i = i + 1;
+                SwitchBit(hditem->fmt, HDF_BITMAP_ON_RIGHT, SvIV(ST(next_i)));
+            } else if(strcmp(option, "-width") == 0) {
+                next_i = i + 1;
+                hditem->cxy = SvIV(ST(next_i));
+                SwitchBit(hditem->mask, HDI_WIDTH, 1);
+                SwitchBit(hditem->mask, HDI_HEIGHT, 0);
+            } else if(strcmp(option, "-height") == 0) {
+                next_i = i + 1;
+                hditem->cxy = SvIV(ST(next_i));
+                SwitchBit(hditem->mask, HDI_WIDTH, 0);
+                SwitchBit(hditem->mask, HDI_HEIGHT, 1);
+            } else if(strcmp(option, "-order") == 0) {
+                next_i = i + 1;
+                hditem->iOrder = SvIV(ST(next_i));
+                SwitchBit(hditem->mask, HDI_ORDER, 1);
+            } else if(strcmp(option, "-align") == 0) {
+                next_i = i + 1;
+                if(strcmp(SvPV_nolen(ST(next_i)), "left") == 0) {
+                    SwitchBit(hditem->fmt, HDF_LEFT, 1);
+                    SwitchBit(hditem->fmt, HDF_CENTER, 0);
+                    SwitchBit(hditem->fmt, HDF_RIGHT, 0);
+                } else if(strcmp(SvPV_nolen(ST(next_i)), "center") == 0) {
+                    SwitchBit(hditem->fmt, HDF_LEFT, 0);
+                    SwitchBit(hditem->fmt, HDF_CENTER, 1);
+                    SwitchBit(hditem->fmt, HDF_RIGHT, 0);
+                } else if(strcmp(SvPV_nolen(ST(next_i)), "right") == 0) {
+                    SwitchBit(hditem->fmt, HDF_LEFT, 0);
+                    SwitchBit(hditem->fmt, HDF_CENTER, 0);
+                    SwitchBit(hditem->fmt, HDF_RIGHT, 1);
+                } else {
+                    if(PL_dowarn) warn("Win32::GUI: Invalid value for -align!");
+                }
+            } else
+            if(strcmp(option, "-item") == 0
+            || strcmp(option, "-index") == 0) {
+                next_i = i + 1;
+                *index = SvIV(ST(next_i));
+            }
+
+        } else {
+            next_i = -1;
+        }
+    }
+}
+
+    /*
+    ###########################################################################
+    # (@)INTERNAL:ParseComboboxExItemOptions(sp, mark, ax ,items, from_i, *item)
+    */
+void ParseComboboxExItemOptions(
+    NOTXSPROC
+    register SV **sp,
+    register SV **mark,
+    I32 ax,
+    I32 items,
+    int from_i,
+    COMBOBOXEXITEM *item
+) {
+    dTHR;
+    int i, next_i;
+    char * option;
+    unsigned int tlen;
+
+    next_i = -1;
+    for(i = from_i; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-text") == 0) {
+                next_i = i + 1;
+                item->pszText = SvPV(ST(next_i), tlen);
+                item->cchTextMax = tlen;
+                SwitchBit(item->mask, CBEIF_TEXT, 1);
+            } else if(strcmp(option, "-image") == 0) {
+                next_i = i + 1;
+                item->iImage = SvIV(ST(next_i));
+                SwitchBit(item->mask, CBEIF_IMAGE, 1);
+            } else if(strcmp(option, "-selectedimage") == 0) {
+                next_i = i + 1;
+                item->iSelectedImage = SvIV(ST(next_i));
+                SwitchBit(item->mask, CBEIF_SELECTEDIMAGE, 1);
+            } else
+            if(strcmp(option, "-item") == 0
+            || strcmp(option, "-index") == 0) {
+                next_i = i + 1;
+                item->iItem = SvIV(ST(next_i));
+            }
+        } else {
+            next_i = -1;
+        }
+    }
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/GridLayout.pm perl-libwin32-0.191/GUI/GridLayout.pm
--- libwin32-0.191/GUI/GridLayout.pm	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/GridLayout.pm	2004-01-12 16:46:40.015625000 -0800
@@ -0,0 +1,268 @@
+package Win32::GUI::GridLayout;
+
+$VERSION = "0.03";
+
+sub new {
+    my($class, $c, $r, $w, $h, $xpad, $ypad) = @_;
+    my $r_grid = {
+        "cols"   => $c,
+        "rows"   => $r,
+        "width"  => $w,
+        "height" => $h,
+        "xPad"   => $xpad,
+        "yPad"   => $ypad,
+    };
+    bless $r_grid, $class;
+    return $r_grid;
+}
+
+sub apply {
+    my($class, $to, $c, $r, $xpad, $ypad) = @_;
+    my $w = $to->ScaleWidth();
+    my $h = $to->ScaleHeight();
+    my $r_grid = {
+        "cols"   => $c,
+        "rows"   => $r,
+        "width"  => $w,
+        "height" => $h,
+        "xPad"   => $xpad,
+        "yPad"   => $ypad,
+        "source" => $to,
+    };
+    bless $r_grid, $class;
+    return $r_grid;
+}
+
+sub add {
+    my($grid, $o, $c, $r, $align) = @_;    
+    my @content = @{$grid->{'content'}};
+    my($halign, $valign) = split(/(\s*|\s*,\s*)/, $align);
+    push(@content, [$o, $c, $r, $halign, $valign] );
+    $grid->{'content'} = [ @content ];
+}
+
+sub recalc {
+    my($grid) = @_;    
+    $grid->{'width'}  = $grid->{'source'}->ScaleWidth();
+    $grid->{'height'} = $grid->{'source'}->ScaleHeight();
+    foreach $inside (@{$grid->{'content'}}) {       
+        $widgetWidth  = $inside->[0]->Width();
+        $widgetHeight = $inside->[0]->Height();
+        $inside->[0]->Move(
+            $grid->col($inside->[1], $inside->[3]),
+            $grid->row($inside->[2], $inside->[4]),
+        );
+    }
+}
+
+sub draw {
+    my($grid) = @_;
+    return undef unless $grid->{'source'};
+    my $DC = $grid->{'source'}->GetDC();
+    my $colWidth = int($grid->{'width'} / $grid->{'cols'});
+    my $rowHeight = int($grid->{'height'} / $grid->{'rows'});
+    my $i;
+    for $i (0..$grid->{'cols'}) {
+        $DC->MoveTo($i*$colWidth, 0);
+        $DC->LineTo($i*$colWidth, $grid->{'height'});
+    }
+    for $i (0..$grid->{'rows'}) {
+        $DC->MoveTo(0, $i*$rowHeight);
+        $DC->LineTo($grid->{'width'}, $i*$rowHeight);
+    }
+}
+
+sub column {
+    my ($grid_param, $col, $align) = @_;
+    $col--;
+    $colWidth = int($grid_param->{'width'} / $grid_param->{'cols'});
+    $x = ($col * $colWidth) + ($grid_param->{'xPad'});
+    $x = int((($colWidth - $widgetWidth) / 2) + $x) 
+        if $align =~ /^c/i;
+    $x = int((($colWidth - $widgetWidth) - $grid_param->{'xPad'}) + $x) 
+        if $align =~ /^r/i;
+    $widgetWidth=0; # in case a width declaration is missed or not used
+    return $x;
+}
+sub col { column @_; }
+
+sub row {
+    my ($grid_param,$row, $align) = @_;
+    $row--;
+    $rowHeight = int($grid_param->{'height'} / $grid_param->{'rows'});
+    $y = ($row * $rowHeight) + ($grid_param->{'yPad'});
+    $y = int((($rowHeight - $widgetHeight) / 2) + $y) 
+        if $align =~ /^c/i;
+    $y = int((($rowHeight - $widgetHeight) - ($grid_param->{'yPad'})) + $y) 
+        if $align =~ /^b/i;
+    $widgetHeight=0; # same reason as coment in &column
+    return $y;
+}
+
+sub width {
+    my ($grid_param,$w) = @_;
+    $widgetWidth = $w;
+    return $widgetWidth;
+}
+
+sub height {
+    my ($grid_param,$h) = @_;
+    $widgetHeight = $h;
+    return $widgetHeight;
+}
+
+1;
+
+__END__
+
+=head1 NAME
+
+Win32::GUI::GridLayout - Grid layout support for Win32::GUI
+
+=head1 SYNOPSIS
+
+    use Win32::GUI::
+    use Win32::GUI::GridLayout;
+
+    # 1. make a "static" grid
+    $grid = new Win32::GUI::GridLayout(400, 300, 3, 3, 0, 0);
+    
+    $win = new Win32::GUI::Window(
+    
+    $win->AddLabel(
+        -name => "label1",
+        -text => "Label 1",
+        -width  => $grid->width(35),
+        -height => $grid->height(11),
+        -left   => $grid->col(1, "left"),
+        -top    => $grid->row(1, "top"),
+    );
+    
+    # 2. make a "dynamic" grid
+    $grid = apply Win32::GUI::GridLayout($win, 3, 3, 0, 0);
+    
+    $win->AddLabel(
+        -name => "label1",
+        -text => "Label 1",
+    );
+    $grid->add($win->label1, 1, 1, "left top");
+
+    $grid->recalc();
+
+=head1 DESCRIPTION
+
+
+
+=head2 Constructors
+
+=over 4
+
+=item new Win32::GUI::GridLayout(WIDTH, HEIGHT, COLS, ROWS, XPAD, YPAD)
+
+=item apply Win32::GUI::GridLayout(WINDOW, COLS, ROWS, XPAD, YPAD)
+
+=back
+
+=head2 Methods
+
+=over 4
+
+=item add(CONTROL, COL, ROW, ALIGN)
+
+Adds CONTROL to the grid at (COL, ROW).
+ALIGN can specify both horizontal and vertical
+alignment (see the col() and row() methods),
+separated by at least one blank and/or a comma.
+
+Example:
+
+    $grid->add($win->label1, 1, 1, "left top");
+
+=item col(N, ALIGN)
+
+Positions the control at the Nth column in the grid,
+optionally with an ALIGN; this can be feed to a
+C<-left> option when creating a control.
+
+ALIGN can be C<left>, C<center> or C<right> (can be 
+shortened to C<l>, C<c>, C<r>); default is C<left>.
+
+Note that for alignment to work properly, the width()
+and height() methods must have been previously
+called.
+
+Example:
+
+    $win->AddLabel(
+        -name => "label1",
+        -text => "Label 1",
+        -width  => $grid->width(35),
+        -height => $grid->height(11),
+        -left   => $grid->col(1, "left"),
+        -top    => $grid->row(1, "top"),
+    );      
+
+=item draw()
+
+Draws the GridLayout in the associated window
+(may be useful for debugging); is only meaningful
+if the GridLayout was created with the apply()
+constructor.
+
+=item height(N)
+
+Sets the height of the control for subsequent
+alignment; this can be feed to a C<-height> option
+when creating a control.
+
+Example: see col().
+
+=item recalc()
+
+Recalculates the grid and repositions all the add()ed 
+controls, taking into account the actual window and
+controls sizes; 
+is only meaningful if the GridLayout was created 
+with the apply() constructor.
+
+Example:
+
+    sub Window_Resize {
+        $grid->recalc();
+    }
+
+=item row(N, ALIGN)
+
+Positions the control at the Nth row in the grid,
+optionally with an ALIGN; this can be feed to a
+C<-top> option when creating a control.
+
+ALIGN can be C<top>, C<center> or C<bottom> (can be 
+shortened to t, c, b); default is top.
+
+Note that for alignment to work properly, the width()
+and height() methods must have been previously
+called.
+
+Example: see col().
+
+=item width(N)
+
+Sets the width of the control for subsequent
+alignment; this can be feed to a C<-width> option
+when creating a control.
+
+Example: see col().
+
+=back
+
+=head1 VERSION
+
+Win32::GUI::GridLayout version 0.03, 13 April 1999.
+
+=head1 AUTHOR
+
+Mike Kangas ( C<kangas@anlon.com> );
+additional coding by Aldo Calpini ( C<dada@perl.it> ).
+
+=cut
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/ImageList.xs perl-libwin32-0.191/GUI/ImageList.xs
--- libwin32-0.191/GUI/ImageList.xs	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/ImageList.xs	2004-01-12 16:46:40.031250000 -0800
@@ -0,0 +1,154 @@
+	/*
+	###########################################################################
+    # (@)PACKAGE:Win32::GUI::ImageList
+    #
+    # $Id: ImageList.xs,v 1.3 2003/12/28 07:17:43 caelum Exp $
+    #
+    ###########################################################################
+	*/
+
+#include "GUI.h"
+
+
+MODULE = Win32::GUI::ImageList		PACKAGE = Win32::GUI::ImageList
+
+PROTOTYPES: DISABLE
+
+
+    ###########################################################################
+    # (@)INTERNAL:Create(X, Y, FLAGS, INITAL, GROW)
+HIMAGELIST
+Create(cx,cy,flags,cInitial,cGrow)
+    int cx
+    int cy
+    UINT flags
+    int cInitial
+    int cGrow
+CODE:
+    RETVAL = ImageList_Create(cx, cy, flags, cInitial, cGrow);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:AddBitmap(BITMAP, [BITMAPMASK])
+	# Adds a Win32::GUI::Bitmap object to the ImageList. BITMAPMASK is
+	# optional. See also Add().
+int
+AddBitmap(handle, bitmap, bitmapMask=NULL)
+    HIMAGELIST handle
+    HBITMAP bitmap
+    HBITMAP bitmapMask
+CODE:
+    RETVAL = ImageList_Add(handle, bitmap, bitmapMask);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:Replace(INDEX, BITMAP, [BITMAPMASK])
+	# Replaces the specified zero-based INDEX image with the image specified
+	# by BITMAP (must be a Win32::GUI::Bitmap object). BITMAPMASK is optional.
+int
+Replace(handle, index, bitmap, bitmapMask=NULL)
+    HIMAGELIST handle
+    int index
+    HBITMAP bitmap
+    HBITMAP bitmapMask
+CODE:
+    RETVAL = ImageList_Replace(handle, index, bitmap, bitmapMask);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Remove(INDEX)
+    # Removes the specified zero-based INDEX image from the ImageList.
+int
+Remove(handle,index)
+    HIMAGELIST handle
+    int index
+CODE:
+    RETVAL = ImageList_Remove(handle, index);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:Clear()
+    # Removes all the images from the ImageList.
+int
+Clear(handle)
+    HIMAGELIST handle
+CODE:
+    RETVAL = ImageList_RemoveAll(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Count()
+    # Returns the number of images in the ImageList.
+int
+Count(handle)
+    HIMAGELIST handle
+CODE:
+    RETVAL = ImageList_GetImageCount(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:BackColor([COLOR])
+    # Gets or sets the background color for the ImageList.
+int
+BackColor(handle,color=(COLORREF) -1)
+    HIMAGELIST handle
+    COLORREF color
+CODE:
+    if(items == 2) {
+        RETVAL = ImageList_SetBkColor(handle, color);
+    } else
+        RETVAL = ImageList_GetBkColor(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Size([X, Y])
+    # Gets or sets the size of the images in the ImageList;
+    # if no parameter is given, returns a 2 element array (X, Y),
+    # otherwise sets the size to the given parameters.
+void
+Size(handle,...)
+    HIMAGELIST handle
+PREINIT:
+    int cx, cy;
+    BOOL result;
+PPCODE:
+    if(items != 1 && items != 3)
+        croak("Usage: Size(handle);\n   or: Size(handle, x, y);\n");
+    if(items == 1) {
+        if(ImageList_GetIconSize(handle, &cx, &cy)) {
+            EXTEND(SP, 2);
+            XST_mIV(0, cx);
+            XST_mIV(1, cy);
+            XSRETURN(2);
+        } else
+            XSRETURN_UNDEF;
+    } else {
+        result = ImageList_SetIconSize(handle, (int) SvIV(ST(1)), (int) SvIV(ST(2)));
+        EXTEND(SP, 1);
+        XST_mIV(0, result);
+        XSRETURN(1);
+    }
+
+
+    ###########################################################################
+    # (@)INTERNAL:DESTROY(HANDLE)
+BOOL
+DESTROY(handle)
+    HIMAGELIST handle
+CODE:
+    RETVAL = ImageList_Destroy(handle);
+OUTPUT:
+    RETVAL
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/Label.xs perl-libwin32-0.191/GUI/Label.xs
--- libwin32-0.191/GUI/Label.xs	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/Label.xs	2004-01-12 16:46:40.046875000 -0800
@@ -0,0 +1,147 @@
+
+	/*
+	###########################################################################
+    # (@)PACKAGE:Win32::GUI::Label
+    ###########################################################################
+	*/
+
+#include "GUI.h"
+
+BOOL
+Label_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs) {
+	BOOL retval;
+	retval = FALSE;
+	if(strcmp(option, "-align") == 0) {
+		retval = TRUE;
+		if(strcmp(SvPV_nolen(value), "left") == 0) {
+			SwitchBit(perlcs->cs.style, SS_LEFT, 1);
+			SwitchBit(perlcs->cs.style, SS_CENTER, 0);
+			SwitchBit(perlcs->cs.style, SS_RIGHT, 0);
+		} else if(strcmp(SvPV_nolen(value), "center") == 0) {
+			SwitchBit(perlcs->cs.style, SS_LEFT, 0);
+			SwitchBit(perlcs->cs.style, SS_CENTER, 1);
+			SwitchBit(perlcs->cs.style, SS_RIGHT, 0);
+		} else if(strcmp(SvPV_nolen(value), "right") == 0) {
+			SwitchBit(perlcs->cs.style, SS_LEFT, 0);
+			SwitchBit(perlcs->cs.style, SS_CENTER, 0);
+			SwitchBit(perlcs->cs.style, SS_RIGHT, 1);
+		} else {
+			if(PL_dowarn) warn("Win32::GUI: Invalid value for -align!");
+		}
+	} else if(strcmp(option, "-bitmap") == 0
+	||        strcmp(option, "-picture") == 0) {
+		retval = TRUE;
+		SwitchBit(perlcs->cs.style, SS_BITMAP, 1);
+		perlcs->hImageList = (HIMAGELIST) handle_From(NOTXSCALL value);
+	} else if(strcmp(option, "-truncate") == 0) {
+		retval = TRUE;
+		if(strcmp(SvPV_nolen(value), "path") == 0) {
+			SwitchBit(perlcs->cs.style, SS_PATHELLIPSIS, 1);
+			SwitchBit(perlcs->cs.style, SS_ENDELLIPSIS, 0);
+			SwitchBit(perlcs->cs.style, SS_WORDELLIPSIS, 0);
+		} else if(strcmp(SvPV_nolen(value), "word") == 0) {
+			SwitchBit(perlcs->cs.style, SS_PATHELLIPSIS, 0);
+			SwitchBit(perlcs->cs.style, SS_ENDELLIPSIS, 0);
+			SwitchBit(perlcs->cs.style, SS_WORDELLIPSIS, 1);
+		} else if(SvIV(value)) {
+			SwitchBit(perlcs->cs.style, SS_PATHELLIPSIS, 0);
+			SwitchBit(perlcs->cs.style, SS_ENDELLIPSIS, 1);
+			SwitchBit(perlcs->cs.style, SS_WORDELLIPSIS, 0);
+		} else {
+			SwitchBit(perlcs->cs.style, SS_PATHELLIPSIS, 0);
+			SwitchBit(perlcs->cs.style, SS_ENDELLIPSIS, 0);
+			SwitchBit(perlcs->cs.style, SS_WORDELLIPSIS, 0);
+		}
+	} else if(strcmp(option, "-frame") == 0) {
+		retval = TRUE;
+		if(strcmp(SvPV_nolen(value), "black") == 0) {
+			SwitchBit(perlcs->cs.style, SS_BLACKFRAME, 1);
+			SwitchBit(perlcs->cs.style, SS_GRAYFRAME, 0);
+			SwitchBit(perlcs->cs.style, SS_WHITEFRAME, 0);
+			SwitchBit(perlcs->cs.style, SS_ETCHEDFRAME, 0);
+		} else if(strcmp(SvPV_nolen(value), "gray") == 0) {
+			SwitchBit(perlcs->cs.style, SS_BLACKFRAME, 0);
+			SwitchBit(perlcs->cs.style, SS_GRAYFRAME, 1);
+			SwitchBit(perlcs->cs.style, SS_WHITEFRAME, 0);
+			SwitchBit(perlcs->cs.style, SS_ETCHEDFRAME, 0);
+		} else if(strcmp(SvPV_nolen(value), "white") == 0) {
+			SwitchBit(perlcs->cs.style, SS_BLACKFRAME, 0);
+			SwitchBit(perlcs->cs.style, SS_GRAYFRAME, 0);
+			SwitchBit(perlcs->cs.style, SS_WHITEFRAME, 1);
+			SwitchBit(perlcs->cs.style, SS_ETCHEDFRAME, 0);
+		} else if(strcmp(SvPV_nolen(value), "etched") == 0) {
+			SwitchBit(perlcs->cs.style, SS_BLACKFRAME, 0);
+			SwitchBit(perlcs->cs.style, SS_GRAYFRAME, 0);
+			SwitchBit(perlcs->cs.style, SS_WHITEFRAME, 0);
+			SwitchBit(perlcs->cs.style, SS_ETCHEDFRAME, 1);
+		} else {
+			SwitchBit(perlcs->cs.style, SS_BLACKFRAME, 0);
+			SwitchBit(perlcs->cs.style, SS_GRAYFRAME, 0);
+			SwitchBit(perlcs->cs.style, SS_WHITEFRAME, 0);
+			SwitchBit(perlcs->cs.style, SS_ETCHEDFRAME, 0);
+		}
+	} else if(strcmp(option, "-fill") == 0) {
+		retval = TRUE;
+		if(strcmp(SvPV_nolen(value), "black") == 0) {
+			SwitchBit(perlcs->cs.style, SS_BLACKRECT, 1);
+			SwitchBit(perlcs->cs.style, SS_GRAYRECT, 0);
+			SwitchBit(perlcs->cs.style, SS_WHITERECT, 0);
+		} else if(strcmp(SvPV_nolen(value), "gray") == 0) {
+			SwitchBit(perlcs->cs.style, SS_BLACKRECT, 0);
+			SwitchBit(perlcs->cs.style, SS_GRAYRECT, 1);
+			SwitchBit(perlcs->cs.style, SS_WHITERECT, 0);
+		} else if(strcmp(SvPV_nolen(value), "white") == 0) {
+			SwitchBit(perlcs->cs.style, SS_BLACKRECT, 0);
+			SwitchBit(perlcs->cs.style, SS_GRAYRECT, 0);
+			SwitchBit(perlcs->cs.style, SS_WHITERECT, 1);
+		} else if(strcmp(SvPV_nolen(value), "etched") == 0) {
+			SwitchBit(perlcs->cs.style, SS_BLACKRECT, 0);
+			SwitchBit(perlcs->cs.style, SS_GRAYRECT, 0);
+			SwitchBit(perlcs->cs.style, SS_WHITERECT, 0);
+		} else {
+			SwitchBit(perlcs->cs.style, SS_BLACKRECT, 0);
+			SwitchBit(perlcs->cs.style, SS_GRAYRECT, 0);
+			SwitchBit(perlcs->cs.style, SS_WHITERECT, 0);
+		}
+	} else BitmaskOptionValue("-sunken", perlcs->cs.style, SS_SUNKEN)
+	} else if(strcmp(option, "-wrap") == 0) {
+		retval = TRUE;
+		if(SvIV(value)) {
+			SwitchBit(perlcs->cs.style, SS_LEFTNOWORDWRAP, 0);
+		} else {
+			SwitchBit(perlcs->cs.style, SS_LEFTNOWORDWRAP, 1);
+		}
+	} else if(strcmp(option, "-notify") == 0) {
+		retval = TRUE;
+		SwitchBit(perlcs->cs.style, SS_NOTIFY, SvIV(value));
+	}
+	return retval;
+}
+
+void
+Label_onPostCreate(NOTXSPROC HWND myhandle, LPPERLWIN32GUI_CREATESTRUCT perlcs) {
+	if(perlcs->hImageList != NULL) {
+		if(perlcs->cs.style & SS_ICON) {
+			SendMessage(
+				myhandle,
+				STM_SETIMAGE,
+				(WPARAM) IMAGE_ICON,
+				(LPARAM) perlcs->hImageList
+			);
+		} else {
+			SendMessage(
+				myhandle,
+				STM_SETIMAGE,
+				(WPARAM) IMAGE_BITMAP,
+				(LPARAM) perlcs->hImageList
+			);
+		}
+	}
+}
+
+
+MODULE = Win32::GUI::Label		PACKAGE = Win32::GUI::Label
+
+PROTOTYPES: DISABLE
+
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/ListView.xs perl-libwin32-0.191/GUI/ListView.xs
--- libwin32-0.191/GUI/ListView.xs	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/ListView.xs	2004-01-12 16:46:40.062500000 -0800
@@ -0,0 +1,730 @@
+	/*
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::ListView
+	#
+	# $Id: ListView.xs,v 1.3 2003/12/28 07:17:43 caelum Exp $
+	#
+    ###########################################################################
+	*/
+
+#include "GUI.h"
+
+BOOL
+ListView_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs) {
+	BOOL retval;
+	retval = FALSE;
+	if(strcmp(option, "-align") == 0) {
+		retval = TRUE;
+		if(strcmp(SvPV_nolen(value), "left") == 0) {
+			SwitchBit(perlcs->cs.style, LVS_ALIGNLEFT, 1);
+			SwitchBit(perlcs->cs.style, LVS_ALIGNTOP, 0);
+		} else if(strcmp(SvPV_nolen(value), "top") == 0) {
+			SwitchBit(perlcs->cs.style, LVS_ALIGNLEFT, 0);
+			SwitchBit(perlcs->cs.style, LVS_ALIGNTOP, 1);
+		} else {
+			if(PL_dowarn) warn("Win32::GUI: Invalid value for -align!");
+		}
+	} else if(strcmp(option, "-imagelist") == 0) {
+		retval = TRUE;
+		perlcs->hImageList = (HIMAGELIST) handle_From(NOTXSCALL value);
+	} else BitmaskOptionValue("-nocolumnheader", perlcs->cs.style, LVS_NOCOLUMNHEADER)
+	} else BitmaskOptionValue("-nosortheader",   perlcs->cs.style, LVS_NOSORTHEADER)
+	} else BitmaskOptionValue("-singlesel",      perlcs->cs.style, LVS_SINGLESEL)
+	} else BitmaskOptionValue("-autoarrange",    perlcs->cs.style, LVS_AUTOARRANGE)
+	} else BitmaskOptionValue("-showselalways",  perlcs->cs.style, LVS_SHOWSELALWAYS)
+	} else BitmaskOptionValue("-sortascending",  perlcs->cs.style, LVS_SORTASCENDING)
+	} else BitmaskOptionValue("-sortdescending", perlcs->cs.style, LVS_SORTDESCENDING)
+	} else BitmaskOptionValue("-fullrowselect",  perlcs->cs.dwExStyle, LVS_EX_FULLROWSELECT)
+	} else BitmaskOptionValue("-gridlines",      perlcs->cs.dwExStyle, LVS_EX_GRIDLINES)
+	} else BitmaskOptionValue("-reordercolumns", perlcs->cs.dwExStyle, LVS_EX_HEADERDRAGDROP)
+	} else BitmaskOptionValue("-checkboxes",     perlcs->cs.dwExStyle, LVS_EX_CHECKBOXES)
+	} else BitmaskOptionValue("-hottrack",       perlcs->cs.dwExStyle, LVS_EX_TRACKSELECT)
+	}
+	return retval;
+}
+
+void
+ListView_onPostCreate(NOTXSPROC HWND myhandle, LPPERLWIN32GUI_CREATESTRUCT perlcs) {
+	if(perlcs->hImageList != NULL) {
+		ListView_SetImageList(myhandle, perlcs->hImageList, LVSIL_NORMAL);
+		ListView_SetImageList(myhandle, perlcs->hImageList, LVSIL_SMALL);
+	}
+	ListView_SetExtendedListViewStyle(myhandle, perlcs->cs.dwExStyle);
+}
+
+MODULE = Win32::GUI::ListView		PACKAGE = Win32::GUI::ListView
+
+PROTOTYPES: ENABLE
+
+    ###########################################################################
+    # (@)METHOD:InsertColumn(%OPTIONS)
+int
+InsertColumn(handle,...)
+    HWND handle
+PREINIT:
+    LV_COLUMN Column;
+    unsigned int tlen;
+    int i, next_i;
+    int iCol;
+    char * option;
+CODE:
+    ZeroMemory(&Column, sizeof(LV_COLUMN));
+    next_i = -1;
+    for(i = 1; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-text") == 0) {
+                next_i = i + 1;
+                Column.pszText = SvPV(ST(next_i), tlen);
+                Column.cchTextMax = tlen;
+                Column.mask |= LVCF_TEXT;
+            } else if(strcmp(option, "-align") == 0) {
+                next_i = i + 1;
+                if(strcmp(SvPV_nolen(ST(next_i)), "right") == 0) {
+                    Column.fmt = LVCFMT_RIGHT;
+                    Column.mask |= LVCF_FMT;
+                } else if(strcmp(SvPV_nolen(ST(next_i)), "left") == 0) {
+                    Column.fmt = LVCFMT_LEFT;
+                    Column.mask |= LVCF_FMT;
+                } else if(strcmp(SvPV_nolen(ST(next_i)), "center") == 0) {
+                    Column.fmt = LVCFMT_CENTER;
+                    Column.mask |= LVCF_FMT;
+                }
+            } else if(strcmp(option, "-width") == 0) {
+                next_i = i + 1;
+                Column.cx = SvIV(ST(next_i));
+                Column.mask |= LVCF_WIDTH;
+            } else if(strcmp(option, "-index") == 0
+            || strcmp(option, "-item") == 0) {
+                next_i = i + 1;
+                iCol = SvIV(ST(next_i));
+            } else if(strcmp(option, "-subitem") == 0) {
+                next_i = i + 1;
+                Column.iSubItem = SvIV(ST(next_i));
+                Column.mask |= LVCF_SUBITEM;
+            } else if(strcmp(option, "-image") == 0) {
+                next_i = i + 1;
+                Column.iImage = SvIV(ST(next_i));
+                Column.mask |= LVCF_IMAGE;
+            }
+        } else {
+            next_i = -1;
+        }
+    }
+    if(!Column.mask & LVCF_FMT) {
+        Column.fmt = LVCFMT_LEFT;
+        Column.mask |= LVCF_FMT;
+    }
+    // evtl. autofill iCol too...
+
+    RETVAL = ListView_InsertColumn(handle, iCol, &Column);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:InsertItem(%OPTIONS)
+    # Inserts a new item in the control.
+    # (@)OPT: -image => NUMBER
+    # (@)OPT:   index of an image from the associated ImageList
+    # (@)OPT: -indent => NUMBER
+    # (@)OPT:   how much the item must be indented; one unit
+	# (@)OPT:   is the width of an item image, so 2 is twice
+	# (@)OPT:   the width of the image, and so on.
+	# (@)OPT: -item => NUMBER
+	# (@)OPT:   zero-based index for the new item; the default
+	# (@)OPT:   is to add the item at the end of the list.
+	# (@)OPT: -selected => 0/1, default 0
+	# (@)OPT: -text => STRING
+	# (@)OPT:   the text for the item
+int
+InsertItem(handle,...)
+    HWND handle
+PREINIT:
+    LV_ITEM Item;
+    unsigned int tlen;
+    int i, next_i;
+    char * option;
+    AV* texts;
+	SV** t;
+CODE:
+	texts = NULL;
+    ZeroMemory(&Item, sizeof(LV_ITEM));
+	Item.iItem = ListView_GetItemCount(handle);
+    next_i = -1;
+    for(i = 1; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-text") == 0) {
+				next_i = i + 1;
+                if(SvROK(ST(next_i)) && SvTYPE(SvRV(ST(next_i))) == SVt_PVAV) {
+                    texts = (AV*)SvRV(ST(next_i));
+					t = av_fetch(texts, 0, 0);
+					if(t != NULL) {
+						Item.pszText = SvPV(*t, tlen);
+						Item.cchTextMax = tlen;
+						SwitchBit(Item.mask, LVIF_TEXT, 1);
+					}
+				} else {
+					Item.pszText = SvPV(ST(next_i), tlen);
+					Item.cchTextMax = tlen;
+					SwitchBit(Item.mask, LVIF_TEXT, 1);
+				}
+            } else if(strcmp(option, "-item") == 0
+            || strcmp(option, "-index") == 0) {
+                next_i = i + 1;
+                Item.iItem = SvIV(ST(next_i));
+            } else if(strcmp(option, "-image") == 0) {
+                next_i = i + 1;
+                Item.iImage = SvIV(ST(next_i));
+				SwitchBit(Item.mask, LVIF_IMAGE, 1);
+            } else if(strcmp(option, "-selected") == 0) {
+                next_i = i + 1;
+				SwitchBit(Item.state, LVIS_SELECTED, SvIV(ST(next_i)));
+				SwitchBit(Item.stateMask, LVIS_SELECTED, 1);
+				SwitchBit(Item.mask, LVIF_STATE, 1);
+            } else if(strcmp(option, "-indent") == 0) {
+                next_i = i + 1;
+                Item.iIndent = SvIV(ST(next_i));
+				SwitchBit(Item.mask, LVIF_INDENT, 1);
+			}
+        } else {
+            next_i = -1;
+        }
+    }
+    RETVAL = ListView_InsertItem(handle, &Item);
+	if(texts != NULL) {
+		for(i=1; i<=av_len(texts); i++) {
+			t = av_fetch(texts, i, 0);
+			if(t != NULL) {
+				Item.pszText = SvPV(*t, tlen);
+				Item.cchTextMax = tlen;
+				SwitchBit(Item.mask, LVIF_TEXT, 1);
+			}
+			Item.iSubItem = i;
+			ListView_SetItem(handle, &Item);
+		}
+	}
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Add(ITEM, ITEM .. ITEM)
+    # Inserts one or more items in the control; each item must be passed as
+    # an hash reference. See InsertItem() for a list of the available
+    # key/values of these hashes.
+int
+Add(handle,...)
+    HWND handle
+PREINIT:
+    LV_ITEM Item;
+    unsigned int tlen;
+    int item_i, i;
+    char * option;
+    AV* texts;
+	SV** t;
+	HV* itemdata;
+	SV* sv_value;
+	I32 retlen;
+	I32 nitems;
+	int iir;
+CODE:
+	RETVAL = 0;
+    for(item_i = 1; item_i < items; item_i++) {
+		texts = NULL;
+		if(SvROK(ST(item_i)) && SvTYPE(SvRV(ST(item_i))) == SVt_PVHV) {
+			ZeroMemory(&Item, sizeof(LV_ITEM));
+			Item.iItem = ListView_GetItemCount(handle);
+			itemdata = (HV*)SvRV(ST(item_i));
+			nitems = hv_iterinit(itemdata);
+			while(nitems--) {
+				sv_value = hv_iternextsv(itemdata, &option, &retlen);
+				if(strcmp(option, "-text") == 0) {
+					if(SvROK(sv_value) && SvTYPE(SvRV(sv_value)) == SVt_PVAV) {
+						texts = (AV*)SvRV(sv_value);
+						t = av_fetch(texts, 0, 0);
+						if(t != NULL) {
+							Item.pszText = SvPV(*t, tlen);
+							Item.cchTextMax = tlen;
+							SwitchBit(Item.mask, LVIF_TEXT, 1);
+						}
+					} else {
+						Item.pszText = SvPV(sv_value, tlen);
+						Item.cchTextMax = tlen;
+						SwitchBit(Item.mask, LVIF_TEXT, 1);
+					}
+				} else if(strcmp(option, "-item") == 0
+				|| strcmp(option, "-index") == 0) {
+					Item.iItem = SvIV(sv_value);
+				} else if(strcmp(option, "-image") == 0) {
+					Item.iImage = SvIV(sv_value);
+					SwitchBit(Item.mask, LVIF_IMAGE, 1);
+				} else if(strcmp(option, "-selected") == 0) {
+					SwitchBit(Item.state, LVIS_SELECTED, SvIV(sv_value));
+					SwitchBit(Item.stateMask, LVIS_SELECTED, 1);
+					SwitchBit(Item.mask, LVIF_STATE, 1);
+				} else if(strcmp(option, "-indent") == 0) {
+					Item.iIndent = SvIV(sv_value);
+					SwitchBit(Item.mask, LVIF_INDENT, 1);
+				}
+			}
+		}
+		iir = ListView_InsertItem(handle, &Item);
+		if(iir != -1) RETVAL++;
+		if(texts != NULL) {
+			for(i=1; i<=av_len(texts); i++) {
+				t = av_fetch(texts, i, 0);
+				if(t != NULL) {
+					Item.pszText = SvPV(*t, tlen);
+					Item.cchTextMax = tlen;
+					SwitchBit(Item.mask, LVIF_TEXT, 1);
+				}
+				Item.iSubItem = i;
+				ListView_SetItem(handle, &Item);
+			}
+		}
+		Item.iItem = ListView_GetItemCount(handle);
+	}
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:ChangeItem(%OPTIONS)
+
+    ###########################################################################
+    # (@)METHOD:SetItem(%OPTIONS)
+    # See ChangeItem().
+int
+ChangeItem(handle,...)
+    HWND handle
+ALIAS:
+    Win32::GUI::ListView::SetItem = 1
+PREINIT:
+    LV_ITEM Item;
+    unsigned int tlen;
+    int i, next_i;
+    char * option;
+CODE:
+    ZeroMemory(&Item, sizeof(LV_ITEM));
+    next_i = -1;
+    for(i = 1; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-text") == 0) {
+                next_i = i + 1;
+                Item.pszText = SvPV(ST(next_i), tlen);
+                Item.cchTextMax = tlen;
+                Item.mask = Item.mask | LVIF_TEXT;
+            } else if(strcmp(option, "-item") == 0
+            || strcmp(option, "-index") == 0) {
+                next_i = i + 1;
+                Item.iItem = SvIV(ST(next_i));
+            } else if(strcmp(option, "-subitem") == 0) {
+                next_i = i + 1;
+                Item.iSubItem = SvIV(ST(next_i));
+            } else if(strcmp(option, "-image") == 0) {
+                next_i = i + 1;
+                Item.iImage = SvIV(ST(next_i));
+                Item.mask = Item.mask | LVIF_IMAGE;
+            }
+        } else {
+            next_i = -1;
+        }
+    }
+    RETVAL = ListView_SetItem(handle, &Item);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:ItemInfo(INDEX, [SUBINDEX])
+    # Returns an associative array of information about the given zero-based
+    # INDEX item:
+	#     -image
+	#     -state
+    #     -text
+	# Optionally, a SUBINDEX (one-based index) can be given, to get the text
+	# for the specified column.
+
+    ###########################################################################
+    # (@)METHOD:GetItem(INDEX, [SUBINDEX])
+    # See ItemInfo().
+void
+ItemInfo(handle,item, subitem=0)
+    HWND handle
+    int item
+    int subitem
+ALIAS:
+    Win32::GUI::ListView::GetItem = 1
+PREINIT:
+    LV_ITEM lv_item;
+    char pszText[1024];
+PPCODE:
+    ZeroMemory(&lv_item, sizeof(LV_ITEM));
+    lv_item.iItem = item;
+    lv_item.mask = LVIF_IMAGE
+                 | LVIF_PARAM
+                 | LVIF_TEXT | LVIF_STATE;
+    lv_item.pszText = pszText;
+    lv_item.cchTextMax = 1024;
+    lv_item.iSubItem = subitem;
+    if(ListView_GetItem(handle, &lv_item)) {
+        EXTEND(SP, 6);
+        XST_mPV(0, "-text");
+        XST_mPV(1, lv_item.pszText);
+        XST_mPV(2, "-image");
+        XST_mIV(3, lv_item.iImage);
+		XST_mPV(4, "-state");
+		XST_mIV(5, lv_item.state);
+        XSRETURN(6);
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:View([MODE])
+long
+View(handle,view=(DWORD) -1)
+    HWND handle
+    DWORD view
+PREINIT:
+    DWORD dwStyle;
+CODE:
+    // Get the current window style.
+    dwStyle = GetWindowLong(handle, GWL_STYLE);
+    if(items == 2) {
+        // Only set the window style if the view bits have changed.
+        if ((dwStyle & LVS_TYPEMASK) != view)
+            SetWindowLong(handle, GWL_STYLE,
+                          (dwStyle & ~LVS_TYPEMASK) | view);
+        dwStyle = GetWindowLong(handle, GWL_STYLE);
+        RETVAL = (dwStyle & LVS_TYPEMASK);
+    } else
+        RETVAL = (dwStyle & LVS_TYPEMASK);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Count()
+    # Returns the number of items in the ListView.
+int
+Count(handle)
+    HWND handle
+CODE:
+    RETVAL = ListView_GetItemCount(handle);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:DeleteItem(INDEX)
+    # Removes the zero-based INDEX item from the ListView.
+BOOL
+DeleteItem(handle,index)
+    HWND handle
+    int index
+CODE:
+    RETVAL = ListView_DeleteItem(handle, index);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:EditLabel(INDEX)
+HWND
+EditLabel(handle,index)
+    HWND handle
+    int index
+CODE:
+    RETVAL = ListView_EditLabel(handle, index);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:Clear()
+    # Deletes all items from the ListView.
+BOOL
+Clear(handle)
+    HWND handle
+CODE:
+    RETVAL = ListView_DeleteAllItems(handle);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:DeleteColumn(INDEX)
+BOOL
+DeleteColumn(handle,index)
+    HWND handle
+    int index
+CODE:
+    RETVAL = ListView_DeleteColumn(handle, index);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:SelectCount()
+UINT
+SelectCount(handle)
+    HWND handle
+CODE:
+    RETVAL = ListView_GetSelectedCount(handle);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:Select(INDEX)
+void
+Select(handle,item)
+    HWND handle
+    int item
+PREINIT:
+    UINT state;
+    UINT mask;
+CODE:
+    state = LVIS_FOCUSED | LVIS_SELECTED;
+    mask = 0xFFFFFFFF;
+    ListView_SetItemState(handle, item, state, mask);
+
+    ###########################################################################
+    # (@)METHOD:HitTest(X, Y)
+void
+HitTest(handle,x,y)
+    HWND handle
+    LONG x
+    LONG y
+PREINIT:
+    LV_HITTESTINFO ht;
+PPCODE:
+    ht.pt.x = x;
+    ht.pt.y = y;
+    ListView_HitTest(handle, &ht);
+    if(GIMME == G_ARRAY) {
+        EXTEND(SP, 2);
+        XST_mIV(0, (long) ht.iItem);
+        XST_mIV(1, ht.flags);
+        XSRETURN(2);
+    } else {
+        XSRETURN_IV((long) ht.iItem);
+    }
+
+    ###########################################################################
+    # (@)METHOD:GetStringWidth(STRING)
+int
+GetStringWidth(handle,string)
+    HWND handle
+    LPCSTR string
+CODE:
+    RETVAL = ListView_GetStringWidth(handle, string);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:GetFirstVisible()
+    # Returns the index of the first visible item in the ListView.
+int
+GetFirstVisible(handle)
+    HWND handle
+CODE:
+    RETVAL = ListView_GetTopIndex(handle);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:EnsureVisible(INDEX, [FLAG])
+BOOL
+EnsureVisible(handle,index,flag=TRUE)
+    HWND handle
+    int index
+    BOOL flag
+CODE:
+    RETVAL = ListView_EnsureVisible(handle, index, flag);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:SetImageList(IMAGELIST, [TYPE])
+HIMAGELIST
+SetImageList(handle,imagelist,type=LVSIL_NORMAL)
+    HWND handle
+    HIMAGELIST imagelist
+    WPARAM type
+CODE:
+    RETVAL = ListView_SetImageList(handle, imagelist, type);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:TextColor([COLOR])
+    # Gets or sets the text color for the ListView.
+COLORREF
+TextColor(handle,color=(COLORREF) -1)
+    HWND handle
+    COLORREF color
+CODE:
+    if(items == 2) {
+        if(ListView_SetTextColor(handle, color))
+            RETVAL = ListView_GetTextColor(handle);
+        else
+            RETVAL = (COLORREF) -1;
+    } else
+        RETVAL = ListView_GetTextColor(handle);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:TextBkColor([COLOR])
+    # Gets or sets the background color for the text in the ListView.
+COLORREF
+TextBkColor(handle,color=(COLORREF) -1)
+    HWND handle
+    COLORREF color
+CODE:
+    if(items == 2) {
+        if(ListView_SetTextBkColor(handle, color))
+            RETVAL = ListView_GetTextBkColor(handle);
+        else
+            RETVAL = (COLORREF) -1;
+    } else
+        RETVAL = ListView_GetTextBkColor(handle);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:ColumnWidth(COLUMN, [WIDTH])
+    # Gets or sets the width of the specified COLUMN; WIDTH can be the desired
+    # width in pixels or one of the following special values:
+    #   -1 automatically size the column
+    #   -2 automatically size the column to fit the header text
+int
+ColumnWidth(handle,column,width=-1)
+    HWND handle
+    int column
+    int width
+CODE:
+    if(items == 2)
+        RETVAL = ListView_GetColumnWidth(handle, column);
+    else
+        RETVAL = ListView_SetColumnWidth(handle, column, width);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:VisibleCount()
+int
+VisibleCount(handle)
+    HWND handle
+CODE:
+    RETVAL = ListView_GetCountPerPage(handle);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:MoveItem(INDEX, X, Y)
+BOOL
+MoveItem(handle, index, x, y)
+    HWND handle
+    int index
+    int x
+    int y
+CODE:
+    RETVAL = ListView_SetItemPosition(handle, index, x, y);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:ItemPosition(INDEX, [X, Y])
+void
+ItemPosition(handle, index, x=-1, y=-1)
+    HWND handle
+    int index
+    int x
+    int y
+PREINIT:
+    POINT p;
+PPCODE:
+    if(items == 2) {
+        if(ListView_GetItemPosition(handle, index, &p)) {
+            EXTEND(SP, 2);
+            XST_mIV(0, p.x);
+            XST_mIV(1, p.y);
+            XSRETURN(2);
+        } else {
+            XSRETURN_UNDEF;
+        }
+    } else {
+        XSRETURN_IV(ListView_SetItemPosition(handle, index, x, y));
+    }
+
+    ###########################################################################
+    # (@)METHOD:Arrange([FLAG])
+int
+Arrange(handle,flag=LVA_DEFAULT)
+    HWND handle
+    UINT flag
+CODE:
+    RETVAL = ListView_Arrange(handle, flag);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:ItemCheck(INDEX)
+BOOL
+ItemCheck(handle,index,value=FALSE)
+    HWND handle
+    int index
+    BOOL value
+PREINIT:
+    // LVITEM lvitem;
+CODE:
+    if(items == 3) {
+		RETVAL = ListView_GetCheckState(handle, index);
+		ListView_SetItemState(handle, index, INDEXTOSTATEIMAGEMASK((value ? 2 : 1)), LVIS_STATEIMAGEMASK);
+		# lvitem.mask = LVIF_STATE;
+		# lvitem.iItem = index;
+		# lvitem.stateMask = LVIS_STATEIMAGEMASK;
+		# lvitem.state = INDEXTOSTATEIMAGEMASK((value ? 2 : 1));
+		# RETVAL = ListView_SetItem(handle, &lvitem);
+    } else {
+        RETVAL = ListView_GetCheckState(handle, index);
+        # lvitem.mask = LVIF_STATE;
+        # lvitem.iItem = index;
+        # lvitem.stateMask = LVIS_STATEIMAGEMASK;
+        # ListView_GetItem(handle, &lvitem);
+        # RETVAL = ((BOOL)(lvitem.state >> 12) -1);
+    }
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:SelectedItems()
+    # Retuns an array containing the zero-based indexes of selected items.
+void
+SelectedItems(handle)
+    HWND handle
+PREINIT:
+	UINT scount;
+	UINT tcount;
+	int index;
+PPCODE:
+	scount = ListView_GetSelectedCount(handle);
+	if(scount > 0) {
+		index = -1;
+		tcount = 0;
+		EXTEND(SP, scount);
+		index = ListView_GetNextItem(handle, index, LVNI_SELECTED);
+		while(tcount < scount && index != -1) {
+			XST_mIV(tcount, (long) index);
+			tcount++;
+			index = ListView_GetNextItem(handle, index, LVNI_SELECTED);
+		}
+		XSRETURN(scount);
+	} else {
+		XSRETURN_UNDEF;
+	}
+
+	# TODO: GetItem
+	# TODO: GetNextItem
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/Listbox.xs perl-libwin32-0.191/GUI/Listbox.xs
--- libwin32-0.191/GUI/Listbox.xs	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/Listbox.xs	2004-01-12 16:46:40.062500000 -0800
@@ -0,0 +1,242 @@
+
+	/*
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::Listbox
+    #
+    # $Id: Listbox.xs,v 1.3 2003/12/28 07:17:43 caelum Exp $
+    #
+    ###########################################################################
+	*/
+
+#include "GUI.h"
+
+BOOL
+Listbox_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs) {
+	BOOL retval;
+	retval = FALSE;
+	if(strcmp(option, "-multisel") == 0) {
+		retval = TRUE;
+		if(SvIV(value) == 0) {
+			SwitchBit(perlcs->cs.style, LBS_MULTIPLESEL, 0);
+			SwitchBit(perlcs->cs.style, LBS_EXTENDEDSEL, 0);
+		} else if(SvIV(value) == 1) {
+			SwitchBit(perlcs->cs.style, LBS_MULTIPLESEL, 1);
+			SwitchBit(perlcs->cs.style, LBS_EXTENDEDSEL, 0);
+		} else if(SvIV(value) == 2) {
+			SwitchBit(perlcs->cs.style, LBS_MULTIPLESEL, 1);
+			SwitchBit(perlcs->cs.style, LBS_EXTENDEDSEL, 1);
+		} else {
+			if(PL_dowarn) warn("Win32::GUI: Invalid value for -multisel!");
+		}
+	} else BitmaskOptionValue("-sort", perlcs->cs.style, LBS_SORT)
+	}
+	return retval;
+}
+
+
+MODULE = Win32::GUI::Listbox		PACKAGE = Win32::GUI::Listbox
+
+PROTOTYPES: DISABLE
+
+
+    ###########################################################################
+    # (@)METHOD:AddString(STRING)
+LRESULT
+AddString(handle,string)
+    HWND handle
+    LPCTSTR string
+CODE:
+    RETVAL = SendMessage(handle, LB_ADDSTRING, 0, (LPARAM) string);
+OUTPUT:
+    RETVAL
+
+	###########################################################################
+    # (@)METHOD:Add(STRING, STRING .. STRING)
+void
+Add(handle,...)
+    HWND handle
+PREINIT:
+	int i;
+CODE:
+	for(i = 1; i < items; i++) {
+		SendMessage(handle, LB_ADDSTRING, 0, (LPARAM) (LPCTSTR) SvPV_nolen(ST(i)));
+	}
+
+    ###########################################################################
+    # (@)METHOD:InsertItem(STRING, [INDEX])
+    # Inserts an item at the specified zero-based INDEX in the Listbox,
+    # or adds it at the end if INDEX is not specified.
+LRESULT
+InsertItem(handle,string,index=-1)
+    HWND handle
+    LPCTSTR string
+    long index
+CODE:
+    RETVAL = SendMessage(handle, LB_INSERTSTRING, (WPARAM) index, (LPARAM) string);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetString(INDEX)
+    # Returns the string at the specified zero-based INDEX in the Listbox.
+void
+GetString(handle,index)
+    HWND handle
+    WPARAM index
+PREINIT:
+    STRLEN cbString;
+    char *szString;
+PPCODE:
+    cbString = SendMessage(handle, LB_GETTEXTLEN, index, 0);
+	if(cbString != LB_ERR) {
+		szString = (char *) safemalloc(cbString);
+		if(SendMessage(handle, LB_GETTEXT,
+					   index, (LPARAM) (LPCTSTR) szString) != LB_ERR) {
+			EXTEND(SP, 1);
+			XST_mPV(0, szString);
+			safefree(szString);
+			XSRETURN(1);
+		} else {
+			safefree(szString);
+			XSRETURN_UNDEF;
+		}
+	} else {
+		XSRETURN_UNDEF;
+	}
+
+    ###########################################################################
+    # (@)METHOD:ItemHeight([HEIGHT])
+    # Gets or sets the items height in a Listbox.
+LRESULT
+ItemHeight(handle,height=-1)
+    HWND handle
+    long height
+CODE:
+    if(items == 1) {
+        RETVAL = SendMessage(handle, LB_GETITEMHEIGHT, 0, 0);
+    } else {
+        RETVAL = SendMessage(handle, LB_SETITEMHEIGHT, 0, MAKELPARAM(height, 0));
+    }
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:FirstVisibleItem([INDEX])
+LRESULT
+FirstVisibleItem(handle,index=-1)
+    HWND handle
+    long index
+CODE:
+    if(items == 1)
+        RETVAL = SendMessage(handle, LB_GETTOPINDEX, 0, 0);
+    else
+        RETVAL = SendMessage(handle, LB_SETTOPINDEX, (WPARAM) index, 0);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:ItemFromPoint(X, Y)
+void
+ItemFromPoint(handle,x,y)
+    HWND handle
+    UINT x
+    UINT y
+PREINIT:
+    LRESULT lresult;
+PPCODE:
+    lresult = SendMessage(handle, LB_ITEMFROMPOINT, 0, (LPARAM) MAKELPARAM(x, y));
+    if(GIMME == G_ARRAY) {
+        EXTEND(SP, 2);
+        XST_mIV(0, (long) LOWORD(lresult));
+        if(HIWORD(lresult) == 0)
+            XST_mIV(1, 1);
+        else
+            XST_mIV(1, 0);
+        XSRETURN(2);
+    } else {
+        XSRETURN_IV((long) LOWORD(lresult));
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:SelectString(STRING, [INDEX])
+LRESULT
+SelectString(handle,string,index=-1)
+    HWND handle
+    LPCTSTR string
+    long index
+CODE:
+    RETVAL = SendMessage(handle, LB_SELECTSTRING, (WPARAM) index, (LPARAM) string);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:FindString(STRING, [INDEX])
+LRESULT
+FindString(handle,string,index=-1)
+    HWND handle
+    LPCTSTR string
+    long index
+CODE:
+    RETVAL = SendMessage(handle, LB_FINDSTRING, (WPARAM) index, (LPARAM) string);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:FindStringExact(STRING, [INDEX])
+LRESULT
+FindStringExact(handle,string,index=-1)
+    HWND handle
+    LPCTSTR string
+    long index
+CODE:
+    RETVAL = SendMessage(handle, LB_FINDSTRINGEXACT, (WPARAM) index, (LPARAM) string);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:SelectCount()
+LRESULT
+SelectCount(handle)
+    HWND handle
+CODE:
+    RETVAL = SendMessage(handle, LB_GETSELCOUNT, 0, 0);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:SelectedItems()
+    # Returns an array containing the zero-based indexes of the selected items
+    # in a multiple selection Listbox.
+void
+SelectedItems(handle)
+    HWND handle
+PREINIT:
+    LRESULT count;
+    LRESULT lresult;
+    LPINT selitems;
+    int i;
+PPCODE:
+    count = SendMessage(handle, LB_GETSELCOUNT, 0, 0);
+    if(count > 0) {
+        selitems = (LPINT) safemalloc(sizeof(INT)*count);
+        lresult = SendMessage(handle, LB_GETSELITEMS, (WPARAM) count, (LPARAM) selitems);
+        if(lresult == -1) {
+            XSRETURN_UNDEF;
+        } else {
+            EXTEND(SP, lresult);
+            for(i=0; i<lresult; i++) {
+                XST_mIV(i, (long) selitems[i]);
+            }
+            safefree(selitems);
+            XSRETURN(lresult);
+        }
+    } else {
+        XSRETURN_UNDEF;
+    }
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/MANIFEST perl-libwin32-0.191/GUI/MANIFEST
--- libwin32-0.191/GUI/MANIFEST	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/MANIFEST	2004-01-12 16:46:40.078125000 -0800
@@ -0,0 +1,201 @@
+CHANGELOG
+hints/cygwin.pl
+hints/MSWin32.pl
+Animation.xs
+BUGS
+Bitmap.xs
+BitmapInline.pm
+DC.xs
+Font.xs
+GUI.h
+GUI.pm
+GUI.rc
+GUI.xs
+GUI_Constants.cpp
+GUI_Events.cpp
+GUI_Helpers.cpp
+GUI_MessageLoops.cpp
+GUI_Options.cpp
+GridLayout.pm
+ImageList.xs
+Label.xs
+ListView.xs
+Listbox.xs
+MANIFEST
+Makefile.PL
+NotifyIcon.xs
+README
+README.txt
+Rebar.xs
+RichEdit.xs
+Splitter.xs
+TODO
+typemap
+TabStrip.xs
+Textfield.xs
+Toolbar.xs
+TreeView.xs
+guiperl.ico
+hsplit.cur
+vsplit.cur
+resource.h
+docs/archdraft.html
+docs/html/archdraft.html
+docs/html/events.html
+docs/html/methods.html
+docs/html/options.html
+docs/html/packages.html
+docs/archdraft.pod
+docs/dodoc.pl
+docs/dodoc2.pl
+docs/dohtml.pl
+docs/events.pod
+docs/GUI.pod
+docs/guiconcepts.pod
+docs/guioptions.pod
+docs/style.css
+docs/methods.pod
+docs/newbuild.pl
+docs/options.pod
+docs/packages.pod
+docs/html/AcceleratorTable.html
+docs/html/Animation.html
+docs/html/Bitmap.html
+docs/html/BitmapInline.html
+docs/html/Brush.html
+docs/html/Button.html
+docs/html/Checkbox.html
+docs/html/Class.html
+docs/html/Combobox.html
+docs/html/ComboboxEx.html
+docs/html/Cursor.html
+docs/html/DC.html
+docs/html/DateTime.html
+docs/html/DialogBox.html
+docs/html/Font.html
+docs/html/Graphic.html
+docs/html/GridLayout.html
+docs/html/Groupbox.html
+docs/html/Header.html
+docs/html/Icon.html
+docs/html/ImageList.html
+docs/html/Label.html
+docs/html/ListView.html
+docs/html/ListView_Item.html
+docs/html/ListView_SubItem.html
+docs/html/Listbox.html
+docs/html/Listbox_Item.html
+docs/html/MDI.html
+docs/html/Menu.html
+docs/html/MenuButton.html
+docs/html/MenuItem.html
+docs/html/NotifyIcon.html
+docs/html/Pen.html
+docs/html/ProgressBar.html
+docs/html/RadioButton.html
+docs/html/Rebar.html
+docs/html/RichEdit.html
+docs/html/Slider.html
+docs/html/Splitter.html
+docs/html/StatusBar.html
+docs/html/TabStrip.html
+docs/html/Textfield.html
+docs/html/Timer.html
+docs/html/Toolbar.html
+docs/html/Tooltip.html
+docs/html/TreeView.html
+docs/html/UpDown.html
+docs/html/Win32_GUI.html
+docs/html/Window.html
+docs/html/GUI.html
+docs/html/guiconcepts.html
+docs/html/guioptions.html
+docs/html/guipacks.html
+docs/tut/guitut1-1.gif
+docs/tut/guitut1-2.gif
+docs/tut/guitut1-3.gif
+docs/tut/guitut1.html
+docs/tut/guitut1.pod
+docs/tut/guitut2.html
+docs/tut/guitut2.pod
+docs/tut/guitut3.html
+docs/tut/guitut3.pod
+docs/tut/guitut4.html
+docs/tut/guitut4.pod
+docs/tut/guitut5-1.gif
+docs/tut/guitut5-2.gif
+docs/tut/guitut5.html
+docs/tut/guitut5.pod
+docs/tut/guitut9.html
+docs/tut/guitut9.pod
+docs/tut/morethanone.pl
+samples/DateTime.pl
+samples/nemtimer.pl
+samples/res.txt
+samples/richedit.rtf
+samples/tt.pl
+samples/Pod/RTF.pm
+samples/Zapotec.bmp
+samples/alarm.bmp
+samples/bitmap.pl
+samples/buttons.pl
+samples/camel.ico
+samples/cf.pl
+samples/class.pl
+samples/close.bmp
+samples/cmeta.pl
+samples/combobox.pl
+samples/dc.pl
+samples/dll.bmp
+samples/draw.pl
+samples/folder.bmp
+samples/frm2pl.pl
+samples/harrow.cur
+samples/hello.pl
+samples/listbox.pl
+samples/listview.pl
+samples/module.bmp
+samples/mousemove.pl
+samples/msk.pl
+samples/nem_lv.pl
+samples/nem_tv.pl
+samples/node.bmp
+samples/node_sel.bmp
+samples/ofn.pl
+samples/one.bmp
+samples/pmx.html
+samples/pmx.pl
+samples/podview.pl
+samples/ppmrepa.bmp
+samples/ppmrepc.bmp
+samples/ppmrepf.bmp
+samples/ppmrepi.bmp
+samples/ppmrepl.bmp
+samples/ppmrepn.bmp
+samples/ppmrepo.bmp
+samples/ppmrepr.bmp
+samples/pride.pl
+samples/progressbar.pl
+samples/richedit.pl
+samples/sfn.pl
+samples/slider.pl
+samples/splitter.pl
+samples/tabstrip.pl
+samples/test.msk
+samples/test2.msk
+samples/textfield.pl
+samples/three.bmp
+samples/timer.pl
+samples/toolbar.pl
+samples/tools.bmp
+samples/treeview.pl
+samples/two.bmp
+samples/unkfolder.bmp
+samples/vmeta.pl
+samples/winlist.pl
+samples/winppm.ini
+samples/winppm.pl
+samples/winsize.pl
+t/01_basic.t
+t/02_window.t
+t/03_button.t
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/Makefile.PL perl-libwin32-0.191/GUI/Makefile.PL
--- libwin32-0.191/GUI/Makefile.PL	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/Makefile.PL	2004-01-12 16:46:40.093750000 -0800
@@ -0,0 +1,63 @@
+use ExtUtils::MakeMaker;
+use Config;
+
+@xs = qw(
+        GUI
+	Animation
+	Bitmap
+	DC
+	Font
+	ImageList
+	Label
+	Listbox
+	ListView
+	NotifyIcon
+	Rebar
+	RichEdit
+	Splitter
+	TabStrip
+	Textfield
+	Toolbar
+	TreeView
+);
+
+@cpp = qw(
+	GUI_Constants
+	GUI_Helpers
+	GUI_Options
+	GUI_MessageLoops
+	GUI_Events
+);
+
+WriteMakefile (
+    NAME => 'Win32::GUI',
+    VERSION_FROM => 'GUI.pm',
+    'PM' => {
+        'GUI.pm'            => '$(INST_LIBDIR)/GUI.pm',
+        'BitmapInline.pm'   => '$(INST_LIBDIR)/GUI/BitmapInline.pm',
+        'GridLayout.pm'     => '$(INST_LIBDIR)/GUI/GridLayout.pm',
+    },
+    DL_FUNCS => { 'Win32::GUI' => [
+        'boot_Win32__GUI',
+    	(map { "boot_Win32__GUI__$_" } @xs[1..$#xs])
+    ]},
+    OBJECT => (join ' ', map { "$_\$(OBJ_EXT)" }  (@xs, @cpp)),
+    XS => { map { ("$_.xs" => "$_.cpp") } @xs},
+	'dist'  => {
+        ZIP => 'zip',
+        ZIPFLAGS => '-r9',
+    },
+    ($] < 5.005 ? () : (
+        'AUTHOR'        => 'Aldo Calpini <dada@perl.it>',
+        'ABSTRACT'      => 'Perl-Win32 Graphical User Interface Extension',
+    )),
+);
+
+package MY;
+
+sub xs_c {
+    '
+.xs.cpp:
+	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs >xstmp.c && $(MV) xstmp.c $*.cpp
+';
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/NotifyIcon.xs perl-libwin32-0.191/GUI/NotifyIcon.xs
--- libwin32-0.191/GUI/NotifyIcon.xs	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/NotifyIcon.xs	2004-01-12 16:46:40.109375000 -0800
@@ -0,0 +1,127 @@
+
+#include "GUI.h"
+
+	/*
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::NotifyIcon
+    ###########################################################################
+	*/
+
+MODULE = Win32::GUI::NotifyIcon		PACKAGE = Win32::GUI::NotifyIcon
+
+PROTOTYPES: ENABLE
+
+    ###########################################################################
+    # (@)INTERNAL:Add(PARENT, %OPTIONS)
+BOOL
+Add(parent,...)
+    HWND parent
+PREINIT:
+    int i, next_i;
+    char * option;
+    NOTIFYICONDATA nid;
+CODE:
+    ZeroMemory(&nid, sizeof(NOTIFYICONDATA));
+    nid.cbSize = sizeof(NOTIFYICONDATA);
+    nid.hWnd = parent;
+    nid.uCallbackMessage = WM_NOTIFYICON;
+    SwitchBit(nid.uFlags, NIF_MESSAGE, 1);
+    next_i = -1;
+    for(i = 1; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-id") == 0) {
+                next_i = i + 1;
+                nid.uID = (UINT) SvIV(ST(next_i));
+            } else if(strcmp(option, "-icon") == 0) {
+                next_i = i + 1;
+                nid.hIcon = (HICON) handle_From(NOTXSCALL ST(next_i));
+                SwitchBit(nid.uFlags, NIF_ICON, 1);
+            } else if(strcmp(option, "-tip") == 0) {
+                next_i = i + 1;
+                strcpy(nid.szTip, SvPV_nolen(ST(next_i)));
+                SwitchBit(nid.uFlags, NIF_TIP, 1);
+            }
+        } else {
+            next_i = -1;
+        }
+    }
+    RETVAL = Shell_NotifyIcon(NIM_ADD, &nid);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)INTERNAL:Modify(PARENT, %OPTIONS)
+BOOL
+Modify(parent,...)
+    HWND parent
+PREINIT:
+    int i, next_i;
+    char * option;
+    NOTIFYICONDATA nid;
+CODE:
+    ZeroMemory(&nid, sizeof(NOTIFYICONDATA));
+    nid.cbSize = sizeof(NOTIFYICONDATA);
+    nid.hWnd = parent;
+    next_i = -1;
+    for(i = 1; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-id") == 0) {
+                next_i = i + 1;
+                nid.uID = (UINT) SvIV(ST(next_i));
+            } else if(strcmp(option, "-icon") == 0) {
+                next_i = i + 1;
+                nid.hIcon = (HICON) handle_From(NOTXSCALL ST(next_i));
+                SwitchBit(nid.uFlags, NIF_ICON, 1);
+            } else if(strcmp(option, "-tip") == 0) {
+                next_i = i + 1;
+                strcpy(nid.szTip, SvPV_nolen(ST(next_i)));
+                SwitchBit(nid.uFlags, NIF_TIP, 1);
+            }
+        } else {
+            next_i = -1;
+        }
+    }
+    RETVAL = Shell_NotifyIcon(NIM_MODIFY, &nid);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)INTERNAL:Delete(PARENT, %OPTIONS)
+BOOL
+Delete(parent,...)
+    HWND parent
+PREINIT:
+    int i, next_i;
+    char * option;
+    NOTIFYICONDATA nid;
+CODE:
+    ZeroMemory(&nid, sizeof(NOTIFYICONDATA));
+    nid.cbSize = sizeof(NOTIFYICONDATA);
+    nid.hWnd = parent;
+    next_i = -1;
+    for(i = 1; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-id") == 0) {
+                next_i = i + 1;
+                nid.uID = (UINT) SvIV(ST(next_i));
+            } else if(strcmp(option, "-icon") == 0) {
+                next_i = i + 1;
+                nid.hIcon = (HICON) handle_From(NOTXSCALL ST(next_i));
+                SwitchBit(nid.uFlags, NIF_ICON, 1);
+            } else if(strcmp(option, "-tip") == 0) {
+                next_i = i + 1;
+                strcpy(nid.szTip, SvPV_nolen(ST(next_i)));
+                SwitchBit(nid.uFlags, NIF_TIP, 1);
+            }
+        } else {
+            next_i = -1;
+        }
+    }
+    RETVAL = Shell_NotifyIcon(NIM_DELETE, &nid);
+OUTPUT:
+    RETVAL
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/README perl-libwin32-0.191/GUI/README
--- libwin32-0.191/GUI/README	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/README	2004-01-12 16:46:40.125000000 -0800
@@ -0,0 +1,21 @@
+
+###############################################################################
+#
+# Win32::GUI - Perl-Win32 Graphical User Interface Extension
+#
+# 29 Jan 1997 by Aldo Calpini <dada@perl.it>
+#
+# Version: 0.0.670 (12 Dec 2003)
+#
+# Copyright (c) 1997..2002 Aldo Calpini. All rights reserved.
+# This program is free software; you can redistribute it and/or
+# modify it under the same terms as Perl itself.
+#
+###############################################################################
+
+Win32::GUI is a Win32-platform native graphical user interface toolkit for perl. 
+basically, it's an XS implementation of most of the functions found in 
+user32.dll and gdi32.dll, with an object oriented perl interface and an 
+event-based dialog model that mimic the functionality of visual basic. 
+
+homepage: http://dada.perl.it
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/README.txt perl-libwin32-0.191/GUI/README.txt
--- libwin32-0.191/GUI/README.txt	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/README.txt	2004-01-12 16:46:40.140625000 -0800
@@ -0,0 +1,21 @@
+
+###############################################################################
+#
+# Win32::GUI - Perl-Win32 Graphical User Interface Extension
+#
+# 29 Jan 1997 by Aldo Calpini <dada@perl.it>
+#
+# Version: 0.0.670 (12 Dec 2003)
+#
+# Copyright (c) 1997..2002 Aldo Calpini. All rights reserved.
+# This program is free software; you can redistribute it and/or
+# modify it under the same terms as Perl itself.
+#
+###############################################################################
+
+Win32::GUI is a Win32-platform native graphical user interface toolkit for perl. 
+basically, it's an XS implementation of most of the functions found in 
+user32.dll and gdi32.dll, with an object oriented perl interface and an 
+event-based dialog model that mimic the functionality of visual basic. 
+
+homepage: http://dada.perl.it  
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/Rebar.xs perl-libwin32-0.191/GUI/Rebar.xs
--- libwin32-0.191/GUI/Rebar.xs	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/Rebar.xs	2004-01-12 16:46:40.156250000 -0800
@@ -0,0 +1,214 @@
+	/*
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::Rebar
+	#
+	# $Id: Rebar.xs,v 1.3 2003/12/28 07:17:43 caelum Exp $
+	#
+    ###########################################################################
+	*/
+
+#include "GUI.h"
+
+BOOL
+Rebar_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs) {
+	BOOL retval;
+	retval = FALSE;
+	if(strcmp(option, "-imagelist") == 0) {
+		retval = TRUE;
+		perlcs->hImageList = (HIMAGELIST) handle_From(NOTXSCALL value);
+	} else BitmaskOptionValue("-bandborders", perlcs->cs.style, RBS_BANDBORDERS)
+	} else BitmaskOptionValue("-fixedorder",  perlcs->cs.style, RBS_FIXEDORDER)
+	} else BitmaskOptionValue("-varheight",   perlcs->cs.style, RBS_VARHEIGHT)
+	} else BitmaskOptionValue("-autosize",    perlcs->cs.style, RBS_AUTOSIZE)
+	} else BitmaskOptionValue("-vertical",    perlcs->cs.style, CCS_VERT)
+	} else BitmaskOptionValue("-doubleclick", perlcs->cs.style, RBS_DBLCLKTOGGLE)
+	} else BitmaskOptionValue("-vgripper",    perlcs->cs.style, RBS_VERTICALGRIPPER)
+	}
+	return retval;
+}
+
+void
+Rebar_onPostCreate(NOTXSPROC HWND myhandle, LPPERLWIN32GUI_CREATESTRUCT perlcs) {
+	// initialize and send the REBARINFO structure.
+	REBARINFO rbi;
+	rbi.cbSize = sizeof(REBARINFO);
+	if(perlcs->hImageList != NULL) {
+		rbi.fMask = RBIM_IMAGELIST;
+		rbi.himl = perlcs->hImageList;
+	} else {
+		rbi.fMask = 0;
+		rbi.himl = NULL;
+	}
+	SendMessage(myhandle, RB_SETBARINFO, 0, (LPARAM) &rbi);
+}
+
+
+MODULE = Win32::GUI::Rebar		PACKAGE = Win32::GUI::Rebar
+
+PROTOTYPES: ENABLE
+
+    ###########################################################################
+    # (@)METHOD:InsertBand(%OPTIONS)
+LRESULT
+InsertBand(handle,...)
+    HWND handle
+PREINIT:
+    REBARBANDINFO rbbi;
+    int i, next_i;
+    UINT index;
+CODE:
+    ZeroMemory(&rbbi, sizeof(REBARBANDINFO));
+    rbbi.cbSize = sizeof(REBARBANDINFO);
+    index = (UINT) -1;
+    next_i = -1;
+    for(i = 1; i < items; i++) {
+        if(next_i == -1) {
+            if(strcmp(SvPV_nolen(ST(i)), "-image") == 0) {
+                next_i = i + 1;
+                rbbi.iImage = SvIV(ST(next_i));
+                SwitchBit(rbbi.fMask, RBBIM_IMAGE, 1);
+            } else if(strcmp(SvPV_nolen(ST(i)), "-index") == 0) {
+                next_i = i + 1;
+                index = (UINT) SvIV(ST(next_i));
+            } else if(strcmp(SvPV_nolen(ST(i)), "-bitmap") == 0) {
+                next_i = i + 1;
+                rbbi.hbmBack = (HBITMAP) handle_From(NOTXSCALL ST(next_i));
+                SwitchBit(rbbi.fMask, RBBIM_BACKGROUND, 1);
+            } else if(strcmp(SvPV_nolen(ST(i)), "-child") == 0) {
+                next_i = i + 1;
+                rbbi.hwndChild = (HWND) handle_From(NOTXSCALL ST(next_i));
+                SwitchBit(rbbi.fMask, RBBIM_CHILD, 1);
+            } else if(strcmp(SvPV_nolen(ST(i)), "-foreground") == 0) {
+                next_i = i + 1;
+                rbbi.clrFore = SvCOLORREF(NOTXSCALL ST(next_i));
+                SwitchBit(rbbi.fMask, RBBIM_COLORS, 1);
+            } else if(strcmp(SvPV_nolen(ST(i)), "-background") == 0) {
+                next_i = i + 1;
+                rbbi.clrBack = SvCOLORREF(NOTXSCALL ST(next_i));
+                SwitchBit(rbbi.fMask, RBBIM_COLORS, 1);
+            } else if(strcmp(SvPV_nolen(ST(i)), "-width") == 0) {
+                next_i = i + 1;
+                rbbi.cx = SvIV(ST(next_i));
+                SwitchBit(rbbi.fMask, RBBIM_SIZE, 1);
+            } else if(strcmp(SvPV_nolen(ST(i)), "-minwidth") == 0) {
+                next_i = i + 1;
+                rbbi.cxMinChild = SvIV(ST(next_i));
+                SwitchBit(rbbi.fMask, RBBIM_CHILDSIZE, 1);
+            } else if(strcmp(SvPV_nolen(ST(i)), "-minheight") == 0) {
+                next_i = i + 1;
+                rbbi.cyMinChild = SvIV(ST(next_i));
+                SwitchBit(rbbi.fMask, RBBIM_CHILDSIZE, 1);
+            } else if(strcmp(SvPV_nolen(ST(i)), "-text") == 0) {
+                next_i = i + 1;
+                rbbi.lpText = SvPV_nolen(ST(next_i));
+                SwitchBit(rbbi.fMask, RBBIM_TEXT, 1);
+            }
+        } else {
+            next_i = -1;
+        }
+    }
+    RETVAL = SendMessage(handle, RB_INSERTBAND, (WPARAM) index, (LPARAM) &rbbi);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:DeleteBand(INDEX)
+LRESULT
+DeleteBand(handle,index)
+    HWND handle
+    UINT index
+CODE:
+    RETVAL = SendMessage(handle, RB_DELETEBAND, (WPARAM) index, 0);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:RowCount()
+LRESULT
+RowCount(handle)
+    HWND handle
+CODE:
+    RETVAL = SendMessage(handle, RB_GETROWCOUNT, 0, 0);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:BandCount()
+LRESULT
+BandCount(handle)
+    HWND handle
+CODE:
+    RETVAL = SendMessage(handle, RB_GETBANDCOUNT, 0, 0);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:BandInfo(INDEX)
+void
+BandInfo(handle,index)
+    HWND handle
+    UINT index
+PREINIT:
+    REBARBANDINFO rbbi;
+CODE:
+    ZeroMemory(&rbbi, sizeof(REBARBANDINFO));
+    rbbi.cbSize = sizeof(REBARBANDINFO);
+    rbbi.fMask =
+    	RBBIM_BACKGROUND | RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_COLORS |
+    	RBBIM_HEADERSIZE | RBBIM_IDEALSIZE | RBBIM_ID | RBBIM_IMAGE |
+    	RBBIM_LPARAM | RBBIM_SIZE | RBBIM_STYLE | RBBIM_TEXT;
+    if(SendMessage(handle, RB_GETBANDINFO, (WPARAM) index, (LPARAM) &rbbi)) {
+        EXTEND(SP, 18);
+        XST_mPV( 0, "-text");
+        XST_mPV( 1, rbbi.lpText);
+        XST_mPV( 2, "-foreground");
+        XST_mIV( 3, rbbi.clrFore);
+		XST_mPV( 4, "-background");
+		XST_mIV( 5, rbbi.clrBack);
+		XST_mPV( 6, "-image");
+		XST_mIV( 7, rbbi.iImage);
+		XST_mPV( 8, "-child");
+		XST_mIV( 9, (long) rbbi.hwndChild);
+		XST_mPV(10, "-bitmap");
+		XST_mIV(11, (long) rbbi.hbmBack);
+		XST_mPV(12, "-width");
+		XST_mIV(13, rbbi.cx);
+		XST_mPV(14, "-minwidth");
+		XST_mIV(15, rbbi.cxMinChild);
+		XST_mPV(16, "-minheight");
+		XST_mIV(17, rbbi.cyMinChild);
+        XSRETURN(18);
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+    ###########################################################################
+    # (@)METHOD:MinimizeBand(INDEX)
+LRESULT
+MinimizeBand(handle,index)
+    HWND handle
+    UINT index
+CODE:
+    RETVAL = SendMessage(handle, RB_MINIMIZEBAND, (WPARAM) index, 0);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:MaximizeBand(INDEX, [FLAG])
+LRESULT
+MaximizeBand(handle,index,flag=0)
+    HWND handle
+    UINT index
+    BOOL flag
+CODE:
+    RETVAL = SendMessage(handle, RB_MAXIMIZEBAND, (WPARAM) index, (LPARAM) flag);
+OUTPUT:
+    RETVAL
+
+
+    # TODO: ChangeBand
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/RichEdit.xs perl-libwin32-0.191/GUI/RichEdit.xs
--- libwin32-0.191/GUI/RichEdit.xs	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/RichEdit.xs	2004-01-12 16:46:40.171875000 -0800
@@ -0,0 +1,502 @@
+	/*
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::RichEdit
+    #
+    # $Id: RichEdit.xs,v 1.3 2003/12/28 07:17:43 caelum Exp $
+    #
+    ###########################################################################
+	*/
+
+#include "GUI.h"
+
+MODULE = Win32::GUI::RichEdit		PACKAGE = Win32::GUI::RichEdit
+
+PROTOTYPES: ENABLE
+
+    ###########################################################################
+    # (@)METHOD:SetCharFormat(%OPTIONS)
+LRESULT
+SetCharFormat(handle,...)
+    HWND handle
+PREINIT:
+    CHARFORMAT cf;
+    int i, next_i;
+    char * option;
+CODE:
+    ZeroMemory(&cf, sizeof(CHARFORMAT));
+    cf.cbSize = sizeof(CHARFORMAT);
+    next_i = -1;
+    for(i = 1; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-bold") == 0) {
+                next_i = i + 1;
+                if(SvIV(ST(next_i)) != 0) {
+                    cf.dwEffects = cf.dwEffects | CFE_BOLD;
+                }
+                cf.dwMask = cf.dwMask | CFM_BOLD;
+            }
+            if(strcmp(option, "-italic") == 0) {
+                next_i = i + 1;
+                if(SvIV(ST(next_i)) != 0) {
+                    cf.dwEffects = cf.dwEffects | CFE_ITALIC;
+                }
+                cf.dwMask = cf.dwMask | CFM_ITALIC;
+            }
+            if(strcmp(option, "-underline") == 0) {
+                next_i = i + 1;
+                if(SvIV(ST(next_i)) != 0) {
+                    cf.dwEffects = cf.dwEffects | CFE_UNDERLINE;
+                }
+                cf.dwMask = cf.dwMask | CFM_UNDERLINE;
+            }
+            if(strcmp(option, "-strikeout") == 0) {
+                next_i = i + 1;
+                if(SvIV(ST(next_i)) != 0) {
+                    cf.dwEffects = cf.dwEffects | CFE_STRIKEOUT;
+                }
+                cf.dwMask = cf.dwMask | CFM_STRIKEOUT;
+            }
+            if(strcmp(option, "-color") == 0) {
+                next_i = i + 1;
+                cf.crTextColor = SvCOLORREF(NOTXSCALL ST(next_i));
+                cf.dwMask = cf.dwMask | CFM_COLOR;
+            }
+            if(strcmp(option, "-autocolor") == 0) {
+                next_i = i + 1;
+                if(SvIV(ST(next_i)) != 0) {
+                    cf.dwEffects = cf.dwEffects | CFE_AUTOCOLOR;
+                    cf.dwMask = cf.dwMask | CFM_COLOR;
+                }
+            }
+            if(strcmp(option, "-height") == 0
+            || strcmp(option, "-size") == 0) {
+                next_i = i + 1;
+                cf.yHeight = (LONG) SvIV(ST(next_i));
+                cf.dwMask = cf.dwMask | CFM_SIZE;
+            }
+            if(strcmp(option, "-name") == 0) {
+                next_i = i + 1;
+                strncpy((char *)cf.szFaceName, SvPV_nolen(ST(next_i)), 32);
+                cf.dwMask = cf.dwMask | CFM_FACE;
+            }
+        } else {
+            next_i = -1;
+        }
+    }
+    RETVAL = SendMessage(handle, EM_SETCHARFORMAT,
+                         (WPARAM) (UINT) SCF_SELECTION,
+                         (LPARAM) (CHARFORMAT FAR *) &cf);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:SetParaFormat(%OPTIONS)
+LRESULT
+SetParaFormat(handle,...)
+    HWND handle
+PREINIT:
+    PARAFORMAT pf;
+    int i, next_i;
+    char * option;
+CODE:
+    ZeroMemory(&pf, sizeof(PARAFORMAT));
+    pf.cbSize = sizeof(PARAFORMAT);
+    next_i = -1;
+    for(i = 1; i < items; i++) {
+        if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-numbering") == 0
+            || strcmp(option, "-bullet") == 0) {
+                next_i = i + 1;
+                if(SvIV(ST(next_i)) != 0) {
+                    pf.wNumbering = PFN_BULLET;
+                } else {
+                    pf.wNumbering = 0;
+                }
+                pf.dwMask = pf.dwMask | PFM_NUMBERING;
+            } else if(strcmp(option, "-align") == 0) {
+                next_i = i + 1;
+                if(strcmp(SvPV_nolen(ST(next_i)), "left") == 0) {
+                    pf.wAlignment = PFA_LEFT;
+                    pf.dwMask = pf.dwMask | PFM_ALIGNMENT;
+                } else if(strcmp(SvPV_nolen(ST(next_i)), "center") == 0) {
+                    pf.wAlignment = PFA_CENTER;
+                    pf.dwMask = pf.dwMask | PFM_ALIGNMENT;
+                } else if(strcmp(SvPV_nolen(ST(next_i)), "right") == 0) {
+                    pf.wAlignment = PFA_RIGHT;
+                    pf.dwMask = pf.dwMask | PFM_ALIGNMENT;
+                } else {
+                    if(PL_dowarn) warn("Win32::GUI:: Invalid value for -align!\n");
+                }
+            } else if(strcmp(option, "-offset") == 0) {
+                next_i = i + 1;
+                pf.dxOffset = SvIV(ST(next_i));
+                pf.dwMask = pf.dwMask | PFM_OFFSET;
+            } else if(strcmp(option, "-startindent") == 0) {
+                next_i = i + 1;
+                pf.dxStartIndent = SvIV(ST(next_i));
+                pf.dwMask = pf.dwMask | PFM_STARTINDENT;
+            } else if(strcmp(option, "-right") == 0) {
+                next_i = i + 1;
+                pf.dxRightIndent = SvIV(ST(next_i));
+                pf.dwMask = pf.dwMask | PFM_RIGHTINDENT;
+            }
+        } else {
+            next_i = -1;
+        }
+    }
+    RETVAL = SendMessage(handle, EM_SETPARAFORMAT, 0,
+                         (LPARAM) (PARAFORMAT FAR *) &pf);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:GetCharFormat([FLAG])
+void
+GetCharFormat(handle,flag=1)
+    HWND handle
+    BOOL flag
+PREINIT:
+    CHARFORMAT cf;
+    DWORD dwMask;
+    int si;
+PPCODE:
+    ZeroMemory(&cf, sizeof(CHARFORMAT));
+    cf.cbSize = sizeof(CHARFORMAT);
+    dwMask = SendMessage(
+        handle, EM_GETCHARFORMAT, (WPARAM) flag, (LPARAM) (CHARFORMAT FAR *) &cf
+    );
+    si = 0;
+    if(dwMask & CFM_BOLD) {
+        if(cf.dwEffects & CFE_BOLD) {
+            EXTEND(SP, 2);
+            XST_mPV(si++, "-bold");
+            XST_mIV(si++, 1);
+        }
+    }
+    if(dwMask & CFM_COLOR) {
+        EXTEND(SP, 2);
+        XST_mPV(si++, "-color");
+        XST_mIV(si++, (long) cf.crTextColor);
+    }
+    if(dwMask & CFM_FACE) {
+        EXTEND(SP, 2);
+        XST_mPV(si++, "-name");
+        XST_mPV(si++, cf.szFaceName);
+    }
+    if(dwMask & CFM_ITALIC) {
+        if(cf.dwEffects & CFE_ITALIC) {
+            EXTEND(SP, 2);
+            XST_mPV(si++, "-italic");
+            XST_mIV(si++, 1);
+        }
+    }
+    if(dwMask & CFM_SIZE) {
+        EXTEND(SP, 2);
+        XST_mPV(si++, "-name");
+        XST_mIV(si++, cf.yHeight);
+    }
+    if(dwMask & CFM_STRIKEOUT) {
+        if(cf.dwEffects & CFE_STRIKEOUT) {
+            EXTEND(SP, 2);
+            XST_mPV(si++, "-strikeout");
+            XST_mIV(si++, 1);
+        }
+    }
+    if(dwMask & CFM_UNDERLINE) {
+        if(cf.dwEffects & CFE_UNDERLINE) {
+            EXTEND(SP, 2);
+            XST_mPV(si++, "-underline");
+            XST_mIV(si++, 1);
+        }
+    }
+    XSRETURN(si);
+
+
+    ###########################################################################
+    # (@)METHOD:CharFromPos(X, Y)
+    # Returns a two elements array identifying the character nearest to the
+    # position specified by X and Y.
+    # The array contains the zero-based index of the character and its line
+    # index.
+void
+CharFromPos(handle,x,y)
+    HWND handle
+    int x
+    int y
+PREINIT:
+    POINT p;
+    LRESULT cfp;
+PPCODE:
+    ZeroMemory(&p, sizeof(POINT));
+    p.x = x;
+    p.y = y;
+    cfp = SendMessage(handle, EM_CHARFROMPOS, 0, (LPARAM) &p);
+    if(cfp == -1) {
+        XSRETURN_IV(-1);
+    } else {
+        EXTEND(SP, 2);
+        XST_mIV(0, LOWORD(cfp));
+        XST_mIV(1, HIWORD(cfp));
+        XSRETURN(2);
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:PosFromChar(INDEX)
+    # Returns a two elements array containing the x and y position of the
+    # specified zero-based INDEX character in the RichEdit control.
+void
+PosFromChar(handle,index)
+    HWND handle
+    LPARAM index
+PREINIT:
+    POINT p;
+CODE:
+    ZeroMemory(&p, sizeof(POINT));
+    SendMessage(handle, EM_POSFROMCHAR, (WPARAM) &p, index);
+    EXTEND(SP, 2);
+    XST_mIV(0, p.x);
+    XST_mIV(1, p.y);
+    XSRETURN(2);
+
+
+    ###########################################################################
+    # (@)METHOD:LineFromChar(INDEX)
+    # Returns the line number where the zero-based INDEX character appears.
+LRESULT
+LineFromChar(handle,index)
+    HWND handle
+    LPARAM index
+CODE:
+    RETVAL = SendMessage(handle, EM_EXLINEFROMCHAR, 0, index);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:FirstVisibleLine()
+    # Returns the first visible line in the RichEdit control.
+LRESULT
+FirstVisibleLine(handle)
+    HWND handle
+CODE:
+    RETVAL = SendMessage(handle, EM_GETFIRSTVISIBLELINE, 0, 0);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:ReplaceSel(STRING, [FLAG])
+    # Replaces the current selection with the given STRING.
+    # The optional FLAG parameter can be set to zero to tell the control that
+    # the operation cannot be undone; see also Undo().
+LRESULT
+ReplaceSel(handle,string,flag=TRUE)
+    HWND handle
+    LPCTSTR string
+    BOOL flag
+CODE:
+    RETVAL = SendMessage(handle, EM_REPLACESEL,
+                         (WPARAM) flag, (LPARAM) string);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Select(START, END)
+    # Selects the characters range from START to END.
+LRESULT
+Select(handle,start,end)
+    HWND handle
+    LONG start
+    LONG end
+PREINIT:
+    CHARRANGE cr;
+CODE:
+    ZeroMemory(&cr, sizeof(CHARRANGE));
+    cr.cpMin = start;
+    cr.cpMax = end;
+    RETVAL = SendMessage(
+        handle, EM_EXSETSEL, 0, (LPARAM) (CHARRANGE FAR *) &cr
+    );
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Selection()
+    # Returns a two elements array containing the current selection start
+    # and end.
+void
+Selection(handle)
+    HWND handle
+PREINIT:
+    CHARRANGE cr;
+PPCODE:
+    ZeroMemory(&cr, sizeof(CHARRANGE));
+    SendMessage(
+        handle, EM_EXGETSEL, 0, (LPARAM) (CHARRANGE FAR *) &cr
+    );
+    EXTEND(SP, 2);
+    XST_mIV(0, cr.cpMin);
+    XST_mIV(1, cr.cpMax);
+    XSRETURN(2);
+
+
+    ###########################################################################
+    # (@)METHOD:Save(FILENAME, [FORMAT])
+LRESULT
+Save(handle,filename,format=SF_RTF)
+    HWND handle
+    LPCTSTR filename
+    WPARAM format
+PREINIT:
+    HANDLE hfile;
+    EDITSTREAM estream;
+CODE:
+    hfile = CreateFile(
+        filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL
+    );
+    estream.dwCookie = (DWORD) hfile;
+    estream.dwError = 0;
+    estream.pfnCallback = (EDITSTREAMCALLBACK) RichEditSave;
+
+    RETVAL = SendMessage(handle, EM_STREAMOUT,
+                         format, (LPARAM) &estream);
+    CloseHandle(hfile);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Load(FILENAME, [FORMAT])
+LRESULT
+Load(handle,filename,format=SF_RTF)
+    HWND handle
+    LPCTSTR filename
+    WPARAM format
+PREINIT:
+    HANDLE hfile;
+    EDITSTREAM estream;
+CODE:
+    hfile = CreateFile(
+        filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
+    );
+    estream.dwCookie = (DWORD) hfile;
+    estream.dwError = 0;
+    estream.pfnCallback = (EDITSTREAMCALLBACK) RichEditLoad;
+
+    RETVAL = SendMessage(handle, EM_STREAMIN,
+                         format, (LPARAM) &estream);
+    CloseHandle(hfile);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:BackColor([COLOR])
+LRESULT
+BackColor(handle,color=(COLORREF) -1)
+    HWND handle
+    COLORREF color
+PREINIT:
+    WPARAM flag;
+CODE:
+    if(color < 0) {
+        color = 0;
+        flag = 1;
+    } else {
+        flag = 0;
+    }
+    RETVAL = SendMessage(handle, EM_SETBKGNDCOLOR, flag, (LPARAM) color);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:TextLength()
+    # Returns the text length of the RichEdit control
+LRESULT
+TextLength(handle)
+    HWND handle
+PREINIT:
+    GETTEXTLENGTHEX tl;
+CODE:
+    ZeroMemory(&tl, sizeof(GETTEXTLENGTHEX));
+    tl.flags = GTL_DEFAULT;
+    tl.codepage = CP_ACP;
+    RETVAL = SendMessage(
+        handle, EM_GETTEXTLENGTHEX, (WPARAM) (GETTEXTLENGTHEX FAR *) &tl, 0
+    );
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:SetTextMode(MODE, UNDO)
+    # Sets the RichEdit control's text mode
+LRESULT
+SetTextMode(handle,mode,undo)
+    HWND handle
+    int mode
+    int undo
+PREINIT:
+    WPARAM wParam;
+CODE:
+    wParam = 0;
+	wParam |= (mode ? TM_RICHTEXT : TM_PLAINTEXT);
+	wParam |= (undo ? TM_MULTILEVELUNDO : TM_SINGLELEVELUNDO);
+
+    RETVAL = SendMessage(
+        handle, EM_SETTEXTMODE, (WPARAM) wParam, 0
+    );
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:SetMaxLength(LENGTH)
+    # Sets the RichEdit control's maximum length (up to 2GB)
+LRESULT
+SetMaxLength(handle,length)
+    HWND handle
+    long length
+CODE:
+    RETVAL = SendMessage(
+        handle, EM_EXLIMITTEXT, 0, (LPARAM) length
+    );
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetTextRange(START, LENGTH)
+    # Returns LENGTH bytes of text from the RichEdit control, starting at START
+void
+GetTextRange(handle,start,length)
+    HWND handle
+    LONG start
+    LONG length
+PREINIT:
+    TEXTRANGE tr;
+    CHARRANGE cr;
+    char * text;
+    LRESULT count;
+PPCODE:
+    ZeroMemory(&tr, sizeof(TEXTRANGE));
+    ZeroMemory(&cr, sizeof(CHARRANGE));
+    if(length < 0) length = 0;
+    if(start < 0) start = 0;
+    text = (char *) safemalloc(length+1);
+    cr.cpMin = start;
+    cr.cpMax = start+length;
+    tr.chrg = cr;
+    tr.lpstrText = text;
+    count = SendMessage(handle, EM_GETTEXTRANGE, 0, (LPARAM) (TEXTRANGE FAR *) &tr);
+    EXTEND(SP, 1);
+    XST_mPV(0, text);
+    safefree(text);
+    XSRETURN(1);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/Splitter.xs perl-libwin32-0.191/GUI/Splitter.xs
--- libwin32-0.191/GUI/Splitter.xs	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/Splitter.xs	2004-01-12 16:46:40.171875000 -0800
@@ -0,0 +1,151 @@
+
+	/*
+	###########################################################################
+    # (@)PACKAGE:Win32::GUI::Splitter
+    ###########################################################################
+	*/
+
+#include "GUI.h"
+
+BOOL
+Splitter_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs) {
+	BOOL retval;
+	SV* storing;
+	SV** stored;
+	retval = FALSE;
+	if(strcmp(option, "-horizontal") == 0) {
+		retval = TRUE;
+		if(SvIV(value)) {
+			perlcs->cs.lpszClass = "Win32::GUI::Splitter(horizontal)";
+		} else {
+			perlcs->cs.lpszClass = "Win32::GUI::Splitter(vertical)";
+		}
+		SwitchBit(perlcs->dwPlStyle, PERLWIN32GUI_HORIZONTAL, SvIV(value));
+	} else if(strcmp(option, "-min") == 0) {
+		retval = TRUE;
+		storing = newSViv((LONG) SvIV(value));
+		stored = hv_store_mg(NOTXSCALL perlcs->hvSelf, "-min", 4, storing, 0);
+		perlcs->iMinWidth = SvIV(value);
+	} else if(strcmp(option, "-max") == 0) {
+		retval = TRUE;
+		storing = newSViv((LONG) SvIV(value));
+		stored = hv_store_mg(NOTXSCALL perlcs->hvSelf, "-max", 4, storing, 0);
+		perlcs->iMaxWidth = SvIV(value);
+	} else if(strcmp(option, "-range") == 0) {
+		retval = TRUE;
+		if(SvROK(value) && SvTYPE(SvRV(value)) == SVt_PVAV) {
+			SV** t;
+			t = av_fetch((AV*)SvRV(value), 0, 0);
+			if(t != NULL) {
+				storing = newSViv((LONG) SvIV(*t));
+				stored = hv_store_mg(NOTXSCALL perlcs->hvSelf, "-min", 4, storing, 0);
+				perlcs->iMinWidth = SvIV(*t);
+			}
+			t = av_fetch((AV*)SvRV(value), 1, 0);
+			if(t != NULL) {
+				storing = newSViv((LONG) SvIV(*t));
+				stored = hv_store_mg(NOTXSCALL perlcs->hvSelf, "-max", 4, storing, 0);
+				perlcs->iMaxWidth = SvIV(*t);
+			}
+		} else {
+			if(PL_dowarn)
+				warn("Win32::GUI: Argument to -range is not an array reference!");
+		}
+	}
+	return retval;
+}
+
+
+MODULE = Win32::GUI::Splitter		PACKAGE = Win32::GUI::Splitter
+
+PROTOTYPES: DISABLE
+
+
+void
+Min(handle,...)
+    HWND handle
+PREINIT:
+    LPPERLWIN32GUI_USERDATA perlud;
+PPCODE:
+    if(items > 2) {
+        CROAK("Usage: Min(handle, [value]);\n");
+    }
+	perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(handle, GWL_USERDATA);
+	if( ValidUserData(perlud) ) {
+		if(items == 1) {
+			XSRETURN_IV(perlud->iMinWidth);
+		} else {
+			perlud->iMinWidth = SvIV(ST(1));
+			XSRETURN_YES;
+		}
+	} else {
+		XSRETURN_UNDEF;
+	}
+
+
+void
+Max(handle,...)
+    HWND handle
+PREINIT:
+    LPPERLWIN32GUI_USERDATA perlud;
+PPCODE:
+    if(items > 2) {
+        CROAK("Usage: Max(handle, [value]);\n");
+    }
+	perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(handle, GWL_USERDATA);
+	if( ValidUserData(perlud) ) {
+		if(items == 1) {
+			XSRETURN_IV(perlud->iMaxWidth);
+		} else {
+			perlud->iMaxWidth = SvIV(ST(1));
+			XSRETURN_YES;
+		}
+	} else {
+		XSRETURN_UNDEF;
+	}
+
+
+void
+Horizontal(handle,...)
+    HWND handle
+PREINIT:
+    LPPERLWIN32GUI_USERDATA perlud;
+PPCODE:
+    if(items > 2) {
+        CROAK("Usage: Horizontal(handle, [value]);\n");
+    }
+	perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(handle, GWL_USERDATA);
+	if( ValidUserData(perlud) ) {
+		if(items == 1) {
+			XSRETURN_IV(perlud->dwPlStyle & PERLWIN32GUI_HORIZONTAL);
+		} else {
+			SwitchBit(perlud->dwPlStyle, PERLWIN32GUI_HORIZONTAL, SvIV(ST(1)));
+			SetWindowLong(handle, GWL_USERDATA, (LONG) perlud);
+			XSRETURN_YES;
+		}
+	} else {
+		XSRETURN_UNDEF;
+	}
+
+
+void
+Vertical(handle,...)
+    HWND handle
+PREINIT:
+    LPPERLWIN32GUI_USERDATA perlud;
+PPCODE:
+    if(items > 2) {
+        CROAK("Usage: Vertical(handle, [value]);\n");
+    }
+	perlud = (LPPERLWIN32GUI_USERDATA) GetWindowLong(handle, GWL_USERDATA);
+	if( ValidUserData(perlud) ) {
+		if(items == 1) {
+			XSRETURN_IV(!(perlud->dwPlStyle & PERLWIN32GUI_HORIZONTAL));
+		} else {
+			SwitchBit(perlud->dwPlStyle, PERLWIN32GUI_HORIZONTAL, !SvIV(ST(1)));
+			SetWindowLong(handle, GWL_USERDATA, (LONG) perlud);
+			XSRETURN_YES;
+		}
+	} else {
+		XSRETURN_UNDEF;
+	}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/TODO perl-libwin32-0.191/GUI/TODO
--- libwin32-0.191/GUI/TODO	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/TODO	2004-01-12 16:46:40.187500000 -0800
@@ -0,0 +1,11 @@
+
+- move menu functions to a separate package
+- expand support for GDI drawing
+- refine event processing
+
+- implement MDI windows
+- evtl. support for owner drawn controls
+
+- write the documentation
+
+- also search for "TODO" in the GUI.xs file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/TabStrip.xs perl-libwin32-0.191/GUI/TabStrip.xs
--- libwin32-0.191/GUI/TabStrip.xs	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/TabStrip.xs	2004-01-12 16:46:40.203125000 -0800
@@ -0,0 +1,300 @@
+
+#include "GUI.h"
+
+	/*
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::TabStrip
+	#
+	# $Id: TabStrip.xs,v 1.3 2003/12/28 07:17:43 caelum Exp $
+	#
+    ###########################################################################
+	*/
+
+BOOL
+TabStrip_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs) {
+	BOOL retval;
+	retval = FALSE;
+	if(strcmp(option, "-imagelist") == 0) {
+		retval = TRUE;
+		perlcs->hImageList = (HIMAGELIST) handle_From(NOTXSCALL value);
+	} else if(strcmp(option, "-vertical") == 0) {
+		retval = TRUE;
+		SwitchBit(perlcs->cs.style, TCS_VERTICAL, SvIV(value));
+		SwitchBit(perlcs->cs.style, TCS_MULTILINE, SvIV(value));
+	} else BitmaskOptionValue("-multiline",  perlcs->cs.style, TCS_MULTILINE)
+	} else BitmaskOptionValue("-bottom",     perlcs->cs.style, TCS_BOTTOM)
+	} else BitmaskOptionValue("-alignright", perlcs->cs.style, TCS_RIGHT)
+	} else BitmaskOptionValue("-hottrack",   perlcs->cs.style, TCS_HOTTRACK)
+	} else BitmaskOptionValue("-buttons",    perlcs->cs.style, TCS_BUTTONS)
+	} else BitmaskOptionValue("-justify",    perlcs->cs.style, TCS_RIGHTJUSTIFY)
+	} else BitmaskOptionValue("-flat",       perlcs->cs.style, TCS_FLATBUTTONS)
+	}
+	return retval;
+}
+
+void
+TabStrip_onPostCreate(NOTXSPROC HWND myhandle, LPPERLWIN32GUI_CREATESTRUCT perlcs) {
+	if(perlcs->hImageList != NULL)
+		TabCtrl_SetImageList(myhandle, perlcs->hImageList);
+}
+
+
+MODULE = Win32::GUI::TabStrip		PACKAGE = Win32::GUI::TabStrip
+
+PROTOTYPES: ENABLE
+
+    ###########################################################################
+    # (@)METHOD:InsertItem(%OPTIONS)
+    # Adds an item to the TabStrip.
+    # Allowed %OPTIONS are:
+    #  -image => NUMBER
+    #    the index of an image from the associated ImageList
+    #  -index => NUMBER
+    #    the position for the new item (if not specified, the item
+    #    is added at the end of the control)
+    #  -text  => STRING
+    #    the text that will appear on the item
+int
+InsertItem(handle,...)
+    HWND handle
+PREINIT:
+    TC_ITEM Item;
+    int iIndex;
+    unsigned int chText;
+    int i, next_i;
+CODE:
+    ZeroMemory(&Item, sizeof(TC_ITEM));
+    iIndex = TabCtrl_GetItemCount(handle)+1;
+    next_i = -1;
+    for(i = 1; i < items; i++) {
+        if(next_i == -1) {
+            if(strcmp(SvPV_nolen(ST(i)), "-image") == 0) {
+                next_i = i + 1;
+                Item.mask = Item.mask | TCIF_IMAGE;
+                Item.iImage = SvIV(ST(next_i));
+            }
+            if(strcmp(SvPV_nolen(ST(i)), "-index") == 0) {
+                next_i = i + 1;
+                iIndex = (int) SvIV(ST(next_i));
+            }
+            if(strcmp(SvPV_nolen(ST(i)), "-text") == 0) {
+                next_i = i + 1;
+                Item.pszText = SvPV(ST(next_i), chText);
+                Item.cchTextMax = (int) chText;
+                Item.mask = Item.mask | TCIF_TEXT;
+            }
+        } else {
+            next_i = -1;
+        }
+    }
+    RETVAL = TabCtrl_InsertItem(handle, iIndex, &Item);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:ChangeItem(ITEM, %OPTIONS)
+    # Change most of the options used when the item was created
+    # (see InsertItem()).
+    # Allowed %OPTIONS are:
+    #     -image
+    #     -text
+BOOL
+ChangeItem(handle,item,...)
+    HWND handle
+    int item
+PREINIT:
+    TC_ITEM Item;
+    unsigned int chText;
+    int i, next_i;
+CODE:
+    ZeroMemory(&Item, sizeof(TC_ITEM));
+    next_i = -1;
+    for(i = 2; i < items; i++) {
+        if(next_i == -1) {
+            if(strcmp(SvPV_nolen(ST(i)), "-image") == 0) {
+                next_i = i + 1;
+                Item.mask = Item.mask | TCIF_IMAGE;
+                Item.iImage = SvIV(ST(next_i));
+            }
+            if(strcmp(SvPV_nolen(ST(i)), "-text") == 0) {
+                next_i = i + 1;
+                Item.pszText = SvPV(ST(next_i), chText);
+                Item.cchTextMax = (int) chText;
+                Item.mask = Item.mask | TCIF_TEXT;
+            }
+        } else {
+            next_i = -1;
+        }
+    }
+    RETVAL = TabCtrl_SetItem(handle, item, &Item);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Count()
+    # Returns the number of items in the TabStrip.
+int
+Count(handle)
+    HWND handle
+CODE:
+    RETVAL = TabCtrl_GetItemCount(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Reset()
+    # Deletes all items from the TabStrip.
+BOOL
+Reset(handle)
+    HWND handle
+CODE:
+    RETVAL = TabCtrl_DeleteAllItems(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:DeleteItem(ITEM)
+    # Removes the specified ITEM from the TabStrip.
+BOOL
+DeleteItem(handle,item)
+    HWND handle
+    int item
+CODE:
+    RETVAL = TabCtrl_DeleteItem(handle, item);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetString(ITEM)
+    # Returns the string associated with the specified ITEM in the TabStrip.
+void
+GetString(handle,item)
+    HWND handle
+    int item
+PREINIT:
+    char *szString;
+    TC_ITEM tcItem;
+PPCODE:
+    szString = (char *) safemalloc(1024);
+    tcItem.pszText = szString;
+    tcItem.cchTextMax = 1024;
+    tcItem.mask = TCIF_TEXT;
+    if(TabCtrl_GetItem(handle, item, &tcItem)) {
+        EXTEND(SP, 1);
+        XST_mPV(0, szString);
+        safefree(szString);
+        XSRETURN(1);
+    } else {
+        safefree(szString);
+        XSRETURN_UNDEF;
+    }
+
+
+      ################################################
+	  # (@)METHOD:AdjustRect(LEFT, TOP, RIGHT, BOTTOM, [FLAG])
+void
+AdjustRect(handle,left,top,right,bottom,flag=0)
+    HWND handle
+    int left
+    int top
+    int right
+    int bottom
+    BOOL flag
+PREINIT:
+    RECT myRect;
+PPCODE:
+    myRect.left   = left;
+    myRect.top    = top;
+    myRect.right  = right;
+    myRect.bottom = bottom;
+    TabCtrl_AdjustRect(handle, flag, &myRect);
+    EXTEND(SP, 4);
+    XST_mIV(0, myRect.left);
+    XST_mIV(1, myRect.top);
+    XST_mIV(2, myRect.right);
+    XST_mIV(3, myRect.bottom);
+    XSRETURN(4);
+
+      ################################################
+      # (@)METHOD:Padding(X,Y)
+void
+Padding(handle,x,y)
+	HWND handle
+	int x
+	int y
+CODE:
+	TabCtrl_SetPadding(handle, x, y);
+
+
+      ################################################
+      # (@)METHOD:MinTabWidth(WIDTH)
+int
+MinTabWidth(handle,width)
+	HWND handle
+	int width
+CODE:
+	RETVAL = TabCtrl_SetMinTabWidth(handle, width);
+OUTPUT:
+	RETVAL
+
+
+      ################################################
+      # (@)METHOD:RowCount()
+int
+RowCount(handle)
+	HWND handle
+CODE:
+	RETVAL = TabCtrl_GetRowCount(handle);
+OUTPUT:
+	RETVAL
+
+
+      ################################################
+      # (@)METHOD:HitTest()
+void
+HitTest(handle,x,y)
+	HWND handle
+	int x
+	int y
+PREINIT:
+	TCHITTESTINFO ht;
+	int index;
+PPCODE:
+	ZeroMemory(&ht, sizeof(TCHITTESTINFO));
+	ht.pt.x = x;
+	ht.pt.y = y;
+	index = TabCtrl_HitTest(handle, &ht);
+	if(GIMME == G_ARRAY) {
+		EXTEND(SP, 2);
+		XST_mIV(0, index);
+		XST_mIV(1, ht.flags);
+		XSRETURN(2);
+	} else {
+		XSRETURN_IV(index);
+	}
+
+      ################################################
+      # (@)METHOD:GetItemRect()
+void
+GetItemRect(handle,index)
+	HWND handle
+	int index
+PREINIT:
+	RECT myRect;
+PPCODE:
+	ZeroMemory(&myRect, sizeof(RECT));
+	if(TabCtrl_GetItemRect(handle, index, &myRect)) {
+		EXTEND(SP, 4);
+		XST_mIV(0, myRect.left);
+		XST_mIV(1, myRect.top);
+		XST_mIV(2, myRect.right);
+		XST_mIV(3, myRect.bottom);
+		XSRETURN(4);
+	} else {
+		XSRETURN_UNDEF;
+	}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/Textfield.xs perl-libwin32-0.191/GUI/Textfield.xs
--- libwin32-0.191/GUI/Textfield.xs	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/Textfield.xs	2004-01-12 16:46:40.218750000 -0800
@@ -0,0 +1,250 @@
+
+#include "GUI.h"
+
+	/*
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::Textfield
+	#
+	# $Id: Textfield.xs,v 1.3 2003/12/28 07:17:43 caelum Exp $
+	#
+    ###########################################################################
+	*/
+
+BOOL
+Textfield_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs) {
+	BOOL retval;
+	retval = FALSE;
+	if(strcmp(option, "-align") == 0) {
+		retval = TRUE;
+		if(strcmp(SvPV_nolen(value), "left") == 0) {
+			SwitchBit(perlcs->cs.style, ES_LEFT, 1);
+			SwitchBit(perlcs->cs.style, ES_CENTER, 0);
+			SwitchBit(perlcs->cs.style, ES_RIGHT, 0);
+		} else if(strcmp(SvPV_nolen(value), "center") == 0) {
+			SwitchBit(perlcs->cs.style, ES_LEFT, 0);
+			SwitchBit(perlcs->cs.style, ES_CENTER, 1);
+			SwitchBit(perlcs->cs.style, ES_RIGHT, 0);
+		} else if(strcmp(SvPV_nolen(value), "right") == 0) {
+			SwitchBit(perlcs->cs.style, ES_LEFT, 0);
+			SwitchBit(perlcs->cs.style, ES_CENTER, 0);
+			SwitchBit(perlcs->cs.style, ES_RIGHT, 1);
+		} else {
+			if(PL_dowarn) warn("Win32::GUI: Invalid value for -align!");
+		}
+	} else if(strcmp(option, "-multiline") == 0) {
+		retval = TRUE;
+		if(SvIV(value)) {
+			SwitchBit(perlcs->cs.style, ES_MULTILINE, 1);
+			SwitchBit(perlcs->cs.style, ES_AUTOHSCROLL, 0);
+		} else {
+			SwitchBit(perlcs->cs.style, ES_MULTILINE, 0);
+			SwitchBit(perlcs->cs.style, ES_AUTOHSCROLL, 1);
+		}
+	} else BitmaskOptionValue("-keepselection", perlcs->cs.style, ES_NOHIDESEL)
+	} else BitmaskOptionValue("-readonly",      perlcs->cs.style, ES_READONLY)
+	} else BitmaskOptionValue("-password",      perlcs->cs.style, ES_PASSWORD)
+	} else BitmaskOptionValue("-lowercase",     perlcs->cs.style, ES_LOWERCASE)
+	} else BitmaskOptionValue("-uppercase",     perlcs->cs.style, ES_UPPERCASE)
+	} else BitmaskOptionValue("-autohscroll",   perlcs->cs.style, ES_AUTOHSCROLL)
+	} else BitmaskOptionValue("-autovscroll",   perlcs->cs.style, ES_AUTOVSCROLL)
+	} else BitmaskOptionValue("-number",        perlcs->cs.style, ES_NUMBER)
+	}
+	return retval;
+}
+
+
+/*
+	###########################################################################
+    # (@)PACKAGE:Win32::GUI::Textfield
+    ###########################################################################
+*/
+
+MODULE = Win32::GUI::Textfield     PACKAGE = Win32::GUI::Textfield
+
+PROTOTYPES: ENABLE
+
+    ###########################################################################
+    # (@)METHOD:ReplaceSel(STRING, [FLAG])
+LRESULT
+ReplaceSel(handle,string,flag=TRUE)
+    HWND handle
+    LPCTSTR string
+    BOOL flag
+CODE:
+    RETVAL = SendMessage(
+        handle, EM_REPLACESEL, (WPARAM) flag, (LPARAM) string
+    );
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:ReadOnly([FLAG])
+BOOL
+ReadOnly(handle,...)
+    HWND handle
+CODE:
+    if(items > 1)
+        RETVAL = SendMessage(
+            handle, EM_SETREADONLY, (WPARAM) (BOOL) SvIV(ST(1)), 0
+        );
+    else
+        RETVAL = (GetWindowLong(handle, GWL_STYLE) & ES_READONLY);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Modified([FLAG])
+BOOL
+Modified(handle,...)
+    HWND handle
+CODE:
+    if(items > 1)
+        RETVAL = SendMessage(
+            handle, EM_SETMODIFY, (WPARAM) (UINT) SvIV(ST(1)), 0
+        );
+    else
+        RETVAL = SendMessage(handle, EM_GETMODIFY, 0, 0);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Undo()
+BOOL
+Undo(handle)
+    HWND handle
+CODE:
+    if (SendMessage(handle, EM_CANUNDO, 0, 0))
+        RETVAL = SendMessage(handle, EM_UNDO, 0, 0);
+    else
+        RETVAL = 0;
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:LineFromChar(INDEX)
+LRESULT
+LineFromChar(handle,index)
+    HWND handle
+    WPARAM index
+CODE:
+    RETVAL = SendMessage(handle, EM_EXLINEFROMCHAR, index, 0);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:PasswordChar([CHAR])
+LRESULT
+PasswordChar(handle,passchar=0)
+    HWND handle
+    UINT passchar
+CODE:
+    if(items == 1) {
+        RETVAL = SendMessage(handle, EM_GETPASSWORDCHAR, 0, 0);
+    } else {
+        RETVAL = SendMessage(handle, EM_SETPASSWORDCHAR, (WPARAM) passchar, 0);
+    }
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Selection()
+void
+Selection(handle)
+    HWND handle
+PREINIT:
+    DWORD start;
+    DWORD end;
+PPCODE:
+    SendMessage(
+        handle, EM_GETSEL, (WPARAM) &start, (LPARAM) &end
+    );
+    EXTEND(SP, 2);
+    XST_mIV(0, (long) start);
+    XST_mIV(1, (long) end);
+    XSRETURN(2);
+
+
+    ###########################################################################
+    # (@)METHOD:Scroll(COMMAND | LINE | HORIZONTAL, VERTICAL)
+LRESULT
+Scroll(handle, line, otherdirection=0)
+    SV* handle
+    SV* line
+    DWORD otherdirection
+PREINIT:
+	HWND hwnd;
+    WPARAM wparam;
+    char *arg;
+CODE:
+	hwnd = handle_From(NOTXSCALL handle);
+	if(items == 2) {
+		if(SvPOK(line)) {
+			arg = strlwr( SvPV_nolen(line) );
+
+			if(0 == strcmp( arg, "bottom" )) {
+				RETVAL = SendMessage( hwnd, EM_GETLINECOUNT, 0, 0 );
+				wparam = RETVAL;
+				RETVAL = SendMessage( hwnd, EM_GETFIRSTVISIBLELINE, 0, 0);
+				wparam -= RETVAL;
+				RETVAL = SendMessage( hwnd, EM_LINESCROLL, 0, wparam);
+			} else if(0 == strcmp( arg, "top" )) {
+				wparam = SendMessage( hwnd, EM_GETFIRSTVISIBLELINE, 0, 0);
+				RETVAL = SendMessage( hwnd, EM_LINESCROLL, 0, -wparam);
+			} else {
+				if(0 == strcmp( arg, "up" )) {
+					wparam = SB_LINEUP;
+				} else if(0 == strcmp( arg, "down" )
+				||        0 == strcmp( arg, "dn" )) {
+					wparam = SB_LINEDOWN;
+				} else if(0 == strcmp( arg, "pageup" )
+				||        0 == strcmp( arg, "pgup" )) {
+					wparam = SB_PAGEUP;
+				} else if(0 == strcmp( arg, "pagedown" )
+				||        0 == strcmp( arg, "pagedn" )
+				||        0 == strcmp( arg, "pgdown" )
+				||        0 == strcmp( arg, "pgdn")) {
+					wparam = SB_PAGEDOWN;
+				}
+				RETVAL = SendMessage(
+					hwnd, EM_SCROLL, (WPARAM) wparam, (LPARAM) 0
+				);
+			}
+		} else {
+			RETVAL = SendMessage(
+				hwnd, EM_LINESCROLL, 0, (WPARAM) SvIV(line)
+			);
+		}
+	} else {
+		if(sv_derived_from(handle, "Win32::GUI::RichEdit")) {
+			RETVAL = SendMessage(
+				hwnd, EM_LINESCROLL, 0, (WPARAM) otherdirection
+			);
+		} else {
+			RETVAL = SendMessage(
+				hwnd, EM_LINESCROLL, (LPARAM) SvIV(line), (WPARAM) otherdirection
+			);
+		}
+	}
+	SendMessage( hwnd , EM_SCROLLCARET, 0, 0);
+OUTPUT:
+	RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Append(TEXT)
+void
+Append(handle, text)
+    HWND handle
+    char * text
+PREINIT:
+	int length;
+CODE:
+	length = GetWindowTextLength(handle);
+	SendMessage(handle, EM_SETSEL, length, length);
+	SendMessage(handle, EM_REPLACESEL, (WPARAM) TRUE, (LPARAM) text);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/Toolbar.xs perl-libwin32-0.191/GUI/Toolbar.xs
--- libwin32-0.191/GUI/Toolbar.xs	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/Toolbar.xs	2004-01-12 16:46:40.234375000 -0800
@@ -0,0 +1,289 @@
+
+#include "GUI.h"
+
+	/*
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::Toolbar
+	#
+	# $Id: Toolbar.xs,v 1.3 2003/12/28 07:17:43 caelum Exp $
+	#
+    ###########################################################################
+	*/
+
+
+BOOL
+Toolbar_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs) {
+	BOOL retval;
+	retval = FALSE;
+	if(strcmp(option, "-imagelist") == 0) {
+		retval = TRUE;
+		perlcs->hImageList = (HIMAGELIST) handle_From(NOTXSCALL value);
+	} else BitmaskOptionValue("-flat", perlcs->cs.style, TBSTYLE_FLAT)
+	} else BitmaskOptionValue("-nodivider", perlcs->cs.style, CCS_NODIVIDER)
+	} else BitmaskOptionValue("-multiline", perlcs->cs.style, TBSTYLE_WRAPABLE)
+	}
+	return retval;
+}
+
+void
+Toolbar_onPostCreate(NOTXSPROC HWND myhandle, LPPERLWIN32GUI_CREATESTRUCT perlcs) {
+	SendMessage(myhandle, TB_BUTTONSTRUCTSIZE, (WPARAM) sizeof(TBBUTTON), 0);
+	/* SendMessage(myhandle, TB_SETIMAGELIST, 0, (LPARAM) perlcs->hImageList); */
+}
+
+MODULE = Win32::GUI::Toolbar     PACKAGE = Win32::GUI::Toolbar
+
+PROTOTYPES: ENABLE
+
+    ###########################################################################
+    # (@)METHOD:AddBitmap(BITMAP, NUMBUTTONS)
+LRESULT
+AddBitmap(handle,bitmap,numbuttons)
+    HWND handle
+    HBITMAP bitmap
+    WPARAM numbuttons
+PREINIT:
+    TBADDBITMAP TbAddBitmap;
+CODE:
+    TbAddBitmap.hInst = (HINSTANCE) NULL;
+    TbAddBitmap.nID = (UINT) bitmap;
+
+    RETVAL = SendMessage(handle, TB_ADDBITMAP, numbuttons,
+                         (LPARAM) (LPTBADDBITMAP) &TbAddBitmap);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:AddString(STRING)
+LRESULT
+AddString(handle,string)
+    HWND handle
+    char * string
+PREINIT:
+    char *Strings;
+    unsigned int szLen, totLen;
+CODE:
+    totLen = 0;
+    #    // the function should accept an array of strings,
+    #    // but actually doesn't work...
+    #
+    #    for(i = 1; i < items; i++) {
+    #        Strings = SvPV(ST(i), szLen);
+    #        __DEBUG("AddString: szLen(%d) = %d\n", i, szLen);
+    #        totLen += szLen+1;
+    #    }
+    #    totLen++;
+    #    __DEBUG("AddString: totLen = %d\n", totLen);
+    #    Strings = (char *) safemalloc(totLen);
+    #
+    #    totLen = 0;
+    #    char *tmpStrings = Strings;
+    #    for(i = 1; i < items; i++) {
+    #        strcat(tmpStrings, SvPV(ST(i), szLen));
+    #        totLen += szLen+1;
+    #
+    #    }
+    #    Strings[totLen++] = '\0';
+    // only one string allowed
+    Strings = SvPV(ST(1), szLen);
+    Strings = (char *) safemalloc(szLen+2);
+    strcpy(Strings, string);
+    Strings[szLen+1] = '\0';
+#ifdef PERLWIN32GUI_DEBUG
+	printf("XS(Toolbar::AddString): Strings='%s', len=%d\n", Strings, szLen);
+#endif
+	#	#ifdef PERLWIN32GUI_DEBUG
+	#		for(i=0; i<=szLen+1; i++) {
+	#			printf("XS(Toolbar::AddString): Strings[%d]='%d'\n", i, Strings[i]);
+	#		}
+	#	#endif
+#ifdef PERLWIN32GUI_DEBUG
+	printf("XS(Toolbar::AddString): handle=0x%x\n", handle);
+	printf("XS(Toolbar::AddString): Strings=0x%x\n", Strings);
+#endif
+    RETVAL = SendMessage(handle, TB_ADDSTRING, 0, (LPARAM) Strings);
+#ifdef PERLWIN32GUI_DEBUG
+	printf("XS(Toolbar::AddString): SendMessage.result=%ld", RETVAL);
+#endif
+    safefree(Strings);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:AddButtons(NUMBER, ...)
+LRESULT
+AddButtons(handle,number,...)
+    HWND handle
+    UINT number
+PREINIT:
+    LPTBBUTTON buttons;
+    int i, q, b;
+CODE:
+    if(items != 2 + number * 5) {
+        CROAK("AddButtons: wrong number of parameters (expected %d, got %d)!\n", 2+number*5, items);
+    }
+    buttons = (LPTBBUTTON) safemalloc(sizeof(TBBUTTON)*number);
+    q = 0;
+    b = 0;
+    for(i = 2; i < items; i++) {
+        switch(q) {
+        case 0:
+            buttons[b].iBitmap = (int) SvIV(ST(i));
+            break;
+        case 1:
+            buttons[b].idCommand = (int) SvIV(ST(i));
+            break;
+        case 2:
+            buttons[b].fsState = (BYTE) SvIV(ST(i));
+            break;
+        case 3:
+            buttons[b].fsStyle = (BYTE) SvIV(ST(i));
+            break;
+        case 4:
+            buttons[b].iString = (int) SvIV(ST(i));
+        }
+        q++;
+        if(q == 5) {
+            buttons[b].dwData = 0;
+            q = 0;
+            b++;
+        }
+    }
+    RETVAL = SendMessage(handle, TB_ADDBUTTONS,
+                         (WPARAM) number,
+                         (LPARAM) (LPTBBUTTON) buttons);
+    safefree(buttons);
+OUTPUT:
+    RETVAL
+
+    # LRESULT
+    # AddButton(handle,...)
+    #     HWND handle
+    # PREINIT:
+    #     TBBUTTON button;
+    #     TBBUTTONINFO buttoninfo;
+    #     int i, next_i;
+    #     char *option;
+    # CODE:
+    #     ZeroMemory(&button, sizeof(TBBUTTON));
+    #     ZeroMemory(&buttoninfo, sizeof(TBBUTTONINFO));
+    #     buttoninfo.cbSize = sizeof(TBBUTTONINFO);
+    #     next_i = -1;
+    #     for(i = 2; i < items; i++) {
+    #         if(next_i == -1) {
+    #             option = SvPV_nolen(ST(i));
+    #             if(strcmp(option, "-image") == 0) {
+    #                 next_i = i + 1;
+    #                 button.iBitmap = SvIV(ST(next_i));
+    #             } else
+    #             if(strcmp(option, "-text") == 0) {
+    #                 next_i = i + 1;
+    #                 buttoninfo.dwMask |= TBIF_TEXT;
+    #                 buttoninfo.pszText = SvPV_nolen(ST(next_i));
+    #             }
+    #             // to implement: -style, -state, -id(?)
+    #         } else {
+    #             next_i = -1;
+    #         }
+    #     }
+    #     RETVAL = FALSE;
+    #     # SendMessage(handle, TB_SETBUTTONINFO, (WPARAM) &buttoninfo, 0);
+    #     # RETVAL = TabCtrl_SetItem(handle, item, &Item);
+    # OUTPUT:
+    #     RETVAL
+
+
+    ###########################################################################
+    # (@)INTERNAL:ButtonStructSize()
+    # initializes the toolbar button structure size
+LRESULT
+ButtonStructSize(handle)
+    HWND handle
+CODE:
+    RETVAL = SendMessage(handle, TB_BUTTONSTRUCTSIZE,
+                         (WPARAM) sizeof(TBBUTTON), 0);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:ButtonCount()
+    # returns the number of buttons in the toolbar
+LRESULT
+ButtonCount(handle)
+    HWND handle
+CODE:
+    RETVAL = SendMessage(handle, TB_BUTTONCOUNT, 0, 0);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:Padding([X], [Y])
+    # gets or sets the padding for the toolbar;
+    # if no value is passed, returns a list containing the current x and y
+    # padding value, in pixels.
+void
+Padding(handle,x=-1,y=-1)
+    HWND handle
+    int x
+    int y
+PREINIT:
+	LRESULT pad;
+PPCODE:
+	if(items == 1) {
+		pad = SendMessage(handle, TB_GETPADDING, 0, 0);
+		EXTEND(SP, 2);
+		XST_mIV(0, LOWORD(pad));
+		XST_mIV(1, HIWORD(pad));
+		XSRETURN(2);
+	} else {
+		if(items == 2) y = x;
+		XSRETURN_IV( SendMessage(handle, TB_SETPADDING, 0, MAKELPARAM(x, y)) );
+	}
+
+    ###########################################################################
+    # (@)METHOD:Indent(VALUE)
+    # sets the indentation value for the toolbar
+LRESULT
+Indent(handle,value)
+    HWND handle
+    int value
+CODE:
+	RETVAL = SendMessage(handle, TB_SETINDENT, (WPARAM) value, 0);
+OUTPUT:
+	RETVAL
+
+    ###########################################################################
+    # (@)METHOD:AutoSize()
+    # causes the toolbar to be resized
+LRESULT
+AutoSize(handle)
+    HWND handle
+CODE:
+	RETVAL = SendMessage(handle, TB_AUTOSIZE, 0, 0);
+OUTPUT:
+	RETVAL
+
+    ###########################################################################
+    # (@)METHOD:MaxSize()
+    # returns the total size of all the visible buttons and separators in the
+    # toolbar (or undef on errors)
+void
+MaxSize(handle)
+    HWND handle
+PREINIT:
+	SIZE size;
+PPCODE:
+	if( SendMessage(handle, TB_GETMAXSIZE, 0, (LPARAM) &size) ) {
+		EXTEND(SP, 2);
+		XST_mIV(0, size.cx);
+		XST_mIV(1, size.cy);
+		XSRETURN(2);
+	} else {
+		XSRETURN_UNDEF;
+	}
+
+
+	# TODO: Rows,
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/TreeView.xs perl-libwin32-0.191/GUI/TreeView.xs
--- libwin32-0.191/GUI/TreeView.xs	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/TreeView.xs	2004-01-12 16:46:40.250000000 -0800
@@ -0,0 +1,626 @@
+	/*
+    ###########################################################################
+    # (@)PACKAGE:Win32::GUI::TreeView
+    #
+    # $Id: TreeView.xs,v 1.3 2003/12/28 07:17:43 caelum Exp $
+    #
+    ###########################################################################
+	*/
+
+#include "GUI.h"
+
+BOOL
+TreeView_onParseOption(NOTXSPROC char *option, SV* value, LPPERLWIN32GUI_CREATESTRUCT perlcs) {
+	BOOL retval;
+	retval = FALSE;
+	BitmaskOptionValue("-lines", perlcs->cs.style, TVS_HASLINES)
+	} else BitmaskOptionValue("-rootlines", perlcs->cs.style, TVS_LINESATROOT)
+	} else BitmaskOptionValue("-buttons", perlcs->cs.style, TVS_HASBUTTONS)
+	} else BitmaskOptionValue("-showselalways", perlcs->cs.style, TVS_SHOWSELALWAYS)
+	} else BitmaskOptionValue("-checkboxes", perlcs->cs.style, TVS_CHECKBOXES)
+	} else BitmaskOptionValue("-lines", perlcs->cs.style, TVS_TRACKSELECT)
+	} else if(strcmp(option, "-imagelist") == 0) {
+		retval = TRUE;
+		perlcs->hImageList = (HIMAGELIST) handle_From(NOTXSCALL value);
+	}
+	return retval;
+}
+
+void
+TreeView_onPostCreate(NOTXSPROC HWND myhandle, LPPERLWIN32GUI_CREATESTRUCT perlcs) {
+	if(perlcs->hImageList != NULL)
+		TreeView_SetImageList(myhandle, perlcs->hImageList, TVSIL_NORMAL);
+	// TODO: later we'll cope with TVSIL_STATE too...
+}
+
+MODULE = Win32::GUI::TreeView		PACKAGE = Win32::GUI::TreeView
+
+PROTOTYPES: DISABLE
+
+    ###########################################################################
+    # (@)METHOD:InsertItem(%OPTIONS)
+    # Inserts a new node in the TreeView.
+    # Allowed %OPTIONS are:
+	#     -bold => 0/1, default 0
+    #     -image => NUMBER
+    #         index of an image from the associated ImageList
+	#     -item => NUMBER
+	#         handle of the node after which the new node is to be inserted,
+	#         or one of the following special values:
+	#             0xFFFF0001: at the beginning of the list
+	#             0xFFFF0002: at the end of the list
+	#             0xFFFF0003: in alphabetical order
+	#         the default value is at the end of the list
+	#     -parent => NUMBER
+	#         handle of the parent node for the new node
+	#     -selected => 0/1, default 0
+    #     -selectedimage => NUMBER
+    #         index of an image from the associated ImageList
+	#     -text => STRING
+	#         the text for the node
+HTREEITEM
+InsertItem(handle,...)
+    HWND handle
+PREINIT:
+    TV_ITEM Item;
+    TV_INSERTSTRUCT Insert;
+    unsigned int tlen;
+    int i, next_i;
+    int imageSeen, selectedImageSeen;
+    LPSTR pszText;
+    char * option;
+CODE:
+    ZeroMemory(&Item, sizeof(TV_ITEM));
+    ZeroMemory(&Insert, sizeof(TV_INSERTSTRUCT));
+    Insert.hParent = NULL;
+    Insert.hInsertAfter = TVI_LAST;
+
+    imageSeen = 0;
+    selectedImageSeen = 0;
+
+    next_i = -1;
+    for(i = 1; i < items; i++) {
+		if(next_i == -1) {
+            option = SvPV_nolen(ST(i));
+			if(strcmp(option, "-text") == 0) {
+                next_i = i + 1;
+                tlen = SvCUR(ST(next_i));
+                pszText = (LPSTR) safemalloc(tlen);
+                strcpy(pszText, SvPV_nolen(ST(next_i)));
+                Item.pszText = pszText;
+                Item.cchTextMax = tlen;
+                SwitchBit(Item.mask, TVIF_TEXT, 1);
+            } else if(strcmp(option, "-image") == 0) {
+                next_i = i + 1;
+                imageSeen = 1;
+                Item.iImage = SvIV(ST(next_i));
+                SwitchBit(Item.mask, TVIF_IMAGE, 1);
+            } else if(strcmp(option, "-selectedimage") == 0) {
+                next_i = i + 1;
+                selectedImageSeen = 1;
+                Item.iSelectedImage = SvIV(ST(next_i));
+                SwitchBit(Item.mask, TVIF_SELECTEDIMAGE, 1);
+            } else if(strcmp(option, "-parent") == 0) {
+                next_i = i + 1;
+                Insert.hParent = (HTREEITEM) handle_From(NOTXSCALL ST(next_i));
+            } else if(strcmp(option, "-item") == 0
+                   || strcmp(option, "-index") == 0) {
+                next_i = i + 1;
+                Insert.hInsertAfter = (HTREEITEM) handle_From(NOTXSCALL ST(next_i));
+            } else if(strcmp(option, "-bold") == 0) {
+                next_i = i + 1;
+                SwitchBit(Item.state, TVIS_BOLD, SvIV(ST(next_i)));
+                SwitchBit(Item.stateMask, TVIS_BOLD, 1);
+				SwitchBit(Item.mask, TVIF_STATE, 1);
+            } else if(strcmp(option, "-selected") == 0) {
+                next_i = i + 1;
+                SwitchBit(Item.state, TVIS_SELECTED, SvIV(ST(next_i)));
+                SwitchBit(Item.stateMask, TVIS_SELECTED, 1);
+                SwitchBit(Item.mask, TVIF_STATE, 1);
+			}
+        } else {
+            next_i = -1;
+        }
+    }
+    if(selectedImageSeen == 0 && imageSeen != 0) {
+        Item.iSelectedImage = Item.iImage;
+		SwitchBit(Item.mask, TVIF_SELECTEDIMAGE, 1);
+    }
+    Insert.item = Item;
+    RETVAL = TreeView_InsertItem(handle, &Insert);
+    safefree(pszText);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:ChangeItem(NODE, %OPTIONS)
+    # Change most of the options used when the item was created
+    # (see InsertItem()).
+    # Allowed %OPTIONS are:
+	#     -bold
+    #     -image
+	#     -selected
+    #     -selectedimage
+    #     -text
+BOOL
+ChangeItem(handle,item,...)
+    HWND handle
+    HTREEITEM item;
+PREINIT:
+    int i, next_i, imageSeen, selectedImageSeen;
+    unsigned int tlen;
+    TV_ITEM Item;
+    char * option;
+CODE:
+    ZeroMemory(&Item, sizeof(TV_ITEM));
+    Item.hItem = item;
+    imageSeen = 0;
+    selectedImageSeen = 0;
+    next_i = -1;
+    for(i = 2; i < items; i++) {
+        if(next_i == -1) {
+			option = SvPV_nolen(ST(i));
+            if(strcmp(option, "-text") == 0) {
+                next_i = i + 1;
+                Item.pszText = SvPV(ST(next_i), tlen);
+                Item.cchTextMax = tlen;
+                SwitchBit(Item.mask, TVIF_TEXT, 1);
+            } else if(strcmp(option, "-image") == 0) {
+                next_i = i + 1;
+                imageSeen = 1;
+                Item.iImage = SvIV(ST(next_i));
+                SwitchBit(Item.mask, TVIF_IMAGE, 1);
+            } else if(strcmp(option, "-selectedimage") == 0) {
+                next_i = i + 1;
+                selectedImageSeen = 1;
+                Item.iSelectedImage = SvIV(ST(next_i));
+                SwitchBit(Item.mask, TVIF_SELECTEDIMAGE, 1);
+            } else if(strcmp(option, "-bold") == 0) {
+                next_i = i + 1;
+                SwitchBit(Item.state, TVIS_BOLD, SvIV(ST(next_i)));
+                SwitchBit(Item.stateMask, TVIS_BOLD, 1);
+				SwitchBit(Item.mask, TVIF_STATE, 1);
+            } else if(strcmp(option, "-selected") == 0) {
+                next_i = i + 1;
+                SwitchBit(Item.state, TVIS_SELECTED, SvIV(ST(next_i)));
+                SwitchBit(Item.stateMask, TVIS_SELECTED, 1);
+                SwitchBit(Item.mask, TVIF_STATE, 1);
+			}
+        } else {
+            next_i = -1;
+        }
+    }
+    if(selectedImageSeen == 0 && imageSeen != 0) {
+        Item.iSelectedImage = Item.iImage;
+		SwitchBit(Item.mask, TVIF_SELECTEDIMAGE, 1);
+    }
+    RETVAL = TreeView_SetItem(handle, &Item);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:ItemInfo(NODE)
+    # Returns an associative array of information about the given NODE:
+    #     -children
+	#     -image
+	#     -parent
+	#     -selectedimage
+	#     -state
+    #     -text
+
+    ###########################################################################
+    # (@)METHOD:GetItem(NODE)
+    # See ItemInfo().
+void
+ItemInfo(handle,item)
+    HWND handle
+    HTREEITEM item
+ALIAS:
+    Win32::GUI::TreeView::GetItem = 1
+PREINIT:
+    TV_ITEM tv_item;
+    char pszText[1024];
+PPCODE:
+    ZeroMemory(&tv_item, sizeof(TV_ITEM));
+    tv_item.hItem = item;
+    tv_item.mask = TVIF_CHILDREN | TVIF_HANDLE | TVIF_IMAGE
+                 | TVIF_PARAM | TVIF_SELECTEDIMAGE
+                 | TVIF_TEXT | TVIF_STATE;
+    tv_item.pszText = pszText;
+    tv_item.cchTextMax = 1024;
+    if(TreeView_GetItem(handle, &tv_item)) {
+        EXTEND(SP, 8);
+        XST_mPV(0, "-text");
+        XST_mPV(1, tv_item.pszText);
+        XST_mPV(2, "-image");
+        XST_mIV(3, tv_item.iImage);
+        XST_mPV(4, "-selectedimage");
+        XST_mIV(5, tv_item.iSelectedImage);
+        XST_mPV(6, "-children");
+        XST_mIV(7, tv_item.cChildren);
+		XST_mPV(8, "-parent");
+		XST_mIV(9, (long) TreeView_GetParent(handle, item));
+		XST_mPV(10, "-state");
+		XST_mIV(11, tv_item.state);
+        XSRETURN(12);
+    } else {
+        XSRETURN_UNDEF;
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:DeleteItem(NODE)
+    # Removes the specified NODE from the TreeView.
+BOOL
+DeleteItem(handle,item)
+    HWND handle
+    HTREEITEM item
+CODE:
+    RETVAL = TreeView_DeleteItem(handle,item);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Reset()
+    # Deletes all nodes from the TreeView.
+BOOL
+Reset(handle)
+    HWND handle
+CODE:
+    RETVAL = TreeView_DeleteAllItems(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Clear([NODE])
+    # Deletes all nodes from the TreeView if no argument is given;
+    # otherwise, delete all nodes under the given NODE.
+BOOL
+Clear(handle,...)
+    HWND handle
+CODE:
+    if(items != 1 && items != 2)
+        croak("Usage: Clear(handle, [item]);\n");
+    if(items == 1)
+        RETVAL = TreeView_DeleteAllItems(handle);
+    else
+        RETVAL = TreeView_Expand(handle,
+                                 (HTREEITEM) (DWORD)SvIV(ST(1)),
+                                 TVE_COLLAPSE | TVE_COLLAPSERESET);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:SetImageList(IMAGELIST, [TYPE])
+HIMAGELIST
+SetImageList(handle,imagelist,type=TVSIL_NORMAL)
+    HWND handle
+    HIMAGELIST imagelist
+    WPARAM type
+CODE:
+    RETVAL = TreeView_SetImageList(handle, imagelist, type);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Expand(NODE, [FLAG])
+BOOL
+Expand(handle,item,flag=TVE_EXPAND)
+    HWND handle
+    HTREEITEM item
+    UINT flag
+CODE:
+    RETVAL = TreeView_Expand(handle, item, flag);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Collapse(NODE)
+    # Closes a NODE of the TreeView.
+BOOL
+Collapse(handle,item)
+    HWND handle
+    HTREEITEM item
+CODE:
+    RETVAL = TreeView_Expand(handle, item, TVE_COLLAPSE);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetRoot()
+    # Returns the handle of the TreeView root node.
+HTREEITEM
+GetRoot(handle)
+    HWND handle
+CODE:
+    RETVAL = TreeView_GetRoot(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetParent(NODE)
+    # Returns the handle of the parent node for the given NODE.
+HTREEITEM
+GetParent(handle,item)
+    HWND handle
+    HTREEITEM item
+CODE:
+    RETVAL = TreeView_GetParent(handle, item);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetChild(NODE)
+    # Returns the handle of the first child node for the given NODE.
+HTREEITEM
+GetChild(handle,item)
+    HWND handle
+    HTREEITEM item
+CODE:
+    RETVAL = TreeView_GetChild(handle, item);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetNextSibling(NODE)
+    # Returns the handle of the next sibling node for the given NODE.
+HTREEITEM
+GetNextSibling(handle,item)
+    HWND handle
+    HTREEITEM item
+CODE:
+    RETVAL = TreeView_GetNextSibling(handle, item);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetPrevSibling(NODE)
+    # Returns the handle of the previous sibling node for the given NODE.
+HTREEITEM
+GetPrevSibling(handle,item)
+    HWND handle
+    HTREEITEM item
+CODE:
+    RETVAL = TreeView_GetPrevSibling(handle, item);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Count()
+    # Returns the number of nodes in the TreeView.
+UINT
+Count(handle)
+    HWND handle
+CODE:
+    RETVAL = TreeView_GetCount(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Select(NODE, [FLAG])
+    # Selects the given NODE in the TreeView; the optional FLAG parameter
+    # can be set to 5 if you want the selected NODE to become, if possible,
+    # the first visible item in the TreeView.
+	# If NODE is 0 (zero), the selected item, if any, is deselected.
+BOOL
+Select(handle,item,flag=TVGN_CARET)
+    HWND handle
+    HTREEITEM item
+    WPARAM flag
+CODE:
+    RETVAL = (BOOL) TreeView_Select(handle, item, flag);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:SelectedItem()
+    # Returns the handle of the currently selected node.
+HTREEITEM
+SelectedItem(handle)
+    HWND handle
+CODE:
+    RETVAL = TreeView_GetSelection(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:HitTest(X, Y)
+void
+HitTest(handle,x,y)
+    HWND handle
+    LONG x
+    LONG y
+PREINIT:
+    TV_HITTESTINFO ht;
+PPCODE:
+    ht.pt.x = x;
+    ht.pt.y = y;
+    TreeView_HitTest(handle, &ht);
+    if(GIMME == G_ARRAY) {
+        EXTEND(SP, 2);
+        XST_mIV(0, (long) ht.hItem);
+        XST_mIV(1, ht.flags);
+        XSRETURN(2);
+    } else {
+        XSRETURN_IV((long) ht.hItem);
+    }
+
+
+    ###########################################################################
+    # (@)METHOD:Indent([VALUE])
+UINT
+Indent(handle,value=(UINT) -1)
+    HWND handle
+    UINT value
+CODE:
+    if(items == 2)
+        RETVAL = TreeView_SetIndent(handle, value);
+    else
+        RETVAL = TreeView_GetIndent(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:Sort(NODE)
+    # Sorts the childs of the specified NODE in the TreeView.
+BOOL
+Sort(handle,item)
+    HWND handle
+    HTREEITEM item
+CODE:
+    RETVAL = TreeView_SortChildren(handle, item, 0);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:EnsureVisible(NODE)
+BOOL
+EnsureVisible(handle,item)
+    HWND handle
+    HTREEITEM item
+CODE:
+    RETVAL = TreeView_EnsureVisible(handle, item);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:VisibleCount()
+UINT
+VisibleCount(handle)
+    HWND handle
+CODE:
+    RETVAL = TreeView_GetVisibleCount(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:FirstVisible([NODE])
+HTREEITEM
+FirstVisible(handle,item=0)
+    HWND handle
+    HTREEITEM item
+CODE:
+    RETVAL = TreeView_GetFirstVisible(handle);
+	if(items == 2)
+        TreeView_SelectSetFirstVisible(handle, item);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetNextVisible(NODE)
+HTREEITEM
+GetNextVisible(handle,item)
+    HWND handle
+    HTREEITEM item
+CODE:
+    RETVAL = TreeView_GetNextVisible(handle, item);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetPrevVisible(NODE)
+HTREEITEM
+GetPrevVisible(handle,item)
+    HWND handle
+    HTREEITEM item
+CODE:
+    RETVAL = TreeView_GetPrevVisible(handle, item);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:GetLastVisible()
+HTREEITEM
+GetLastVisible(handle)
+    HWND handle
+CODE:
+    RETVAL = TreeView_GetLastVisible(handle);
+OUTPUT:
+    RETVAL
+
+
+    ###########################################################################
+    # (@)METHOD:ItemCheck(NODE, [VALUE])
+BOOL
+ItemCheck(handle,item,value=FALSE)
+    HWND handle
+    HTREEITEM item
+    BOOL value
+PREINIT:
+    TVITEM tvitem;
+CODE:
+    if(items == 3) {
+        tvitem.mask = TVIF_HANDLE | TVIF_STATE;
+        tvitem.hItem = item;
+        tvitem.stateMask = TVIS_STATEIMAGEMASK;
+        tvitem.state = INDEXTOSTATEIMAGEMASK((value ? 2 : 1));
+        RETVAL = TreeView_SetItem(handle, &tvitem);
+    } else {
+        tvitem.mask = TVIF_HANDLE | TVIF_STATE;
+        tvitem.hItem = item;
+        tvitem.stateMask = TVIS_STATEIMAGEMASK;
+        TreeView_GetItem(handle, &tvitem);
+        RETVAL = ((BOOL)(tvitem.state >> 12) -1);
+    }
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:TextColor([COLOR])
+    # Gets or sets the text color for the control.
+COLORREF
+TextColor(handle,color=(COLORREF) -1)
+    HWND handle
+    COLORREF color
+CODE:
+    if(items == 2) {
+        if(TreeView_SetTextColor(handle, color))
+            RETVAL = TreeView_GetTextColor(handle);
+        else
+            RETVAL = (COLORREF) -1;
+    } else
+        RETVAL = TreeView_GetTextColor(handle);
+OUTPUT:
+    RETVAL
+
+    ###########################################################################
+    # (@)METHOD:BackColor([COLOR])
+    # Gets or sets the background color for the control.
+COLORREF
+BackColor(handle,color=(COLORREF) -1)
+    HWND handle
+    COLORREF color
+CODE:
+    if(items == 2) {
+        if(TreeView_SetBkColor(handle, color))
+            RETVAL = TreeView_GetBkColor(handle);
+        else
+            RETVAL = (COLORREF) -1;
+    } else
+        RETVAL = TreeView_GetBkColor(handle);
+OUTPUT:
+    RETVAL
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/GUI.pod perl-libwin32-0.191/GUI/docs/GUI.pod
--- libwin32-0.191/GUI/docs/GUI.pod	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/GUI.pod	2004-01-12 16:46:40.265625000 -0800
@@ -0,0 +1,78 @@
+=head1 Win32::GUI Documentation
+
+Version: B<0.0.665>, 12 Dec 2003
+
+=head2 Table Of Contents
+
+=over
+
+=item *
+
+B<User's Guide>
+
+=over
+
+=item *
+
+L<Introduction|guiintro/>
+
+=item *
+
+L<General concepts|guiconcepts/>
+
+=item *
+
+L<Writing a script with Win32::GUI|guitut/>
+
+=back
+
+=for html <P>
+
+=item *
+
+B<Reference Manual>
+
+=over
+
+=item *
+
+L<Common options|guioptions/>
+
+=item *
+
+L<Packages|guipacks/>
+
+=item *
+
+B<Support packages>
+
+
+=over 4
+
+=item *
+
+L<Win32::GUI::BitmapInline|BitmapInline/>
+
+=item *
+
+L<Win32::GUI::GridLayout|GridLayout/>
+
+=back
+
+=back
+
+=for html <P>
+
+=item *
+
+B<FAQs>
+
+=back
+
+=head2 AUTHOR
+
+(c) 1997, 8, 9 Aldo Calpini, C<dada@divinf.it>.
+
+
+
+=cut
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/archdraft.html perl-libwin32-0.191/GUI/docs/archdraft.html
--- libwin32-0.191/GUI/docs/archdraft.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/archdraft.html	2004-01-12 16:46:40.281250000 -0800
@@ -0,0 +1,38 @@
+<HTML>
+<HEAD>
+<TITLE>Win32::GUI Architecture Draft</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<A NAME="__index__"></A>
+<!-- INDEX BEGIN -->
+
+<UL>
+
+	<LI><A HREF="#win32::gui architecture draft">Win32::GUI Architecture Draft</A></LI>
+	<UL>
+
+		<LI><A HREF="#source files">Source Files</A></LI>
+	</UL>
+
+</UL>
+<!-- INDEX END -->
+
+<HR>
+<P>
+<H1><A NAME="win32::gui architecture draft">Win32::GUI Architecture Draft</A></H1>
+<P>
+<H2><A NAME="source files">Source Files</A></H2>
+<UL>
+<LI><STRONG><A NAME="item_package">Each package (almost) has its own XS file.</A></STRONG><BR>
+
+<LI><STRONG><A NAME="item_Each_pure%2DC_function_in_XS_file_must_be_prototyp">Each pure-C function in XS file must be prototyped
+in <EM>GUI.h</EM>.</A></STRONG><BR>
+
+</UL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/archdraft.pod perl-libwin32-0.191/GUI/docs/archdraft.pod
--- libwin32-0.191/GUI/docs/archdraft.pod	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/archdraft.pod	2004-01-12 16:46:40.296875000 -0800
@@ -0,0 +1,15 @@
+
+=head1 Win32::GUI Architecture Draft
+
+=head2 Source Files
+
+=over 4
+=item *
+Each package (almost) has its own XS file.
+
+=item *
+Each pure-C function in XS file must be prototyped
+in F<GUI.h>.
+
+=back
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/dodoc.pl perl-libwin32-0.191/GUI/docs/dodoc.pl
--- libwin32-0.191/GUI/docs/dodoc.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/dodoc.pl	2004-01-12 16:46:40.312500000 -0800
@@ -0,0 +1,611 @@
+#perl -w
+use strict;
+use Pod::Html;
+
+my %METHOD;
+my %EVENT;
+my $DEBUG = 0;
+
+Parse("../GUI.xs");
+Parse("../GUI.pm");
+Parse("../Animation.xs");
+Parse("../Bitmap.xs");
+Parse("../DC.xs");
+Parse("../Font.xs");
+Parse("../ImageList.xs");
+Parse("../Label.xs");
+Parse("../Listbox.xs");
+Parse("../ListView.xs");
+Parse("../NotifyIcon.xs");
+Parse("../Rebar.xs");
+Parse("../RichEdit.xs");
+Parse("../Splitter.xs");
+Parse("../TabStrip.xs");
+Parse("../Textfield.xs");
+Parse("../Toolbar.xs");
+Parse("../Treeview.xs");
+Parse("../GUI_MessageLoops.cpp");
+
+if($ARGV[0] eq "-u") {
+    TbdOutput();
+} elsif($ARGV[0] eq "-t") {
+    TxtOutput();
+} elsif($ARGV[0] eq "-h") {
+    HtmlOutput();
+} else {
+    PodOutput();
+}
+
+###############################################################################
+
+sub Parse {
+    my($file) = @_;
+    my $package;
+    my $method;
+    my $methodname;
+    my $applies;
+    my $event;
+    my $thisevent;
+    my @packages;
+    my $p;
+
+    open(FILE, "<$file") or die;
+    while(<FILE>) {
+        if($method) {
+            if(s/^\s*#\s?//) {
+                $METHOD{$package}{$method} .= $_;            
+            } else {
+                $method = 0;           
+            }
+        }
+        if($event) {
+            if(s/^\s*[#\*]\s?//) {
+                if(/\(\@\)APPLIES_TO:\s*(.*\S)\s*/) {
+                    $applies = $1;
+                    if($applies eq "*") {
+                    } else {
+                        @packages = split(/\s*,\s*/, $applies);
+                        foreach $p (@packages) {
+                            $p = "Win32::GUI::".$p;
+                            $p =~ s/\s*$//;
+                            $METHOD{$p} = {} unless exists($METHOD{$p});
+                            $EVENT{$p} = {} unless exists($EVENT{$p});
+                            $EVENT{$p}{$event} = $thisevent;
+                        }
+                    }
+                } else {
+                    $thisevent .= $_;
+                }
+            } else {
+                $event = 0;         
+                $thisevent = "";
+            }
+        }
+        if(/\(\@\)PACKAGE:\s*(.*\S)\s*$/) {
+            $package = $1;
+            print "Found package: '$package'\n" if $DEBUG == 1;
+            $METHOD{$package} = {} unless exists($METHOD{$package});
+        }
+        if(/\(\@\)EVENT:\s*(.*\S)\s*/) {        
+            $event = $1;        
+            print "Found event: '$event'\n" if $DEBUG == 1;
+
+        }
+        if(/\(\@\)METHOD:\s*(.*\S)\s*/) {
+            $methodname = $1;
+            ($method = $methodname) =~ s/\(.*//;
+            print "Found method: '$method'\n" if $DEBUG == 1;
+            $METHOD{$package}{$method} = "$methodname;;;";
+        }
+    }
+    close(FILE);
+}
+
+###############################################################################
+
+sub TxtOutput {
+    my $pak;
+    my $sub;
+    my $syntax;
+    my $content;
+    foreach $pak (sort keys %METHOD) {
+        print "\n\nPACKAGE: $pak\n";
+        foreach $sub (sort keys %{$METHOD{$pak}}) {
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub}, 2);
+            $content =~ s/^/\t  /;
+            $content =~ s/\n/\n\t  /g;
+            print "\t* ", $syntax, "\n", $content, "\n";
+        }
+        foreach $sub (sort keys %{$EVENT{$pak}}) {
+            $EVENT{$pak}{$sub} =~ s/^/\t  /;
+            $EVENT{$pak}{$sub} =~ s/\n/\n\t  /g;
+            print "\t@ ", $sub, "\n", $EVENT{$pak}{$sub}, "\n";
+        }
+    }
+}
+
+###############################################################################
+
+sub newfirst {
+    return ($a =~ /^new/) ? -1 : 
+           ($b =~ /^new/) ? 1 : uc($a) cmp uc($b);
+}
+
+sub HtmlOutput {
+    my $pak;
+    my $page;
+    my $sub;
+    my $subname;
+    my $syntax;
+    my $content;
+    my $newdone;
+
+    my $nofpackages = 0;
+    my $nofmethods = 0;
+    my $nofumethods = 0;
+    my $nofevents = 0;
+    my $nofuevents = 0;
+
+    open(INDEX, ">index.html");
+    print INDEX HtmlStart("Win32::GUI");
+    print INDEX HtmlHeading("Packages");
+    print INDEX "<UL>\n";
+    foreach $pak (sort keys %METHOD) {
+        $page = HtmlPage($pak);
+        print INDEX HtmlList("$page", $pak);
+        open(HTML, ">$page");
+        print HTML HtmlStart($pak);
+        $newdone = 0;
+        foreach $sub (sort newfirst keys %{$METHOD{$pak}}) {
+            if(!$newdone) {
+                if($METHOD{$pak}{$sub} =~ /^new/) {
+                    print HTML HtmlHeading("Constructor");
+                    print HTML "<UL>\n";
+                } else {
+                    print HTML HtmlHeading("Methods");
+                    print HTML "<UL>\n";
+                }
+            } elsif($newdone == 2) {
+                print HTML HtmlHeading("Methods");
+                print HTML "<UL>\n";
+                $newdone = 1;
+            }
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            print HTML HtmlList("#m_".$sub, $syntax);        
+            $nofmethods++;
+            $nofumethods++ if $content eq "";
+            if($METHOD{$pak}{$sub} =~ /^new/) {
+                print HTML "</UL>\n";
+                $newdone = 2;
+            } else {
+                $newdone = 1;
+            }
+        }
+        if(keys %{$EVENT{$pak}} > 0) {
+            print HTML "</UL>\n";
+            print HTML HtmlHeading("Events");
+            print HTML "<UL>\n";
+            foreach $sub (sort keys %{$EVENT{$pak}}) {
+                $subname = $sub;
+                $subname =~ s/\(.*$//;
+                print HTML HtmlList("#e_".$subname, $sub);
+                $nofevents++;
+                $nofuevents++ if $EVENT{$pak}{$sub} eq "";
+            }
+        }
+        print HTML "</UL>\n<HR><DL>\n";
+        foreach $sub (sort newfirst keys %{$METHOD{$pak}}) {
+            print "METHOD<$pak><$sub>\n" if $DEBUG == 1;
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            print HTML HtmlDefinition($pak, "m_".$sub, $syntax, $content);
+        }
+        foreach $sub (sort keys %{$EVENT{$pak}}) {
+            $subname = $sub;
+            $subname =~ s/\(.*$//;
+            print HTML HtmlDefinition($pak, "e_".$subname, $sub, $EVENT{$pak}{$sub});
+        }
+        print HTML "</DL></BODY></HTML>\n";
+        close(HTML);
+        $nofpackages++;
+    }
+    print INDEX "</UL></BODY></HTML>\n";
+    close(INDEX);
+
+    print STDERR "$nofpackages packages.\n";
+    print STDERR "$nofmethods methods ($nofumethods undocumented).\n";
+    print STDERR "$nofevents events ($nofuevents undocumented).\n";
+}
+
+
+sub HtmlPage {
+    my($package) = @_;
+    # $package =~ s/^Win32::GUI:://;
+    $package =~ s/::/_/g;
+    return $package.".html";
+}
+
+sub HtmlStart {
+    my($title) = @_;
+    return "
+        <HTML>
+        <HEAD>
+        <TITLE>$title</TITLE>
+        </HEAD>
+        <BODY BGCOLOR=white>
+        <FONT FACE=\"Verdana, Tahoma, Arial, Helvetica\" SIZE=2>
+        <H3>$title</H3>
+    ";
+}
+
+sub HtmlHeading {
+    my($text) = @_;
+    return "<B>$text</B>\n";
+}
+
+sub HtmlDefinition {
+    my($package, $link, $term, $definition) = @_;
+    #$definition =~ s/\n/<BR>\n/g;
+    $definition =~ s/\n(\s*)/"<BR>\n"."&nbsp;" x length($1)/ge;
+    #$definition =~ s/\s/&nbsp;/g;
+    $definition =~ s
+        [see(&nbsp;|\s)*(also)?(&nbsp;|\s)*(.*\(\))]
+        ['see'.$1.$2.'&nbsp;'.HtmlInternalLink($package, $4)]gie;
+    if($definition eq "") {
+        print "TBD: ${package}::${term}\n";
+        $definition = "<I>[TBD]</I><BR>\n";
+    }
+    if($link =~ /^e_/) {
+        $term = "<I>OBJECT_</I><B>$term</B>";
+    } else {
+        $term = "<B>$term</B>";
+    }
+    return "
+        <DT><A NAME=\"$link\">$term
+        <DD>$definition<BR>
+    ";
+}
+
+sub HtmlList {
+    my($link, $item) = @_;
+    return "<LI><A HREF=\"$link\">$item</A>\n";
+}
+
+###############################################################################
+
+sub PodOutput {
+    my $pak;
+    my $page;
+    my $sub;
+    my $subname;
+    my $syntax;
+    my $content;
+    my $newdone;
+
+    my $nofpackages = 0;
+    my $nofmethods = 0;
+    my $nofumethods = 0;
+    my $nofevents = 0;
+    my $nofuevents = 0;
+
+    foreach $pak (sort keys %METHOD) {
+        $page = PodPage($pak);
+        open(POD, ">$page") or warn "$0: can't open $page for writing: $!";
+        print POD "=head2 Package $pak\n\n";
+        print POD "L<Back to the Packages|guipacks/>\n\n";
+        $newdone = 0;
+        print POD "=over\n\n";
+        foreach $sub (sort newfirst keys %{$METHOD{$pak}}) {
+            if(!$newdone) {
+                if($METHOD{$pak}{$sub} =~ /^new/) {
+                    print POD "=item *\n\nL<Constructor>\n\n=over\n\n";
+                } else {
+                    print POD "=item *\n\nL<Methods>\n\n=over\n\n";
+                }
+            } elsif($newdone == 2) {
+                print POD "=back\n\n=item *\n\nL<Methods>\n\n=over\n\n";
+                $newdone = 1;
+            }
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            if($METHOD{$pak}{$sub} =~ /^new/) {
+                $newdone = 2;
+            } else {
+                $newdone = 1;
+            }
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            ($subname = $syntax) =~ s/\|/&#124;/g;
+            print POD "=item *\n\nL<$subname|/".htmlify(0, $syntax).">\n\n";
+        }
+        if(keys %{$EVENT{$pak}} > 0) {
+            print POD "=back\n\n=item *\n\nL<Events>\n\n=over\n\n";
+            foreach $sub (sort keys %{$EVENT{$pak}}) {
+                $subname = $sub;
+                $subname =~ s/\(.*$//;
+                print POD "=item *\n\nL<$sub|/".htmlify(0, $sub).">\n\n";
+            }
+        }
+        print POD "=back\n\n=back\n\n";
+        $newdone = 0;
+        foreach $sub (sort newfirst keys %{$METHOD{$pak}}) {
+            if(!$newdone) {
+                if($METHOD{$pak}{$sub} =~ /^new/) {
+                    print POD "=head3 Constructor\n\n=over 4\n\n";
+                } else {
+                    print POD "=head3 Methods\n\n=over 4\n\n";
+                }
+            } elsif($newdone == 2) {
+                print POD "=back\n\n=head3 Methods\n\n=over 4\n\n";
+                $newdone = 1;
+            }
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            $nofmethods++;
+            $nofumethods++ if $content eq "";
+            if($METHOD{$pak}{$sub} =~ /^new/) {
+                $newdone = 2;
+            } else {
+                $newdone = 1;
+            }
+            print "METHOD<$pak><$sub>\n" if $DEBUG == 1;
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            print POD PodDefinition($pak, $syntax, $content);
+            #print POD "=head4 $syntax\n\n";
+            #print POD "$content\n\n";
+        }
+        if(keys %{$EVENT{$pak}} > 0) {
+            print POD "=back\n\n=head3 Events\n\n=over 4\n\n";
+        }
+        foreach $sub (sort keys %{$EVENT{$pak}}) {
+            $subname = $sub;
+            $subname =~ s/\(.*$//;
+            print POD PodDefinition($pak, $sub, $EVENT{$pak}{$sub});
+            #print POD "=head4 $sub\n\n";
+            #print POD "$EVENT{$pak}{$sub}\n\n";            
+        }
+        print POD "=back\n\n=cut\n";
+        close(POD);
+        $nofpackages++;
+    }
+
+    open(INDEX, ">pod/guipacks.pod") or warn "$0: can't open guipacks.pod for writing!";
+    print INDEX "=head2 Win32::GUI Packages\n\n";
+    print INDEX "L<Back to the index|gui/>\n\n";
+    print INDEX "=head3 Packages\n\n=over\n\n";
+    foreach $pak (sort keys %METHOD) {
+        $page = PodPage($pak);
+        $page =~ s/\.pod//;
+		$page =~ s/^pod\///;
+        print INDEX "=item *\n\nL<$pak|$page/>\n\n";
+    }
+    print INDEX "=back\n\n=cut\n";
+    close(INDEX);
+
+    print STDERR "$nofpackages packages.\n";
+    print STDERR "$nofmethods methods ($nofumethods undocumented).\n";
+    print STDERR "$nofevents events ($nofuevents undocumented).\n";
+}
+
+sub PodPage {
+    my($package) = @_;
+    $package =~ s/^Win32::GUI:://;
+    $package =~ s/::/_/g;
+    return "pod/$package.pod";
+}
+
+sub PodDefinition {
+    my($package, $term, $definition) = @_;
+    #
+    # properly split literal paragraphs from plain text
+    #
+    my(@lines) = split(/\n/, $definition);
+    foreach my $i (0..$#lines) {
+        if($lines[$i] =~ /^\S/ and $lines[$i+1] =~ /^\s/) {
+            $lines[$i] .= "\n";
+        }
+        if($lines[$i] =~ /^\s/ and $lines[$i+1] =~ /^\S/) {
+            $lines[$i] .= "\n";
+        }
+    }
+    $definition = join("\n", @lines);
+    #$definition =~ s/\n(\S.*)\n/\n$1\n\n/g;
+    #$definition =~ s/\n(\s.*)\n(\S)/\n\n$1\n\n$2/g;
+    $definition =~ s
+        [(see\s*)(also)?(\s*)(.*\(\))]
+        [$1.$2.$3.' '.PodInternalLink($package, $4)]gie;
+    if($definition eq "") {
+        # print "TBD: ${package}::${term}\n";
+        $definition = "[TBD]\n\n";
+    }
+    
+    return 
+    "=for html <A NAME=\"".htmlify(0, $term)."\">\n\n"
+    .
+    "=item $term\n\n$definition\n\n"
+    .
+    "=for html <P>\n\n"
+    ;
+}
+
+sub PodInternalLink {
+    my($package, $link) = @_;
+    my $pak;
+    $link =~ s/^\s*//;
+    $link =~ s/\s*$//;
+    my $name = substr($link, 0, index($link, '('));
+    if(defined($METHOD{$package}{$name})) {
+        my $section = PodLinkSyntax($package, $name);
+        return "L<$link|/$section>";
+    } elsif(defined($EVENT{$package}{$name})) {
+        return "L<$link|/$name>";
+    } else {
+        foreach $pak (sort keys %METHOD) {
+            if($METHOD{$pak}{$name}) {
+                my $section = PodLinkSyntax($pak, $name);
+                my $page = PodPage($pak);
+                $page =~ s/\.pod//;
+                $page =~ s/^pod\///;
+                return "L<$link|".$page."/$section>";
+            } elsif($EVENT{$pak}{$name}) {
+                my $page = PodPage($pak);
+                $page =~ s/\.pod//;
+                $page =~ s/^pod\///;
+				return "L<$link|".$page."/$name>";
+            }
+        }
+    }
+    warn "broken link (package: $package, link: $name)\n";
+    return $link;
+}
+
+sub PodLinkSyntax {
+    my($package, $name) = @_;
+    my ($syntax, $content) = split(/;;;/, $METHOD{$package}{$name});
+    return htmlify(0, $syntax);
+}
+
+sub PodOutput_OLD {
+    my $pak;
+    my $page;
+    my $sub;
+    my $subname;
+    my $syntax;
+    my $content;
+    my $newdone;
+
+    my $nofpackages = 0;
+    my $nofmethods = 0;
+    my $nofumethods = 0;
+    my $nofevents = 0;
+    my $nofuevents = 0;
+
+    foreach $pak (sort keys %METHOD) {
+        $page = PodPage($pak);
+        open(POD, ">$page") or warn "$0: can't open $page for writing: $!";
+        print POD "=head2 Package $pak\n\n";
+        print POD "L<Back to the Packages|guipacks/>\n\n";
+        $newdone = 0;
+        print POD "=over\n\n";
+        foreach $sub (sort newfirst keys %{$METHOD{$pak}}) {
+            if(!$newdone) {
+                if($METHOD{$pak}{$sub} =~ /^new/) {
+                    print POD "=item *\n\nL<Constructor>\n\n=over\n\n";
+                } else {
+                    print POD "=item *\n\nL<Methods>\n\n=over\n\n";
+                }
+            } elsif($newdone == 2) {
+                print POD "=back\n\n=item *\n\nL<Methods>\n\n=over\n\n";
+                $newdone = 1;
+            }
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            if($METHOD{$pak}{$sub} =~ /^new/) {
+                $newdone = 2;
+            } else {
+                $newdone = 1;
+            }
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            ($subname = $syntax) =~ s/\|/&#124;/g;
+            print POD "=item *\n\nL<$subname|/".htmlify(0, $syntax).">\n\n";
+        }
+        if(keys %{$EVENT{$pak}} > 0) {
+            print POD "=back\n\n=item *\n\nL<Events>\n\n=over\n\n";
+            foreach $sub (sort keys %{$EVENT{$pak}}) {
+                $subname = $sub;
+                $subname =~ s/\(.*$//;
+                print POD "=item *\n\nL<$sub|/".htmlify(0, $sub).">\n\n";
+            }
+        }
+        print POD "=back\n\n=back\n\n";
+        $newdone = 0;
+        foreach $sub (sort newfirst keys %{$METHOD{$pak}}) {
+            if(!$newdone) {
+                if($METHOD{$pak}{$sub} =~ /^new/) {
+                    print POD "=head3 Constructor\n\n";
+                } else {
+                    print POD "=head3 Methods\n\n";
+                }
+            } elsif($newdone == 2) {
+                print POD "=head3 Methods\n\n";
+                $newdone = 1;
+            }
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            $nofmethods++;
+            $nofumethods++ if $content eq "";
+            if($METHOD{$pak}{$sub} =~ /^new/) {
+                $newdone = 2;
+            } else {
+                $newdone = 1;
+            }
+            print "METHOD<$pak><$sub>\n" if $DEBUG == 1;
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            print POD PodDefinition($pak, $syntax, $content);
+            #print POD "=head4 $syntax\n\n";
+            #print POD "$content\n\n";
+        }
+        if(keys %{$EVENT{$pak}} > 0) {
+            print POD "=head3 Events\n\n";
+        }
+        foreach $sub (sort keys %{$EVENT{$pak}}) {
+            $subname = $sub;
+            $subname =~ s/\(.*$//;
+            print POD "=head4 $sub\n\n";
+            print POD "$EVENT{$pak}{$sub}\n\n";            
+        }
+        print POD "=cut\n";
+        close(POD);
+        $nofpackages++;
+    }
+
+    open(INDEX, ">guipacks.pod") or warn "$0: can't open guipacks.pod for writing!";
+    print INDEX "=head2 Win32::GUI Packages\n\n";
+    print INDEX "L<Back to the index|gui/>\n\n";
+    print INDEX "=head3 Packages\n\n=over\n\n";
+    foreach $pak (sort keys %METHOD) {
+        $page = PodPage($pak);
+        $page =~ s/\.pod//;
+        print INDEX "=item *\n\nL<$pak|$page/>\n\n";
+    }
+    print INDEX "=back\n\n=cut\n";
+    close(INDEX);
+
+    print STDERR "$nofpackages packages.\n";
+    print STDERR "$nofmethods methods ($nofumethods undocumented).\n";
+    print STDERR "$nofevents events ($nofuevents undocumented).\n";
+}
+
+sub TbdOutput {
+    my $pak;
+    my $page;
+    my $sub;
+    my $subname;
+    my $syntax;
+    my $content;
+    my $newdone;
+
+    my $nofpackages = 0;
+    my $nofmethods = 0;
+    my $nofumethods = 0;
+    my $nofevents = 0;
+    my $nofuevents = 0;
+
+    foreach $pak (sort keys %METHOD) {
+        foreach $sub (sort newfirst keys %{$METHOD{$pak}}) {
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            $nofmethods++;
+            if($content eq "") {
+                $nofumethods++;
+                print "Method: ${pak}::$sub\n";
+            }            
+        }
+        if(keys %{$EVENT{$pak}} > 0) {
+            foreach $sub (sort keys %{$EVENT{$pak}}) {
+                $nofevents++;
+                if($EVENT{$pak}{$sub} eq "") {
+                    $nofuevents++;
+                    print "Event: ${pak}::$sub\n";
+                }
+            }
+        }
+        $nofpackages++;
+    }
+    print STDERR "$nofpackages packages.\n";
+    print STDERR "$nofmethods methods ($nofumethods undocumented).\n";
+    print STDERR "$nofevents events ($nofuevents undocumented).\n";
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/dodoc2.pl perl-libwin32-0.191/GUI/docs/dodoc2.pl
--- libwin32-0.191/GUI/docs/dodoc2.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/dodoc2.pl	2004-01-12 16:46:40.328125000 -0800
@@ -0,0 +1,605 @@
+#perl -w
+#use strict;
+use Pod::Html;
+
+my %D;
+my %METHOD;
+my %EVENT;
+my $DEBUG = 0;
+
+Parse("../GUI.xs");
+Parse("../GUI.pm");
+
+if($ARGV[0] eq "-u") {
+    TbdOutput();
+} elsif($ARGV[0] eq "-t") {
+    TxtOutput();
+} elsif($ARGV[0] eq "-h") {
+    HtmlOutput();
+} else {
+    HtmlOutput();
+#    PodOutput();
+}
+
+###############################################################################
+
+sub Parse {
+    my($file) = @_;
+    my $package;
+    my $method;
+    my $methodname;
+    my $applies;
+    my $event;
+    my $thisevent;
+    my @packages;
+    my $p;
+
+    open(FILE, "<$file") or die;
+    while(<FILE>) {
+        if($method) {
+            if(s/^\s*#\s?//) {
+                $D{$package}{methods}{$method} .= $_;            
+            } else {
+                $method = 0;           
+            }
+        }
+        if($event) {
+            if(s/^\s*[#\*]\s?//) {
+                if(/\(\@\)APPLIES_TO:\s*(.*\S)\s*/) {
+                    $applies = $1;
+                    if($applies eq "*") {
+                    } else {
+                        @packages = split(/\s*,\s*/, $applies);
+                        foreach $p (@packages) {
+                            #$p = "Win32::GUI::".$p;
+                            #$p =~ s/\s*$//;
+                            $METHOD{$p} = {} unless exists($METHOD{$p});
+                            $EVENT{$p} = {} unless exists($EVENT{$p});
+                            $EVENT{$p}{$event} = $thisevent;
+							$D{$p}{events}{$event} = $thisevent;
+                        }
+                    }
+                } else {
+                    $thisevent .= $_;
+                }
+            } else {
+                $event = 0;         
+                $thisevent = "";
+            }
+        }
+        if(/\(\@\)PACKAGE:\s*(.*\S)\s*$/) {
+            $packname = $1;
+			($package = $packname) =~ s/Win32::GUI:://;
+            print "Found package: '$package'\n" if $DEBUG == 1;
+			$D{$package}{name} = $packname;
+			$D{$package}{methods} = {} unless exists $D{$package}{methods};
+			$D{$package}{events}  = {} unless exists $D{$package}{events};
+			$D{$package}{attrs}   = {} unless exists $D{$package}{attrs};
+        }
+        if(/\(\@\)EVENT:\s*(.*\S)\s*/) {        
+            $event = $1;        
+            print "Found event: '$event'\n" if $DEBUG == 1;
+
+        }
+        if(/\(\@\)METHOD:\s*(.*\S)\s*/) {
+            $methodname = $1;
+            ($method = $methodname) =~ s/\(.*//;
+            print "Found method: '$method'\n" if $DEBUG == 1;
+			$D{$package}{methods}{$method} = "$methodname;;;";
+        }
+    }
+    close(FILE);
+}
+
+###############################################################################
+
+sub newfirst {
+    return ($a =~ /^new/) ? -1 : 
+           ($b =~ /^new/) ? 1 : uc($a) cmp uc($b);
+}
+
+sub HtmlOutput {
+    my $pak;
+    my $page;
+    my $sub;
+    my $subname;
+    my $syntax;
+    my $content;
+    my $newdone;
+
+    my $nofpackages = 0;
+    my $nofmethods = 0;
+    my $nofumethods = 0;
+    my $nofevents = 0;
+    my $nofuevents = 0;
+
+    open(INDEX, ">new.html");
+	print INDEX "
+		<HTML><HEAD><TITLE>new docs</TITLE></HEAD><BODY BGCOLOR=white>
+	";
+	# objects
+	print INDEX qq(<B><A HREF="#objects">OBJECTS</A></B> -- );
+	foreach $pak (sort keys %D) {
+		next if $pak eq "Win32::GUI";
+		push(@P, qq(<A HREF="#O_$pak">$pak</A>));
+	}
+	print INDEX join(", ", @P);
+	# attributes
+
+	# events
+	@P = ();
+	print INDEX "<P>";
+	print INDEX qq(<B><A HREF="#events">EVENTS</A></B> -- );
+	foreach $pak (sort keys %D) {
+		foreach $evt (sort keys %{$D{$pak}{events}}) {
+			$evt =~ s/\(.*$//;
+			next if exists $evt{$evt};
+			push(@P, qq(<A HREF="#E_$evt">$evt</A>));
+			$evt{$evt} = 1;
+		}
+	}
+	print INDEX join(", ", sort @P);
+	# methods
+	@P = ();
+	print INDEX "<P>";
+	print INDEX qq(<B><A HREF="#methods">METHODS</A></B> -- );
+	foreach $pak (sort keys %D) {
+		foreach $met (sort keys %{$D{$pak}{methods}}) {
+			next if $met =~ /^new /;
+			$met =~ s/\(.*$//;
+			next if exists $met{$met};
+			push(@P, qq(<A HREF="#M_$met">$met</A>));
+			$met{$met} = 1;
+		}
+	}
+	print INDEX join(", ", sort @P);
+
+
+	# constructors
+	print INDEX qq(<H1><A NAME="objects">OBJECTS</H1>);
+	foreach $pak (sort keys %D) {
+		next if $pak eq "Win32::GUI";
+		print INDEX qq(<H2><A NAME="O_$pak">$pak</H2>);
+		%met = ();
+		@P = ();
+		foreach $met (sort keys %{$D{$pak}{methods}}) {
+			next unless $met =~ /^new /;
+			($syntax, $content) = split(/;;;/, $D{$pak}{methods}{$met});
+			push(@P, qq(<TT>$syntax</TT><BR>$content));
+			$met{$met} = 1;
+		}
+		if($#P >= 0) {
+			print INDEX qq(<B>CONSTRUCTOR(S)</B><P>);
+			print INDEX join("<P>", @P);
+		}
+		%w = ();
+		@P = ();
+
+		foreach $w (sort keys %{$D{$pak}{methods}}) {
+			next if $w =~ /^new /;
+			$w =~ s/\(.*$//;
+			next if exists $w{$w};
+			push(@P, qq(<A HREF="#M_$w">$w</A>));
+			$w{$w} = 1;
+		}
+		if($#P >= 0) {
+			print INDEX "<P>";
+			print INDEX qq(<B>METHODS</B> -- );
+			print INDEX join(", ", @P);
+		}
+
+		%w = ();
+		@P = ();	
+		foreach $w (sort keys %{$D{$pak}{events}}) {
+			$w =~ s/\(.*$//;
+			next if exists $w{$w};
+			push(@P, qq(<A HREF="#E_$w">$w</A>));
+			$w{$w} = 1;
+		}
+		if($#P >= 0) {
+			print INDEX "<P>";
+			print INDEX qq(<B>EVENTS</B> -- );
+			print INDEX join(", ", @P);
+		}
+		print INDEX "<HR>";
+
+	}
+
+	print INDEX "</BODY></HTML>\n";
+	close(INDEX);
+    close(INDEX);
+}
+
+
+sub HtmlPage {
+    my($package) = @_;
+    # $package =~ s/^Win32::GUI:://;
+    $package =~ s/::/_/g;
+    return $package.".html";
+}
+
+sub HtmlStart {
+    my($title) = @_;
+    return "
+        <HTML>
+        <HEAD>
+        <TITLE>$title</TITLE>
+        </HEAD>
+        <BODY BGCOLOR=white>
+        <FONT FACE=\"Verdana, Tahoma, Arial, Helvetica\" SIZE=2>
+        <H3>$title</H3>
+    ";
+}
+
+sub HtmlHeading {
+    my($text) = @_;
+    return "<B>$text</B>\n";
+}
+
+sub HtmlDefinition {
+    my($package, $link, $term, $definition) = @_;
+    #$definition =~ s/\n/<BR>\n/g;
+    $definition =~ s/\n(\s*)/"<BR>\n"."&nbsp;" x length($1)/ge;
+    #$definition =~ s/\s/&nbsp;/g;
+    $definition =~ s
+        [see(&nbsp;|\s)*(also)?(&nbsp;|\s)*(.*\(\))]
+        ['see'.$1.$2.'&nbsp;'.HtmlInternalLink($package, $4)]gie;
+    if($definition eq "") {
+        print "TBD: ${package}::${term}\n";
+        $definition = "<I>[TBD]</I><BR>\n";
+    }
+    if($link =~ /^e_/) {
+        $term = "<I>OBJECT_</I><B>$term</B>";
+    } else {
+        $term = "<B>$term</B>";
+    }
+    return "
+        <DT><A NAME=\"$link\">$term
+        <DD>$definition<BR>
+    ";
+}
+
+sub HtmlList {
+    my($link, $item) = @_;
+    return "<LI><A HREF=\"$link\">$item</A>\n";
+}
+
+###############################################################################
+
+sub PodOutput {
+    my $pak;
+    my $page;
+    my $sub;
+    my $subname;
+    my $syntax;
+    my $content;
+    my $newdone;
+
+    my $nofpackages = 0;
+    my $nofmethods = 0;
+    my $nofumethods = 0;
+    my $nofevents = 0;
+    my $nofuevents = 0;
+
+    foreach $pak (sort keys %METHOD) {
+        $page = PodPage($pak);
+        open(POD, ">$page") or warn "$0: can't open $page for writing: $!";
+        print POD "=head2 Package $pak\n\n";
+        print POD "L<Back to the Packages|guipacks/>\n\n";
+        $newdone = 0;
+        print POD "=over\n\n";
+        foreach $sub (sort newfirst keys %{$METHOD{$pak}}) {
+            if(!$newdone) {
+                if($METHOD{$pak}{$sub} =~ /^new/) {
+                    print POD "=item *\n\nL<Constructor>\n\n=over\n\n";
+                } else {
+                    print POD "=item *\n\nL<Methods>\n\n=over\n\n";
+                }
+            } elsif($newdone == 2) {
+                print POD "=back\n\n=item *\n\nL<Methods>\n\n=over\n\n";
+                $newdone = 1;
+            }
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            if($METHOD{$pak}{$sub} =~ /^new/) {
+                $newdone = 2;
+            } else {
+                $newdone = 1;
+            }
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            ($subname = $syntax) =~ s/\|/&#124;/g;
+            print POD "=item *\n\nL<$subname|/".htmlify(0, $syntax).">\n\n";
+        }
+        if(keys %{$EVENT{$pak}} > 0) {
+            print POD "=back\n\n=item *\n\nL<Events>\n\n=over\n\n";
+            foreach $sub (sort keys %{$EVENT{$pak}}) {
+                $subname = $sub;
+                $subname =~ s/\(.*$//;
+                print POD "=item *\n\nL<$sub|/".htmlify(0, $sub).">\n\n";
+            }
+        }
+        print POD "=back\n\n=back\n\n";
+        $newdone = 0;
+        foreach $sub (sort newfirst keys %{$METHOD{$pak}}) {
+            if(!$newdone) {
+                if($METHOD{$pak}{$sub} =~ /^new/) {
+                    print POD "=head3 Constructor\n\n=over 4\n\n";
+                } else {
+                    print POD "=head3 Methods\n\n=over 4\n\n";
+                }
+            } elsif($newdone == 2) {
+                print POD "=back\n\n=head3 Methods\n\n=over 4\n\n";
+                $newdone = 1;
+            }
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            $nofmethods++;
+            $nofumethods++ if $content eq "";
+            if($METHOD{$pak}{$sub} =~ /^new/) {
+                $newdone = 2;
+            } else {
+                $newdone = 1;
+            }
+            print "METHOD<$pak><$sub>\n" if $DEBUG == 1;
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            print POD PodDefinition($pak, $syntax, $content);
+            #print POD "=head4 $syntax\n\n";
+            #print POD "$content\n\n";
+        }
+        if(keys %{$EVENT{$pak}} > 0) {
+            print POD "=back\n\n=head3 Events\n\n=over 4\n\n";
+        }
+        foreach $sub (sort keys %{$EVENT{$pak}}) {
+            $subname = $sub;
+            $subname =~ s/\(.*$//;
+            print POD PodDefinition($pak, $sub, $EVENT{$pak}{$sub});
+            #print POD "=head4 $sub\n\n";
+            #print POD "$EVENT{$pak}{$sub}\n\n";            
+        }
+        print POD "=back\n\n=cut\n";
+        close(POD);
+        $nofpackages++;
+    }
+
+    open(INDEX, ">pod/guipacks.pod") or warn "$0: can't open guipacks.pod for writing!";
+    print INDEX "=head2 Win32::GUI Packages\n\n";
+    print INDEX "L<Back to the index|gui/>\n\n";
+    print INDEX "=head3 Packages\n\n=over\n\n";
+    foreach $pak (sort keys %METHOD) {
+        $page = PodPage($pak);
+        $page =~ s/\.pod//;
+		$page =~ s/^pod\///;
+        print INDEX "=item *\n\nL<$pak|$page/>\n\n";
+    }
+    print INDEX "=back\n\n=cut\n";
+    close(INDEX);
+
+    print STDERR "$nofpackages packages.\n";
+    print STDERR "$nofmethods methods ($nofumethods undocumented).\n";
+    print STDERR "$nofevents events ($nofuevents undocumented).\n";
+}
+
+sub PodPage {
+    my($package) = @_;
+    $package =~ s/^Win32::GUI:://;
+    $package =~ s/::/_/g;
+    return "pod/$package.pod";
+}
+
+sub PodDefinition {
+    my($package, $term, $definition) = @_;
+    #
+    # properly split literal paragraphs from plain text
+    #
+    my(@lines) = split(/\n/, $definition);
+    foreach my $i (0..$#lines) {
+        if($lines[$i] =~ /^\S/ and $lines[$i+1] =~ /^\s/) {
+            $lines[$i] .= "\n";
+        }
+        if($lines[$i] =~ /^\s/ and $lines[$i+1] =~ /^\S/) {
+            $lines[$i] .= "\n";
+        }
+    }
+    $definition = join("\n", @lines);
+    #$definition =~ s/\n(\S.*)\n/\n$1\n\n/g;
+    #$definition =~ s/\n(\s.*)\n(\S)/\n\n$1\n\n$2/g;
+    $definition =~ s
+        [(see\s*)(also)?(\s*)(.*\(\))]
+        [$1.$2.$3.' '.PodInternalLink($package, $4)]gie;
+    if($definition eq "") {
+        # print "TBD: ${package}::${term}\n";
+        $definition = "[TBD]\n\n";
+    }
+    
+    return 
+    "=for html <A NAME=\"".htmlify(0, $term)."\">\n\n"
+    .
+    "=item $term\n\n$definition\n\n"
+    .
+    "=for html <P>\n\n"
+    ;
+}
+
+sub PodInternalLink {
+    my($package, $link) = @_;
+    my $pak;
+    $link =~ s/^\s*//;
+    $link =~ s/\s*$//;
+    my $name = substr($link, 0, index($link, '('));
+    if(defined($METHOD{$package}{$name})) {
+        my $section = PodLinkSyntax($package, $name);
+        return "L<$link|/$section>";
+    } elsif(defined($EVENT{$package}{$name})) {
+        return "L<$link|/$name>";
+    } else {
+        foreach $pak (sort keys %METHOD) {
+            if($METHOD{$pak}{$name}) {
+                my $section = PodLinkSyntax($pak, $name);
+                my $page = PodPage($pak);
+                $page =~ s/\.pod//;
+                $page =~ s/^pod\///;
+                return "L<$link|".$page."/$section>";
+            } elsif($EVENT{$pak}{$name}) {
+                my $page = PodPage($pak);
+                $page =~ s/\.pod//;
+                $page =~ s/^pod\///;
+				return "L<$link|".$page."/$name>";
+            }
+        }
+    }
+    warn "broken link (package: $package, link: $name)\n";
+    return $link;
+}
+
+sub PodLinkSyntax {
+    my($package, $name) = @_;
+    my ($syntax, $content) = split(/;;;/, $METHOD{$package}{$name});
+    return htmlify(0, $syntax);
+}
+
+sub PodOutput_OLD {
+    my $pak;
+    my $page;
+    my $sub;
+    my $subname;
+    my $syntax;
+    my $content;
+    my $newdone;
+
+    my $nofpackages = 0;
+    my $nofmethods = 0;
+    my $nofumethods = 0;
+    my $nofevents = 0;
+    my $nofuevents = 0;
+
+    foreach $pak (sort keys %METHOD) {
+        $page = PodPage($pak);
+        open(POD, ">$page") or warn "$0: can't open $page for writing: $!";
+        print POD "=head2 Package $pak\n\n";
+        print POD "L<Back to the Packages|guipacks/>\n\n";
+        $newdone = 0;
+        print POD "=over\n\n";
+        foreach $sub (sort newfirst keys %{$METHOD{$pak}}) {
+            if(!$newdone) {
+                if($METHOD{$pak}{$sub} =~ /^new/) {
+                    print POD "=item *\n\nL<Constructor>\n\n=over\n\n";
+                } else {
+                    print POD "=item *\n\nL<Methods>\n\n=over\n\n";
+                }
+            } elsif($newdone == 2) {
+                print POD "=back\n\n=item *\n\nL<Methods>\n\n=over\n\n";
+                $newdone = 1;
+            }
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            if($METHOD{$pak}{$sub} =~ /^new/) {
+                $newdone = 2;
+            } else {
+                $newdone = 1;
+            }
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            ($subname = $syntax) =~ s/\|/&#124;/g;
+            print POD "=item *\n\nL<$subname|/".htmlify(0, $syntax).">\n\n";
+        }
+        if(keys %{$EVENT{$pak}} > 0) {
+            print POD "=back\n\n=item *\n\nL<Events>\n\n=over\n\n";
+            foreach $sub (sort keys %{$EVENT{$pak}}) {
+                $subname = $sub;
+                $subname =~ s/\(.*$//;
+                print POD "=item *\n\nL<$sub|/".htmlify(0, $sub).">\n\n";
+            }
+        }
+        print POD "=back\n\n=back\n\n";
+        $newdone = 0;
+        foreach $sub (sort newfirst keys %{$METHOD{$pak}}) {
+            if(!$newdone) {
+                if($METHOD{$pak}{$sub} =~ /^new/) {
+                    print POD "=head3 Constructor\n\n";
+                } else {
+                    print POD "=head3 Methods\n\n";
+                }
+            } elsif($newdone == 2) {
+                print POD "=head3 Methods\n\n";
+                $newdone = 1;
+            }
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            $nofmethods++;
+            $nofumethods++ if $content eq "";
+            if($METHOD{$pak}{$sub} =~ /^new/) {
+                $newdone = 2;
+            } else {
+                $newdone = 1;
+            }
+            print "METHOD<$pak><$sub>\n" if $DEBUG == 1;
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            print POD PodDefinition($pak, $syntax, $content);
+            #print POD "=head4 $syntax\n\n";
+            #print POD "$content\n\n";
+        }
+        if(keys %{$EVENT{$pak}} > 0) {
+            print POD "=head3 Events\n\n";
+        }
+        foreach $sub (sort keys %{$EVENT{$pak}}) {
+            $subname = $sub;
+            $subname =~ s/\(.*$//;
+            print POD "=head4 $sub\n\n";
+            print POD "$EVENT{$pak}{$sub}\n\n";            
+        }
+        print POD "=cut\n";
+        close(POD);
+        $nofpackages++;
+    }
+
+    open(INDEX, ">guipacks.pod") or warn "$0: can't open guipacks.pod for writing!";
+    print INDEX "=head2 Win32::GUI Packages\n\n";
+    print INDEX "L<Back to the index|gui/>\n\n";
+    print INDEX "=head3 Packages\n\n=over\n\n";
+    foreach $pak (sort keys %METHOD) {
+        $page = PodPage($pak);
+        $page =~ s/\.pod//;
+        print INDEX "=item *\n\nL<$pak|$page/>\n\n";
+    }
+    print INDEX "=back\n\n=cut\n";
+    close(INDEX);
+
+    print STDERR "$nofpackages packages.\n";
+    print STDERR "$nofmethods methods ($nofumethods undocumented).\n";
+    print STDERR "$nofevents events ($nofuevents undocumented).\n";
+}
+
+sub TbdOutput {
+    my $pak;
+    my $page;
+    my $sub;
+    my $subname;
+    my $syntax;
+    my $content;
+    my $newdone;
+
+    my $nofpackages = 0;
+    my $nofmethods = 0;
+    my $nofumethods = 0;
+    my $nofevents = 0;
+    my $nofuevents = 0;
+
+    foreach $pak (sort keys %METHOD) {
+        foreach $sub (sort newfirst keys %{$METHOD{$pak}}) {
+            ($syntax, $content) = split(/;;;/, $METHOD{$pak}{$sub});
+            $nofmethods++;
+            if($content eq "") {
+                $nofumethods++;
+                print "Method: ${pak}::$sub\n";
+            }            
+        }
+        if(keys %{$EVENT{$pak}} > 0) {
+            foreach $sub (sort keys %{$EVENT{$pak}}) {
+                $nofevents++;
+                if($EVENT{$pak}{$sub} eq "") {
+                    $nofuevents++;
+                    print "Event: ${pak}::$sub\n";
+                }
+            }
+        }
+        $nofpackages++;
+    }
+    print STDERR "$nofpackages packages.\n";
+    print STDERR "$nofmethods methods ($nofumethods undocumented).\n";
+    print STDERR "$nofevents events ($nofuevents undocumented).\n";
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/dohtml.pl perl-libwin32-0.191/GUI/docs/dohtml.pl
--- libwin32-0.191/GUI/docs/dohtml.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/dohtml.pl	2004-01-12 16:46:40.343750000 -0800
@@ -0,0 +1,122 @@
+use Pod::Html;
+use File::Copy;
+use Win32::GUI;
+
+@toindex = qw(
+    guioptions
+    guiconcepts
+);
+
+opendir(D, "..");
+while($infile = readdir(D)) {
+    next unless $infile =~ /\.pm$/i
+            and $infile !~ /^GUI\.pm$/i;
+    ($outfile = $infile) =~ s/\.pm$/.pod/i;   
+    copy("../$infile", "pod/$outfile");
+    $infile =~ s/\.pm$//i;
+	print "found support_pack: $infile\n";
+    push(@support_pack, $infile);
+}
+closedir(D);
+
+open(P, "<GUI.pod");
+open(N, ">GUI.new");
+$found = "no";
+$ver = Win32::GUI::Version();
+($mday,$mon,$year) = (localtime)[3..5];
+@monthname = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
+$date = sprintf("%02d %3s %4d", $mday, $monthname[$mon], $year+1900);
+while(<P>) {
+    if(/Support packages/i) {
+        print N $_;
+        $found = "yes";
+    }
+    if($found ne "no") {        
+        if(/^=back/) {
+            print N $_;
+            $found = "no";
+        }
+        if($found eq "yes") {
+            print N "\n\n=over 4\n\n";
+            foreach $p (@support_pack) {
+                ($n = $p) =~ s/^/Win32::GUI::/;
+                print N "=item *\n\nL<$n|$p/>\n\n";
+            }
+            $found = "done";
+        }
+    } else {
+        s/^Version:\s+.*/Version: B<$ver>, $date/io and print "found VERSION on line $.\n";
+        print N $_;
+    }
+}
+close(P);
+close(N);
+unlink("GUI.pod");
+rename("GUI.new", "GUI.pod");
+
+system("copy *.pod pod");
+
+chdir("./pod");
+opendir(D, ".");
+@files = readdir(D);
+foreach $infile (sort @files) {
+    next unless $infile =~ /\.pod$/i;
+    ($outfile = $infile) =~ s/\.pod$/.html/i;
+    pod2html(
+        "--htmlroot=.", 
+        "--podpath=.", 
+        "--infile=./$infile",
+        "--outfile=../html/$outfile",
+        "--noindex",
+    );
+}
+closedir(D);
+chdir("..");
+
+foreach $file (@toindex) {
+    open(P, "pod/$file.pod");
+    @poddata = <P>;
+    close(P);
+    $index = Pod::Html::scan_headings(\%sections, @poddata);
+    $index =~ s/<LI>.*\n//;
+    1 while ($index =~ s/<UL>([\s\n]*)<UL>/<UL>/);
+    1 while ($index =~ s/<\/UL>([\s\n]*)<\/UL>/<\/UL>/);
+    $opened++ while ($index =~ /<UL>/g);
+    $closed++ while ($index =~ /<\/UL>/g);
+    if($opened > $closed) {
+        $index .= "</UL>" x ($opened-$closed);
+    }
+    open(H, "<html/$file.html");
+    open(N, ">html/$file.new");
+    $idone = 0;
+    while(<H>) {    
+        if($idone == 2) {
+            next if /^\s*$/ or /^\s*<(P|BR)>\s*$/;
+            print N "<HR>" unless /<HR>/;
+            $idone = 3;
+        }
+        print N $_;        
+        if($idone == 1) {
+            print N $index;
+            $idone = 2;
+        }
+        if(/<A HREF=.*>Back/ and not $idone) {
+            $idone = 1;
+        }
+    }
+    close(H);
+    close(N);
+    unlink("html/$file.html");
+    rename("html/$file.new", "html/$file.html");
+}
+
+#$exists = Win32::GUI::FindWindow(
+#    '', 
+#    'Win32::GUI Documentation - Microsoft Internet Explorer',
+#);
+#if($exists) {
+#    print "window is a ", Win32::GUI::GetClassName($exists), "\n";
+#    Win32::GUI::BringWindowToTop($exists);
+#} else {
+#    system("start html\\gui.html");
+#}
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/events.pod perl-libwin32-0.191/GUI/docs/events.pod
--- libwin32-0.191/GUI/docs/events.pod	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/events.pod	2004-01-12 16:46:40.359375000 -0800
@@ -0,0 +1,31 @@
+=head1 Win32::GUI events
+
+=for HTML <TT>
+
+=head2 Click()
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Timer()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Sent when the Timer reaches its timeout value,
+eg. after the number of milliseconds specified
+when creating the Timer.
+
+
+
+
+B<Applies to>: L<Timer|packages/Timer>
+
+=for HTML </BLOCKQUOTE>
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/guiconcepts.pod perl-libwin32-0.191/GUI/docs/guiconcepts.pod
--- libwin32-0.191/GUI/docs/guiconcepts.pod	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/guiconcepts.pod	2004-01-12 16:46:40.375000000 -0800
@@ -0,0 +1,522 @@
+=head2 Win32::GUI General Concepts
+
+L<Back to the index|gui/>
+
+=head3 Packages
+
+Packages in Win32::GUI can be divided into three main
+categories: B<Windows>, B<Controls> and B<Resources>;
+but a big part of the core of this module is in the
+L<Win32::GUI|Win32_GUI/> package. All the generic
+functions are defined there, and all the components 
+of the user interface inherit from it, so that most 
+of the functions that refer to windows (eg. Show, Hide,
+Height, Enable, and so on) apply to every object and
+can be used as their methods:
+
+    $Window->Show();
+    $Window->Button1->Show();
+
+Some other functions (like for example GetCursorPos)
+aren't applicable to an object, and they require
+a fully qualified call including the package name:
+
+    ($x, $y) = Win32::GUI::GetCursorPos();
+
+L<Windows> are the well known windows that you see on 
+your screen; your script will probably generate one
+or more window that contain your user interface;
+this content is usually made up of L<Controls> (eg.
+labels, buttons, input fields and so on).
+They can also be considered as child windows,
+and, as said, they are all inherited from the 
+Win32::GUI package.
+
+L<Resources> are of a different category: they
+build up, so to say, the graphical Windows
+toolkit (usually referred to as GDI, Graphics
+Device Interface); you'll find there fonts, 
+brushes, bitmaps, icons, cursors and so on.
+These objects are generally associated with
+your windows and controls (eg. you can set
+a windows or controls font); some of them,
+like pens and brushes, are used instead with
+the L<Win32::GUI::DC|DC/> package, which
+implement the drawing primitives.
+
+There are then some packages that simply don't
+fit into the three categories above, because
+their use goes beyond the simple user interface:
+this is the case with L<Win32::GUI::Class|Class/>
+and the mentioned L<Win32::GUI::DC|DC/>.
+
+
+=head3 Objects
+
+You create an object using its B<constructor>,
+which is usally of the form:
+
+    $Object = new Win32::GUI::<something>( <options> );
+
+where <something> is the class of the object you want 
+to create (eg. Window, Menu, Font, etc.) and <options>
+are the characteristics of your object. Once you have
+the $Object variable, you can invoke methods on it:
+
+    $Object->Show();
+
+A different approach is possible with B<Controls>.
+Usually, once you created your $Window object, you
+will add controls in it with this construct:
+
+    $Window->AddButton( <options> );
+
+This function will return a $Button object as you
+may expect, but you don't need to store it in a
+variable: Win32::GUI will use the very special
+C<-name> option to store the object reference
+in the window as a named key (or sub-object):
+
+    $Window->AddButton( -name => "Button1" );
+    $Window->Button1->Show();
+    # or
+    $Window->{'Button1'}->Show();
+
+These sub-objects are really hash keys, but
+for your convenience are also AUTOLOAD'ed
+as if they were subroutines (see AutoLoader.pm
+for details); this can introduce some confusion
+if you name an object with the same name as a
+Win32::GUI function.
+
+    $Window->AddButton( -name => "Show" );
+    $Window->Show->Show();
+
+This syntax will not work because "Show" is
+already defined as a method of your $Window
+object. The advice is to use a different
+name for your object, but if you B<really>
+can't renounce to it, you can still use the
+safer syntax:
+
+    $Window->{'Show'}->Show();
+
+It is of course always possible, if you don't
+mind using too much variables, to use the 
+less elegant form:
+
+    $Button1 = $Window->AddButton( ... );
+    $Button1->Show();
+
+=head3 Options
+
+The definition of an object is made up of
+B<options>, which are pretty much
+like an associative array; option names
+are always lowercase and preceded by a dash (-),
+while their value vary (can be strings,
+numbers, objects or array references).
+
+A number of options is common to any window
+(and control), and they're documented in 
+L<Common options|guioptions/>; furthermore,
+different objects have different specific
+options, documented in the single packages
+reference.
+
+The most important option for a window is
+C<-name>; this defines the name of the object
+in its container (as explained above) and
+the name used in the L<Events> naming 
+convention:
+
+    $Window->AddButton( -name => "Button1" );
+    
+    $Window->Button1->Show();
+    
+    sub Button1_Click { print "ouch!\n"; }
+
+An example of using a complete set of options:
+
+    $Window = new Win32::GUI::Window(
+        -name   => "Window",
+        -title  => "Perl Window Example",
+        -left   => 100,  
+        -top    => 100,
+        -width  => 500, 
+        -height => 400,         
+        -menu   => $Menu,
+    );
+
+=head3 The dialog phase
+
+After creating your windows and done all the needed
+initialization processes, you may probably want your
+script to present the user with a window and await
+for his actions; in other words, you want to interact
+with the user. This is done in the dialog phase.
+
+To enter the dialog phase simply call this instruction:
+
+    Win32::GUI::Dialog();
+
+or better yet, if you want to check the exit code
+of your GUI program:
+
+    $exitcode = Win32::GUI::Dialog();
+
+When the script encounter this instruction, its 
+execution halts and the user has the ability to 
+interact with what's on the screen. Since windows
+are by default created in an invisible state, you
+may probably call before something like:
+
+    $Window->Show();
+
+if your program is supposed to start with $Window
+as its entry point.
+
+While in the dialog phase, user's actions will
+generate B<Events> as needed. This phase ends
+when an event returns -1 or you press Cancel
+in response to a program error (see below for
+more details); when it ends, the control returns
+to the main body of your script (at the line after
+the one with the Win32::GUI::Dialog call) 
+and it can go on normally.
+
+
+=head3 Events
+
+Events are Perl subs that are called in response
+to an event occurred in the user interface, usually
+generated by an action of the user. For example,
+a button has a Click event that is called when the
+user pushes it. The naming convention for events
+follows the Microsoft Visual Basic's one; its form
+is:
+
+    OBJECTNAME_Eventname
+
+(note there's an underscore in between),
+where B<OBJECTNAME> is the value of the C<-name>
+option used when creating the object, and 
+B<Eventname> is the event name, eg. Click.
+So if you have a button named C<Button1>, your
+Click event will be defined as follows:
+
+    sub Button1_Click {
+        # ...do something...
+    }
+
+The code inside will be executed when C<Button1>
+gets pressed.
+
+Win32::GUI also interprets the value returned
+by the sub; unless otherwise documented in the
+event description, the meaning of the return
+value is:
+
+=over
+
+=item * 1 (one, or a true value)
+
+the script proceeds normally and the event is
+passed to the underlying default event 
+processor.
+
+=item * 0 (zero)
+
+the dialog phase continues but the event is
+not passed to the default event processor
+(what this means effectively depends on the
+event).
+
+=item * -1 (minus one)
+
+the dialog phase ends, and control returns to
+the main body of your script. You will much
+probably use this to end your program:
+
+    sub Window_Terminate {
+        return -1;
+    }
+
+=back
+
+The behaviour of the default event processor
+depends on the control and the event; in case
+of doubt, is always a good idea to end your event 
+with an explicit:
+
+    return 1;
+
+Finally, you should note that events are really
+B<evaluated> (as if they were called with C<eval()>),
+so that errors are trapped, and a message box is shown.
+This box reports the offending event name on the title bar, 
+the error message in its body and has OK and Cancel
+buttons. If you press OK, Win32::GUI will ignore the
+error and go on with the dialog (the event, of course,
+doesn't take place); if you press Cancel instead the
+dialog will end (with return code -1).
+This means that for example if you define an event like:
+
+    sub Button1_Click {
+        die();
+    }
+
+your script will not die immediately at the click of a
+button, but the message box will appear, reporting for 
+example "Died at script.pl line 73".
+
+
+=head3 Windows
+
+In its widest acception, windows include what you normally
+call a window (sometimes referred to as a "top level window"),
+controls (sometimes referred to as "child windows") and even 
+L<Non-owned windows> (not created by Win32::GUI).
+
+Real (top level) windows are the container of your user
+interface; Win32::GUI defines two packages, L<Window|Window/>
+and L<DialogBox|DialogBox/>. By default, a Window has a title
+bar, the usual minimize/maximize/close buttons, a system
+menu (the button on the top left corner) and resizable borders. 
+A DialogBox is very similar, except that by default it cannot 
+be resized and it doesn't have the minimize and maximize buttons.
+The main difference between the two packages is in the dialog
+phase; DialogBox intercepts the tab and arrow keys to switch 
+between controls, the use of Return and Esc for the Ok and
+Cancel button and accelerators, while Window not.
+
+=head3 Controls
+
+Also known as "widgets" , these represent the content of 
+your windows, and includes almost all the controls provided
+by Windows:
+
+=over
+
+=item *
+
+L<Animation|Animation/>
+
+=item *
+
+L<Button|Button/>
+
+=item *
+
+L<Checkbox|Checkbox/>
+
+=item *
+
+L<Combobox|Combobox/>
+
+=item *
+
+L<Label|Label/>
+
+=item *
+
+L<ListView|ListView/>
+
+=item *
+
+L<Listbox|Listbox/>
+
+=item *
+
+L<NotifyIcon|NotifyIcon/>
+
+=item *
+
+L<ProgressBar|ProgressBar/>
+
+=item *
+
+L<RadioButton|RadioButton/>
+
+=item *
+
+L<Rebar|Rebar/>
+
+=item *
+
+L<RichEdit|RichEdit/>
+
+=item *
+
+L<Slider|Slider/>
+
+=item *
+
+L<StatusBar|StatusBar/>
+
+=item *
+
+L<TabStrip|TabStrip/>
+
+=item *
+
+L<Textfield|Textfield/>
+
+=item *
+
+L<Timer|Timer/>
+
+=item *
+
+L<Toolbar|Toolbar/>
+
+=item *
+
+L<Tooltip|Tooltip/>
+
+=item *
+
+L<TreeView|TreeView/>
+
+=item *
+
+L<UpDown|UpDown/>
+
+=back
+
+=head3 Resources
+
+=over
+
+=item *
+
+L<Bitmap|Bitmap/>
+
+=item *
+
+L<Brush|Brush/>
+
+=item *
+
+L<Cursor|Cursor/>
+
+=item *
+
+L<Font|Font/>
+
+=item *
+
+L<Icon|Icon/>
+
+=item *
+
+L<ImageList|ImageList/>
+
+=item *
+
+L<Menu|Menu/>
+
+=item *
+
+L<MenuButton|MenuButton/>
+
+=item *
+
+L<MenuItem|MenuItem/>
+
+=item *
+
+L<Pen|Pen/>
+
+=back
+
+=head3 Others
+
+=over
+
+=item *
+
+L<Class|Class/>
+
+=item *
+
+L<DC|DC/>
+
+=back
+
+=head3 Non-owned windows
+
+Every window, even windows not created by your Perl script,
+can be referenced by Win32::GUI; all you need to know is
+its "handle", a numerical value that identifies that window.
+Many functions in the Win32::GUI package return such handles,
+as for example:
+
+    $First = Win32::GUI::GetForegroundWindow();
+
+This value can then be passed to any function that requires
+a window object; but of course, not being an object, you can't
+call it as a method:
+
+    Win32::GUI::Hide($First); # correct
+    $First->Hide();           # wrong
+
+Should you need to know the numerical handle of a window
+created by Win32::GUI, it is stored in its C<-handle> key
+(this is the value that almost all function really use):
+
+    print "Window handle is $Window->{-handle} \n";
+
+=head3 Colors
+
+Wherever you need to express a color, there are two
+possibilities: 
+
+=over 4
+
+=item first: 
+
+Use a numeric value that
+contains red, green and blue components
+(that's the form Windows uses); expressing this
+form in hexadecimal, components are reversed with
+respect to the traditional (RGB) order:
+
+    0xBBGGRR
+
+Each components range is 0 to 0xFF, or 255; 
+a value of 0, 0, 0 (0x000000) represents black,
+while a value of 255, 255, 255 (0xFFFFFF) represents
+white.
+The following are all valid color definitions in
+hexadecimal and decimal format (for practical reasons, 
+you would probably prefer the hexadecimal notation):
+
+    $color = 0xFF0000;  # blue
+    $color = 16711680;  # blue
+    $color = 255 << 16; # blue
+    $color = 0x00FF00;  # green
+    $color = 65280;     # green
+    $color = 0x80FFFF;  # pale yellow
+    $color = 8454143;   # pale yellow
+
+=item second:
+
+Use a reference to a list with 3 values that
+express the red, green and blue components as above:
+
+    [ R, G, B ]
+
+Note that this is NOT a plain list (since a color
+is usually one parameter in a list of parameters to a 
+function, it wouldn't make much sense); so the following
+forms are valid:
+
+    [ 0, 0, 0 ]
+    [ 255, 255, 255]
+    [ 0x80, 0xFF, 0xFF ]
+    \@color
+
+=back
+
+=cut
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/guioptions.pod perl-libwin32-0.191/GUI/docs/guioptions.pod
--- libwin32-0.191/GUI/docs/guioptions.pod	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/guioptions.pod	2004-01-12 16:46:40.390625000 -0800
@@ -0,0 +1,138 @@
+
+=head2 Win32::GUI Common Options
+
+L<Back to the index|gui/>
+
+This document illustrates the options available when creating
+an object (in particular, windows and controls).
+Here you'll find the general options, the ones that apply to
+every window class; for class-specific options, refer to that
+package reference.
+
+=head3 List of available options
+
+=head4 -background => COLOR
+
+Defines the background color for the control.
+Note that not all controls support background and foreground
+colors.
+
+=head4 -class => CLASS
+
+Specifies the window class (which is different
+from the Perl's object class, eg. Win32::GUI::Button) for
+the window; all the predefined objects have hardcoded class
+names (eg. "BUTTON" for Win32::GUI::Button), so you shouldn't
+want to pick a different one unless you are familiar with
+window classes and you want to subclass an existing one.
+This technique is documented in the Microsoft Platform SDK 
+Reference, and (at a lighter level) in L<guiclasses.pod>.
+The CLASS parameter can be either a name or a reference
+to a L<Win32::GUI::Class|Class/> object. 
+As for many other options in Win32::GUI, 
+its use is B<not recommended> unless 
+you know what you're doing.
+
+=head4 -disabled => 0/1
+
+Sets the initial enabled state for the control; by default
+this option is 0 (the control is enabled). Set it to 1
+to create a control which is initially disabled.
+
+=head4 -font => FONT
+
+Defines the font for the control; must be a Win32::GUI::Font
+object.
+
+=head4 -foreground => COLOR
+
+Defines the foreground color for the control.
+Note that not all controls support background and foreground
+colors.
+
+=head4 -group => 0/1
+
+[TBD]
+
+=head4 -height => NUMBER
+
+Specifies the height of the window in pixels.
+
+=head4 -left => NUMBER
+
+Specifies the left position (X coordinate) for the window,
+in pixels. For Windows and DialogBoxes is absolute (screen
+position), while for controls is relative to the client
+area of their parent window.
+
+=head4 -menu => MENU
+
+[TBD]
+
+=head4 -name => STRING
+
+Defines the name for the control. The name is used to
+callback its events and to access its methods, so it
+is absolutely B<necessary>, and each name must be
+unique in your application.
+
+Example:
+
+	$Window->AddButton(
+		-name => "Button1",
+		# ...
+	);
+
+	# methods...
+	$Window->Button1->Hide();
+
+	# events...
+	sub Button1_Click {
+		# ...
+	}
+
+=head4 -style => NUMBER
+
+[TBD]
+
+=head4 -tabstop => 0/1
+
+If 1, the control can be enabled by pressing
+the TAB key to switch between controls.
+Note that this functionality is available
+in DialogBox objects only, not in Window,
+so the control must be child of a DialogBox
+for this option to be effective.
+
+=head4 -text => STRING
+
+Specifies the STRING that will appear on
+the window's caption or in the control's body (eg. a
+Label text, a Button caption, a Textfield content, and
+so on). Its use depends of course on the control type;
+some controls, like ProgressBars, makes no use of it
+at all.
+
+=head4 -title => STRING
+
+A synonim for L<-text|/_text_STRING>.
+
+=head4 -top => NUMBER
+
+Specifies the top position (Y coordinate) for the window,
+in pixels. For Windows and DialogBoxes is absolute (screen
+position), while for controls is relative to the client
+area of their parent window.
+
+=head4 -visible => 0/1
+
+Sets the initial visibility state for the control; by default
+this option is 1 (the control is visible). Set it to 0
+to create a control which is initially hidden.
+
+=head4 -width => NUMBER
+
+Specifies the width of the window in pixels.
+
+
+=cut
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/AcceleratorTable.html perl-libwin32-0.191/GUI/docs/html/AcceleratorTable.html
--- libwin32-0.191/GUI/docs/html/AcceleratorTable.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/AcceleratorTable.html	2004-01-12 16:46:40.406250000 -0800
@@ -0,0 +1,137 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::AcceleratorTable</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_AcceleratorT">Package Win32::GUI::AcceleratorTable</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_AcceleratorT">Package Win32::GUI::AcceleratorTable</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_AcceleratorTable">new Win32::GUI::AcceleratorTable(%ACCELERATORS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Click_">Click()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_AcceleratorTable">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::AcceleratorTable(%ACCELERATORS)</A></STRONG><DD>
+<P>
+Creates an AcceleratorTable object. <CODE>%ACCELERATORS</CODE> is an
+associative array of key combinations and accelerator names, in pair:
+Example:
+
+</P>
+<P>
+<PRE>    $A = new Win32::GUI::AcceleratorTable(
+        &quot;Ctrl-X&quot;       =&gt; &quot;Close&quot;,
+        &quot;Shift-N&quot;      =&gt; &quot;New&quot;,
+        &quot;Ctrl-Alt-Del&quot; =&gt; &quot;Reboot&quot;,
+    );
+</PRE>
+</P>
+<P>
+The AcceleratorTable object can be associated to a window with the -accel
+option; then, when an accelerator is used, a corresponding
+&lt;name&gt;_Click event is fired. Keyboard combinations currently support
+the following modifier :
+
+</P>
+<P>
+<PRE>    Shift
+    Ctrl  (or Control)
+    Alt
+</PRE>
+</P>
+<P>
+and the following keys:
+
+</P>
+<P>
+<PRE>    A..Z, 0..9
+    Left, Right, Up, Down
+    Home, End, PageUp, PageDown (or PgUp/PgDn)
+    Space, Ins, Del, Esc, Backspace, Tab, Return
+    F1..F12
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Click_">
+
+<DL>
+<DT><STRONG><A NAME="item_Click">Click()</A></STRONG><DD>
+<P>
+Sent when the users triggers an Accelerator object.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Animation.html perl-libwin32-0.191/GUI/docs/html/Animation.html
--- libwin32-0.191/GUI/docs/html/Animation.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Animation.html	2004-01-12 16:46:40.421875000 -0800
@@ -0,0 +1,177 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Animation</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Animation">Package Win32::GUI::Animation</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Animation">Package Win32::GUI::Animation</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Animation_PARENT">new Win32::GUI::Animation(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Close_">Close()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Open_FILE_">Open(FILE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Play_FROM_TO_REPEAT_">Play([FROM], [TO], [REPEAT])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Seek_FRAME_">Seek(FRAME)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Stop_">Stop()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Animation_PARENT">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Animation(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new Animation object; can also be called as
+PARENT-&gt;AddAnimation(%OPTIONS). Class specific <CODE>%OPTIONS</CODE>
+are:
+
+</P>
+<P>
+<PRE>  -autoplay    =&gt; 0/1 (default 0)
+    starts playing the animation as soon as an AVI clip is loaded
+  -center      =&gt; 0/1 (default 0)
+    centers the animation in the control window
+  -transparent =&gt; 0/1 (default 0)
+    draws the animation using a transparent background
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="Close_">
+
+<DL>
+<DT><STRONG><A NAME="item_Close">Close()</A></STRONG><DD>
+<P>
+Closes an AVI clip and displays its first frame in an animation control
+
+</P>
+<P>
+
+<A NAME="Open_FILE_">
+
+<DT><STRONG><A NAME="item_Open">Open(FILE)</A></STRONG><DD>
+<P>
+Opens an AVI clip and displays its first frame in an animation control. 
+
+</P>
+<P>
+
+<A NAME="Play_FROM_TO_REPEAT_">
+
+<DT><STRONG><A NAME="item_Play">Play([FROM], [TO], [REPEAT])</A></STRONG><DD>
+<P>
+Plays an AVI clip in an animation control.     
+
+</P>
+<P>
+
+<A NAME="Seek_FRAME_">
+
+<DT><STRONG><A NAME="item_Seek">Seek(FRAME)</A></STRONG><DD>
+<P>
+Directs an animation control to display a particular frame of an AVI clip.
+
+</P>
+<P>
+
+<A NAME="Stop_">
+
+<DT><STRONG><A NAME="item_Stop">Stop()</A></STRONG><DD>
+<P>
+Stops playing an AVI clip in an animation control. 
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Bitmap.html perl-libwin32-0.191/GUI/docs/html/Bitmap.html
--- libwin32-0.191/GUI/docs/html/Bitmap.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Bitmap.html	2004-01-12 16:46:40.437500000 -0800
@@ -0,0 +1,148 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Bitmap</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Bitmap">Package Win32::GUI::Bitmap</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Bitmap">Package Win32::GUI::Bitmap</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Bitmap_FILENAME_">new Win32::GUI::Bitmap(FILENAME, [TYPE, X, Y, FLAGS])</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Create_WIDTH_HEIGHT_PLANES_BP">Create(WIDTH, HEIGHT, PLANES, BPP, DATA)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetDIBits_">GetDIBits()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Info_">Info()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Bitmap_FILENAME_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Bitmap(FILENAME, [TYPE, X, Y, FLAGS])</A></STRONG><DD>
+<P>
+Creates a new Bitmap object reading from FILENAME; all other arguments are
+optional. TYPE can be:
+
+</P>
+<P>
+<PRE>  0  bitmap (this is the default)
+  1  icon
+  2  cursor
+</PRE>
+</P>
+<P>
+You can eventually specify your desired size for the image with X and Y and
+pass some FLAGS to the underlying LoadImage API (at your own risk)
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="Create_WIDTH_HEIGHT_PLANES_BP">
+
+<DL>
+<DT><STRONG><A NAME="item_Create">Create(WIDTH, HEIGHT, PLANES, BPP, DATA)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetDIBits_">
+
+<DT><STRONG><A NAME="item_GetDIBits">GetDIBits()</A></STRONG><DD>
+<P>
+The GetDIBits function retrieves the bits of the specified bitmap and
+copies them into a buffer using the specified format. 
+
+</P>
+<P>
+
+<A NAME="Info_">
+
+<DT><STRONG><A NAME="item_Info">Info()</A></STRONG><DD>
+<P>
+returns a four elements array containing the following information about
+the bitmap: width, height, color planes, bits per pixel or undef on errors
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/BitmapInline.html perl-libwin32-0.191/GUI/docs/html/BitmapInline.html
--- libwin32-0.191/GUI/docs/html/BitmapInline.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/BitmapInline.html	2004-01-12 16:46:40.453125000 -0800
@@ -0,0 +1,214 @@
+<HTML>
+<HEAD>
+<TITLE>Win32::GUI::BitmapInline - Inline bitmap support for Win32::GUI</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<LI><A HREF="#NAME">NAME</A></LI>
+	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A></LI>
+	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A></LI>
+	<LI><A HREF="#WARNINGS">WARNINGS</A></LI>
+	<LI><A HREF="#VERSION">VERSION</A></LI>
+	<LI><A HREF="#AUTHOR">AUTHOR</A></LI>
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H1><A NAME="NAME">NAME</A></H1>
+<P>
+Win32::GUI::BitmapInline - Inline bitmap support for Win32::GUI
+
+</P>
+<P>
+<HR>
+<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
+<P>
+To create a BitmapInline:
+
+</P>
+<P>
+<PRE>    perl -MWin32::GUI::BitmapInline -e inline('image.bmp') &gt;&gt;script.pl
+</PRE>
+</P>
+<P>
+To use a BitmapInline (in script.pl):
+
+</P>
+<P>
+<PRE>    use Win32::GUI;
+    use Win32::GUI::BitmapInline ();
+    
+    $Bitmap1 = new Win32::GUI::BitmapInline( q(
+    Qk32AAAAAAAAAHYAAAAoAAAAEAAAABAAAAABAAQAAAAAAIAAAAAAAAAAAAAAABAAAAAQAAAAAAAA
+    AACcnABjzs4A9/f3AJzO/wCc//8Azv//AP///wD///8A////AP///wD///8A////AP///wD///8A
+    ////AHd3d3d3d3d3d3d3d3d3d3dwAAAAAAAABxIiIiIiIiIHFkVFRUVEQgcWVVRUVFRCBxZVVVVF
+    RUIHFlVVVFRUUgcWVVVVVUVCBxZVVVVUVFIHFlVVVVVVQgcWZmZmZmZSBxIiIiIRERF3cTZlUQd3
+    d3d3EREQd3d3d3d3d3d3d3d3
+    ) );
+</PRE>
+</P>
+<P>
+<HR>
+<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
+<P>
+This module can be used to ``inline'' a bitmap file in your script, so that
+it doesn't need to be accompained by several external files (less hassle
+when you need to redistribute your script or move it to another location).
+
+</P>
+<P>
+The <CODE>inline</CODE> function is used to create an inlined bitmap resource; it will print on
+STDOUT the packed data including the lines of Perl needed to use the
+inlined bitmap resource; it is intended to be used as a one-liner whose
+output is appended to your script.
+
+</P>
+<P>
+The function takes the name of the bitmap file to inline as its first
+parameter; an additional, optional parameter can be given which will be the
+name of the bitmap object in the resulting scriptlet, eg:
+
+</P>
+<P>
+<PRE>    perl -MWin32::GUI::BitmapInline -e inline('image.bmp','IMAGE')
+    
+    $IMAGE = new Win32::GUI::BitmapInline( q( ...
+</PRE>
+</P>
+<P>
+If no name is given, the resulting object name will be
+<CODE>$Bitmap1</CODE> (the next ones <CODE>$Bitmap2</CODE> ,
+<CODE>$Bitmap3</CODE> and so on).
+
+</P>
+<P>
+Note that the object returned by <CODE>new Win32::GUI::BitmapInline</CODE> is a regular Win32::GUI::Bitmap object.
+
+</P>
+<P>
+With version 0.02 you can inline icons and cursors too. Nothing changes in
+the inlining process, just the file extension:
+
+</P>
+<P>
+<PRE>    perl -MWin32::GUI::BitmapInline -e inline('harrow.cur','Cursor1') &gt;&gt;script.pl
+    perl -MWin32::GUI::BitmapInline -e inline('guiperl.ico','Icon1') &gt;&gt;script.pl
+</PRE>
+</P>
+<P>
+The module recognizes from the extension the type of object that it should
+recreate, so it will add these lines to <EM>script.pl</EM>:
+
+</P>
+<P>
+<PRE>    $Cursor1 = newCursor Win32::GUI::BitmapInline( q( ...
+    $Icon1 = newIcon Win32::GUI::BitmapInline( q( ...
+   
+C&lt;newCursor&gt; or C&lt;newIcon&gt; are used in place of just C&lt;new&gt;. As above,
+the returned objects are regular Win32::GUI objects (respectively,
+Win32::GUI::Cursor and Win32::GUI::Icon).
+</PRE>
+</P>
+<P>
+<HR>
+<H1><A NAME="WARNINGS">WARNINGS</A></H1>
+<UL>
+<LI>
+<P>
+<STRONG>Requires MIME::Base64</STRONG>
+
+
+
+</P>
+<P>
+...and, of course, Win32::GUI :-)
+
+</P>
+<P>
+
+<LI>
+<P>
+<STRONG>Don't use it on large bitmap files!</STRONG>
+
+
+
+</P>
+<P>
+BitmapInline was designed for small bitmaps, such as toolbar items, icons,
+et alia; it is not at all performant. Inlined data takes approximatively
+the size of your bitmap file plus a 30%; thus, if you inline a 100k bitmap
+you're adding about 130k of bad-looking data to your script...
+
+</P>
+<P>
+
+<LI>
+<P>
+<STRONG>Your script must have write access to its current directory</STRONG>
+
+
+
+</P>
+<P>
+When inlined data are used in your script (with 
+<CODE>new Win32::GUI::BitmapInline...</CODE>) a temporary file is created, then loaded as a regular bitmap and then
+immediately deleted. This will fail if your script is not able to create
+and delete files in the current directory at the moment of the call. One
+workaround could be to change directory to a safer place before
+constructing the bitmap:
+
+</P>
+<P>
+<PRE>    chdir(&quot;c:\\temp&quot;);
+    $Bitmap1 = new Win32::GUI::BitmapInline( ... );
+</PRE>
+</P>
+<P>
+A better solution could pop up in some future release...
+
+</P>
+<P>
+
+<LI>
+<P>
+<STRONG>The package exports <CODE>inline</CODE> by default</STRONG>
+
+
+
+</P>
+<P>
+For practical reasons (see one-liners above), <CODE>inline</CODE> is exported by default into your <CODE>main</CODE> namespace; to avoid this side-effect is recommended to use the module in
+your production scripts as follows:
+
+</P>
+<P>
+<PRE>    use Win32::GUI::BitmapInline ();
+</PRE>
+</P>
+</UL>
+<P>
+<HR>
+<H1><A NAME="VERSION">VERSION</A></H1>
+<P>
+Win32::GUI::BitmapInline version 0.02, 24 January 2001.
+
+</P>
+<P>
+<HR>
+<H1><A NAME="AUTHOR">AUTHOR</A></H1>
+<P>
+Aldo Calpini ( <CODE>dada@perl.it</CODE> ).
+
+</P>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Brush.html perl-libwin32-0.191/GUI/docs/html/Brush.html
--- libwin32-0.191/GUI/docs/html/Brush.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Brush.html	2004-01-12 16:46:40.468750000 -0800
@@ -0,0 +1,120 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Brush</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Brush">Package Win32::GUI::Brush</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Brush">Package Win32::GUI::Brush</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Brush_COLOR_O">new Win32::GUI::Brush(COLOR &#124; %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Info_">Info()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Brush_COLOR_O">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Brush(COLOR | %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new Brush object. Allowed <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>  -style =&gt;
+    0 BS_SOLID
+    1 BS_NULL
+    2 BS_HATCHED
+    3 BS_PATTERN
+  -pattern =&gt; Win32::GUI::Bitmap object (valid for -style =&gt; BS_PATTERN)
+  -hatch =&gt; (valid for -style =&gt; BS_HATCHED)
+    0 HS_ORIZONTAL (-----)
+    1 HS_VERTICAL  (|||||)
+    2 HS_FDIAGONAL (\\\\\)
+    3 HS_BDIAGONAL (/////)
+    4 HS_CROSS     (+++++)
+    5 HS_DIAGCROSS (xxxxx)
+  -color =&gt; COLOR
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="Info_">
+
+<DL>
+<DT><STRONG><A NAME="item_Info">Info()</A></STRONG><DD>
+<P>
+Returns an associative array of information about the Brush object, with
+the same options given when creating the Brush.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Button.html perl-libwin32-0.191/GUI/docs/html/Button.html
--- libwin32-0.191/GUI/docs/html/Button.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Button.html	2004-01-12 16:46:40.484375000 -0800
@@ -0,0 +1,227 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Button</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Button">Package Win32::GUI::Button</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Button">Package Win32::GUI::Button</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Button_PARENT_">new Win32::GUI::Button(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#SetImage_BITMAP_">SetImage(BITMAP)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Click_">Click()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DblClick_">DblClick()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GotFocus_">GotFocus()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#LostFocus_">LostFocus()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#MouseDown_">MouseDown()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#MouseUp_">MouseUp()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Button_PARENT_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Button(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new Button object; can also be called as
+PARENT-&gt;AddButton(%OPTIONS). Class specific <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>    -align   =&gt; left/center/right (default left)
+    -valign  =&gt; top/center/bottom
+    -default =&gt; 0/1 (default 0)
+    -ok      =&gt; 0/1 (default 0)
+    -cancel  =&gt; 0/1 (default 0)
+    -bitmap  =&gt; Win32::GUI::Bitmap object
+    -picture =&gt; see -bitmap
+    -icon    =&gt; Win32::GUI::Icon object
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="SetImage_BITMAP_">
+
+<DL>
+<DT><STRONG><A NAME="item_SetImage">SetImage(BITMAP)</A></STRONG><DD>
+<P>
+Draws the specified BITMAP, a Win32::GUI::Bitmap or Win32::GUI::Icon
+object, in the Button.
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Click_">
+
+<DL>
+<DT><STRONG><A NAME="item_Click">Click()</A></STRONG><DD>
+<P>
+Sent when the control is selected (eg. the button pushed, the checkbox
+checked, etc.).
+
+</P>
+<P>
+
+<A NAME="DblClick_">
+
+<DT><STRONG><A NAME="item_DblClick">DblClick()</A></STRONG><DD>
+<P>
+Sent when the user double clicks on the control.
+
+</P>
+<P>
+
+<A NAME="GotFocus_">
+
+<DT><STRONG><A NAME="item_GotFocus">GotFocus()</A></STRONG><DD>
+<P>
+Sent when the control is activated.
+
+</P>
+<P>
+
+<A NAME="LostFocus_">
+
+<DT><STRONG><A NAME="item_LostFocus">LostFocus()</A></STRONG><DD>
+<P>
+Sent when the control is deactivated.
+
+</P>
+<P>
+
+<A NAME="MouseDown_">
+
+<DT><STRONG><A NAME="item_MouseDown">MouseDown()</A></STRONG><DD>
+<P>
+Sent when the user down clicks on the control.
+
+</P>
+<P>
+
+<A NAME="MouseUp_">
+
+<DT><STRONG><A NAME="item_MouseUp">MouseUp()</A></STRONG><DD>
+<P>
+Sent when the user releases a down click on the control.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Checkbox.html perl-libwin32-0.191/GUI/docs/html/Checkbox.html
--- libwin32-0.191/GUI/docs/html/Checkbox.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Checkbox.html	2004-01-12 16:46:40.500000000 -0800
@@ -0,0 +1,266 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Checkbox</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Checkbox">Package Win32::GUI::Checkbox</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Checkbox">Package Win32::GUI::Checkbox</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Checkbox_PARENT_">new Win32::GUI::Checkbox(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Checked_VALUE_">Checked([VALUE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetCheck_">GetCheck()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetCheck_VALUE_">SetCheck([VALUE])</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Click_">Click()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DblClick_">DblClick()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GotFocus_">GotFocus()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#LostFocus_">LostFocus()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#MouseDown_">MouseDown()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#MouseUp_">MouseUp()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Checkbox_PARENT_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Checkbox(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new Checkbox object; can also be called as
+PARENT-&gt;AddCheckbox(%OPTIONS). <CODE>%OPTIONS</CODE> are the same of
+Button (see  <A HREF="././Button.html#new_Win32_GUI_Button_PARENT_">new Win32::GUI::Button()</A> ).
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="Checked_VALUE_">
+
+<DL>
+<DT><STRONG><A NAME="item_Checked">Checked([VALUE])</A></STRONG><DD>
+<P>
+Gets or sets the check state of the Checkbox; if called without arguments,
+returns the current state:
+
+</P>
+<P>
+<PRE>  0 not checked
+  1 checked
+  2 indeterminate (grayed)
+</PRE>
+</P>
+<P>
+If a VALUE is specified, it can be one of these (eg. 0 to uncheck the
+Checkbox, 1 to check it).
+
+</P>
+<P>
+
+<A NAME="GetCheck_">
+
+<DT><STRONG><A NAME="item_GetCheck">GetCheck()</A></STRONG><DD>
+<P>
+Returns the check state of the Checkbox:
+
+</P>
+<P>
+<PRE>  0 not checked
+  1 checked
+  2 indeterminate (grayed)
+</PRE>
+</P>
+<P>
+
+<A NAME="SetCheck_VALUE_">
+
+<DT><STRONG><A NAME="item_SetCheck">SetCheck([VALUE])</A></STRONG><DD>
+<P>
+Sets the check state of the Checkbox; for a list of possible values, see  <A HREF="#GetCheck_">GetCheck()</A>. If called without arguments, it checks the Checkbox (eg. state = 1).
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Click_">
+
+<DL>
+<DT><STRONG><A NAME="item_Click">Click()</A></STRONG><DD>
+<P>
+Sent when the control is selected (eg. the button pushed, the checkbox
+checked, etc.).
+
+</P>
+<P>
+
+<A NAME="DblClick_">
+
+<DT><STRONG><A NAME="item_DblClick">DblClick()</A></STRONG><DD>
+<P>
+Sent when the user double clicks on the control.
+
+</P>
+<P>
+
+<A NAME="GotFocus_">
+
+<DT><STRONG><A NAME="item_GotFocus">GotFocus()</A></STRONG><DD>
+<P>
+Sent when the control is activated.
+
+</P>
+<P>
+
+<A NAME="LostFocus_">
+
+<DT><STRONG><A NAME="item_LostFocus">LostFocus()</A></STRONG><DD>
+<P>
+Sent when the control is deactivated.
+
+</P>
+<P>
+
+<A NAME="MouseDown_">
+
+<DT><STRONG><A NAME="item_MouseDown">MouseDown()</A></STRONG><DD>
+<P>
+Sent when the user down clicks on the control.
+
+</P>
+<P>
+
+<A NAME="MouseUp_">
+
+<DT><STRONG><A NAME="item_MouseUp">MouseUp()</A></STRONG><DD>
+<P>
+Sent when the user releases a down click on the control.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Class.html perl-libwin32-0.191/GUI/docs/html/Class.html
--- libwin32-0.191/GUI/docs/html/Class.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Class.html	2004-01-12 16:46:40.531250000 -0800
@@ -0,0 +1,89 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Class</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Class">Package Win32::GUI::Class</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Class">Package Win32::GUI::Class</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Class_OPTIONS_">new Win32::GUI::Class(%OPTIONS)</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Class_OPTIONS_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Class(%OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new window class object. Allowed <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>  -name =&gt; STRING
+      the name for the class (it must be unique!).
+  -icon =&gt; Win32::GUI::Icon object
+  -cursor =&gt; Win32::GUI::Cursor object
+  -color =&gt; COLOR or Win32::GUI::Brush object
+      the window background color.
+  -menu =&gt; STRING
+      a menu name (not yet implemented).
+  -extends =&gt; STRING
+      name of the class to extend (aka subclassing).
+  -widget =&gt; STRING
+      name of a widget class to subclass; currently available are:
+      Button, Listbox, TabStrip, RichEdit.
+  -style =&gt; FLAGS
+      use with caution!
+</PRE>
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Combobox.html perl-libwin32-0.191/GUI/docs/html/Combobox.html
--- libwin32-0.191/GUI/docs/html/Combobox.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Combobox.html	2004-01-12 16:46:40.546875000 -0800
@@ -0,0 +1,392 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Combobox</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Combobox">Package Win32::GUI::Combobox</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Combobox">Package Win32::GUI::Combobox</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Combobox_PARENT_">new Win32::GUI::Combobox(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Add_STRING_STRING_STRING_">Add(STRING, STRING .. STRING)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddString_STRING_">AddString(STRING)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Clear_">Clear()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Count_">Count()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#FindString_STRING_INDEX_">FindString(STRING, [INDEX])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#FindStringExact_STRING_INDEX_">FindStringExact(STRING, [INDEX])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#FirstVisibleItem_INDEX_">FirstVisibleItem([INDEX])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetString_INDEX_">GetString(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#InsertItem_STRING_INDEX_">InsertItem(STRING, [INDEX])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ItemHeight_HEIGHT_">ItemHeight([HEIGHT])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ListIndex_">ListIndex()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#RemoveItem_INDEX_">RemoveItem(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Reset_">Reset()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Select_INDEX_">Select(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SelectedItem_">SelectedItem()</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Change_">Change()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GotFocus_">GotFocus()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#LostFocus_">LostFocus()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Combobox_PARENT_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Combobox(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new Combobox object; can also be called as
+PARENT-&gt;AddCombobox(%OPTIONS).
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="Add_STRING_STRING_STRING_">
+
+<DL>
+<DT><STRONG><A NAME="item_Add">Add(STRING, STRING .. STRING)</A></STRONG><DD>
+<P>
+Adds one or more items at the end of the control's list.
+
+</P>
+<P>
+
+<A NAME="AddString_STRING_">
+
+<DT><STRONG><A NAME="item_AddString">AddString(STRING)</A></STRONG><DD>
+<P>
+Adds an item at the end of the control's list.
+
+</P>
+<P>
+
+<A NAME="Clear_">
+
+<DT><STRONG><A NAME="item_Clear">Clear()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Count_">
+
+<DT><STRONG><A NAME="item_Count">Count()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="FindString_STRING_INDEX_">
+
+<DT><STRONG><A NAME="item_FindString">FindString(STRING, [INDEX])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="FindStringExact_STRING_INDEX_">
+
+<DT><STRONG><A NAME="item_FindStringExact">FindStringExact(STRING, [INDEX])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="FirstVisibleItem_INDEX_">
+
+<DT><STRONG><A NAME="item_FirstVisibleItem">FirstVisibleItem([INDEX])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetString_INDEX_">
+
+<DT><STRONG><A NAME="item_GetString">GetString(INDEX)</A></STRONG><DD>
+<P>
+Returns the string at the specified zero-based INDEX in the Combobox.
+
+</P>
+<P>
+
+<A NAME="InsertItem_STRING_INDEX_">
+
+<DT><STRONG><A NAME="item_InsertItem">InsertItem(STRING, [INDEX])</A></STRONG><DD>
+<P>
+Inserts an item at the specified zero-based INDEX in the Combobox, or adds
+it at the end if INDEX is not specified.
+
+</P>
+<P>
+
+<A NAME="ItemHeight_HEIGHT_">
+
+<DT><STRONG><A NAME="item_ItemHeight">ItemHeight([HEIGHT])</A></STRONG><DD>
+<P>
+Gets or sets the items height in a Combobox.
+
+</P>
+<P>
+
+<A NAME="ListIndex_">
+
+<DT><STRONG><A NAME="item_ListIndex">ListIndex()</A></STRONG><DD>
+<P>
+See  <A HREF="#SelectedItem_">SelectedItem()</A>.
+
+</P>
+<P>
+
+<A NAME="RemoveItem_INDEX_">
+
+<DT><STRONG><A NAME="item_RemoveItem">RemoveItem(INDEX)</A></STRONG><DD>
+<P>
+Removes the zero-based INDEX item from the Combobox.
+
+</P>
+<P>
+
+<A NAME="Reset_">
+
+<DT><STRONG><A NAME="item_Reset">Reset()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Select_INDEX_">
+
+<DT><STRONG><A NAME="item_Select">Select(INDEX)</A></STRONG><DD>
+<P>
+Selects the zero-based INDEX item in the Combobox.
+
+</P>
+<P>
+
+<A NAME="SelectedItem_">
+
+<DT><STRONG><A NAME="item_SelectedItem">SelectedItem()</A></STRONG><DD>
+<P>
+Returns the zero-based index of the currently selected item, or -1 if no
+item is selected.
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Change_">
+
+<DL>
+<DT><STRONG><A NAME="item_Change">Change()</A></STRONG><DD>
+<P>
+Sent when the user selects an item from the Combobox
+
+</P>
+<P>
+
+<A NAME="GotFocus_">
+
+<DT><STRONG><A NAME="item_GotFocus">GotFocus()</A></STRONG><DD>
+<P>
+Sent when the control is activated.
+
+</P>
+<P>
+
+<A NAME="LostFocus_">
+
+<DT><STRONG><A NAME="item_LostFocus">LostFocus()</A></STRONG><DD>
+<P>
+Sent when the control is deactivated.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/ComboboxEx.html perl-libwin32-0.191/GUI/docs/html/ComboboxEx.html
--- libwin32-0.191/GUI/docs/html/ComboboxEx.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/ComboboxEx.html	2004-01-12 16:46:40.562500000 -0800
@@ -0,0 +1,185 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::ComboboxEx</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_ComboboxEx">Package Win32::GUI::ComboboxEx</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_ComboboxEx">Package Win32::GUI::ComboboxEx</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_ComboboxEx_PAREN">new Win32::GUI::ComboboxEx(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#InsertItem_OPTIONS_">InsertItem(%OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Change_">Change()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GotFocus_">GotFocus()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#LostFocus_">LostFocus()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_ComboboxEx_PAREN">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::ComboboxEx(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new ComboboxEx object; can also be called as
+PARENT-&gt;AddComboboxEx(%OPTIONS). Class specific <CODE>%OPTIONS</CODE>
+are:
+
+</P>
+<P>
+<PRE>  -imagelist =&gt; Win32::GUI::ImageList object
+</PRE>
+</P>
+<P>
+Except for images, a ComboboxEx object acts like a Win32::GUI::Combobox
+object. See also  <A HREF="././Combobox.html#new_Win32_GUI_Combobox_PARENT_">new Win32::GUI::Combobox()</A>.
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="InsertItem_OPTIONS_">
+
+<DL>
+<DT><STRONG><A NAME="item_InsertItem">InsertItem(%OPTIONS)</A></STRONG><DD>
+<P>
+Inserts a new item in the ComboboxEx control. Returns the newly created
+item zero-based index or -1 on errors. <CODE>%OPTIONS</CODE> can be:
+
+</P>
+<P>
+<PRE>  -index =&gt; position (-1 for the end of the list)
+  -image =&gt; index of an image from the associated ImageList
+  -selectedimage =&gt; index of an image from the associated ImageList
+  -text =&gt; string
+  -indent =&gt; indentation spaces (1 space == 10 pixels)
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Change_">
+
+<DL>
+<DT><STRONG><A NAME="item_Change">Change()</A></STRONG><DD>
+<P>
+Sent when the user selects an item from the Combobox
+
+</P>
+<P>
+
+<A NAME="GotFocus_">
+
+<DT><STRONG><A NAME="item_GotFocus">GotFocus()</A></STRONG><DD>
+<P>
+Sent when the control is activated.
+
+</P>
+<P>
+
+<A NAME="LostFocus_">
+
+<DT><STRONG><A NAME="item_LostFocus">LostFocus()</A></STRONG><DD>
+<P>
+Sent when the control is deactivated.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Cursor.html perl-libwin32-0.191/GUI/docs/html/Cursor.html
--- libwin32-0.191/GUI/docs/html/Cursor.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Cursor.html	2004-01-12 16:46:40.578125000 -0800
@@ -0,0 +1,71 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Cursor</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Cursor">Package Win32::GUI::Cursor</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Cursor">Package Win32::GUI::Cursor</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Cursor_FILENAME_">new Win32::GUI::Cursor(FILENAME)</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Cursor_FILENAME_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Cursor(FILENAME)</A></STRONG><DD>
+<P>
+Creates a new Cursor object reading from FILENAME.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/DC.html perl-libwin32-0.191/GUI/docs/html/DC.html
--- libwin32-0.191/GUI/docs/html/DC.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/DC.html	2004-01-12 16:46:40.593750000 -0800
@@ -0,0 +1,605 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::DC</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_DC">Package Win32::GUI::DC</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_DC">Package Win32::GUI::DC</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_DC_WINDOW_DRIV">new Win32::GUI::DC(WINDOW &#124; DRIVER, DEVICE)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#AbortPath_">AbortPath()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Arc_X_Y_RADIUS_START_SWEEP_">Arc(X, Y, RADIUS, START, SWEEP)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#BackColor_COLOR_">BackColor([COLOR])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#BeginPath_">BeginPath()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#BkMode_MODE_">BkMode([MODE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Circle_X_Y_WIDTH_HEIGHT_RA">Circle(X, Y, (WIDTH, HEIGHT &#124; RADIUS))</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#CloseFigure_">CloseFigure()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DrawEdge_LEFT_TOP_RIGHT_BOTTO">DrawEdge(LEFT, TOP, RIGHT, BOTTOM, [EDGE, FLAGS])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Ellipse_LEFT_TOP_RIGHT_BOTTOM">Ellipse(LEFT, TOP, RIGHT, BOTTOM)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#EndPath_">EndPath()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Fill_X_Y_COLOR_TYPE_">Fill(X, Y, [COLOR], [TYPE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#FillPath_">FillPath()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetPixel_X_Y_">GetPixel(X, Y)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetUpdateRect_ERASE_">GetUpdateRect([ERASE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#InvertRect_LEFT_TOP_RIGHT_BOT">InvertRect(LEFT, TOP, RIGHT, BOTTOM)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#LineTo_X_Y_">LineTo(X, Y)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#MapMode_MODE_">MapMode([MODE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#MoveTo_X_Y_">MoveTo(X, Y)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#PaintDesktop_">PaintDesktop()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Pie_LEFT_TOP_RIGHT_BOTTOM_XF">Pie(LEFT, TOP, RIGHT, BOTTOM, XF, YF, XS, YS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Rectangle_LEFT_TOP_RIGHT_BOTT">Rectangle(LEFT, TOP, RIGHT, BOTTOM)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Restore_STATE_">Restore([STATE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Save_">Save()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SelectObject_OBJECT_">SelectObject(OBJECT)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetPixel_X_Y_COLOR_">SetPixel(X, Y, [COLOR])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#StrokeAndFillPath_">StrokeAndFillPath()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#StrokePath_">StrokePath()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#TextColor_COLOR_">TextColor([COLOR])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#TextOut_X_Y_TEXT_">TextOut(X, Y, TEXT)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Validate_">Validate()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_DC_WINDOW_DRIV">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::DC(WINDOW | DRIVER, DEVICE)</A></STRONG><DD>
+<P>
+Creates a new DC object; the first form (WINDOW is a Win32::GUI object)
+gets the DC for the specified window (can also be called as
+WINDOW-&gt;GetDC). The second form creates a DC for the specified DEVICE;
+actually, the only supported DRIVER is the display driver (eg. the screen).
+To get the DC for the entire screen use:
+
+</P>
+<P>
+<PRE>    $Screen = new Win32::GUI::DC(&quot;DISPLAY&quot;);
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="AbortPath_">
+
+<DL>
+<DT><STRONG><A NAME="item_AbortPath">AbortPath()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Arc_X_Y_RADIUS_START_SWEEP_">
+
+<DT><STRONG><A NAME="item_Arc">Arc(X, Y, RADIUS, START, SWEEP)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="BackColor_COLOR_">
+
+<DT><STRONG><A NAME="item_BackColor">BackColor([COLOR])</A></STRONG><DD>
+<P>
+Gets or sets the background color.
+
+</P>
+<P>
+
+<A NAME="BeginPath_">
+
+<DT><STRONG><A NAME="item_BeginPath">BeginPath()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="BkMode_MODE_">
+
+<DT><STRONG><A NAME="item_BkMode">BkMode([MODE])</A></STRONG><DD>
+<P>
+Gets or sets the current background mix mode for the DC; possible values
+are:
+
+</P>
+<P>
+<PRE> 1 TRANSPARENT
+ 2 OPAQUE
+</PRE>
+</P>
+<P>
+
+<A NAME="Circle_X_Y_WIDTH_HEIGHT_RA">
+
+<DT><STRONG><A NAME="item_Circle">Circle(X, Y, (WIDTH, HEIGHT | RADIUS))</A></STRONG><DD>
+<P>
+Draws a circle or an ellipse; X, Y, RADIUS specifies the center point and
+the radius of the circle, while X, Y, WIDTH, HEIGHT specifies the center
+point and the size of the ellipse. Returns nonzero if succesful, zero on
+errors.
+
+</P>
+<P>
+
+<A NAME="CloseFigure_">
+
+<DT><STRONG><A NAME="item_CloseFigure">CloseFigure()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="DrawEdge_LEFT_TOP_RIGHT_BOTTO">
+
+<DT><STRONG><A NAME="item_DrawEdge">DrawEdge(LEFT, TOP, RIGHT, BOTTOM, [EDGE, FLAGS])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Ellipse_LEFT_TOP_RIGHT_BOTTOM">
+
+<DT><STRONG><A NAME="item_Ellipse">Ellipse(LEFT, TOP, RIGHT, BOTTOM)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="EndPath_">
+
+<DT><STRONG><A NAME="item_EndPath">EndPath()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Fill_X_Y_COLOR_TYPE_">
+
+<DT><STRONG><A NAME="item_Fill">Fill(X, Y, [COLOR], [TYPE])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="FillPath_">
+
+<DT><STRONG><A NAME="item_FillPath">FillPath()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetPixel_X_Y_">
+
+<DT><STRONG><A NAME="item_GetPixel">GetPixel(X, Y)</A></STRONG><DD>
+<P>
+Returns the color of the pixel at X, Y.
+
+</P>
+<P>
+
+<A NAME="GetUpdateRect_ERASE_">
+
+<DT><STRONG><A NAME="item_GetUpdateRect">GetUpdateRect([ERASE])</A></STRONG><DD>
+<P>
+Returns the rectangle (as a four-element array containing left, top, right,
+bottom coordinates) that needs to be updated. If the update region is empty
+(eg. no need to update, the function returns undef). The optional ERASE
+parameter can be set to 1 to force an erase of the update region, if there
+is any; by default, no erase action is performed. This function is intended
+to be used in a Paint event; see Win32::GUI::Graphic::Paint().
+
+</P>
+<P>
+
+<A NAME="InvertRect_LEFT_TOP_RIGHT_BOT">
+
+<DT><STRONG><A NAME="item_InvertRect">InvertRect(LEFT, TOP, RIGHT, BOTTOM)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="LineTo_X_Y_">
+
+<DT><STRONG><A NAME="item_LineTo">LineTo(X, Y)</A></STRONG><DD>
+<P>
+Draws a line from the current drawing position up to, but not including,
+the point specified by X, Y. Returns nonzero if succesful, zero on errors.
+
+</P>
+<P>
+
+<A NAME="MapMode_MODE_">
+
+<DT><STRONG><A NAME="item_MapMode">MapMode([MODE])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="MoveTo_X_Y_">
+
+<DT><STRONG><A NAME="item_MoveTo">MoveTo(X, Y)</A></STRONG><DD>
+<P>
+Moves the current drawing position to the point specified by X, Y. Returns
+nonzero if succesful, zero on errors.
+
+</P>
+<P>
+
+<A NAME="PaintDesktop_">
+
+<DT><STRONG><A NAME="item_PaintDesktop">PaintDesktop()</A></STRONG><DD>
+<P>
+Fills the DC content with the desktop pattern or wallpaper. Returns nonzero
+if succesful, zero on errors.
+
+</P>
+<P>
+
+<A NAME="Pie_LEFT_TOP_RIGHT_BOTTOM_XF">
+
+<DT><STRONG><A NAME="item_Pie">Pie(LEFT, TOP, RIGHT, BOTTOM, XF, YF, XS, YS)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Rectangle_LEFT_TOP_RIGHT_BOTT">
+
+<DT><STRONG><A NAME="item_Rectangle">Rectangle(LEFT, TOP, RIGHT, BOTTOM)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Restore_STATE_">
+
+<DT><STRONG><A NAME="item_Restore">Restore([STATE])</A></STRONG><DD>
+<P>
+Restores the state of the DC saved by <CODE>Save().</CODE> STATE can
+identify a state from the saved stack (use the identifier returned by the
+corresponding <CODE>Save()</CODE> call) or a negative number that specifies
+how many steps backwards in the stack to recall (eg. -1 recalls the last
+saved state). The default if STATE is not specified is -1. Note that the
+restored state is removed from the stack, and if you restore an early one,
+all the subsequent states will be removed too. Returns nonzero if
+succesful, zero on errors. See also  <A HREF="#Save_">Save()</A>.
+
+</P>
+<P>
+
+<A NAME="Save_">
+
+<DT><STRONG><A NAME="item_Save">Save()</A></STRONG><DD>
+<P>
+Saves the current state of the DC (this means the currently selected
+colors, brushes, pens, drawing modes, etc.) to an internal stack. The
+function returns a number identifying the saved state; this number can then
+be passed to the <CODE>Restore()</CODE> function to load it back. If the
+return value is zero, an error occurred. See also  <A HREF="#Restore_STATE_">Restore()</A>.
+
+</P>
+<P>
+
+<A NAME="SelectObject_OBJECT_">
+
+<DT><STRONG><A NAME="item_SelectObject">SelectObject(OBJECT)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="SetPixel_X_Y_COLOR_">
+
+<DT><STRONG><A NAME="item_SetPixel">SetPixel(X, Y, [COLOR])</A></STRONG><DD>
+<P>
+Sets the pixel at X, Y to the specified COLOR (or to the current
+<CODE>TextColor()</CODE> if COLOR is not specified).
+
+</P>
+<P>
+
+<A NAME="StrokeAndFillPath_">
+
+<DT><STRONG><A NAME="item_StrokeAndFillPath">StrokeAndFillPath()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="StrokePath_">
+
+<DT><STRONG><A NAME="item_StrokePath">StrokePath()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="TextColor_COLOR_">
+
+<DT><STRONG><A NAME="item_TextColor">TextColor([COLOR])</A></STRONG><DD>
+<P>
+Gets or sets the text color.
+
+</P>
+<P>
+
+<A NAME="TextOut_X_Y_TEXT_">
+
+<DT><STRONG><A NAME="item_TextOut">TextOut(X, Y, TEXT)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Validate_">
+
+<DT><STRONG><A NAME="item_Validate">Validate()</A></STRONG><DD>
+<P>
+Validates (removes from the update region) the whole DC area. This function
+is intended to be used in a Paint event; see Win32::GUI::Graphic::Paint().
+Returns nonzero if succesful, zero on errors.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/DateTime.html perl-libwin32-0.191/GUI/docs/html/DateTime.html
--- libwin32-0.191/GUI/docs/html/DateTime.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/DateTime.html	2004-01-12 16:46:40.609375000 -0800
@@ -0,0 +1,257 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::DateTime</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_DateTime">Package Win32::GUI::DateTime</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_DateTime">Package Win32::GUI::DateTime</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_DateTime_PARENT_">new Win32::GUI::DateTime(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Format_FORMAT_">Format(FORMAT)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetDate_">GetDate()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetDateTime_">GetDateTime()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetTime_">GetTime()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#IsNone_">IsNone()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetDate_DAY_MONTH_YEAR_">SetDate(DAY, MONTH, YEAR)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetDateTime_YEAR_MON_DAY_HOUR_">SetDateTime(YEAR,MON, DAY, HOUR, MIN, SEC, [MSEC=0])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetNone_handle_">SetNone(handle)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetTime_HOUR_MIN_SEC_MSEC_0_">SetTime(HOUR, MIN, SEC, [MSEC=0])</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_DateTime_PARENT_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::DateTime(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new DateTime object; can also be called as
+PARENT-&gt;AddDateTime(%OPTIONS). Class specific <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>  -align  =&gt; 'right'/'left' (default 'left')
+    The drop-down month calendar alignement.
+  -format =&gt; 'shortdate', 'longdate', 'time'
+    Control format type (Use local format date/time).
+  -shownone =&gt; 0/1 (default 0)
+    Allow no datetime (add a prefix checkbox).
+  -updown   =&gt; 0/1 (default 0 for date, 1 for time format)
+    Use updown control instead of the drop-down month calendar.
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="Format_FORMAT_">
+
+<DL>
+<DT><STRONG><A NAME="item_Format">Format(FORMAT)</A></STRONG><DD>
+<P>
+(preliminary) Sets the format for the DateTime control to the specified
+string. More info [TBD].
+
+</P>
+<P>
+
+<A NAME="GetDate_">
+
+<DT><STRONG><A NAME="item_GetDate">GetDate()</A></STRONG><DD>
+<P>
+(preliminary) Returns the date in the DateTime control in a three elements
+array (day, month, year).
+
+</P>
+<P>
+
+<A NAME="GetDateTime_">
+
+<DT><STRONG><A NAME="item_GetDateTime">GetDateTime()</A></STRONG><DD>
+<P>
+(preliminary) Returns the date and time in the DateTime control in a eight
+elements array (year, month, day, dayofweek, hour, minute, second,
+millisecond).
+
+</P>
+<P>
+
+<A NAME="GetTime_">
+
+<DT><STRONG><A NAME="item_GetTime">GetTime()</A></STRONG><DD>
+<P>
+(preliminary) Returns the time in the DateTime control in a four elements
+array (hour, min, sec, msec).
+
+</P>
+<P>
+
+<A NAME="IsNone_">
+
+<DT><STRONG><A NAME="item_IsNone">IsNone()</A></STRONG><DD>
+<P>
+(preliminary) Test if the DateTime control is None (control check box was
+
+</P>
+<P>
+<PRE> not selected).
+</PRE>
+</P>
+<P>
+
+<A NAME="SetDate_DAY_MONTH_YEAR_">
+
+<DT><STRONG><A NAME="item_SetDate">SetDate(DAY, MONTH, YEAR)</A></STRONG><DD>
+<P>
+(preliminary) Sets the date in the DateTime control in a three elements
+array (day, month, year).
+
+</P>
+<P>
+
+<A NAME="SetDateTime_YEAR_MON_DAY_HOUR_">
+
+<DT><STRONG><A NAME="item_SetDateTime">SetDateTime(YEAR,MON, DAY, HOUR, MIN, SEC, [MSEC=0])</A></STRONG><DD>
+<P>
+(preliminary) Sets the date time in the DateTime control
+
+</P>
+<P>
+
+<A NAME="SetNone_handle_">
+
+<DT><STRONG><A NAME="item_SetNone">SetNone(handle)</A></STRONG><DD>
+<P>
+(preliminary) Set none state in the DateTime control (control check box was
+
+</P>
+<P>
+<PRE> selected)..
+</PRE>
+</P>
+<P>
+
+<A NAME="SetTime_HOUR_MIN_SEC_MSEC_0_">
+
+<DT><STRONG><A NAME="item_SetTime">SetTime(HOUR, MIN, SEC, [MSEC=0])</A></STRONG><DD>
+<P>
+(preliminary) Sets the time in the DateTime control in a four elements
+array (hour, min, sec, [msec=0]).
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/DialogBox.html perl-libwin32-0.191/GUI/docs/html/DialogBox.html
--- libwin32-0.191/GUI/docs/html/DialogBox.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/DialogBox.html	2004-01-12 16:46:40.640625000 -0800
@@ -0,0 +1,199 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::DialogBox</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_DialogBox">Package Win32::GUI::DialogBox</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_DialogBox">Package Win32::GUI::DialogBox</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_DialogBox_OPTIO">new Win32::GUI::DialogBox(%OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Activate_">Activate()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Deactivate_">Deactivate()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DropFiles_DROP_HANDLE_">DropFiles(DROP_HANDLE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Maximize_">Maximize()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Minimize_">Minimize()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Resize_">Resize()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Terminate_">Terminate()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_DialogBox_OPTIO">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::DialogBox(%OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new DialogBox object. See  <A HREF="././Window.html#new_Win32_GUI_Window_OPTIONS_">new Win32::GUI::Window()</A>.
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Activate_">
+
+<DL>
+<DT><STRONG><A NAME="item_Activate">Activate()</A></STRONG><DD>
+<P>
+Sent when the window is activated.
+
+</P>
+<P>
+
+<A NAME="Deactivate_">
+
+<DT><STRONG><A NAME="item_Deactivate">Deactivate()</A></STRONG><DD>
+<P>
+Sent when the window is deactivated.
+
+</P>
+<P>
+
+<A NAME="DropFiles_DROP_HANDLE_">
+
+<DT><STRONG><A NAME="item_DropFiles">DropFiles(DROP_HANDLE)</A></STRONG><DD>
+<P>
+Sent when the window receives dropped files.
+
+</P>
+<P>
+
+<A NAME="Maximize_">
+
+<DT><STRONG><A NAME="item_Maximize">Maximize()</A></STRONG><DD>
+<P>
+Sent when the window is maximized.
+
+</P>
+<P>
+
+<A NAME="Minimize_">
+
+<DT><STRONG><A NAME="item_Minimize">Minimize()</A></STRONG><DD>
+<P>
+Sent when the window is minimized.
+
+</P>
+<P>
+
+<A NAME="Resize_">
+
+<DT><STRONG><A NAME="item_Resize">Resize()</A></STRONG><DD>
+<P>
+Sent when the window is resized.
+
+</P>
+<P>
+
+<A NAME="Terminate_">
+
+<DT><STRONG><A NAME="item_Terminate">Terminate()</A></STRONG><DD>
+<P>
+Sent when the window is closed. The event should return -1 to terminate the
+interaction and return control to the perl script; see  <A HREF="././Win32_GUI.html#Dialog_">Dialog()</A>.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Font.html perl-libwin32-0.191/GUI/docs/html/Font.html
--- libwin32-0.191/GUI/docs/html/Font.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Font.html	2004-01-12 16:46:40.656250000 -0800
@@ -0,0 +1,160 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Font</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Font">Package Win32::GUI::Font</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Font">Package Win32::GUI::Font</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Font_OPTIONS_">new Win32::GUI::Font(%OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#GetMetrics_">GetMetrics()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Info_">Info()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Font_OPTIONS_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Font(%OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new Font object. <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>  -size
+  -height
+  -width
+  -escapement
+  -orientation
+  -weight
+  -bold =&gt; 0/1
+  -italic =&gt; 0/1
+  -underline =&gt; 0/1
+  -strikeout =&gt; 0/1
+  -charset
+  -outputprecision
+  -clipprecision
+  -family
+  -quality
+  -name
+  -face
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="GetMetrics_">
+
+<DL>
+<DT><STRONG><A NAME="item_GetMetrics">GetMetrics()</A></STRONG><DD>
+<P>
+Returns an associative array of information about the Font:
+
+</P>
+<P>
+<PRE> -height
+ -ascent
+ -descent
+ -ileading
+ -eleading
+ -avgwidth
+ -maxwidth
+ -overhang
+ -aspectx
+ -aspecty
+ -firstchar
+ -lastchar
+ -breakchar
+ -italic
+ -underline
+ -strikeout
+ -flags
+ -charset
+</PRE>
+</P>
+<P>
+
+<A NAME="Info_">
+
+<DT><STRONG><A NAME="item_Info">Info()</A></STRONG><DD>
+<P>
+Returns an associative array of information about the Font, with the same
+options given when creating the font.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/GUI.html perl-libwin32-0.191/GUI/docs/html/GUI.html
--- libwin32-0.191/GUI/docs/html/GUI.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/GUI.html	2004-01-12 16:46:40.671875000 -0800
@@ -0,0 +1,133 @@
+<HTML>
+<HEAD>
+<TITLE>Win32::GUI Documentation</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<LI><A HREF="#Win32_GUI_Documentation">Win32::GUI Documentation</A></LI>
+	<UL>
+
+		<LI><A HREF="#Table_Of_Contents">Table Of Contents</A></LI>
+		<LI><A HREF="#AUTHOR">AUTHOR</A></LI>
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H1><A NAME="Win32_GUI_Documentation">Win32::GUI Documentation</A></H1>
+<P>
+Version: <STRONG>0.0.665</STRONG>, 12 Dec 2003
+
+</P>
+<P>
+<HR>
+<H2><A NAME="Table_Of_Contents">Table Of Contents</A></H2>
+<UL>
+<LI>
+<P>
+<STRONG>User's Guide</STRONG>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<EM>Introduction</EM>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././guiconcepts.html#">General concepts</A>
+
+
+
+</P>
+<LI>
+<P>
+<EM>Writing a script with Win32::GUI</EM>
+
+
+
+</P>
+</UL>
+<P>
+
+<LI>
+<P>
+<STRONG>Reference Manual</STRONG>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="././guioptions.html#">Common options</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././guipacks.html#">Packages</A>
+
+
+
+</P>
+<LI>
+<P>
+<STRONG>Support packages</STRONG>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="././BitmapInline.html#">Win32::GUI::BitmapInline</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././GridLayout.html#">Win32::GUI::GridLayout</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+
+<LI>
+<P>
+<STRONG>FAQs</STRONG>
+
+
+
+</P>
+</UL>
+<P>
+<HR>
+<H2><A NAME="AUTHOR">AUTHOR</A></H2>
+<P>
+(c) 1997, 8, 9 Aldo Calpini, <CODE>dada@divinf.it</CODE>.
+
+</P>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Graphic.html perl-libwin32-0.191/GUI/docs/html/Graphic.html
--- libwin32-0.191/GUI/docs/html/Graphic.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Graphic.html	2004-01-12 16:46:40.687500000 -0800
@@ -0,0 +1,147 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Graphic</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Graphic">Package Win32::GUI::Graphic</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Graphic">Package Win32::GUI::Graphic</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Graphic_PARENT_">new Win32::GUI::Graphic(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#GetDC_">GetDC()</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Paint_">Paint()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Graphic_PARENT_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Graphic(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new Graphic object; can also be called as
+PARENT-&gt;AddGraphic(%OPTIONS). Class specific <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="GetDC_">
+
+<DL>
+<DT><STRONG><A NAME="item_GetDC">GetDC()</A></STRONG><DD>
+<P>
+Returns the DC object associated with the window.
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Paint_">
+
+<DL>
+<DT><STRONG><A NAME="item_Paint">Paint()</A></STRONG><DD>
+<P>
+Sent when the Graphic object needs to be repainted. Note that you need to
+use <CODE>GetDC()</CODE> to get the DC of the Graphic object where you do
+your paint work, and then <CODE>Validate()</CODE> the DC to inform Windows
+that you painted the DC area (otherwise it will continue to call the Paint
+event continuously). Example:
+
+</P>
+<P>
+<PRE>  sub Graphic_Paint {
+      my $DC = $Window-&gt;Graphic-&gt;GetDC();
+      $DC-&gt;MoveTo(0, 0);
+      $DC-&gt;LineTo(100, 100);
+      $DC-&gt;Validate();
+  }
+</PRE>
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/GridLayout.html perl-libwin32-0.191/GUI/docs/html/GridLayout.html
--- libwin32-0.191/GUI/docs/html/GridLayout.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/GridLayout.html	2004-01-12 16:46:40.703125000 -0800
@@ -0,0 +1,215 @@
+<HTML>
+<HEAD>
+<TITLE>Win32::GUI::GridLayout - Grid layout support for Win32::GUI</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<LI><A HREF="#NAME">NAME</A></LI>
+	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A></LI>
+	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A></LI>
+	<UL>
+
+		<LI><A HREF="#Constructors">Constructors</A></LI>
+		<LI><A HREF="#Methods">Methods</A></LI>
+	</UL>
+
+	<LI><A HREF="#VERSION">VERSION</A></LI>
+	<LI><A HREF="#AUTHOR">AUTHOR</A></LI>
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H1><A NAME="NAME">NAME</A></H1>
+<P>
+Win32::GUI::GridLayout - Grid layout support for Win32::GUI
+
+</P>
+<P>
+<HR>
+<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
+<P>
+<PRE>    use Win32::GUI::
+    use Win32::GUI::GridLayout;
+</PRE>
+</P>
+<P>
+<PRE>    # 1. make a &quot;static&quot; grid
+    $grid = new Win32::GUI::GridLayout(400, 300, 3, 3, 0, 0);
+    
+    $win = new Win32::GUI::Window(
+    
+    $win-&gt;AddLabel(
+        -name =&gt; &quot;label1&quot;,
+        -text =&gt; &quot;Label 1&quot;,
+        -width  =&gt; $grid-&gt;width(35),
+        -height =&gt; $grid-&gt;height(11),
+        -left   =&gt; $grid-&gt;col(1, &quot;left&quot;),
+        -top    =&gt; $grid-&gt;row(1, &quot;top&quot;),
+    );
+    
+    # 2. make a &quot;dynamic&quot; grid
+    $grid = apply Win32::GUI::GridLayout($win, 3, 3, 0, 0);
+    
+    $win-&gt;AddLabel(
+        -name =&gt; &quot;label1&quot;,
+        -text =&gt; &quot;Label 1&quot;,
+    );
+    $grid-&gt;add($win-&gt;label1, 1, 1, &quot;left top&quot;);
+</PRE>
+</P>
+<P>
+<PRE>    $grid-&gt;recalc();
+</PRE>
+</P>
+<P>
+<HR>
+<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
+<P>
+<HR>
+<H2><A NAME="Constructors">Constructors</A></H2>
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::GridLayout(WIDTH, HEIGHT, COLS, ROWS, XPAD, YPAD)</A></STRONG><DD>
+<DT><STRONG><A NAME="item_apply">apply Win32::GUI::GridLayout(WINDOW, COLS, ROWS, XPAD, YPAD)</A></STRONG><DD>
+</DL>
+<P>
+<HR>
+<H2><A NAME="Methods">Methods</A></H2>
+<DL>
+<DT><STRONG><A NAME="item_add">add(CONTROL, COL, ROW, ALIGN)</A></STRONG><DD>
+<P>
+Adds CONTROL to the grid at (COL, ROW). ALIGN can specify both horizontal
+and vertical alignment (see the <CODE>col()</CODE> and <CODE>row()</CODE>
+methods), separated by at least one blank and/or a comma.
+
+</P>
+<P>
+Example:
+
+</P>
+<P>
+<PRE>    $grid-&gt;add($win-&gt;label1, 1, 1, &quot;left top&quot;);
+</PRE>
+</P>
+<DT><STRONG><A NAME="item_col">col(N, ALIGN)</A></STRONG><DD>
+<P>
+Positions the control at the Nth column in the grid, optionally with an
+ALIGN; this can be feed to a
+<CODE>-left</CODE> option when creating a control.
+
+</P>
+<P>
+ALIGN can be <CODE>left</CODE>, <CODE>center</CODE> or <CODE>right</CODE> (can be shortened to <CODE>l</CODE>, <CODE>c</CODE>, <CODE>r</CODE>); default is <CODE>left</CODE>.
+
+</P>
+<P>
+Note that for alignment to work properly, the <CODE>width()</CODE> and
+<CODE>height()</CODE> methods must have been previously called.
+
+</P>
+<P>
+Example:
+
+</P>
+<P>
+<PRE>    $win-&gt;AddLabel(
+        -name =&gt; &quot;label1&quot;,
+        -text =&gt; &quot;Label 1&quot;,
+        -width  =&gt; $grid-&gt;width(35),
+        -height =&gt; $grid-&gt;height(11),
+        -left   =&gt; $grid-&gt;col(1, &quot;left&quot;),
+        -top    =&gt; $grid-&gt;row(1, &quot;top&quot;),
+    );      
+</PRE>
+</P>
+<DT><STRONG><A NAME="item_draw">draw()</A></STRONG><DD>
+<P>
+Draws the GridLayout in the associated window (may be useful for
+debugging); is only meaningful if the GridLayout was created with the
+<CODE>apply()</CODE> constructor.
+
+</P>
+<DT><STRONG><A NAME="item_height">height(N)</A></STRONG><DD>
+<P>
+Sets the height of the control for subsequent alignment; this can be feed
+to a <A HREF="#item__height">-height</A> option when creating a control.
+
+</P>
+<P>
+Example: see <CODE>col().</CODE>
+
+</P>
+<DT><STRONG><A NAME="item_recalc">recalc()</A></STRONG><DD>
+<P>
+Recalculates the grid and repositions all the <CODE>add()ed</CODE>
+controls, taking into account the actual window and controls sizes; is only
+meaningful if the GridLayout was created with the <CODE>apply()</CODE>
+constructor.
+
+</P>
+<P>
+Example:
+
+</P>
+<P>
+<PRE>    sub Window_Resize {
+        $grid-&gt;recalc();
+    }
+</PRE>
+</P>
+<DT><STRONG><A NAME="item_row">row(N, ALIGN)</A></STRONG><DD>
+<P>
+Positions the control at the Nth row in the grid, optionally with an ALIGN;
+this can be feed to a
+<CODE>-top</CODE> option when creating a control.
+
+</P>
+<P>
+ALIGN can be <CODE>top</CODE>, <CODE>center</CODE> or <CODE>bottom</CODE> (can be shortened to t, c, b); default is top.
+
+</P>
+<P>
+Note that for alignment to work properly, the <CODE>width()</CODE> and
+<CODE>height()</CODE> methods must have been previously called.
+
+</P>
+<P>
+Example: see <CODE>col().</CODE>
+
+</P>
+<DT><STRONG><A NAME="item_width">width(N)</A></STRONG><DD>
+<P>
+Sets the width of the control for subsequent alignment; this can be feed to
+a <A HREF="#item__width">-width</A> option when creating a control.
+
+</P>
+<P>
+Example: see <CODE>col().</CODE>
+
+</P>
+</DL>
+<P>
+<HR>
+<H1><A NAME="VERSION">VERSION</A></H1>
+<P>
+Win32::GUI::GridLayout version 0.03, 13 April 1999.
+
+</P>
+<P>
+<HR>
+<H1><A NAME="AUTHOR">AUTHOR</A></H1>
+<P>
+Mike Kangas ( <CODE>kangas@anlon.com</CODE> ); additional coding by Aldo Calpini ( <CODE>dada@perl.it</CODE> ).
+
+</P>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Groupbox.html perl-libwin32-0.191/GUI/docs/html/Groupbox.html
--- libwin32-0.191/GUI/docs/html/Groupbox.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Groupbox.html	2004-01-12 16:46:40.718750000 -0800
@@ -0,0 +1,72 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Groupbox</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Groupbox">Package Win32::GUI::Groupbox</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Groupbox">Package Win32::GUI::Groupbox</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Groupbox_PARENT_">new Win32::GUI::Groupbox(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Groupbox_PARENT_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Groupbox(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new Groupbox object; can also be called as
+PARENT-&gt;AddGroupbox(%OPTIONS).
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Header.html perl-libwin32-0.191/GUI/docs/html/Header.html
--- libwin32-0.191/GUI/docs/html/Header.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Header.html	2004-01-12 16:46:40.734375000 -0800
@@ -0,0 +1,355 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Header</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Header">Package Win32::GUI::Header</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Header">Package Win32::GUI::Header</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Header_PARENT_">new Win32::GUI::Header(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#ChangeItem_INDEX_OPTIONS_">ChangeItem(INDEX, %OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Clear_">Clear()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Count_">Count()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DeleteItem_INDEX_">DeleteItem(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#HitTest_X_Y_">HitTest(X, Y)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#InsertItem_OPTIONS_">InsertItem(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ItemRect_INDEX_">ItemRect(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Reset_">Reset()</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#BeginTrack_INDEX_WIDTH_">BeginTrack(INDEX, WIDTH)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DividerDblClick_INDEX_">DividerDblClick(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#EndTrack_INDEX_WIDTH_">EndTrack(INDEX, WIDTH)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ItemClick_INDEX_">ItemClick(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ItemDblClick_INDEX_">ItemDblClick(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Track_INDEX_WIDTH_">Track(INDEX, WIDTH)</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Header_PARENT_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Header(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new Header object; can also be called as
+PARENT-&gt;AddHeader(%OPTIONS). Class specific <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>  -buttons =&gt; 0/1 (default 0)
+    header items look like push buttons and can be clicked.
+  -hottrack =&gt; 0/1 (default 0)
+  -imagelist =&gt; Win32::GUI::ImageList object
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="ChangeItem_INDEX_OPTIONS_">
+
+<DL>
+<DT><STRONG><A NAME="item_ChangeItem">ChangeItem(INDEX, %OPTIONS)</A></STRONG><DD>
+<P>
+Changes the options for an item in the Header control. Returns nonzero if
+successful, zero otherwise. For a list of the available options see  <A HREF="#InsertItem_OPTIONS_">InsertItem()</A>.
+
+</P>
+<P>
+
+<A NAME="Clear_">
+
+<DT><STRONG><A NAME="item_Clear">Clear()</A></STRONG><DD>
+<P>
+Deletes all items from the control.
+
+</P>
+<P>
+
+<A NAME="Count_">
+
+<DT><STRONG><A NAME="item_Count">Count()</A></STRONG><DD>
+<P>
+Returns the number of items in the Header control.
+
+</P>
+<P>
+
+<A NAME="DeleteItem_INDEX_">
+
+<DT><STRONG><A NAME="item_DeleteItem">DeleteItem(INDEX)</A></STRONG><DD>
+<P>
+Deletes the zero-based INDEX item from the Header.
+
+</P>
+<P>
+
+<A NAME="HitTest_X_Y_">
+
+<DT><STRONG><A NAME="item_HitTest">HitTest(X, Y)</A></STRONG><DD>
+<P>
+Checks if the specified point is on an Header item; it returns the index of
+the found item or -1 if none was found. If called in an array context, it
+returns an additional value containing more info about the position of the
+specified point.
+
+</P>
+<P>
+
+<A NAME="InsertItem_OPTIONS_">
+
+<DT><STRONG><A NAME="item_InsertItem">InsertItem(%OPTIONS)</A></STRONG><DD>
+<P>
+Inserts a new item in the Header control. Returns the newly created item
+zero-based index or -1 on errors. <CODE>%OPTIONS</CODE> can be:
+
+</P>
+<P>
+<PRE>  -index =&gt; position
+  -image =&gt; index of an image from the associated ImageList
+  -bitmap =&gt; Win32::GUI::Bitmap object
+  -width =&gt; pixels
+  -height =&gt; pixels
+  -text =&gt; string
+  -align =&gt; left|center|right
+</PRE>
+</P>
+<P>
+
+<A NAME="ItemRect_INDEX_">
+
+<DT><STRONG><A NAME="item_ItemRect">ItemRect(INDEX)</A></STRONG><DD>
+<P>
+Returns a four element array defining the rectangle of the specified
+zero-based INDEX item; the array contains (left, top, right, bottom). If
+not succesful returns undef.
+
+</P>
+<P>
+
+<A NAME="Reset_">
+
+<DT><STRONG><A NAME="item_Reset">Reset()</A></STRONG><DD>
+<P>
+See  <A HREF="#Clear_">Clear()</A>.
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="BeginTrack_INDEX_WIDTH_">
+
+<DL>
+<DT><STRONG><A NAME="item_BeginTrack">BeginTrack(INDEX, WIDTH)</A></STRONG><DD>
+<P>
+Sent when a divider of the Header control is being moved; the event must
+return 0 to prevent moving the divider, 1 to allow it. Passes the
+zero-based INDEX of the item being resized and its current WIDTH.
+
+</P>
+<P>
+
+<A NAME="DividerDblClick_INDEX_">
+
+<DT><STRONG><A NAME="item_DividerDblClick">DividerDblClick(INDEX)</A></STRONG><DD>
+<P>
+Sent when the user double-clicked on a divider of the Header control.
+
+</P>
+<P>
+
+<A NAME="EndTrack_INDEX_WIDTH_">
+
+<DT><STRONG><A NAME="item_EndTrack">EndTrack(INDEX, WIDTH)</A></STRONG><DD>
+<P>
+Sent when a divider of the Header control has been moved. Passes the
+zero-based INDEX of the item being resized and its current WIDTH.
+
+</P>
+<P>
+
+<A NAME="ItemClick_INDEX_">
+
+<DT><STRONG><A NAME="item_ItemClick">ItemClick(INDEX)</A></STRONG><DD>
+<P>
+Sent when the user clicked on a Header item.
+
+</P>
+<P>
+
+<A NAME="ItemDblClick_INDEX_">
+
+<DT><STRONG><A NAME="item_ItemDblClick">ItemDblClick(INDEX)</A></STRONG><DD>
+<P>
+Sent when the user double-clicked on a Header item.
+
+</P>
+<P>
+
+<A NAME="Track_INDEX_WIDTH_">
+
+<DT><STRONG><A NAME="item_Track">Track(INDEX, WIDTH)</A></STRONG><DD>
+<P>
+Sent while a divider of the Header control is being moved; the event must
+return 1 to continue moving the divider, 0 to end its movement. Passes the
+zero-based INDEX of the item being resized and its current WIDTH.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Icon.html perl-libwin32-0.191/GUI/docs/html/Icon.html
--- libwin32-0.191/GUI/docs/html/Icon.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Icon.html	2004-01-12 16:46:40.750000000 -0800
@@ -0,0 +1,71 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Icon</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Icon">Package Win32::GUI::Icon</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Icon">Package Win32::GUI::Icon</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Icon_FILENAME_">new Win32::GUI::Icon(FILENAME)</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Icon_FILENAME_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Icon(FILENAME)</A></STRONG><DD>
+<P>
+Creates a new Icon object reading from FILENAME.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/ImageList.html perl-libwin32-0.191/GUI/docs/html/ImageList.html
--- libwin32-0.191/GUI/docs/html/ImageList.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/ImageList.html	2004-01-12 16:46:40.765625000 -0800
@@ -0,0 +1,222 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::ImageList</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_ImageList">Package Win32::GUI::ImageList</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_ImageList">Package Win32::GUI::ImageList</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_ImageList_X_Y_">new Win32::GUI::ImageList(X, Y, FLAGS, INITAL, GROW)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Add_BITMAP_BITMAPMASK_">Add(BITMAP, [BITMAPMASK])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddBitmap_BITMAP_BITMAPMASK_">AddBitmap(BITMAP, [BITMAPMASK])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#BackColor_COLOR_">BackColor([COLOR])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Clear_">Clear()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Count_">Count()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Remove_INDEX_">Remove(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Replace_INDEX_BITMAP_BITMAPMA">Replace(INDEX, BITMAP, [BITMAPMASK])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Size_X_Y_">Size([X, Y])</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_ImageList_X_Y_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::ImageList(X, Y, FLAGS, INITAL, GROW)</A></STRONG><DD>
+<P>
+Creates an ImageList object; X and Y specify the size of the images, FLAGS
+[TBD]. INITIAL and GROW specify the number of images the ImageList actually
+contains (INITIAL) and the number of images for which memory is allocated
+(GROW).
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="Add_BITMAP_BITMAPMASK_">
+
+<DL>
+<DT><STRONG><A NAME="item_Add">Add(BITMAP, [BITMAPMASK])</A></STRONG><DD>
+<P>
+Adds a bitmap to the ImageList; both BITMAP and BITMAPMASK can be either
+Win32::GUI::Bitmap objects or filenames.
+
+</P>
+<P>
+
+<A NAME="AddBitmap_BITMAP_BITMAPMASK_">
+
+<DT><STRONG><A NAME="item_AddBitmap">AddBitmap(BITMAP, [BITMAPMASK])</A></STRONG><DD>
+<P>
+Adds a Win32::GUI::Bitmap object to the ImageList. BITMAPMASK is optional.
+See also  <A HREF="#Add_BITMAP_BITMAPMASK_">Add()</A>.
+
+</P>
+<P>
+
+<A NAME="BackColor_COLOR_">
+
+<DT><STRONG><A NAME="item_BackColor">BackColor([COLOR])</A></STRONG><DD>
+<P>
+Gets or sets the background color for the ImageList.
+
+</P>
+<P>
+
+<A NAME="Clear_">
+
+<DT><STRONG><A NAME="item_Clear">Clear()</A></STRONG><DD>
+<P>
+Removes all the images from the ImageList.
+
+</P>
+<P>
+
+<A NAME="Count_">
+
+<DT><STRONG><A NAME="item_Count">Count()</A></STRONG><DD>
+<P>
+Returns the number of images in the ImageList.
+
+</P>
+<P>
+
+<A NAME="Remove_INDEX_">
+
+<DT><STRONG><A NAME="item_Remove">Remove(INDEX)</A></STRONG><DD>
+<P>
+Removes the specified zero-based INDEX image from the ImageList.
+
+</P>
+<P>
+
+<A NAME="Replace_INDEX_BITMAP_BITMAPMA">
+
+<DT><STRONG><A NAME="item_Replace">Replace(INDEX, BITMAP, [BITMAPMASK])</A></STRONG><DD>
+<P>
+Replaces the specified zero-based INDEX image with the image specified by
+BITMAP (must be a Win32::GUI::Bitmap object). BITMAPMASK is optional.
+
+</P>
+<P>
+
+<A NAME="Size_X_Y_">
+
+<DT><STRONG><A NAME="item_Size">Size([X, Y])</A></STRONG><DD>
+<P>
+Gets or sets the size of the images in the ImageList; if no parameter is
+given, returns a 2 element array (X, Y), otherwise sets the size to the
+given parameters.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Label.html perl-libwin32-0.191/GUI/docs/html/Label.html
--- libwin32-0.191/GUI/docs/html/Label.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Label.html	2004-01-12 16:46:40.781250000 -0800
@@ -0,0 +1,178 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Label</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Label">Package Win32::GUI::Label</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Label">Package Win32::GUI::Label</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Label_PARENT_O">new Win32::GUI::Label(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#SetImage_BITMAP_">SetImage(BITMAP)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Click_">Click()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DblClick_">DblClick()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Label_PARENT_O">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Label(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new Label object; can also be called as
+PARENT-&gt;AddLabel(%OPTIONS). Class specific <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>   -align    =&gt; left/center/right (default left)
+   -bitmap   =&gt; Win32::GUI::Bitmap object
+   -fill     =&gt; black/gray/white/none (default none)
+       fills the control rectangle (&quot;black&quot;, &quot;gray&quot; and &quot;white&quot; are
+       the window frame color, the desktop color and the window
+       background color respectively).
+   -frame    =&gt; black/gray/white/etched/none (default none)
+       draws a border around the control. colors are the same
+       of -fill, with the addition of &quot;etched&quot; (a raised border).
+   -icon     =&gt; Win32::GUI::Icon object
+   -noprefix =&gt; 0/1 (default 0)
+       disables the interpretation of &quot;&amp;&quot; as accelerator prefix.
+   -notify   =&gt; 0/1 (default 0)
+       enables the Click(), DblClick, etc. events.
+   -picture  =&gt; see -bitmap
+   -sunken   =&gt; 0/1 (default 0)
+       draws a half-sunken border around the control.
+   -truncate =&gt; 0/1/word/path (default 0)
+       specifies how the text is to be truncated:
+           0 the text is not truncated
+           1 the text is truncated at the end
+        path the text is truncated before the last &quot;\&quot;
+             (used to shorten paths).
+   -wrap     =&gt; 0/1 (default 1)
+       the text wraps automatically to a new line.
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="SetImage_BITMAP_">
+
+<DL>
+<DT><STRONG><A NAME="item_SetImage">SetImage(BITMAP)</A></STRONG><DD>
+<P>
+Draws the specified BITMAP, a Win32::GUI::Bitmap object, in the Label.
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Click_">
+
+<DL>
+<DT><STRONG><A NAME="item_Click">Click()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="DblClick_">
+
+<DT><STRONG><A NAME="item_DblClick">DblClick()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/ListView.html perl-libwin32-0.191/GUI/docs/html/ListView.html
--- libwin32-0.191/GUI/docs/html/ListView.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/ListView.html	2004-01-12 16:46:40.796875000 -0800
@@ -0,0 +1,660 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::ListView</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_ListView">Package Win32::GUI::ListView</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_ListView">Package Win32::GUI::ListView</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_ListView_PARENT_">new Win32::GUI::ListView(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Add_ITEM_ITEM_ITEM_">Add(ITEM, ITEM .. ITEM)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Arrange_FLAG_">Arrange([FLAG])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ChangeItem_OPTIONS_">ChangeItem(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Clear_">Clear()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ColumnWidth_COLUMN_WIDTH_">ColumnWidth(COLUMN, [WIDTH])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Count_">Count()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DeleteColumn_INDEX_">DeleteColumn(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DeleteItem_INDEX_">DeleteItem(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#EditLabel_INDEX_">EditLabel(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#EnsureVisible_INDEX_FLAG_">EnsureVisible(INDEX, [FLAG])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetFirstVisible_">GetFirstVisible()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetItem_INDEX_SUBINDEX_">GetItem(INDEX, [SUBINDEX])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetStringWidth_STRING_">GetStringWidth(STRING)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#HitTest_X_Y_">HitTest(X, Y)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#InsertColumn_OPTIONS_">InsertColumn(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#InsertItem_OPTIONS_">InsertItem(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ItemCheck_INDEX_">ItemCheck(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ItemInfo_INDEX_SUBINDEX_">ItemInfo(INDEX, [SUBINDEX])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ItemPosition_INDEX_X_Y_">ItemPosition(INDEX, [X, Y])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#MoveItem_INDEX_X_Y_">MoveItem(INDEX, X, Y)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Select_INDEX_">Select(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SelectCount_">SelectCount()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SelectedItems_">SelectedItems()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetImageList_IMAGELIST_TYPE_">SetImageList(IMAGELIST, [TYPE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetItem_OPTIONS_">SetItem(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#TextBkColor_COLOR_">TextBkColor([COLOR])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#TextColor_COLOR_">TextColor([COLOR])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#View_MODE_">View([MODE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#VisibleCount_">VisibleCount()</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#ColumnClick_ITEM_">ColumnClick(ITEM)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ItemCheck_ITEM_">ItemCheck(ITEM)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ItemClick_ITEM_">ItemClick(ITEM)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#KeyDown_KEY_">KeyDown(KEY)</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_ListView_PARENT_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::ListView(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new ListView object; can also be called as
+PARENT-&gt;AddListView(%OPTIONS).
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="Add_ITEM_ITEM_ITEM_">
+
+<DL>
+<DT><STRONG><A NAME="item_Add">Add(ITEM, ITEM .. ITEM)</A></STRONG><DD>
+<P>
+Inserts one or more items in the control; each item must be passed as an
+hash reference. See  <A HREF="#InsertItem_OPTIONS_">InsertItem()</A> for a list of the available key/values of these hashes.
+
+</P>
+<P>
+
+<A NAME="Arrange_FLAG_">
+
+<DT><STRONG><A NAME="item_Arrange">Arrange([FLAG])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="ChangeItem_OPTIONS_">
+
+<DT><STRONG><A NAME="item_ChangeItem">ChangeItem(%OPTIONS)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Clear_">
+
+<DT><STRONG><A NAME="item_Clear">Clear()</A></STRONG><DD>
+<P>
+Deletes all items from the ListView.
+
+</P>
+<P>
+
+<A NAME="ColumnWidth_COLUMN_WIDTH_">
+
+<DT><STRONG><A NAME="item_ColumnWidth">ColumnWidth(COLUMN, [WIDTH])</A></STRONG><DD>
+<P>
+Gets or sets the width of the specified COLUMN; WIDTH can be the desired
+width in pixels or one of the following special values:
+
+</P>
+<P>
+<PRE>  -1 automatically size the column
+  -2 automatically size the column to fit the header text
+</PRE>
+</P>
+<P>
+
+<A NAME="Count_">
+
+<DT><STRONG><A NAME="item_Count">Count()</A></STRONG><DD>
+<P>
+Returns the number of items in the ListView.
+
+</P>
+<P>
+
+<A NAME="DeleteColumn_INDEX_">
+
+<DT><STRONG><A NAME="item_DeleteColumn">DeleteColumn(INDEX)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="DeleteItem_INDEX_">
+
+<DT><STRONG><A NAME="item_DeleteItem">DeleteItem(INDEX)</A></STRONG><DD>
+<P>
+Removes the zero-based INDEX item from the ListView.
+
+</P>
+<P>
+
+<A NAME="EditLabel_INDEX_">
+
+<DT><STRONG><A NAME="item_EditLabel">EditLabel(INDEX)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="EnsureVisible_INDEX_FLAG_">
+
+<DT><STRONG><A NAME="item_EnsureVisible">EnsureVisible(INDEX, [FLAG])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetFirstVisible_">
+
+<DT><STRONG><A NAME="item_GetFirstVisible">GetFirstVisible()</A></STRONG><DD>
+<P>
+Returns the index of the first visible item in the ListView.
+
+</P>
+<P>
+
+<A NAME="GetItem_INDEX_SUBINDEX_">
+
+<DT><STRONG><A NAME="item_GetItem">GetItem(INDEX, [SUBINDEX])</A></STRONG><DD>
+<P>
+See  <A HREF="#ItemInfo_INDEX_SUBINDEX_">ItemInfo()</A>.
+
+</P>
+<P>
+
+<A NAME="GetStringWidth_STRING_">
+
+<DT><STRONG><A NAME="item_GetStringWidth">GetStringWidth(STRING)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="HitTest_X_Y_">
+
+<DT><STRONG><A NAME="item_HitTest">HitTest(X, Y)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="InsertColumn_OPTIONS_">
+
+<DT><STRONG><A NAME="item_InsertColumn">InsertColumn(%OPTIONS)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="InsertItem_OPTIONS_">
+
+<DT><STRONG><A NAME="item_InsertItem">InsertItem(%OPTIONS)</A></STRONG><DD>
+<P>
+Inserts a new item in the control. (@)OPT: -image =&gt; NUMBER (@)OPT:
+index of an image from the associated ImageList (@)OPT: -indent =&gt;
+NUMBER (@)OPT: how much the item must be indented; one unit (@)OPT: is the
+width of an item image, so 2 is twice (@)OPT: the width of the image, and
+so on. (@)OPT: -item =&gt; NUMBER (@)OPT: zero-based index for the new
+item; the default (@)OPT: is to add the item at the end of the list.
+(@)OPT: -selected =&gt; 0/1, default 0 (@)OPT: -text =&gt; STRING (@)OPT:
+the text for the item
+
+</P>
+<P>
+
+<A NAME="ItemCheck_INDEX_">
+
+<DT><STRONG><A NAME="item_ItemCheck">ItemCheck(INDEX)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="ItemInfo_INDEX_SUBINDEX_">
+
+<DT><STRONG><A NAME="item_ItemInfo">ItemInfo(INDEX, [SUBINDEX])</A></STRONG><DD>
+<P>
+Returns an associative array of information about the given zero-based
+INDEX item:
+
+</P>
+<P>
+<PRE>    -image
+    -state
+    -text
+</PRE>
+</P>
+<P>
+Optionally, a SUBINDEX (one-based index) can be given, to get the text for
+the specified column.
+
+</P>
+<P>
+
+<A NAME="ItemPosition_INDEX_X_Y_">
+
+<DT><STRONG><A NAME="item_ItemPosition">ItemPosition(INDEX, [X, Y])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="MoveItem_INDEX_X_Y_">
+
+<DT><STRONG><A NAME="item_MoveItem">MoveItem(INDEX, X, Y)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Select_INDEX_">
+
+<DT><STRONG><A NAME="item_Select">Select(INDEX)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="SelectCount_">
+
+<DT><STRONG><A NAME="item_SelectCount">SelectCount()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="SelectedItems_">
+
+<DT><STRONG><A NAME="item_SelectedItems">SelectedItems()</A></STRONG><DD>
+<P>
+Retuns an array containing the zero-based indexes of selected items.
+
+</P>
+<P>
+
+<A NAME="SetImageList_IMAGELIST_TYPE_">
+
+<DT><STRONG><A NAME="item_SetImageList">SetImageList(IMAGELIST, [TYPE])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="SetItem_OPTIONS_">
+
+<DT><STRONG><A NAME="item_SetItem">SetItem(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="#ChangeItem_OPTIONS_">ChangeItem()</A>.
+
+</P>
+<P>
+
+<A NAME="TextBkColor_COLOR_">
+
+<DT><STRONG><A NAME="item_TextBkColor">TextBkColor([COLOR])</A></STRONG><DD>
+<P>
+Gets or sets the background color for the text in the ListView.
+
+</P>
+<P>
+
+<A NAME="TextColor_COLOR_">
+
+<DT><STRONG><A NAME="item_TextColor">TextColor([COLOR])</A></STRONG><DD>
+<P>
+Gets or sets the text color for the ListView.
+
+</P>
+<P>
+
+<A NAME="View_MODE_">
+
+<DT><STRONG><A NAME="item_View">View([MODE])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="VisibleCount_">
+
+<DT><STRONG><A NAME="item_VisibleCount">VisibleCount()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="ColumnClick_ITEM_">
+
+<DL>
+<DT><STRONG><A NAME="item_ColumnClick">ColumnClick(ITEM)</A></STRONG><DD>
+<P>
+Sent when the user clicks on a column header in the ListView; ITEM
+specifies the one-based index of the selected column.
+
+</P>
+<P>
+
+<A NAME="ItemCheck_ITEM_">
+
+<DT><STRONG><A NAME="item_ItemCheck">ItemCheck(ITEM)</A></STRONG><DD>
+<P>
+Sent when the user changes the checkbox of an item in the ListView; ITEM
+specifies the zero-based index of the selected item.
+
+</P>
+<P>
+
+<A NAME="ItemClick_ITEM_">
+
+<DT><STRONG><A NAME="item_ItemClick">ItemClick(ITEM)</A></STRONG><DD>
+<P>
+Sent when the user selects an item in the ListView; ITEM specifies the
+zero-based index of the selected item.
+
+</P>
+<P>
+
+<A NAME="KeyDown_KEY_">
+
+<DT><STRONG><A NAME="item_KeyDown">KeyDown(KEY)</A></STRONG><DD>
+<P>
+Sent when the user presses a key while the ListView control has focus; KEY
+is the ASCII code of the key being pressed.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/ListView_Item.html perl-libwin32-0.191/GUI/docs/html/ListView_Item.html
--- libwin32-0.191/GUI/docs/html/ListView_Item.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/ListView_Item.html	2004-01-12 16:46:40.812500000 -0800
@@ -0,0 +1,35 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::ListView::Item</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_ListView_It">Package Win32::GUI::ListView::Item</A></LI>
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_ListView_It">Package Win32::GUI::ListView::Item</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/ListView_SubItem.html perl-libwin32-0.191/GUI/docs/html/ListView_SubItem.html
--- libwin32-0.191/GUI/docs/html/ListView_SubItem.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/ListView_SubItem.html	2004-01-12 16:46:40.828125000 -0800
@@ -0,0 +1,35 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::ListView::SubItem</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_ListView_Su">Package Win32::GUI::ListView::SubItem</A></LI>
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_ListView_Su">Package Win32::GUI::ListView::SubItem</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Listbox.html perl-libwin32-0.191/GUI/docs/html/Listbox.html
--- libwin32-0.191/GUI/docs/html/Listbox.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Listbox.html	2004-01-12 16:46:40.859375000 -0800
@@ -0,0 +1,482 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Listbox</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Listbox">Package Win32::GUI::Listbox</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Listbox">Package Win32::GUI::Listbox</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Listbox_PARENT_">new Win32::GUI::Listbox(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Add_STRING_STRING_STRING_">Add(STRING, STRING .. STRING)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddString_STRING_">AddString(STRING)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Clear_">Clear()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Count_">Count()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#FindString_STRING_INDEX_">FindString(STRING, [INDEX])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#FindStringExact_STRING_INDEX_">FindStringExact(STRING, [INDEX])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#FirstVisibleItem_INDEX_">FirstVisibleItem([INDEX])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetString_INDEX_">GetString(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#InsertItem_STRING_INDEX_">InsertItem(STRING, [INDEX])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ItemFromPoint_X_Y_">ItemFromPoint(X, Y)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ItemHeight_HEIGHT_">ItemHeight([HEIGHT])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ListIndex_">ListIndex()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#RemoveItem_INDEX_">RemoveItem(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Reset_">Reset()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Select_INDEX_">Select(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SelectCount_">SelectCount()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SelectedItem_">SelectedItem()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SelectedItems_">SelectedItems()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SelectString_STRING_INDEX_">SelectString(STRING, [INDEX])</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Click_">Click()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DblClick_">DblClick()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GotFocus_">GotFocus()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#LostFocus_">LostFocus()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Listbox_PARENT_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Listbox(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new Listbox object; can also be called as
+PARENT-&gt;AddListbox(%OPTIONS). Class specific <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>   -multisel =&gt; 0/1/2 (default 0)
+       specifies the selection type:
+           0 single selection
+           1 multiple selection
+           2 multiple selection ehnanced (with Shift, Control, etc.)
+   -sort     =&gt; 0/1 (default 0)
+       items are sorted alphabetically.
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="Add_STRING_STRING_STRING_">
+
+<DL>
+<DT><STRONG><A NAME="item_Add">Add(STRING, STRING .. STRING)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="AddString_STRING_">
+
+<DT><STRONG><A NAME="item_AddString">AddString(STRING)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Clear_">
+
+<DT><STRONG><A NAME="item_Clear">Clear()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Count_">
+
+<DT><STRONG><A NAME="item_Count">Count()</A></STRONG><DD>
+<P>
+Returns the number of items in the Listbox.
+
+</P>
+<P>
+
+<A NAME="FindString_STRING_INDEX_">
+
+<DT><STRONG><A NAME="item_FindString">FindString(STRING, [INDEX])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="FindStringExact_STRING_INDEX_">
+
+<DT><STRONG><A NAME="item_FindStringExact">FindStringExact(STRING, [INDEX])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="FirstVisibleItem_INDEX_">
+
+<DT><STRONG><A NAME="item_FirstVisibleItem">FirstVisibleItem([INDEX])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetString_INDEX_">
+
+<DT><STRONG><A NAME="item_GetString">GetString(INDEX)</A></STRONG><DD>
+<P>
+Returns the string at the specified zero-based INDEX in the Listbox.
+
+</P>
+<P>
+
+<A NAME="InsertItem_STRING_INDEX_">
+
+<DT><STRONG><A NAME="item_InsertItem">InsertItem(STRING, [INDEX])</A></STRONG><DD>
+<P>
+Inserts an item at the specified zero-based INDEX in the Listbox, or adds
+it at the end if INDEX is not specified.
+
+</P>
+<P>
+
+<A NAME="ItemFromPoint_X_Y_">
+
+<DT><STRONG><A NAME="item_ItemFromPoint">ItemFromPoint(X, Y)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="ItemHeight_HEIGHT_">
+
+<DT><STRONG><A NAME="item_ItemHeight">ItemHeight([HEIGHT])</A></STRONG><DD>
+<P>
+Gets or sets the items height in a Listbox.
+
+</P>
+<P>
+
+<A NAME="ListIndex_">
+
+<DT><STRONG><A NAME="item_ListIndex">ListIndex()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="RemoveItem_INDEX_">
+
+<DT><STRONG><A NAME="item_RemoveItem">RemoveItem(INDEX)</A></STRONG><DD>
+<P>
+Removes the zero-based INDEX item from the Listbox.
+
+</P>
+<P>
+
+<A NAME="Reset_">
+
+<DT><STRONG><A NAME="item_Reset">Reset()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Select_INDEX_">
+
+<DT><STRONG><A NAME="item_Select">Select(INDEX)</A></STRONG><DD>
+<P>
+Selects the zero-based INDEX item in the Listbox.
+
+</P>
+<P>
+
+<A NAME="SelectCount_">
+
+<DT><STRONG><A NAME="item_SelectCount">SelectCount()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="SelectedItem_">
+
+<DT><STRONG><A NAME="item_SelectedItem">SelectedItem()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="SelectedItems_">
+
+<DT><STRONG><A NAME="item_SelectedItems">SelectedItems()</A></STRONG><DD>
+<P>
+Returns an array containing the zero-based indexes of the selected items in
+a multiple selection Listbox.
+
+</P>
+<P>
+
+<A NAME="SelectString_STRING_INDEX_">
+
+<DT><STRONG><A NAME="item_SelectString">SelectString(STRING, [INDEX])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Click_">
+
+<DL>
+<DT><STRONG><A NAME="item_Click">Click()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="DblClick_">
+
+<DT><STRONG><A NAME="item_DblClick">DblClick()</A></STRONG><DD>
+<P>
+Sent when the user double clicks on the control.
+
+</P>
+<P>
+
+<A NAME="GotFocus_">
+
+<DT><STRONG><A NAME="item_GotFocus">GotFocus()</A></STRONG><DD>
+<P>
+Sent when the control is activated.
+
+</P>
+<P>
+
+<A NAME="LostFocus_">
+
+<DT><STRONG><A NAME="item_LostFocus">LostFocus()</A></STRONG><DD>
+<P>
+Sent when the control is deactivated.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Listbox_Item.html perl-libwin32-0.191/GUI/docs/html/Listbox_Item.html
--- libwin32-0.191/GUI/docs/html/Listbox_Item.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Listbox_Item.html	2004-01-12 16:46:40.875000000 -0800
@@ -0,0 +1,35 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Listbox::Item</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Listbox_Ite">Package Win32::GUI::Listbox::Item</A></LI>
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Listbox_Ite">Package Win32::GUI::Listbox::Item</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/MDI.html perl-libwin32-0.191/GUI/docs/html/MDI.html
--- libwin32-0.191/GUI/docs/html/MDI.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/MDI.html	2004-01-12 16:46:40.890625000 -0800
@@ -0,0 +1,89 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::MDI</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_MDI">Package Win32::GUI::MDI</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_MDI">Package Win32::GUI::MDI</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_MDI_OPTIONS_">new Win32::GUI::MDI(%OPTIONS)</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_MDI_OPTIONS_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::MDI(%OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new MDI (Multiple Document Interface) object. Class specific
+<CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>  -minsize =&gt; [X, Y]
+    specifies the minimum size (width and height) in pixels;
+    X and Y must be passed in an array reference
+  -maxsize =&gt; [X, Y]
+    specifies the maximum size (width and height) in pixels;
+    X and Y must be passed in an array reference
+  -minwidth  =&gt; N
+  -minheight =&gt; N
+  -maxwidht  =&gt; N
+  -maxheight =&gt; N
+    specify the minimum and maximum size width
+    and height, in pixels
+  -topmost =&gt; 0/1 (default 0)
+    the window &quot;stays on top&quot; even when deactivated
+</PRE>
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Menu.html perl-libwin32-0.191/GUI/docs/html/Menu.html
--- libwin32-0.191/GUI/docs/html/Menu.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Menu.html	2004-01-12 16:46:40.906250000 -0800
@@ -0,0 +1,135 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Menu</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Menu">Package Win32::GUI::Menu</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Menu">Package Win32::GUI::Menu</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Menu_">new Win32::GUI::Menu(...)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#AddMenuButton_">AddMenuButton()</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Click_">Click()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Menu_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Menu(...)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="AddMenuButton_">
+
+<DL>
+<DT><STRONG><A NAME="item_AddMenuButton">AddMenuButton()</A></STRONG><DD>
+<P>
+see  <A HREF="././MenuButton.html#new_Win32_GUI_MenuButton_">new Win32::GUI::MenuButton()</A>
+
+
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Click_">
+
+<DL>
+<DT><STRONG><A NAME="item_Click">Click()</A></STRONG><DD>
+<P>
+Sent when the users choose a menu point.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/MenuButton.html perl-libwin32-0.191/GUI/docs/html/MenuButton.html
--- libwin32-0.191/GUI/docs/html/MenuButton.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/MenuButton.html	2004-01-12 16:46:40.921875000 -0800
@@ -0,0 +1,104 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::MenuButton</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_MenuButton">Package Win32::GUI::MenuButton</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_MenuButton">Package Win32::GUI::MenuButton</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_MenuButton_">new Win32::GUI::MenuButton()</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#AddMenuItem_">AddMenuItem()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_MenuButton_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::MenuButton()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="AddMenuItem_">
+
+<DL>
+<DT><STRONG><A NAME="item_AddMenuItem">AddMenuItem()</A></STRONG><DD>
+<P>
+see  <A HREF="././MenuItem.html#new_Win32_GUI_MenuItem_">new Win32::GUI::MenuItem()</A>
+
+
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/MenuItem.html perl-libwin32-0.191/GUI/docs/html/MenuItem.html
--- libwin32-0.191/GUI/docs/html/MenuItem.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/MenuItem.html	2004-01-12 16:46:40.937500000 -0800
@@ -0,0 +1,134 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::MenuItem</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_MenuItem">Package Win32::GUI::MenuItem</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_MenuItem">Package Win32::GUI::MenuItem</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_MenuItem_">new Win32::GUI::MenuItem()</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Change_OPTIONS_">Change(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Checked_">Checked(...)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Enabled_">Enabled(...)</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_MenuItem_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::MenuItem()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="Change_OPTIONS_">
+
+<DL>
+<DT><STRONG><A NAME="item_Change">Change(%OPTIONS)</A></STRONG><DD>
+<P>
+Change most of the options used when the object was created.
+
+</P>
+<P>
+
+<A NAME="Checked_">
+
+<DT><STRONG><A NAME="item_Checked">Checked(...)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Enabled_">
+
+<DT><STRONG><A NAME="item_Enabled">Enabled(...)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/NotifyIcon.html perl-libwin32-0.191/GUI/docs/html/NotifyIcon.html
--- libwin32-0.191/GUI/docs/html/NotifyIcon.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/NotifyIcon.html	2004-01-12 16:46:40.953125000 -0800
@@ -0,0 +1,147 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::NotifyIcon</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_NotifyIcon">Package Win32::GUI::NotifyIcon</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_NotifyIcon">Package Win32::GUI::NotifyIcon</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_NotifyIcon_PAREN">new Win32::GUI::NotifyIcon(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Click_">Click()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#MouseEvent_MSG_">MouseEvent(MSG)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#RightClick_">RightClick()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_NotifyIcon_PAREN">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::NotifyIcon(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new NotifyIcon (also known as system tray icon) object; can also
+be called as PARENT-&gt;AddNotifyIcon(%OPTIONS). <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>    -icon =&gt; Win32::GUI::Icon object
+    -id =&gt; NUMBER
+        a unique identifier for the NotifyIcon object
+    -name =&gt; STRING
+        the name for the object
+    -tip =&gt; STRING
+        the text that will appear as tooltip when the mouse is
+        on the NotifyIcon
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Click_">
+
+<DL>
+<DT><STRONG><A NAME="item_Click">Click()</A></STRONG><DD>
+<P>
+Sent when the user clicks the left mouse button on a NotifyIcon.
+
+</P>
+<P>
+
+<A NAME="MouseEvent_MSG_">
+
+<DT><STRONG><A NAME="item_MouseEvent">MouseEvent(MSG)</A></STRONG><DD>
+<P>
+Sent when the user performs a mouse event on a NotifyIcon; MSG is the
+message code.
+
+</P>
+<P>
+
+<A NAME="RightClick_">
+
+<DT><STRONG><A NAME="item_RightClick">RightClick()</A></STRONG><DD>
+<P>
+Sent when the user clicks the right mouse button on a NotifyIcon.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Pen.html perl-libwin32-0.191/GUI/docs/html/Pen.html
--- libwin32-0.191/GUI/docs/html/Pen.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Pen.html	2004-01-12 16:46:40.968750000 -0800
@@ -0,0 +1,116 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Pen</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Pen">Package Win32::GUI::Pen</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Pen">Package Win32::GUI::Pen</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Pen_COLOR_OPT">new Win32::GUI::Pen(COLOR &#124; %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Info_">Info()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Pen_COLOR_OPT">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Pen(COLOR | %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new Pen object. Allowed <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>  -style =&gt;
+    0 PS_SOLID
+    1 PS_DASH
+    2 PS_DOT
+    3 PS_DASHDOT
+    4 PS_DASHDOTDOT
+    5 PS_NULL
+    6 PS_INSIDEFRAME
+  -width =&gt; number
+  -color =&gt; COLOR
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="Info_">
+
+<DL>
+<DT><STRONG><A NAME="item_Info">Info()</A></STRONG><DD>
+<P>
+Returns an associative array of information about the Pen object, with the
+same options given when creating the Pen.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/ProgressBar.html perl-libwin32-0.191/GUI/docs/html/ProgressBar.html
--- libwin32-0.191/GUI/docs/html/ProgressBar.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/ProgressBar.html	2004-01-12 16:46:40.984375000 -0800
@@ -0,0 +1,159 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::ProgressBar</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_ProgressBar">Package Win32::GUI::ProgressBar</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_ProgressBar">Package Win32::GUI::ProgressBar</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_ProgressBar_PARE">new Win32::GUI::ProgressBar(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#SetPos_VALUE_">SetPos(VALUE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetRange_MIN_MAX_">SetRange([MIN], MAX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetStep_VALUE_">SetStep([VALUE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#StepIt_">StepIt()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_ProgressBar_PARE">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::ProgressBar(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new ProgressBar object; can also be called as
+PARENT-&gt;AddProgressBar(%OPTIONS). Class specific <CODE>%OPTIONS</CODE>
+are:
+
+</P>
+<P>
+<PRE>    -smooth   =&gt; 0/1 (default 0)
+        uses a smooth bar instead of the default segmented bar.
+    -vertical =&gt; 0/1 (default 0)
+        display progress status vertically (from bottom to top).
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="SetPos_VALUE_">
+
+<DL>
+<DT><STRONG><A NAME="item_SetPos">SetPos(VALUE)</A></STRONG><DD>
+<P>
+Sets the position of the ProgressBar to the specified VALUE.
+
+</P>
+<P>
+
+<A NAME="SetRange_MIN_MAX_">
+
+<DT><STRONG><A NAME="item_SetRange">SetRange([MIN], MAX)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="SetStep_VALUE_">
+
+<DT><STRONG><A NAME="item_SetStep">SetStep([VALUE])</A></STRONG><DD>
+<P>
+Sets the increment value for the ProgressBar; see  <A HREF="#StepIt_">StepIt()</A>.
+
+</P>
+<P>
+
+<A NAME="StepIt_">
+
+<DT><STRONG><A NAME="item_StepIt">StepIt()</A></STRONG><DD>
+<P>
+Increments the position of the ProgressBar of the defined step value; see  <A HREF="#SetStep_VALUE_">SetStep()</A>.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/RadioButton.html perl-libwin32-0.191/GUI/docs/html/RadioButton.html
--- libwin32-0.191/GUI/docs/html/RadioButton.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/RadioButton.html	2004-01-12 16:46:41.000000000 -0800
@@ -0,0 +1,227 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::RadioButton</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_RadioButton">Package Win32::GUI::RadioButton</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_RadioButton">Package Win32::GUI::RadioButton</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_RadioButton_PARE">new Win32::GUI::RadioButton(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Checked_VALUE_">Checked([VALUE])</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Click_">Click()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DblClick_">DblClick()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GotFocus_">GotFocus()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#LostFocus_">LostFocus()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#MouseDown_">MouseDown()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#MouseUp_">MouseUp()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_RadioButton_PARE">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::RadioButton(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new RadioButton object; can also be called as
+PARENT-&gt;AddRadioButton(%OPTIONS). <CODE>%OPTIONS</CODE> are the same of
+Button (see  <A HREF="././Button.html#new_Win32_GUI_Button_PARENT_">new Win32::GUI::Button()</A> ).
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="Checked_VALUE_">
+
+<DL>
+<DT><STRONG><A NAME="item_Checked">Checked([VALUE])</A></STRONG><DD>
+<P>
+Gets or sets the checked state of the RadioButton; if called without
+arguments, returns the current state:
+
+</P>
+<P>
+<PRE>  0 not checked
+  1 checked
+</PRE>
+</P>
+<P>
+If a VALUE is specified, it can be one of these (eg. 0 to uncheck the
+RadioButton, 1 to check it).
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Click_">
+
+<DL>
+<DT><STRONG><A NAME="item_Click">Click()</A></STRONG><DD>
+<P>
+Sent when the control is selected (eg. the button pushed, the checkbox
+checked, etc.).
+
+</P>
+<P>
+
+<A NAME="DblClick_">
+
+<DT><STRONG><A NAME="item_DblClick">DblClick()</A></STRONG><DD>
+<P>
+Sent when the user double clicks on the control.
+
+</P>
+<P>
+
+<A NAME="GotFocus_">
+
+<DT><STRONG><A NAME="item_GotFocus">GotFocus()</A></STRONG><DD>
+<P>
+Sent when the control is activated.
+
+</P>
+<P>
+
+<A NAME="LostFocus_">
+
+<DT><STRONG><A NAME="item_LostFocus">LostFocus()</A></STRONG><DD>
+<P>
+Sent when the control is deactivated.
+
+</P>
+<P>
+
+<A NAME="MouseDown_">
+
+<DT><STRONG><A NAME="item_MouseDown">MouseDown()</A></STRONG><DD>
+<P>
+Sent when the user down clicks on the control.
+
+</P>
+<P>
+
+<A NAME="MouseUp_">
+
+<DT><STRONG><A NAME="item_MouseUp">MouseUp()</A></STRONG><DD>
+<P>
+Sent when the user releases a down click on the control.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Rebar.html perl-libwin32-0.191/GUI/docs/html/Rebar.html
--- libwin32-0.191/GUI/docs/html/Rebar.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Rebar.html	2004-01-12 16:46:41.015625000 -0800
@@ -0,0 +1,240 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Rebar</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Rebar">Package Win32::GUI::Rebar</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Rebar">Package Win32::GUI::Rebar</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Rebar_PARENT_O">new Win32::GUI::Rebar(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#BandCount_">BandCount()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#BandInfo_INDEX_">BandInfo(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DeleteBand_INDEX_">DeleteBand(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#InsertBand_OPTIONS_">InsertBand(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#MaximizeBand_INDEX_FLAG_">MaximizeBand(INDEX, [FLAG])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#MinimizeBand_INDEX_">MinimizeBand(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#RowCount_">RowCount()</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#HeightChange_">HeightChange()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Rebar_PARENT_O">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Rebar(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new Rebar object; can also be called as
+PARENT-&gt;AddRebar(%OPTIONS). Class specific <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>  -bandborders =&gt; 0/1 (default 0)
+    display a border to separate bands.
+  -fixedorder =&gt; 0/1 (default 0)
+    band position cannot be swapped.
+  -imagelist =&gt; Win32::GUI::ImageList object
+  -varheight =&gt; 0/1 (default 1)
+    display bands using the minimum required height.
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="BandCount_">
+
+<DL>
+<DT><STRONG><A NAME="item_BandCount">BandCount()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="BandInfo_INDEX_">
+
+<DT><STRONG><A NAME="item_BandInfo">BandInfo(INDEX)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="DeleteBand_INDEX_">
+
+<DT><STRONG><A NAME="item_DeleteBand">DeleteBand(INDEX)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="InsertBand_OPTIONS_">
+
+<DT><STRONG><A NAME="item_InsertBand">InsertBand(%OPTIONS)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="MaximizeBand_INDEX_FLAG_">
+
+<DT><STRONG><A NAME="item_MaximizeBand">MaximizeBand(INDEX, [FLAG])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="MinimizeBand_INDEX_">
+
+<DT><STRONG><A NAME="item_MinimizeBand">MinimizeBand(INDEX)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="RowCount_">
+
+<DT><STRONG><A NAME="item_RowCount">RowCount()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="HeightChange_">
+
+<DL>
+<DT><STRONG><A NAME="item_HeightChange">HeightChange()</A></STRONG><DD>
+<P>
+Sent when the height of the Rebar control has changed.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/RichEdit.html perl-libwin32-0.191/GUI/docs/html/RichEdit.html
--- libwin32-0.191/GUI/docs/html/RichEdit.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/RichEdit.html	2004-01-12 16:46:41.031250000 -0800
@@ -0,0 +1,428 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::RichEdit</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_RichEdit">Package Win32::GUI::RichEdit</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_RichEdit">Package Win32::GUI::RichEdit</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_RichEdit_PARENT_">new Win32::GUI::RichEdit(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#BackColor_COLOR_">BackColor([COLOR])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#CharFromPos_X_Y_">CharFromPos(X, Y)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#FirstVisibleLine_">FirstVisibleLine()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetCharFormat_FLAG_">GetCharFormat([FLAG])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetTextRange_START_LENGTH_">GetTextRange(START, LENGTH)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#LineFromChar_INDEX_">LineFromChar(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Load_FILENAME_FORMAT_">Load(FILENAME, [FORMAT])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#PosFromChar_INDEX_">PosFromChar(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ReplaceSel_STRING_FLAG_">ReplaceSel(STRING, [FLAG])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Save_FILENAME_FORMAT_">Save(FILENAME, [FORMAT])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Select_START_END_">Select(START, END)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Selection_">Selection()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetCharFormat_OPTIONS_">SetCharFormat(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetMaxLength_LENGTH_">SetMaxLength(LENGTH)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetParaFormat_OPTIONS_">SetParaFormat(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetTextMode_MODE_UNDO_">SetTextMode(MODE, UNDO)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#TextLength_">TextLength()</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Change_">Change()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GotFocus_">GotFocus()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#LostFocus_">LostFocus()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_RichEdit_PARENT_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::RichEdit(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new RichEdit object; can also be called as
+PARENT-&gt;AddRichEdit(%OPTIONS).
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="BackColor_COLOR_">
+
+<DL>
+<DT><STRONG><A NAME="item_BackColor">BackColor([COLOR])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="CharFromPos_X_Y_">
+
+<DT><STRONG><A NAME="item_CharFromPos">CharFromPos(X, Y)</A></STRONG><DD>
+<P>
+Returns a two elements array identifying the character nearest to the
+position specified by X and Y. The array contains the zero-based index of
+the character and its line index.
+
+</P>
+<P>
+
+<A NAME="FirstVisibleLine_">
+
+<DT><STRONG><A NAME="item_FirstVisibleLine">FirstVisibleLine()</A></STRONG><DD>
+<P>
+Returns the first visible line in the RichEdit control.
+
+</P>
+<P>
+
+<A NAME="GetCharFormat_FLAG_">
+
+<DT><STRONG><A NAME="item_GetCharFormat">GetCharFormat([FLAG])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetTextRange_START_LENGTH_">
+
+<DT><STRONG><A NAME="item_GetTextRange">GetTextRange(START, LENGTH)</A></STRONG><DD>
+<P>
+Returns LENGTH bytes of text from the RichEdit control, starting at START
+
+</P>
+<P>
+
+<A NAME="LineFromChar_INDEX_">
+
+<DT><STRONG><A NAME="item_LineFromChar">LineFromChar(INDEX)</A></STRONG><DD>
+<P>
+Returns the line number where the zero-based INDEX character appears.
+
+</P>
+<P>
+
+<A NAME="Load_FILENAME_FORMAT_">
+
+<DT><STRONG><A NAME="item_Load">Load(FILENAME, [FORMAT])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="PosFromChar_INDEX_">
+
+<DT><STRONG><A NAME="item_PosFromChar">PosFromChar(INDEX)</A></STRONG><DD>
+<P>
+Returns a two elements array containing the x and y position of the
+specified zero-based INDEX character in the RichEdit control.
+
+</P>
+<P>
+
+<A NAME="ReplaceSel_STRING_FLAG_">
+
+<DT><STRONG><A NAME="item_ReplaceSel">ReplaceSel(STRING, [FLAG])</A></STRONG><DD>
+<P>
+Replaces the current selection with the given STRING. The optional FLAG
+parameter can be set to zero to tell the control that the operation cannot
+be undone; see also  <A HREF="././Textfield.html#Undo_">Undo()</A>.
+
+</P>
+<P>
+
+<A NAME="Save_FILENAME_FORMAT_">
+
+<DT><STRONG><A NAME="item_Save">Save(FILENAME, [FORMAT])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Select_START_END_">
+
+<DT><STRONG><A NAME="item_Select">Select(START, END)</A></STRONG><DD>
+<P>
+Selects the characters range from START to END.
+
+</P>
+<P>
+
+<A NAME="Selection_">
+
+<DT><STRONG><A NAME="item_Selection">Selection()</A></STRONG><DD>
+<P>
+Returns a two elements array containing the current selection start and
+end.
+
+</P>
+<P>
+
+<A NAME="SetCharFormat_OPTIONS_">
+
+<DT><STRONG><A NAME="item_SetCharFormat">SetCharFormat(%OPTIONS)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="SetMaxLength_LENGTH_">
+
+<DT><STRONG><A NAME="item_SetMaxLength">SetMaxLength(LENGTH)</A></STRONG><DD>
+<P>
+Sets the RichEdit control's maximum length (up to 2GB)
+
+</P>
+<P>
+
+<A NAME="SetParaFormat_OPTIONS_">
+
+<DT><STRONG><A NAME="item_SetParaFormat">SetParaFormat(%OPTIONS)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="SetTextMode_MODE_UNDO_">
+
+<DT><STRONG><A NAME="item_SetTextMode">SetTextMode(MODE, UNDO)</A></STRONG><DD>
+<P>
+Sets the RichEdit control's text mode
+
+</P>
+<P>
+
+<A NAME="TextLength_">
+
+<DT><STRONG><A NAME="item_TextLength">TextLength()</A></STRONG><DD>
+<P>
+Returns the text length of the RichEdit control
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Change_">
+
+<DL>
+<DT><STRONG><A NAME="item_Change">Change()</A></STRONG><DD>
+<P>
+Sent when the text in the field is changed by the user.
+
+</P>
+<P>
+
+<A NAME="GotFocus_">
+
+<DT><STRONG><A NAME="item_GotFocus">GotFocus()</A></STRONG><DD>
+<P>
+Sent when the control is activated.
+
+</P>
+<P>
+
+<A NAME="LostFocus_">
+
+<DT><STRONG><A NAME="item_LostFocus">LostFocus()</A></STRONG><DD>
+<P>
+Sent when the control is deactivated.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Slider.html perl-libwin32-0.191/GUI/docs/html/Slider.html
--- libwin32-0.191/GUI/docs/html/Slider.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Slider.html	2004-01-12 16:46:41.046875000 -0800
@@ -0,0 +1,103 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Slider</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Slider">Package Win32::GUI::Slider</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Slider">Package Win32::GUI::Slider</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Slider_PARENT_">new Win32::GUI::Slider(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Scroll_">Scroll()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Slider_PARENT_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Slider(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new Slider object; can also be called as
+PARENT-&gt;AddSlider(%OPTIONS).
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Scroll_">
+
+<DL>
+<DT><STRONG><A NAME="item_Scroll">Scroll()</A></STRONG><DD>
+<P>
+Sent when the user moves the slider handle.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Splitter.html perl-libwin32-0.191/GUI/docs/html/Splitter.html
--- libwin32-0.191/GUI/docs/html/Splitter.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Splitter.html	2004-01-12 16:46:41.078125000 -0800
@@ -0,0 +1,111 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Splitter</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Splitter">Package Win32::GUI::Splitter</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Splitter">Package Win32::GUI::Splitter</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Splitter_PARENT_">new Win32::GUI::Splitter(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Release_COORD_">Release(COORD)</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Splitter_PARENT_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Splitter(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new Splitter object; can also be called as
+PARENT-&gt;AddHeader(%OPTIONS). Class specific <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>  -buttons =&gt; 0/1 (default 0)
+    header items look like push buttons and can be clicked.
+  -hottrack =&gt; 0/1 (default 0)
+  -imagelist =&gt; Win32::GUI::ImageList object
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Release_COORD_">
+
+<DL>
+<DT><STRONG><A NAME="item_Release">Release(COORD)</A></STRONG><DD>
+<P>
+Sent when the Splitter is released after being dragged to a new location
+(identified by the COORD parameter).
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/StatusBar.html perl-libwin32-0.191/GUI/docs/html/StatusBar.html
--- libwin32-0.191/GUI/docs/html/StatusBar.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/StatusBar.html	2004-01-12 16:46:41.093750000 -0800
@@ -0,0 +1,72 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::StatusBar</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_StatusBar">Package Win32::GUI::StatusBar</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_StatusBar">Package Win32::GUI::StatusBar</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_StatusBar_PARENT">new Win32::GUI::StatusBar(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_StatusBar_PARENT">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::StatusBar(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new StatusBar object; can also be called as
+PARENT-&gt;AddStatusBar(%OPTIONS).
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/TabStrip.html perl-libwin32-0.191/GUI/docs/html/TabStrip.html
--- libwin32-0.191/GUI/docs/html/TabStrip.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/TabStrip.html	2004-01-12 16:46:41.109375000 -0800
@@ -0,0 +1,403 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::TabStrip</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_TabStrip">Package Win32::GUI::TabStrip</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_TabStrip">Package Win32::GUI::TabStrip</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_TabStrip_PARENT_">new Win32::GUI::TabStrip(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#AdjustRect_LEFT_TOP_RIGHT_BOT">AdjustRect(LEFT, TOP, RIGHT, BOTTOM, [FLAG])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ChangeItem_ITEM_OPTIONS_">ChangeItem(ITEM, %OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Count_">Count()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DeleteItem_ITEM_">DeleteItem(ITEM)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DisplayArea_">DisplayArea()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetItemRect_">GetItemRect()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetString_ITEM_">GetString(ITEM)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#HitTest_">HitTest()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#InsertItem_OPTIONS_">InsertItem(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#MinTabWidth_WIDTH_">MinTabWidth(WIDTH)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Padding_X_Y_">Padding(X,Y)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Reset_">Reset()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#RowCount_">RowCount()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Select_INDEX_">Select(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SelectedItem_">SelectedItem()</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Change_">Change()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Changing_">Changing()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_TabStrip_PARENT_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::TabStrip(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new TabStrip object; can also be called as
+PARENT-&gt;AddTabStrip(%OPTIONS). Class specific <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>  -bottom    =&gt; 0/1 (default 0)
+  -buttons   =&gt; 0/1 (default 0)
+  -hottrack  =&gt; 0/1 (default 0)
+  -imagelist =&gt; Win32::GUI::ImageList object
+  -justify   =&gt; 0/1 (default 0)
+  -multiline =&gt; 0/1 (default 0)
+  -right     =&gt; 0/1 (default 0)
+  -vertical  =&gt; 0/1 (default 0)
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="AdjustRect_LEFT_TOP_RIGHT_BOT">
+
+<DL>
+<DT><STRONG><A NAME="item_AdjustRect">AdjustRect(LEFT, TOP, RIGHT, BOTTOM, [FLAG])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="ChangeItem_ITEM_OPTIONS_">
+
+<DT><STRONG><A NAME="item_ChangeItem">ChangeItem(ITEM, %OPTIONS)</A></STRONG><DD>
+<P>
+Change most of the options used when the item was created (see  <A HREF="#InsertItem_OPTIONS_">InsertItem()</A>). Allowed <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>    -image
+    -text
+</PRE>
+</P>
+<P>
+
+<A NAME="Count_">
+
+<DT><STRONG><A NAME="item_Count">Count()</A></STRONG><DD>
+<P>
+Returns the number of items in the TabStrip.
+
+</P>
+<P>
+
+<A NAME="DeleteItem_ITEM_">
+
+<DT><STRONG><A NAME="item_DeleteItem">DeleteItem(ITEM)</A></STRONG><DD>
+<P>
+Removes the specified ITEM from the TabStrip.
+
+</P>
+<P>
+
+<A NAME="DisplayArea_">
+
+<DT><STRONG><A NAME="item_DisplayArea">DisplayArea()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetItemRect_">
+
+<DT><STRONG><A NAME="item_GetItemRect">GetItemRect()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetString_ITEM_">
+
+<DT><STRONG><A NAME="item_GetString">GetString(ITEM)</A></STRONG><DD>
+<P>
+Returns the string associated with the specified ITEM in the TabStrip.
+
+</P>
+<P>
+
+<A NAME="HitTest_">
+
+<DT><STRONG><A NAME="item_HitTest">HitTest()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="InsertItem_OPTIONS_">
+
+<DT><STRONG><A NAME="item_InsertItem">InsertItem(%OPTIONS)</A></STRONG><DD>
+<P>
+Adds an item to the TabStrip. Allowed <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE> -image =&gt; NUMBER
+   the index of an image from the associated ImageList
+ -index =&gt; NUMBER
+   the position for the new item (if not specified, the item
+   is added at the end of the control)
+ -text  =&gt; STRING
+   the text that will appear on the item
+</PRE>
+</P>
+<P>
+
+<A NAME="MinTabWidth_WIDTH_">
+
+<DT><STRONG><A NAME="item_MinTabWidth">MinTabWidth(WIDTH)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Padding_X_Y_">
+
+<DT><STRONG><A NAME="item_Padding">Padding(X,Y)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Reset_">
+
+<DT><STRONG><A NAME="item_Reset">Reset()</A></STRONG><DD>
+<P>
+Deletes all items from the TabStrip.
+
+</P>
+<P>
+
+<A NAME="RowCount_">
+
+<DT><STRONG><A NAME="item_RowCount">RowCount()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Select_INDEX_">
+
+<DT><STRONG><A NAME="item_Select">Select(INDEX)</A></STRONG><DD>
+<P>
+Selects the zero-based INDEX item in the TabStrip.
+
+</P>
+<P>
+
+<A NAME="SelectedItem_">
+
+<DT><STRONG><A NAME="item_SelectedItem">SelectedItem()</A></STRONG><DD>
+<P>
+Returns the zero-based index of the currently selected item.
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Change_">
+
+<DL>
+<DT><STRONG><A NAME="item_Change">Change()</A></STRONG><DD>
+<P>
+Sent when the current selection has changed. Use
+<CODE>SelectedItem()</CODE> to determine the current selection.
+
+</P>
+<P>
+
+<A NAME="Changing_">
+
+<DT><STRONG><A NAME="item_Changing">Changing()</A></STRONG><DD>
+<P>
+Sent before the current selection changes. Use <CODE>SelectedItem()</CODE>
+to determine the current selection. The event should return 0 to prevent
+the selection changing, 1 to allow it.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Textfield.html perl-libwin32-0.191/GUI/docs/html/Textfield.html
--- libwin32-0.191/GUI/docs/html/Textfield.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Textfield.html	2004-01-12 16:46:41.125000000 -0800
@@ -0,0 +1,395 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Textfield</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Textfield">Package Win32::GUI::Textfield</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Textfield">Package Win32::GUI::Textfield</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Textfield_PARENT">new Win32::GUI::Textfield(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Append_TEXT_">Append(TEXT)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#LineFromChar_INDEX_">LineFromChar(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#MaxLength_CHARS_">MaxLength([CHARS])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Modified_FLAG_">Modified([FLAG])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#PasswordChar_CHAR_">PasswordChar([CHAR])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ReadOnly_FLAG_">ReadOnly([FLAG])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ReplaceSel_STRING_FLAG_">ReplaceSel(STRING, [FLAG])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Scroll_COMMAND_LINE_HORIZONT">Scroll(COMMAND &#124; LINE &#124; HORIZONTAL, VERTICAL)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Select_START_END_">Select(START, END)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SelectAll_">SelectAll()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Selection_">Selection()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Undo_">Undo()</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Change_">Change()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GotFocus_">GotFocus()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#LostFocus_">LostFocus()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Textfield_PARENT">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Textfield(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new Textfield object; can also be called as
+PARENT-&gt;AddTextfield(%OPTIONS). Class specific <CODE>%OPTIONS</CODE>
+are:
+
+</P>
+<P>
+<PRE>  -align         =&gt; left/center/right (default left)
+      aligns the text in the control accordingly.
+  -keepselection =&gt; 0/1 (default 0)
+      the selection is not hidden when the control loses focus.
+  -multiline     =&gt; 0/1 (default 0)
+      the control can have more than one line (note that newline
+      is &quot;\r\n&quot;, not &quot;\n&quot;!).
+  -password      =&gt; 0/1 (default 0)
+      masks the user input (like password prompts).
+  -passwordchar  =&gt; char (default '*')
+      the char that is shown instead of the text with -password =&gt; 1.
+  -prompt        =&gt; (see below)
+  -readonly      =&gt; 0/1 (default 0)
+      text can't be changed.
+</PRE>
+</P>
+<P>
+The -prompt option is very special; if a string is passed, a
+Win32::GUI::Label object (with text set to the string passed) is created to
+the left of the Textfield. Example:
+
+</P>
+<P>
+<PRE>    $Window-&gt;AddTextfield(
+        -name   =&gt; &quot;Username&quot;,
+        -left   =&gt; 75,
+        -top    =&gt; 150,
+        -prompt =&gt; &quot;Your name:&quot;,
+    );
+</PRE>
+</P>
+<P>
+Furthermore, the value to -prompt can be a reference to a list containing
+the string and an additional parameter, which sets the width for the Label
+(eg. [ STRING, WIDTH ] ). If WIDTH is negative, it is calculated relative
+to the Textfield left coordinate. Example:
+
+</P>
+<P>
+<PRE>    -left =&gt; 75,                          (Label left) (Textfield left)
+    -prompt =&gt; [ &quot;Your name:&quot;, 30 ],       75           105 (75+30)
+    -left =&gt; 75,
+    -prompt =&gt; [ &quot;Your name:&quot;, -30 ],      45 (75-30)   75
+</PRE>
+</P>
+<P>
+Note that the Win32::GUI::Label object is named like the Textfield, with a
+``_Prompt'' suffix (in the example above, the Label is named
+``Username_Prompt'').
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="Append_TEXT_">
+
+<DL>
+<DT><STRONG><A NAME="item_Append">Append(TEXT)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="LineFromChar_INDEX_">
+
+<DT><STRONG><A NAME="item_LineFromChar">LineFromChar(INDEX)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="MaxLength_CHARS_">
+
+<DT><STRONG><A NAME="item_MaxLength">MaxLength([CHARS])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Modified_FLAG_">
+
+<DT><STRONG><A NAME="item_Modified">Modified([FLAG])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="PasswordChar_CHAR_">
+
+<DT><STRONG><A NAME="item_PasswordChar">PasswordChar([CHAR])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="ReadOnly_FLAG_">
+
+<DT><STRONG><A NAME="item_ReadOnly">ReadOnly([FLAG])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="ReplaceSel_STRING_FLAG_">
+
+<DT><STRONG><A NAME="item_ReplaceSel">ReplaceSel(STRING, [FLAG])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Scroll_COMMAND_LINE_HORIZONT">
+
+<DT><STRONG><A NAME="item_Scroll">Scroll(COMMAND | LINE | HORIZONTAL, VERTICAL)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Select_START_END_">
+
+<DT><STRONG><A NAME="item_Select">Select(START, END)</A></STRONG><DD>
+<P>
+Selects the specified range of characters.
+
+</P>
+<P>
+
+<A NAME="SelectAll_">
+
+<DT><STRONG><A NAME="item_SelectAll">SelectAll()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Selection_">
+
+<DT><STRONG><A NAME="item_Selection">Selection()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Undo_">
+
+<DT><STRONG><A NAME="item_Undo">Undo()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Change_">
+
+<DL>
+<DT><STRONG><A NAME="item_Change">Change()</A></STRONG><DD>
+<P>
+Sent when the text in the field is changed by the user.
+
+</P>
+<P>
+
+<A NAME="GotFocus_">
+
+<DT><STRONG><A NAME="item_GotFocus">GotFocus()</A></STRONG><DD>
+<P>
+Sent when the control is activated.
+
+</P>
+<P>
+
+<A NAME="LostFocus_">
+
+<DT><STRONG><A NAME="item_LostFocus">LostFocus()</A></STRONG><DD>
+<P>
+Sent when the control is deactivated.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Timer.html perl-libwin32-0.191/GUI/docs/html/Timer.html
--- libwin32-0.191/GUI/docs/html/Timer.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Timer.html	2004-01-12 16:46:41.140625000 -0800
@@ -0,0 +1,120 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Timer</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Timer">Package Win32::GUI::Timer</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Timer">Package Win32::GUI::Timer</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Timer_PARENT_NA">new Win32::GUI::Timer(PARENT, NAME, ELAPSE)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Interval_ELAPSE_">Interval(ELAPSE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Kill_">Kill()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Timer_PARENT_NA">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Timer(PARENT, NAME, ELAPSE)</A></STRONG><DD>
+<P>
+Creates a new timer in the PARENT window named NAME that will trigger its
+<CODE>Timer()</CODE> event after ELAPSE milliseconds. Can also be called as
+PARENT-&gt;AddTimer(NAME, ELAPSE).
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="Interval_ELAPSE_">
+
+<DL>
+<DT><STRONG><A NAME="item_Interval">Interval(ELAPSE)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Kill_">
+
+<DT><STRONG><A NAME="item_Kill">Kill()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Toolbar.html perl-libwin32-0.191/GUI/docs/html/Toolbar.html
--- libwin32-0.191/GUI/docs/html/Toolbar.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Toolbar.html	2004-01-12 16:46:41.156250000 -0800
@@ -0,0 +1,272 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Toolbar</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Toolbar">Package Win32::GUI::Toolbar</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Toolbar">Package Win32::GUI::Toolbar</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Toolbar_PARENT_">new Win32::GUI::Toolbar(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#AddBitmap_BITMAP_NUMBUTTONS_">AddBitmap(BITMAP, NUMBUTTONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddButtons_NUMBER_">AddButtons(NUMBER, ...)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddString_STRING_">AddString(STRING)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AutoSize_">AutoSize()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ButtonCount_">ButtonCount()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Indent_VALUE_">Indent(VALUE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#MaxSize_">MaxSize()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Padding_X_Y_">Padding([X], [Y])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetBitmapSize_X_Y_">SetBitmapSize([X, Y])</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#ButtonClick_INDEX_">ButtonClick(INDEX)</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Toolbar_PARENT_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Toolbar(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new Toolbar object; can also be called as
+PARENT-&gt;AddToolbar(%OPTIONS). Class specific <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>  -flat      =&gt; 0/1
+  -imagelist =&gt; IMAGELIST
+  -multiline =&gt; 0/1
+  -nodivider =&gt; 0/1
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="AddBitmap_BITMAP_NUMBUTTONS_">
+
+<DL>
+<DT><STRONG><A NAME="item_AddBitmap">AddBitmap(BITMAP, NUMBUTTONS)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="AddButtons_NUMBER_">
+
+<DT><STRONG><A NAME="item_AddButtons">AddButtons(NUMBER, ...)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="AddString_STRING_">
+
+<DT><STRONG><A NAME="item_AddString">AddString(STRING)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="AutoSize_">
+
+<DT><STRONG><A NAME="item_AutoSize">AutoSize()</A></STRONG><DD>
+<P>
+causes the toolbar to be resized
+
+</P>
+<P>
+
+<A NAME="ButtonCount_">
+
+<DT><STRONG><A NAME="item_ButtonCount">ButtonCount()</A></STRONG><DD>
+<P>
+returns the number of buttons in the toolbar
+
+</P>
+<P>
+
+<A NAME="Indent_VALUE_">
+
+<DT><STRONG><A NAME="item_Indent">Indent(VALUE)</A></STRONG><DD>
+<P>
+sets the indentation value for the toolbar
+
+</P>
+<P>
+
+<A NAME="MaxSize_">
+
+<DT><STRONG><A NAME="item_MaxSize">MaxSize()</A></STRONG><DD>
+<P>
+returns the total size of all the visible buttons and separators in the
+toolbar (or undef on errors)
+
+</P>
+<P>
+
+<A NAME="Padding_X_Y_">
+
+<DT><STRONG><A NAME="item_Padding">Padding([X], [Y])</A></STRONG><DD>
+<P>
+gets or sets the padding for the toolbar; if no value is passed, returns a
+list containing the current x and y padding value, in pixels.
+
+</P>
+<P>
+
+<A NAME="SetBitmapSize_X_Y_">
+
+<DT><STRONG><A NAME="item_SetBitmapSize">SetBitmapSize([X, Y])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="ButtonClick_INDEX_">
+
+<DL>
+<DT><STRONG><A NAME="item_ButtonClick">ButtonClick(INDEX)</A></STRONG><DD>
+<P>
+Sent when the user presses a button of the Toolbar the INDEX argument
+identifies the zero-based index of the pressed button
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Tooltip.html perl-libwin32-0.191/GUI/docs/html/Tooltip.html
--- libwin32-0.191/GUI/docs/html/Tooltip.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Tooltip.html	2004-01-12 16:46:41.171875000 -0800
@@ -0,0 +1,149 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Tooltip</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Tooltip">Package Win32::GUI::Tooltip</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Tooltip">Package Win32::GUI::Tooltip</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Tooltip_PARENT_">new Win32::GUI::Tooltip(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Add_">Add(...)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Count_">Count()</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#NeedText_ID_">NeedText(ID)</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Tooltip_PARENT_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Tooltip(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+(preliminary) creates a new Tooltip object
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="Add_">
+
+<DL>
+<DT><STRONG><A NAME="item_Add">Add(...)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Count_">
+
+<DT><STRONG><A NAME="item_Count">Count()</A></STRONG><DD>
+<P>
+Returns the number of tools in the Tooltip.
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="NeedText_ID_">
+
+<DL>
+<DT><STRONG><A NAME="item_NeedText">NeedText(ID)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/TreeView.html perl-libwin32-0.191/GUI/docs/html/TreeView.html
--- libwin32-0.191/GUI/docs/html/TreeView.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/TreeView.html	2004-01-12 16:46:41.187500000 -0800
@@ -0,0 +1,722 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::TreeView</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_TreeView">Package Win32::GUI::TreeView</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_TreeView">Package Win32::GUI::TreeView</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_TreeView_PARENT_">new Win32::GUI::TreeView(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#BackColor_COLOR_">BackColor([COLOR])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ChangeItem_NODE_OPTIONS_">ChangeItem(NODE, %OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Clear_NODE_">Clear([NODE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Collapse_NODE_">Collapse(NODE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Count_">Count()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DeleteItem_NODE_">DeleteItem(NODE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#EnsureVisible_NODE_">EnsureVisible(NODE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Expand_NODE_FLAG_">Expand(NODE, [FLAG])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#FirstVisible_NODE_">FirstVisible([NODE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetChild_NODE_">GetChild(NODE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetItem_NODE_">GetItem(NODE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetLastVisible_">GetLastVisible()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetNextSibling_NODE_">GetNextSibling(NODE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetNextVisible_NODE_">GetNextVisible(NODE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetParent_NODE_">GetParent(NODE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetPrevSibling_NODE_">GetPrevSibling(NODE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetPrevVisible_NODE_">GetPrevVisible(NODE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetRoot_">GetRoot()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#HitTest_X_Y_">HitTest(X, Y)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Indent_VALUE_">Indent([VALUE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#InsertItem_OPTIONS_">InsertItem(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ItemCheck_NODE_VALUE_">ItemCheck(NODE, [VALUE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ItemInfo_NODE_">ItemInfo(NODE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Reset_">Reset()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Select_NODE_FLAG_">Select(NODE, [FLAG])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SelectedItem_">SelectedItem()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetImageList_IMAGELIST_TYPE_">SetImageList(IMAGELIST, [TYPE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Sort_NODE_">Sort(NODE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#TextColor_COLOR_">TextColor([COLOR])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#VisibleCount_">VisibleCount()</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Collapse_NODE_">Collapse(NODE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Collapsing_NODE_">Collapsing(NODE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Expand_NODE_">Expand(NODE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Expanding_NODE_">Expanding(NODE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#KeyDown_KEY_">KeyDown(KEY)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#NodeClick_NODE_">NodeClick(NODE)</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_TreeView_PARENT_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::TreeView(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new TreeView object can also be called as
+PARENT-&gt;AddTreeView(%OPTIONS).
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="BackColor_COLOR_">
+
+<DL>
+<DT><STRONG><A NAME="item_BackColor">BackColor([COLOR])</A></STRONG><DD>
+<P>
+Gets or sets the background color for the control.
+
+</P>
+<P>
+
+<A NAME="ChangeItem_NODE_OPTIONS_">
+
+<DT><STRONG><A NAME="item_ChangeItem">ChangeItem(NODE, %OPTIONS)</A></STRONG><DD>
+<P>
+Change most of the options used when the item was created (see  <A HREF="#InsertItem_OPTIONS_">InsertItem()</A>). Allowed <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>    -bold
+    -image
+    -selected
+    -selectedimage
+    -text
+</PRE>
+</P>
+<P>
+
+<A NAME="Clear_NODE_">
+
+<DT><STRONG><A NAME="item_Clear">Clear([NODE])</A></STRONG><DD>
+<P>
+Deletes all nodes from the TreeView if no argument is given; otherwise,
+delete all nodes under the given NODE.
+
+</P>
+<P>
+
+<A NAME="Collapse_NODE_">
+
+<DT><STRONG><A NAME="item_Collapse">Collapse(NODE)</A></STRONG><DD>
+<P>
+Closes a NODE of the TreeView.
+
+</P>
+<P>
+
+<A NAME="Count_">
+
+<DT><STRONG><A NAME="item_Count">Count()</A></STRONG><DD>
+<P>
+Returns the number of nodes in the TreeView.
+
+</P>
+<P>
+
+<A NAME="DeleteItem_NODE_">
+
+<DT><STRONG><A NAME="item_DeleteItem">DeleteItem(NODE)</A></STRONG><DD>
+<P>
+Removes the specified NODE from the TreeView.
+
+</P>
+<P>
+
+<A NAME="EnsureVisible_NODE_">
+
+<DT><STRONG><A NAME="item_EnsureVisible">EnsureVisible(NODE)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Expand_NODE_FLAG_">
+
+<DT><STRONG><A NAME="item_Expand">Expand(NODE, [FLAG])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="FirstVisible_NODE_">
+
+<DT><STRONG><A NAME="item_FirstVisible">FirstVisible([NODE])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetChild_NODE_">
+
+<DT><STRONG><A NAME="item_GetChild">GetChild(NODE)</A></STRONG><DD>
+<P>
+Returns the handle of the first child node for the given NODE.
+
+</P>
+<P>
+
+<A NAME="GetItem_NODE_">
+
+<DT><STRONG><A NAME="item_GetItem">GetItem(NODE)</A></STRONG><DD>
+<P>
+See  <A HREF="#ItemInfo_NODE_">ItemInfo()</A>.
+
+</P>
+<P>
+
+<A NAME="GetLastVisible_">
+
+<DT><STRONG><A NAME="item_GetLastVisible">GetLastVisible()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetNextSibling_NODE_">
+
+<DT><STRONG><A NAME="item_GetNextSibling">GetNextSibling(NODE)</A></STRONG><DD>
+<P>
+Returns the handle of the next sibling node for the given NODE.
+
+</P>
+<P>
+
+<A NAME="GetNextVisible_NODE_">
+
+<DT><STRONG><A NAME="item_GetNextVisible">GetNextVisible(NODE)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetParent_NODE_">
+
+<DT><STRONG><A NAME="item_GetParent">GetParent(NODE)</A></STRONG><DD>
+<P>
+Returns the handle of the parent node for the given NODE.
+
+</P>
+<P>
+
+<A NAME="GetPrevSibling_NODE_">
+
+<DT><STRONG><A NAME="item_GetPrevSibling">GetPrevSibling(NODE)</A></STRONG><DD>
+<P>
+Returns the handle of the previous sibling node for the given NODE.
+
+</P>
+<P>
+
+<A NAME="GetPrevVisible_NODE_">
+
+<DT><STRONG><A NAME="item_GetPrevVisible">GetPrevVisible(NODE)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetRoot_">
+
+<DT><STRONG><A NAME="item_GetRoot">GetRoot()</A></STRONG><DD>
+<P>
+Returns the handle of the TreeView root node.
+
+</P>
+<P>
+
+<A NAME="HitTest_X_Y_">
+
+<DT><STRONG><A NAME="item_HitTest">HitTest(X, Y)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Indent_VALUE_">
+
+<DT><STRONG><A NAME="item_Indent">Indent([VALUE])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="InsertItem_OPTIONS_">
+
+<DT><STRONG><A NAME="item_InsertItem">InsertItem(%OPTIONS)</A></STRONG><DD>
+<P>
+Inserts a new node in the TreeView. Allowed <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>    -bold =&gt; 0/1, default 0
+    -image =&gt; NUMBER
+        index of an image from the associated ImageList
+    -item =&gt; NUMBER
+        handle of the node after which the new node is to be inserted,
+        or one of the following special values:
+            0xFFFF0001: at the beginning of the list
+            0xFFFF0002: at the end of the list
+            0xFFFF0003: in alphabetical order
+        the default value is at the end of the list
+    -parent =&gt; NUMBER
+        handle of the parent node for the new node
+    -selected =&gt; 0/1, default 0
+    -selectedimage =&gt; NUMBER
+        index of an image from the associated ImageList
+    -text =&gt; STRING
+        the text for the node
+</PRE>
+</P>
+<P>
+
+<A NAME="ItemCheck_NODE_VALUE_">
+
+<DT><STRONG><A NAME="item_ItemCheck">ItemCheck(NODE, [VALUE])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="ItemInfo_NODE_">
+
+<DT><STRONG><A NAME="item_ItemInfo">ItemInfo(NODE)</A></STRONG><DD>
+<P>
+Returns an associative array of information about the given NODE:
+
+</P>
+<P>
+<PRE>    -children
+    -image
+    -parent
+    -selectedimage
+    -state
+    -text
+</PRE>
+</P>
+<P>
+
+<A NAME="Reset_">
+
+<DT><STRONG><A NAME="item_Reset">Reset()</A></STRONG><DD>
+<P>
+Deletes all nodes from the TreeView.
+
+</P>
+<P>
+
+<A NAME="Select_NODE_FLAG_">
+
+<DT><STRONG><A NAME="item_Select">Select(NODE, [FLAG])</A></STRONG><DD>
+<P>
+Selects the given NODE in the TreeView; the optional FLAG parameter can be
+set to 5 if you want the selected NODE to become, if possible, the first
+visible item in the TreeView. If NODE is 0 (zero), the selected item, if
+any, is deselected.
+
+</P>
+<P>
+
+<A NAME="SelectedItem_">
+
+<DT><STRONG><A NAME="item_SelectedItem">SelectedItem()</A></STRONG><DD>
+<P>
+Returns the handle of the currently selected node.
+
+</P>
+<P>
+
+<A NAME="SetImageList_IMAGELIST_TYPE_">
+
+<DT><STRONG><A NAME="item_SetImageList">SetImageList(IMAGELIST, [TYPE])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Sort_NODE_">
+
+<DT><STRONG><A NAME="item_Sort">Sort(NODE)</A></STRONG><DD>
+<P>
+Sorts the childs of the specified NODE in the TreeView.
+
+</P>
+<P>
+
+<A NAME="TextColor_COLOR_">
+
+<DT><STRONG><A NAME="item_TextColor">TextColor([COLOR])</A></STRONG><DD>
+<P>
+Gets or sets the text color for the control.
+
+</P>
+<P>
+
+<A NAME="VisibleCount_">
+
+<DT><STRONG><A NAME="item_VisibleCount">VisibleCount()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Collapse_NODE_">
+
+<DL>
+<DT><STRONG>Collapse(NODE)</STRONG><DD>
+<P>
+Sent when the user closes the specified NODE of the TreeView.
+
+</P>
+<P>
+
+<A NAME="Collapsing_NODE_">
+
+<DT><STRONG><A NAME="item_Collapsing">Collapsing(NODE)</A></STRONG><DD>
+<P>
+Sent when the user is about to close the specified NODE of the TreeView.
+The event should return 0 to prevent the action, 1 to allow it.
+
+</P>
+<P>
+
+<A NAME="Expand_NODE_">
+
+<DT><STRONG><A NAME="item_Expand">Expand(NODE)</A></STRONG><DD>
+<P>
+Sent when the user opens the specified NODE of the TreeView.
+
+</P>
+<P>
+
+<A NAME="Expanding_NODE_">
+
+<DT><STRONG><A NAME="item_Expanding">Expanding(NODE)</A></STRONG><DD>
+<P>
+Sent when the user is about to open the specified NODE of the TreeView The
+event should return 0 to prevent the action, 1 to allow it.
+
+</P>
+<P>
+
+<A NAME="KeyDown_KEY_">
+
+<DT><STRONG><A NAME="item_KeyDown">KeyDown(KEY)</A></STRONG><DD>
+<P>
+Sent when the user presses a key while the TreeView control has focus; KEY
+is the ASCII code of the key being pressed.
+
+</P>
+<P>
+
+<A NAME="NodeClick_NODE_">
+
+<DT><STRONG><A NAME="item_NodeClick">NodeClick(NODE)</A></STRONG><DD>
+<P>
+Sent when the user clicks on the specified NODE of the TreeView.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/UpDown.html perl-libwin32-0.191/GUI/docs/html/UpDown.html
--- libwin32-0.191/GUI/docs/html/UpDown.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/UpDown.html	2004-01-12 16:46:41.203125000 -0800
@@ -0,0 +1,188 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::UpDown</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_UpDown">Package Win32::GUI::UpDown</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_UpDown">Package Win32::GUI::UpDown</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_UpDown_PARENT_">new Win32::GUI::UpDown(PARENT, %OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Base_VALUE_">Base([VALUE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Buddy_OBJECT_">Buddy([OBJECT])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Pos_VALUE_">Pos([VALUE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Range_MIN_MAX_">Range([MIN, MAX])</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Scroll_">Scroll()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_UpDown_PARENT_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::UpDown(PARENT, %OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new UpDown object; can also be called as
+PARENT-&gt;AddUpDown(%OPTIONS).
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="Base_VALUE_">
+
+<DL>
+<DT><STRONG><A NAME="item_Base">Base([VALUE])</A></STRONG><DD>
+<P>
+Gets or sets the radix base for the UpDown control; VALUE can be either 10
+or 16 for decimal or hexadecimal base numbering.
+
+</P>
+<P>
+
+<A NAME="Buddy_OBJECT_">
+
+<DT><STRONG><A NAME="item_Buddy">Buddy([OBJECT])</A></STRONG><DD>
+<P>
+Gets or sets the buddy window for the UpDown control.
+
+</P>
+<P>
+
+<A NAME="Pos_VALUE_">
+
+<DT><STRONG><A NAME="item_Pos">Pos([VALUE])</A></STRONG><DD>
+<P>
+Gets or sets the current position of the UpDown control.
+
+</P>
+<P>
+
+<A NAME="Range_MIN_MAX_">
+
+<DT><STRONG><A NAME="item_Range">Range([MIN, MAX])</A></STRONG><DD>
+<P>
+Gets or sets the range for the UpDown control; if no parameter is given,
+returns a two element array containing the MIN and MAX range values,
+otherwise sets them to the given values. If MAX is lower than MIN, the
+UpDown control function is reversed, eg. the up button decrements the value
+and the down button increments it
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Scroll_">
+
+<DL>
+<DT><STRONG><A NAME="item_Scroll">Scroll()</A></STRONG><DD>
+<P>
+Sent when the user presses either the up or down button of the UpDown
+control.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Win32_GUI.html perl-libwin32-0.191/GUI/docs/html/Win32_GUI.html
--- libwin32-0.191/GUI/docs/html/Win32_GUI.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Win32_GUI.html	2004-01-12 16:46:41.218750000 -0800
@@ -0,0 +1,1936 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI">Package Win32::GUI</A></LI>
+		<UL>
+
+			<LI><A HREF="#Methods">Methods</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI">Package Win32::GUI</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#AbsLeft_">AbsLeft()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AbsTop_">AbsTop()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ArrangeIconicWindows_">ArrangeIconicWindows()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AttachThreadInput_FROM_TO_FLA">AttachThreadInput(FROM, TO, [FLAG])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#BringWindowToTop_">BringWindowToTop()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#BrowseForFolder_OPTIONS_">BrowseForFolder(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Caption_TEXT_">Caption([TEXT])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Change_HANDLE_OPTIONS_">Change(HANDLE, %OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ChangeCursor_CURSOR_">ChangeCursor(CURSOR)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ChangeIcon_ICON_">ChangeIcon(ICON)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ChangeSmallIcon_ICON_">ChangeSmallIcon(ICON)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ChooseColor_OPTIONS_">ChooseColor(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ChooseFont_OPTIONS_">ChooseFont(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ClipCursor_LEFT_TOP_RIGHT_BO">ClipCursor([LEFT, TOP, RIGHT, BOTTOM])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#CloseEnhMetaFile_">CloseEnhMetaFile()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#CloseWindow_">CloseWindow()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#CommDlgExtendedError_">CommDlgExtendedError()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#CreateEnhMetaFile_FILENAME_DES">CreateEnhMetaFile(FILENAME, [DESCRIPTION])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DeleteEnhMetaFile_HANDLE_">DeleteEnhMetaFile(HANDLE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Dialog_">Dialog()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DialogUI_HANDLE_FLAG_">DialogUI(HANDLE, [FLAG])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Disable_">Disable()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DoEvents_">DoEvents()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DoModal_">DoModal()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DrawMenuBar_">DrawMenuBar()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Enable_FLAG_">Enable([FLAG])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#EnumMyWindows_">EnumMyWindows()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#FindWindow_CLASSNAME_WINDOWNAME">FindWindow(CLASSNAME, WINDOWNAME)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetActiveWindow_">GetActiveWindow()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetClassName_">GetClassName()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetClientRect_">GetClientRect()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetCursor_">GetCursor()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetCursorPos_">GetCursorPos()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetDesktopWindow_">GetDesktopWindow()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetDlgItem_ID_">GetDlgItem(ID)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetEffectiveClientRect_HANDLE_I">GetEffectiveClientRect(HANDLE, ID)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetFocus_">GetFocus()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetFont_FONT_">GetFont(FONT)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetFontName_">GetFontName()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetForegroundWindow_">GetForegroundWindow()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetMenu_">GetMenu()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetMessage_MIN_MAX_">GetMessage([MIN, MAX])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetOpenFileName_OPTIONS_">GetOpenFileName(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetPerlWindow_">GetPerlWindow()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetSaveFileName_OPTIONS_">GetSaveFileName(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetStockObject_OBJECT_">GetStockObject(OBJECT)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetSystemMetrics_INDEX_">GetSystemMetrics(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetTextExtentPoint32_STRING_FO">GetTextExtentPoint32(STRING, [FONT])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetTopWindow_">GetTopWindow()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetWindow_COMMAND_">GetWindow(COMMAND)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetWindowLong_INDEX_">GetWindowLong(INDEX)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetWindowRect_">GetWindowRect()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetWindowThreadProcessId_">GetWindowThreadProcessId()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Height_HEIGHT_">Height([HEIGHT])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Hide_">Hide()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Hook_MSG_CODEREF_">Hook(MSG,CODEREF)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#InvalidateRect_">InvalidateRect(...)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#IsEnabled_">IsEnabled()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#IsIconic_">IsIconic()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#IsVisible_">IsVisible()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#IsWindow_">IsWindow()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#IsZoomed_">IsZoomed()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Left_LEFT_">Left([LEFT])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Maximize_">Maximize()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#MessageBox_HANDLE_TEXT_CAPT">MessageBox([HANDLE], TEXT, [CAPTION], [TYPE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Minimize_">Minimize()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Move_X_Y_">Move(X, Y)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#OpenIcon_">OpenIcon()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#PeekMessage_MIN_MAX_MESSAGE_">PeekMessage([MIN, MAX, MESSAGE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#PlayEnhMetaFile_FILENAME_">PlayEnhMetaFile(FILENAME)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#PlayWinMetaFile_FILENAME_">PlayWinMetaFile(FILENAME)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#PostMessage_MSG_WPARAM_LPARAM_">PostMessage(MSG, WPARAM, LPARAM)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#PostQuitMessage_EXITCODE_">PostQuitMessage([EXITCODE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ReleaseCapture_">ReleaseCapture()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Resize_X_Y_">Resize(X, Y)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Restore_">Restore()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SaveBMP_handle_">SaveBMP(handle)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ScaleHeight_">ScaleHeight()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ScaleWidth_">ScaleWidth()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#ScreenToClient_X_Y_">ScreenToClient(X, Y)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SendMessage_MSG_WPARAM_LPARAM_">SendMessage(MSG, WPARAM, LPARAM)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SendMessageTimeout_MSG_WPARAM_">SendMessageTimeout(MSG, WPARAM, LPARAM, [FLAGS], TIMEOUT)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetCapture_">SetCapture()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetCursor_CURSOR_">SetCursor(CURSOR)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetCursorPos_X_Y_">SetCursorPos(X, Y)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetFocus_">SetFocus()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetFont_FONT_">SetFont(FONT)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetForegroundWindow_">SetForegroundWindow()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetIcon_ICON_TYPE_">SetIcon(ICON, [TYPE])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetMenu_MENU_">SetMenu(MENU)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetRedraw_FLAG_">SetRedraw(FLAG)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#SetWindowLong_INDEX_VALUE_">SetWindowLong(INDEX, VALUE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Show_COMMAND_">Show([COMMAND])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Text_TEXT_">Text([TEXT])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Top_TOP_">Top([TOP])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#TrackMouse_TIMEOUT_EVENTS_">TrackMouse([TIMEOUT, EVENTS])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#TrackPopupMenu_MENU_X_Y_FLAG">TrackPopupMenu(MENU, X, Y, [FLAGS])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#UnHook_MSG_">UnHook(MSG)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#UntrackMouse_">UntrackMouse()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Update_">Update()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Version_">Version()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Width_WIDTH_">Width([WIDTH])</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#WindowFromPoint_X_Y_">WindowFromPoint(X, Y)</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="AbsLeft_">
+
+<DL>
+<DT><STRONG><A NAME="item_AbsLeft">AbsLeft()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="AbsTop_">
+
+<DT><STRONG><A NAME="item_AbsTop">AbsTop()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="ArrangeIconicWindows_">
+
+<DT><STRONG><A NAME="item_ArrangeIconicWindows">ArrangeIconicWindows()</A></STRONG><DD>
+<P>
+Arranges all the minimized child windows of the specified parent window.
+
+</P>
+<P>
+
+<A NAME="AttachThreadInput_FROM_TO_FLA">
+
+<DT><STRONG><A NAME="item_AttachThreadInput">AttachThreadInput(FROM, TO, [FLAG])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="BringWindowToTop_">
+
+<DT><STRONG><A NAME="item_BringWindowToTop">BringWindowToTop()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="BrowseForFolder_OPTIONS_">
+
+<DT><STRONG><A NAME="item_BrowseForFolder">BrowseForFolder(%OPTIONS)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Caption_TEXT_">
+
+<DT><STRONG><A NAME="item_Caption">Caption([TEXT])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Change_HANDLE_OPTIONS_">
+
+<DT><STRONG><A NAME="item_Change">Change(HANDLE, %OPTIONS)</A></STRONG><DD>
+<P>
+Change most of the options used when the object was created.
+
+</P>
+<P>
+
+<A NAME="ChangeCursor_CURSOR_">
+
+<DT><STRONG><A NAME="item_ChangeCursor">ChangeCursor(CURSOR)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="ChangeIcon_ICON_">
+
+<DT><STRONG><A NAME="item_ChangeIcon">ChangeIcon(ICON)</A></STRONG><DD>
+<P>
+Changes the default icon for a window to ICON (a Win32::GUI::Icon object).
+Returns the handle of the previous default icon.
+
+</P>
+<P>
+
+<A NAME="ChangeSmallIcon_ICON_">
+
+<DT><STRONG><A NAME="item_ChangeSmallIcon">ChangeSmallIcon(ICON)</A></STRONG><DD>
+<P>
+Changes the default small icon for a window to ICON (a Win32::GUI::Icon
+object). Returns the handle of the previous default small icon.
+
+</P>
+<P>
+
+<A NAME="ChooseColor_OPTIONS_">
+
+<DT><STRONG><A NAME="item_ChooseColor">ChooseColor(%OPTIONS)</A></STRONG><DD>
+<P>
+Allowed <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE> -owner
+ -color
+</PRE>
+</P>
+<P>
+
+<A NAME="ChooseFont_OPTIONS_">
+
+<DT><STRONG><A NAME="item_ChooseFont">ChooseFont(%OPTIONS)</A></STRONG><DD>
+<P>
+Allowed <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE> -owner
+ -size
+ -height
+ -width
+ -escapement
+ -orientation
+ -weight
+ -bold
+ -italic
+ -underline
+ -strikeout
+ -charset
+ -outputprecision
+ -clipprecision
+ -quality
+ -family
+ -name
+ -face (== -name)
+ -color
+ -ttonly
+ -fixedonly
+ -effects
+ -script
+ -minsize
+ -maxsize
+</PRE>
+</P>
+<P>
+
+<A NAME="ClipCursor_LEFT_TOP_RIGHT_BO">
+
+<DT><STRONG><A NAME="item_ClipCursor">ClipCursor([LEFT, TOP, RIGHT, BOTTOM])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="CloseEnhMetaFile_">
+
+<DT><STRONG><A NAME="item_CloseEnhMetaFile">CloseEnhMetaFile()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="CloseWindow_">
+
+<DT><STRONG><A NAME="item_CloseWindow">CloseWindow()</A></STRONG><DD>
+<P>
+(@)METHOD:Minimize()
+
+</P>
+<P>
+
+<A NAME="CommDlgExtendedError_">
+
+<DT><STRONG><A NAME="item_CommDlgExtendedError">CommDlgExtendedError()</A></STRONG><DD>
+<P>
+Returns the common dialog library error code.
+
+</P>
+<P>
+
+<A NAME="CreateEnhMetaFile_FILENAME_DES">
+
+<DT><STRONG><A NAME="item_CreateEnhMetaFile">CreateEnhMetaFile(FILENAME, [DESCRIPTION])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="DeleteEnhMetaFile_HANDLE_">
+
+<DT><STRONG><A NAME="item_DeleteEnhMetaFile">DeleteEnhMetaFile(HANDLE)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Dialog_">
+
+<DT><STRONG><A NAME="item_Dialog">Dialog()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="DialogUI_HANDLE_FLAG_">
+
+<DT><STRONG><A NAME="item_DialogUI">DialogUI(HANDLE, [FLAG])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Disable_">
+
+<DT><STRONG><A NAME="item_Disable">Disable()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="DoEvents_">
+
+<DT><STRONG><A NAME="item_DoEvents">DoEvents()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="DoModal_">
+
+<DT><STRONG><A NAME="item_DoModal">DoModal()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="DrawMenuBar_">
+
+<DT><STRONG><A NAME="item_DrawMenuBar">DrawMenuBar()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Enable_FLAG_">
+
+<DT><STRONG><A NAME="item_Enable">Enable([FLAG])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="EnumMyWindows_">
+
+<DT><STRONG><A NAME="item_EnumMyWindows">EnumMyWindows()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="FindWindow_CLASSNAME_WINDOWNAME">
+
+<DT><STRONG><A NAME="item_FindWindow">FindWindow(CLASSNAME, WINDOWNAME)</A></STRONG><DD>
+<P>
+Returns the handle of the window whose class name and window name match the
+specified strings; both strings can be empty. Note that the function does
+not search child windows, only top level windows. If no matching windows is
+found, the return value is zero.
+
+</P>
+<P>
+
+<A NAME="GetActiveWindow_">
+
+<DT><STRONG><A NAME="item_GetActiveWindow">GetActiveWindow()</A></STRONG><DD>
+<P>
+Returns the handle of the active window.
+
+</P>
+<P>
+
+<A NAME="GetClassName_">
+
+<DT><STRONG><A NAME="item_GetClassName">GetClassName()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetClientRect_">
+
+<DT><STRONG><A NAME="item_GetClientRect">GetClientRect()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetCursor_">
+
+<DT><STRONG><A NAME="item_GetCursor">GetCursor()</A></STRONG><DD>
+<P>
+Returns the handle of the current cursor.
+
+</P>
+<P>
+
+<A NAME="GetCursorPos_">
+
+<DT><STRONG><A NAME="item_GetCursorPos">GetCursorPos()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetDesktopWindow_">
+
+<DT><STRONG><A NAME="item_GetDesktopWindow">GetDesktopWindow()</A></STRONG><DD>
+<P>
+Returns the handle of the desktop window.
+
+</P>
+<P>
+
+<A NAME="GetDlgItem_ID_">
+
+<DT><STRONG><A NAME="item_GetDlgItem">GetDlgItem(ID)</A></STRONG><DD>
+<P>
+Returns the handle of a control in the dialog box given its ID.
+
+</P>
+<P>
+
+<A NAME="GetEffectiveClientRect_HANDLE_I">
+
+<DT><STRONG><A NAME="item_GetEffectiveClientRect">GetEffectiveClientRect(HANDLE, ID)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetFocus_">
+
+<DT><STRONG><A NAME="item_GetFocus">GetFocus()</A></STRONG><DD>
+<P>
+Returns the handle of the window that has the keyboard focus.
+
+</P>
+<P>
+
+<A NAME="GetFont_FONT_">
+
+<DT><STRONG><A NAME="item_GetFont">GetFont(FONT)</A></STRONG><DD>
+<P>
+Gets the font of the window (returns an handle; use
+
+</P>
+<P>
+<PRE>  $Font = $W-&gt;GetFont();
+  %details = Win32::GUI::Font::Info( $Font );
+</PRE>
+</P>
+<P>
+to get font details).
+
+</P>
+<P>
+
+<A NAME="GetFontName_">
+
+<DT><STRONG><A NAME="item_GetFontName">GetFontName()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetForegroundWindow_">
+
+<DT><STRONG><A NAME="item_GetForegroundWindow">GetForegroundWindow()</A></STRONG><DD>
+<P>
+Returns the handle of the foreground window.
+
+</P>
+<P>
+
+<A NAME="GetMenu_">
+
+<DT><STRONG><A NAME="item_GetMenu">GetMenu()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetMessage_MIN_MAX_">
+
+<DT><STRONG><A NAME="item_GetMessage">GetMessage([MIN, MAX])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetOpenFileName_OPTIONS_">
+
+<DT><STRONG><A NAME="item_GetOpenFileName">GetOpenFileName(%OPTIONS)</A></STRONG><DD>
+<P>
+Allowed <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE> -owner =&gt; WINDOW
+     Identifies the window that owns the dialog box.
+ -title =&gt; STRING
+     The title for the dialog
+ -directory =&gt; STRING
+     Specifies the initial directory
+ -file =&gt; STRING
+     Specifies a name that will appear on the dialog's edit field
+ -filter =&gt; ARRAY REFERENCE
+     Specifies an array containing pairs of filter strings.
+     The first string in each pair is a display string that describes the filter
+     (for example, &quot;Text Files&quot;), and the second string specifies the filter pattern
+     (for example, &quot;*.TXT&quot;). To specify multiple filter patterns for a single display
+     string, use a semicolon to separate the patterns (for example, &quot;*.TXT;*.DOC;*.BAK&quot;).
+     A pattern string can be a combination of valid filename characters and the asterisk (*)
+     wildcard character. Do not include spaces in the pattern string.
+ -defaultextention =&gt; STRING
+     Contains the default extension. GetOpenFileName append this extension to the filename if the user
+     fails to type an extension. This string can be any length, but only the first three characters are
+     appended. The string should not contain a period (.).
+ -defaultfilter =&gt; NUMBER
+     Specifies the index of the currently selected filter in the File Types control.
+     The first pair of strings has an index value of 0, the second pair 1, and so on.
+</PRE>
+</P>
+<P>
+Flags :
+
+</P>
+<P>
+<PRE> -createprompt =&gt; 0/1 (default 0)
+     If the user specifies a file that does not exist, this flag causes the dialog box to prompt
+     the user for permission to create the file. If the user chooses to create the file, the dialog box
+     closes and the function returns the specified name; otherwise, the dialog box remains open.
+     If you use this flag with the -multisel flag, the dialog box allows the user to specify
+     only one nonexistent file.
+ -multisel =&gt; 0/1 (default 0)
+     Allow multiple file selection
+     If the user selects more than one file then return filename with full path.
+     If the user selects more than one file then return an array with the path
+     to the current directory followed by the filenames of the selected files.
+ -explorer =&gt; 0/1 (default 1)
+     Explorer look.
+ -extensiondifferent =&gt; 0/1 (default 0)
+     Specifies that the user can typed a filename extension that differs from the extension specified by -defaultextention.
+ -filemustexist =&gt; 0/1 (default 0)
+     Specifies that the user can type only names of existing files in the File Name entry field.
+     If this flag is specified and the user enters an invalid name, the dialog box procedure displays
+     a warning in a message box.
+ -hidereadonly =&gt; 0/1 (default 1)
+     Hides the Read Only check box.
+     If -hidereadonly is set to 0, the read only statut is return only in array context as last value.
+ -nochangedir =&gt; 0/1 (default 0)
+     Restores the current directory to its original value if the user changed the directory while searching for files.
+ -nodeferencelinks =&gt; 0/1 (default 0)
+     Directs the dialog box to return the path and filename of the selected shortcut (.LNK) file.
+     If this value is not given, the dialog box returns the path and filename of the file referenced by the shortcut.
+ -nonetwork  =&gt; 0/1 (default 0)
+     Hides and disables the Network button
+ -noreadonlyreturn =&gt; 0/1 (default 0)
+     Specifies that the returned file does not have the Read Only check box checked and is not in a write-protected directory.
+ -pathmustexist =&gt; 0/1 (default 0)
+     Specifies that the user can type only valid paths and filenames.
+     If this flag is used and the user types an invalid path and filename in the File Name entry field, the dialog box function displays a warning in a message box.
+ -readonly =&gt; 0/1 (default 0)
+           Causes the Read Only check box to be checked initially when the dialog box is created.
+</PRE>
+</P>
+<P>
+
+<A NAME="GetPerlWindow_">
+
+<DT><STRONG><A NAME="item_GetPerlWindow">GetPerlWindow()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetSaveFileName_OPTIONS_">
+
+<DT><STRONG><A NAME="item_GetSaveFileName">GetSaveFileName(%OPTIONS)</A></STRONG><DD>
+<P>
+Allowed <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE> -owner =&gt; WINDOW
+     Identifies the window that owns the dialog box.
+ -title =&gt; STRING
+     The title for the dialog
+ -directory =&gt; STRING
+     Specifies the initial directory
+ -file =&gt; STRING
+     Specifies a name that will appear on the dialog's edit field
+ -filter =&gt; ARRAY REFERENCE
+     Specifies an array containing pairs of filter strings.
+     The first string in each pair is a display string that describes the filter
+     (for example, &quot;Text Files&quot;), and the second string specifies the filter pattern
+     (for example, &quot;*.TXT&quot;). To specify multiple filter patterns for a single display
+     string, use a semicolon to separate the patterns (for example, &quot;*.TXT;*.DOC;*.BAK&quot;).
+     A pattern string can be a combination of valid filename characters and the asterisk (*)
+     wildcard character. Do not include spaces in the pattern string.
+ -defaultextention =&gt; STRING
+     Contains the default extension. GetSaveFileName append this extension to the filename if the user
+     fails to type an extension. This string can be any length, but only the first three characters are
+     appended. The string should not contain a period (.).
+ -defaultfilter =&gt; NUMBER
+     Specifies the index of the currently selected filter in the File Types control.
+     The first pair of strings has an index value of 0, the second pair 1, and so on.
+</PRE>
+</P>
+<P>
+Flags :
+
+</P>
+<P>
+<PRE> -createprompt =&gt; 0/1 (default 0)
+     If the user specifies a file that does not exist, this flag causes the dialog box to prompt
+     the user for permission to create the file. If the user chooses to create the file, the dialog box
+     closes and the function returns the specified name; otherwise, the dialog box remains open.
+     If you use this flag with the -multisel flag, the dialog box allows the user to specify
+     only one nonexistent file.
+ -explorer =&gt; 0/1 (default 1)
+     Explorer look.
+ -extensiondifferent =&gt; 0/1 (default 0)
+     Specifies that the user can typed a filename extension that differs from the extension specified by -defaultextention.
+ -filemustexist =&gt; 0/1 (default 0)
+     Specifies that the user can type only names of existing files in the File Name entry field.
+     If this flag is specified and the user enters an invalid name, the dialog box procedure displays
+     a warning in a message box.
+ -nochangedir =&gt; 0/1 (default 0)
+     Restores the current directory to its original value if the user changed the directory while searching for files.
+ -nodeferencelinks =&gt; 0/1 (default 0)
+     Directs the dialog box to return the path and filename of the selected shortcut (.LNK) file.
+     If this value is not given, the dialog box returns the path and filename of the file referenced by the shortcut.
+ -nonetwork  =&gt; 0/1 (default 0)
+     Hides and disables the Network button
+ -noreadonlyreturn =&gt; 0/1 (default 0)
+     Specifies that the returned file is not in a write-protected directory.
+ -pathmustexist =&gt; 0/1 (default 1)
+     Specifies that the user can type only valid paths and filenames.
+     If this flag is used and the user types an invalid path and filename in the File Name entry field, the dialog box function displays a warning in a message box.
+ -overdriveprompt =&gt; 0/1 (default 1)
+     Generate a message box if the selected file already exists. The user must confirm whether to overwrite the file.
+</PRE>
+</P>
+<P>
+
+<A NAME="GetStockObject_OBJECT_">
+
+<DT><STRONG><A NAME="item_GetStockObject">GetStockObject(OBJECT)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetSystemMetrics_INDEX_">
+
+<DT><STRONG><A NAME="item_GetSystemMetrics">GetSystemMetrics(INDEX)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetTextExtentPoint32_STRING_FO">
+
+<DT><STRONG><A NAME="item_GetTextExtentPoint32">GetTextExtentPoint32(STRING, [FONT])</A></STRONG><DD>
+<P>
+Returns a two elements array containing the x and y size of the specified
+STRING in the window (eventually with the speficied FONT), or undef on
+errors.
+
+</P>
+<P>
+
+<A NAME="GetTopWindow_">
+
+<DT><STRONG><A NAME="item_GetTopWindow">GetTopWindow()</A></STRONG><DD>
+<P>
+Returns the handle of the foreground window.
+
+</P>
+<P>
+
+<A NAME="GetWindow_COMMAND_">
+
+<DT><STRONG><A NAME="item_GetWindow">GetWindow(COMMAND)</A></STRONG><DD>
+<P>
+Returns handle of the window that has the specified relationship (given by
+COMMAND) with the specified window. Available COMMANDs are:
+
+</P>
+<P>
+<PRE>  GW_CHILD
+  GW_HWNDFIRST
+  GW_HWNDLAST
+  GW_HWNDNEXT
+  GW_HWNDPREV
+  GW_OWNER
+</PRE>
+</P>
+<P>
+Example:
+
+</P>
+<P>
+<PRE>    $Button-&gt;GetWindow(GW_OWNER);
+</PRE>
+</P>
+<P>
+
+<A NAME="GetWindowLong_INDEX_">
+
+<DT><STRONG><A NAME="item_GetWindowLong">GetWindowLong(INDEX)</A></STRONG><DD>
+<P>
+Retrieves a windows property; for more info consult the original API
+documentation.
+
+</P>
+<P>
+
+<A NAME="GetWindowRect_">
+
+<DT><STRONG><A NAME="item_GetWindowRect">GetWindowRect()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="GetWindowThreadProcessId_">
+
+<DT><STRONG><A NAME="item_GetWindowThreadProcessId">GetWindowThreadProcessId()</A></STRONG><DD>
+<P>
+Returns a two elements array containing the thread and the process
+identifier for the specified window.
+
+</P>
+<P>
+
+<A NAME="Height_HEIGHT_">
+
+<DT><STRONG><A NAME="item_Height">Height([HEIGHT])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Hide_">
+
+<DT><STRONG><A NAME="item_Hide">Hide()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Hook_MSG_CODEREF_">
+
+<DT><STRONG><A NAME="item_Hook">Hook(MSG,CODEREF)</A></STRONG><DD>
+<P>
+Assigns a handler to a window message. Returns the previous handler code
+reference or undef if no previous perl handler was defined.
+
+</P>
+<P>
+
+<A NAME="InvalidateRect_">
+
+<DT><STRONG><A NAME="item_InvalidateRect">InvalidateRect(...)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="IsEnabled_">
+
+<DT><STRONG><A NAME="item_IsEnabled">IsEnabled()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="IsIconic_">
+
+<DT><STRONG><A NAME="item_IsIconic">IsIconic()</A></STRONG><DD>
+<P>
+Returns TRUE if the window is minimized, FALSE otherwise.
+
+</P>
+<P>
+
+<A NAME="IsVisible_">
+
+<DT><STRONG><A NAME="item_IsVisible">IsVisible()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="IsWindow_">
+
+<DT><STRONG><A NAME="item_IsWindow">IsWindow()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="IsZoomed_">
+
+<DT><STRONG><A NAME="item_IsZoomed">IsZoomed()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Left_LEFT_">
+
+<DT><STRONG><A NAME="item_Left">Left([LEFT])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Maximize_">
+
+<DT><STRONG><A NAME="item_Maximize">Maximize()</A></STRONG><DD>
+<P>
+Maximizes a window.
+
+</P>
+<P>
+
+<A NAME="MessageBox_HANDLE_TEXT_CAPT">
+
+<DT><STRONG><A NAME="item_MessageBox">MessageBox([HANDLE], TEXT, [CAPTION], [TYPE])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Minimize_">
+
+<DT><STRONG><A NAME="item_Minimize">Minimize()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Move_X_Y_">
+
+<DT><STRONG><A NAME="item_Move">Move(X, Y)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="OpenIcon_">
+
+<DT><STRONG><A NAME="item_OpenIcon">OpenIcon()</A></STRONG><DD>
+<P>
+(@)METHOD:Restore()
+
+</P>
+<P>
+
+<A NAME="PeekMessage_MIN_MAX_MESSAGE_">
+
+<DT><STRONG><A NAME="item_PeekMessage">PeekMessage([MIN, MAX, MESSAGE])</A></STRONG><DD>
+<P>
+Inspects the window's message queue and eventually returns data about the
+message it contains; it can optionally check only for message identifiers
+in the range MIN..MAX; the last MESSAGE parameter, if specified, must be an
+array reference. If a message is found, the function puts in that array 7
+elements containing:
+
+</P>
+<P>
+<PRE>  - the handle of the window to which the message is addressed
+  - the message identifier
+  - the wParam argument
+  - the lParam argument
+  - the time when message occurs
+  - the x coordinate at which message occurs
+  - the y coordinate at which message occurs
+</PRE>
+</P>
+<P>
+
+<A NAME="PlayEnhMetaFile_FILENAME_">
+
+<DT><STRONG><A NAME="item_PlayEnhMetaFile">PlayEnhMetaFile(FILENAME)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="PlayWinMetaFile_FILENAME_">
+
+<DT><STRONG><A NAME="item_PlayWinMetaFile">PlayWinMetaFile(FILENAME)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="PostMessage_MSG_WPARAM_LPARAM_">
+
+<DT><STRONG><A NAME="item_PostMessage">PostMessage(MSG, WPARAM, LPARAM)</A></STRONG><DD>
+<P>
+Posts a message to a window.
+
+</P>
+<P>
+
+<A NAME="PostQuitMessage_EXITCODE_">
+
+<DT><STRONG><A NAME="item_PostQuitMessage">PostQuitMessage([EXITCODE])</A></STRONG><DD>
+<P>
+Sends a quit message to a window, optionally with an EXITCODE; if no
+EXITCODE is given, it defaults to 0.
+
+</P>
+<P>
+
+<A NAME="ReleaseCapture_">
+
+<DT><STRONG><A NAME="item_ReleaseCapture">ReleaseCapture()</A></STRONG><DD>
+<P>
+Releases the mouse capture.
+
+</P>
+<P>
+
+<A NAME="Resize_X_Y_">
+
+<DT><STRONG><A NAME="item_Resize">Resize(X, Y)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Restore_">
+
+<DT><STRONG><A NAME="item_Restore">Restore()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="SaveBMP_handle_">
+
+<DT><STRONG><A NAME="item_SaveBMP">SaveBMP(handle)</A></STRONG><DD>
+<P>
+(preliminary) Saves the window content to a BMP file.
+
+</P>
+<P>
+
+<A NAME="ScaleHeight_">
+
+<DT><STRONG><A NAME="item_ScaleHeight">ScaleHeight()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="ScaleWidth_">
+
+<DT><STRONG><A NAME="item_ScaleWidth">ScaleWidth()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="ScreenToClient_X_Y_">
+
+<DT><STRONG><A NAME="item_ScreenToClient">ScreenToClient(X, Y)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="SendMessage_MSG_WPARAM_LPARAM_">
+
+<DT><STRONG><A NAME="item_SendMessage">SendMessage(MSG, WPARAM, LPARAM)</A></STRONG><DD>
+<P>
+Sends a message to a window.
+
+</P>
+<P>
+
+<A NAME="SendMessageTimeout_MSG_WPARAM_">
+
+<DT><STRONG><A NAME="item_SendMessageTimeout">SendMessageTimeout(MSG, WPARAM, LPARAM, [FLAGS], TIMEOUT)</A></STRONG><DD>
+<P>
+Sends a message to a window and wait for it to be processed or until the
+specified TIMEOUT (number of milliseconds) elapses; returns the result code
+of the processed message or undef on errors. If undef is returned and a
+call to Win32::GetLastError() returns 0, then the window timed out
+processing the message. The FLAGS parameter is optional, possible values
+are:
+
+</P>
+<P>
+<PRE> 0 SMTO_NORMAL
+   (the calling thread can process other requests while waiting;
+   this is the default setting)
+ 1 SMTO_BLOCK
+   (the calling thread does not process other requests)
+ 2 SMTO_ABORTIFHUNG
+   (returns without waiting if the receiving process seems to be &quot;hung&quot;)
+</PRE>
+</P>
+<P>
+
+<A NAME="SetCapture_">
+
+<DT><STRONG><A NAME="item_SetCapture">SetCapture()</A></STRONG><DD>
+<P>
+Assigns the mouse capture to a window.
+
+</P>
+<P>
+
+<A NAME="SetCursor_CURSOR_">
+
+<DT><STRONG><A NAME="item_SetCursor">SetCursor(CURSOR)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="SetCursorPos_X_Y_">
+
+<DT><STRONG><A NAME="item_SetCursorPos">SetCursorPos(X, Y)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="SetFocus_">
+
+<DT><STRONG><A NAME="item_SetFocus">SetFocus()</A></STRONG><DD>
+<P>
+Activates a window.
+
+</P>
+<P>
+
+<A NAME="SetFont_FONT_">
+
+<DT><STRONG><A NAME="item_SetFont">SetFont(FONT)</A></STRONG><DD>
+<P>
+Sets the font of the window (FONT is a Win32::GUI::Font object).
+
+</P>
+<P>
+
+<A NAME="SetForegroundWindow_">
+
+<DT><STRONG><A NAME="item_SetForegroundWindow">SetForegroundWindow()</A></STRONG><DD>
+<P>
+Brings the window to the foreground.
+
+</P>
+<P>
+
+<A NAME="SetIcon_ICON_TYPE_">
+
+<DT><STRONG><A NAME="item_SetIcon">SetIcon(ICON, [TYPE])</A></STRONG><DD>
+<P>
+Sets the icon of the window; TYPE can be 0 for the small icon, 1 for the
+big icon. Default is the same icon for small and big.
+
+</P>
+<P>
+
+<A NAME="SetMenu_MENU_">
+
+<DT><STRONG><A NAME="item_SetMenu">SetMenu(MENU)</A></STRONG><DD>
+<P>
+Associates the specified MENU to a window.
+
+</P>
+<P>
+
+<A NAME="SetRedraw_FLAG_">
+
+<DT><STRONG><A NAME="item_SetRedraw">SetRedraw(FLAG)</A></STRONG><DD>
+<P>
+Determines if a window is automatically redrawn when its content changes.
+FLAG can be a true value to allow redraw, false to prevent it.
+
+</P>
+<P>
+
+<A NAME="SetWindowLong_INDEX_VALUE_">
+
+<DT><STRONG><A NAME="item_SetWindowLong">SetWindowLong(INDEX, VALUE)</A></STRONG><DD>
+<P>
+Sets a windows property; for more info consult the original API
+documentation.
+
+</P>
+<P>
+
+<A NAME="Show_COMMAND_">
+
+<DT><STRONG><A NAME="item_Show">Show([COMMAND])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Text_TEXT_">
+
+<DT><STRONG><A NAME="item_Text">Text([TEXT])</A></STRONG><DD>
+<P>
+(@)METHOD:Caption([TEXT])
+
+</P>
+<P>
+
+<A NAME="Top_TOP_">
+
+<DT><STRONG><A NAME="item_Top">Top([TOP])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="TrackMouse_TIMEOUT_EVENTS_">
+
+<DT><STRONG><A NAME="item_TrackMouse">TrackMouse([TIMEOUT, EVENTS])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="TrackPopupMenu_MENU_X_Y_FLAG">
+
+<DT><STRONG><A NAME="item_TrackPopupMenu">TrackPopupMenu(MENU, X, Y, [FLAGS])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="UnHook_MSG_">
+
+<DT><STRONG><A NAME="item_UnHook">UnHook(MSG)</A></STRONG><DD>
+<P>
+;Undefines a Window Message hook.
+
+</P>
+<P>
+
+<A NAME="UntrackMouse_">
+
+<DT><STRONG><A NAME="item_UntrackMouse">UntrackMouse()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Update_">
+
+<DT><STRONG><A NAME="item_Update">Update()</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="Version_">
+
+<DT><STRONG><A NAME="item_Version">Version()</A></STRONG><DD>
+<P>
+Returns the module version number.
+
+</P>
+<P>
+
+<A NAME="Width_WIDTH_">
+
+<DT><STRONG><A NAME="item_Width">Width([WIDTH])</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+<A NAME="WindowFromPoint_X_Y_">
+
+<DT><STRONG><A NAME="item_WindowFromPoint">WindowFromPoint(X, Y)</A></STRONG><DD>
+<P>
+[TBD]
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/Window.html perl-libwin32-0.191/GUI/docs/html/Window.html
--- libwin32-0.191/GUI/docs/html/Window.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/Window.html	2004-01-12 16:46:41.250000000 -0800
@@ -0,0 +1,679 @@
+<HTML>
+<HEAD>
+<TITLE>Package Win32::GUI::Window</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Package_Win32_GUI_Window">Package Win32::GUI::Window</A></LI>
+		<UL>
+
+			<LI><A HREF="#Constructor">Constructor</A></LI>
+			<LI><A HREF="#Methods">Methods</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Package_Win32_GUI_Window">Package Win32::GUI::Window</A></H2>
+<P>
+<A HREF="././guipacks.html#">Back to the Packages</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Constructor">Constructor</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#new_Win32_GUI_Window_OPTIONS_">new Win32::GUI::Window(%OPTIONS)</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Methods">Methods</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#AddAnimation_OPTIONS_">AddAnimation(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddButton_OPTIONS_">AddButton(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddCheckbox_OPTIONS_">AddCheckbox(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddCombobox_OPTIONS_">AddCombobox(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddComboboxEx_OPTIONS_">AddComboboxEx(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddDateTime_OPTIONS_">AddDateTime(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddGraphic_OPTIONS_">AddGraphic(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddGroupbox_OPTIONS_">AddGroupbox(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddHeader_OPTIONS_">AddHeader(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddLabel_OPTIONS_">AddLabel(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddListbox_OPTIONS_">AddListbox(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddListView_OPTIONS_">AddListView(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddMenu_">AddMenu()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddNotifyIcon_OPTIONS_">AddNotifyIcon(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddProgressBar_OPTIONS_">AddProgressBar(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddRadioButton_OPTIONS_">AddRadioButton(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddRebar_OPTIONS_">AddRebar(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddRichEdit_OPTIONS_">AddRichEdit(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddSlider_OPTIONS_">AddSlider(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddSplitter_OPTIONS_">AddSplitter(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddStatusBar_OPTIONS_">AddStatusBar(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddTabStrip_OPTIONS_">AddTabStrip(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddTextfield_OPTIONS_">AddTextfield(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddTimer_NAME_ELAPSE_">AddTimer(NAME, ELAPSE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddToolbar_OPTIONS_">AddToolbar(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddTreeView_OPTIONS_">AddTreeView(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#AddUpDown_OPTIONS_">AddUpDown(%OPTIONS)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#GetDC_">GetDC()</A>
+
+
+
+</P>
+</UL>
+<LI>
+<P>
+<A HREF="#Events">Events</A>
+
+
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="#Activate_">Activate()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Deactivate_">Deactivate()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#DropFiles_DROP_HANDLE_">DropFiles(DROP_HANDLE)</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Maximize_">Maximize()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Minimize_">Minimize()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Resize_">Resize()</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="#Terminate_">Terminate()</A>
+
+
+
+</P>
+</UL>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Constructor">Constructor</A></H3>
+<A NAME="new_Win32_GUI_Window_OPTIONS_">
+
+<DL>
+<DT><STRONG><A NAME="item_new">new Win32::GUI::Window(%OPTIONS)</A></STRONG><DD>
+<P>
+Creates a new Window object. Class specific <CODE>%OPTIONS</CODE> are:
+
+</P>
+<P>
+<PRE>  -minsize =&gt; [X, Y]
+    specifies the minimum size (width and height) in pixels;
+    X and Y must be passed in an array reference
+  -maxsize =&gt; [X, Y]
+    specifies the maximum size (width and height) in pixels;
+    X and Y must be passed in an array reference
+  -minwidth  =&gt; N
+  -minheight =&gt; N
+  -maxwidht  =&gt; N
+  -maxheight =&gt; N
+    specify the minimum and maximum size width
+    and height, in pixels
+  -topmost =&gt; 0/1 (default 0)
+    the window &quot;stays on top&quot; even when deactivated
+</PRE>
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Methods">Methods</A></H3>
+<A NAME="AddAnimation_OPTIONS_">
+
+<DL>
+<DT><STRONG><A NAME="item_AddAnimation">AddAnimation(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././Animation.html#new_Win32_GUI_Animation_PARENT">new Win32::GUI::Animation()</A>.
+
+</P>
+<P>
+
+<A NAME="AddButton_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddButton">AddButton(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././Button.html#new_Win32_GUI_Button_PARENT_">new Win32::GUI::Button()</A>.
+
+</P>
+<P>
+
+<A NAME="AddCheckbox_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddCheckbox">AddCheckbox(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././Checkbox.html#new_Win32_GUI_Checkbox_PARENT_">new Win32::GUI::Checkbox()</A>.
+
+</P>
+<P>
+
+<A NAME="AddCombobox_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddCombobox">AddCombobox(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././Combobox.html#new_Win32_GUI_Combobox_PARENT_">new Win32::GUI::Combobox()</A>.
+
+</P>
+<P>
+
+<A NAME="AddComboboxEx_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddComboboxEx">AddComboboxEx(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././Combobox.html#new_Win32_GUI_Combobox_PARENT_">new Win32::GUI::Combobox()</A>.
+
+</P>
+<P>
+
+<A NAME="AddDateTime_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddDateTime">AddDateTime(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././DateTime.html#new_Win32_GUI_DateTime_PARENT_">new Win32::GUI::DateTime()</A>.
+
+</P>
+<P>
+
+<A NAME="AddGraphic_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddGraphic">AddGraphic(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././Graphic.html#new_Win32_GUI_Graphic_PARENT_">new Win32::GUI::Graphic()</A>.
+
+</P>
+<P>
+
+<A NAME="AddGroupbox_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddGroupbox">AddGroupbox(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././Groupbox.html#new_Win32_GUI_Groupbox_PARENT_">new Win32::GUI::Groupbox()</A>.
+
+</P>
+<P>
+
+<A NAME="AddHeader_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddHeader">AddHeader(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././Header.html#new_Win32_GUI_Header_PARENT_">new Win32::GUI::Header()</A>.
+
+</P>
+<P>
+
+<A NAME="AddLabel_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddLabel">AddLabel(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././Label.html#new_Win32_GUI_Label_PARENT_O">new Win32::GUI::Label()</A>.
+
+</P>
+<P>
+
+<A NAME="AddListbox_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddListbox">AddListbox(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././Listbox.html#new_Win32_GUI_Listbox_PARENT_">new Win32::GUI::Listbox()</A>.
+
+</P>
+<P>
+
+<A NAME="AddListView_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddListView">AddListView(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././ListView.html#new_Win32_GUI_ListView_PARENT_">new Win32::GUI::ListView()</A>.
+
+</P>
+<P>
+
+<A NAME="AddMenu_">
+
+<DT><STRONG><A NAME="item_AddMenu">AddMenu()</A></STRONG><DD>
+<P>
+See  <A HREF="././Menu.html#new_Win32_GUI_Menu_">new Win32::GUI::Menu()</A>.
+
+</P>
+<P>
+
+<A NAME="AddNotifyIcon_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddNotifyIcon">AddNotifyIcon(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././NotifyIcon.html#new_Win32_GUI_NotifyIcon_PAREN">new Win32::GUI::NotifyIcon()</A>.
+
+</P>
+<P>
+
+<A NAME="AddProgressBar_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddProgressBar">AddProgressBar(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././ProgressBar.html#new_Win32_GUI_ProgressBar_PARE">new Win32::GUI::ProgressBar()</A>.
+
+</P>
+<P>
+
+<A NAME="AddRadioButton_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddRadioButton">AddRadioButton(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././RadioButton.html#new_Win32_GUI_RadioButton_PARE">new Win32::GUI::RadioButton()</A>.
+
+</P>
+<P>
+
+<A NAME="AddRebar_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddRebar">AddRebar(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././Rebar.html#new_Win32_GUI_Rebar_PARENT_O">new Win32::GUI::Rebar()</A>.
+
+</P>
+<P>
+
+<A NAME="AddRichEdit_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddRichEdit">AddRichEdit(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././RichEdit.html#new_Win32_GUI_RichEdit_PARENT_">new Win32::GUI::RichEdit()</A>.
+
+</P>
+<P>
+
+<A NAME="AddSlider_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddSlider">AddSlider(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././Slider.html#new_Win32_GUI_Slider_PARENT_">new Win32::GUI::Slider()</A>.
+
+</P>
+<P>
+
+<A NAME="AddSplitter_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddSplitter">AddSplitter(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././Splitter.html#new_Win32_GUI_Splitter_PARENT_">new Win32::GUI::Splitter()</A>.
+
+</P>
+<P>
+
+<A NAME="AddStatusBar_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddStatusBar">AddStatusBar(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././StatusBar.html#new_Win32_GUI_StatusBar_PARENT">new Win32::GUI::StatusBar()</A>.
+
+</P>
+<P>
+
+<A NAME="AddTabStrip_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddTabStrip">AddTabStrip(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././TabStrip.html#new_Win32_GUI_TabStrip_PARENT_">new Win32::GUI::TabStrip()</A>.
+
+</P>
+<P>
+
+<A NAME="AddTextfield_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddTextfield">AddTextfield(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././Textfield.html#new_Win32_GUI_Textfield_PARENT">new Win32::GUI::Textfield()</A>.
+
+</P>
+<P>
+
+<A NAME="AddTimer_NAME_ELAPSE_">
+
+<DT><STRONG><A NAME="item_AddTimer">AddTimer(NAME, ELAPSE)</A></STRONG><DD>
+<P>
+See  <A HREF="././Timer.html#new_Win32_GUI_Timer_PARENT_NA">new Win32::GUI::Timer()</A>.
+
+</P>
+<P>
+
+<A NAME="AddToolbar_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddToolbar">AddToolbar(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././Toolbar.html#new_Win32_GUI_Toolbar_PARENT_">new Win32::GUI::Toolbar()</A>.
+
+</P>
+<P>
+
+<A NAME="AddTreeView_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddTreeView">AddTreeView(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././TreeView.html#new_Win32_GUI_TreeView_PARENT_">new Win32::GUI::TreeView()</A>.
+
+</P>
+<P>
+
+<A NAME="AddUpDown_OPTIONS_">
+
+<DT><STRONG><A NAME="item_AddUpDown">AddUpDown(%OPTIONS)</A></STRONG><DD>
+<P>
+See  <A HREF="././UpDown.html#new_Win32_GUI_UpDown_PARENT_">new Win32::GUI::UpDown()</A>.
+
+</P>
+<P>
+
+<A NAME="GetDC_">
+
+<DT><STRONG><A NAME="item_GetDC">GetDC()</A></STRONG><DD>
+<P>
+Returns the DC object associated with the window.
+
+</P>
+<P>
+
+</DL>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<A NAME="Activate_">
+
+<DL>
+<DT><STRONG><A NAME="item_Activate">Activate()</A></STRONG><DD>
+<P>
+Sent when the window is activated.
+
+</P>
+<P>
+
+<A NAME="Deactivate_">
+
+<DT><STRONG><A NAME="item_Deactivate">Deactivate()</A></STRONG><DD>
+<P>
+Sent when the window is deactivated.
+
+</P>
+<P>
+
+<A NAME="DropFiles_DROP_HANDLE_">
+
+<DT><STRONG><A NAME="item_DropFiles">DropFiles(DROP_HANDLE)</A></STRONG><DD>
+<P>
+Sent when the window receives dropped files.
+
+</P>
+<P>
+
+<A NAME="Maximize_">
+
+<DT><STRONG><A NAME="item_Maximize">Maximize()</A></STRONG><DD>
+<P>
+Sent when the window is maximized.
+
+</P>
+<P>
+
+<A NAME="Minimize_">
+
+<DT><STRONG><A NAME="item_Minimize">Minimize()</A></STRONG><DD>
+<P>
+Sent when the window is minimized.
+
+</P>
+<P>
+
+<A NAME="Resize_">
+
+<DT><STRONG><A NAME="item_Resize">Resize()</A></STRONG><DD>
+<P>
+Sent when the window is resized.
+
+</P>
+<P>
+
+<A NAME="Terminate_">
+
+<DT><STRONG><A NAME="item_Terminate">Terminate()</A></STRONG><DD>
+<P>
+Sent when the window is closed. The event should return -1 to terminate the
+interaction and return control to the perl script; see  <A HREF="././Win32_GUI.html#Dialog_">Dialog()</A>.
+
+</P>
+<P>
+
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/archdraft.html perl-libwin32-0.191/GUI/docs/html/archdraft.html
--- libwin32-0.191/GUI/docs/html/archdraft.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/archdraft.html	2004-01-12 16:46:41.265625000 -0800
@@ -0,0 +1,37 @@
+<HTML>
+<HEAD>
+<TITLE>Win32::GUI Architecture Draft</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<LI><A HREF="#Win32_GUI_Architecture_Draft">Win32::GUI Architecture Draft</A></LI>
+	<UL>
+
+		<LI><A HREF="#Source_Files">Source Files</A></LI>
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H1><A NAME="Win32_GUI_Architecture_Draft">Win32::GUI Architecture Draft</A></H1>
+<P>
+<HR>
+<H2><A NAME="Source_Files">Source Files</A></H2>
+<UL>
+<LI><STRONG><A NAME="item_Each">Each package (almost) has its own XS file.</A></STRONG>
+<LI><STRONG><A NAME="item_Each">Each pure-C function in XS file must be prototyped
+in GUI.h.</A></STRONG>
+</UL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/events.html perl-libwin32-0.191/GUI/docs/html/events.html
--- libwin32-0.191/GUI/docs/html/events.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/events.html	2004-01-12 16:46:41.281250000 -0800
@@ -0,0 +1,63 @@
+<HTML>
+<HEAD>
+<TITLE>Win32::GUI events</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<LI><A HREF="#Win32_GUI_events">Win32::GUI events</A></LI>
+	<UL>
+
+		<LI><A HREF="#Click_">Click()</A></LI>
+		<LI><A HREF="#Timer_">Timer()</A></LI>
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H1><A NAME="Win32_GUI_events">Win32::GUI events</A></H1>
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Click_">Click()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Timer_">Timer()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Sent when the Timer reaches its timeout value, eg. after the number of
+milliseconds specified when creating the Timer.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Timer">Timer</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/guiconcepts.html perl-libwin32-0.191/GUI/docs/html/guiconcepts.html
--- libwin32-0.191/GUI/docs/html/guiconcepts.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/guiconcepts.html	2004-01-12 16:46:41.296875000 -0800
@@ -0,0 +1,737 @@
+<HTML>
+<HEAD>
+<TITLE>Win32::GUI General Concepts</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Win32_GUI_General_Concepts">Win32::GUI General Concepts</A></LI>
+		<UL>
+
+			<LI><A HREF="#Packages">Packages</A></LI>
+			<LI><A HREF="#Objects">Objects</A></LI>
+			<LI><A HREF="#Options">Options</A></LI>
+			<LI><A HREF="#The_dialog_phase">The dialog phase</A></LI>
+			<LI><A HREF="#Events">Events</A></LI>
+			<LI><A HREF="#Windows">Windows</A></LI>
+			<LI><A HREF="#Controls">Controls</A></LI>
+			<LI><A HREF="#Resources">Resources</A></LI>
+			<LI><A HREF="#Others">Others</A></LI>
+			<LI><A HREF="#Non_owned_windows">Non-owned windows</A></LI>
+			<LI><A HREF="#Colors">Colors</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Win32_GUI_General_Concepts">Win32::GUI General Concepts</A></H2>
+<P>
+<EM>Back to the index</EM>
+
+
+
+</P>
+<P>
+<HR>
+<H3><A NAME="Packages">Packages</A></H3>
+<P>
+Packages in Win32::GUI can be divided into three main categories: <STRONG>Windows</STRONG>, <STRONG>Controls</STRONG> and <STRONG>Resources</STRONG>; but a big part of the core of this module is in the
+<A HREF="././Win32_GUI.html#">Win32::GUI</A> package. All the generic functions are defined there, and all the
+components of the user interface inherit from it, so that most of the
+functions that refer to windows (eg. Show, Hide, Height, Enable, and so on)
+apply to every object and can be used as their methods:
+
+</P>
+<P>
+<PRE>    $Window-&gt;Show();
+    $Window-&gt;Button1-&gt;Show();
+</PRE>
+</P>
+<P>
+Some other functions (like for example GetCursorPos) aren't applicable to
+an object, and they require a fully qualified call including the package
+name:
+
+</P>
+<P>
+<PRE>    ($x, $y) = Win32::GUI::GetCursorPos();
+</PRE>
+</P>
+<P>
+<A HREF="#Windows">Windows</A> are the well known windows that you see on your screen; your script will
+probably generate one or more window that contain your user interface; this
+content is usually made up of <A HREF="#Controls">Controls</A> (eg. labels, buttons, input fields and so on). They can also be considered
+as child windows, and, as said, they are all inherited from the Win32::GUI
+package.
+
+</P>
+<P>
+<A HREF="#Resources">Resources</A> are of a different category: they build up, so to say, the graphical
+Windows toolkit (usually referred to as GDI, Graphics Device Interface);
+you'll find there fonts, brushes, bitmaps, icons, cursors and so on. These
+objects are generally associated with your windows and controls (eg. you
+can set a windows or controls font); some of them, like pens and brushes,
+are used instead with the <A HREF="././DC.html#">Win32::GUI::DC</A> package, which implement the drawing primitives.
+
+</P>
+<P>
+There are then some packages that simply don't fit into the three
+categories above, because their use goes beyond the simple user interface:
+this is the case with <A HREF="././Class.html#">Win32::GUI::Class</A>
+and the mentioned <A HREF="././DC.html#">Win32::GUI::DC</A>.
+
+</P>
+<P>
+<HR>
+<H3><A NAME="Objects">Objects</A></H3>
+<P>
+You create an object using its <STRONG>constructor</STRONG>, which is usally of the form:
+
+</P>
+<P>
+<PRE>    $Object = new Win32::GUI::&lt;something&gt;( &lt;options&gt; );
+</PRE>
+</P>
+<P>
+where &lt;something&gt; is the class of the object you want to create (eg.
+Window, Menu, Font, etc.) and &lt;options&gt; are the characteristics of
+your object. Once you have the <CODE>$Object</CODE> variable, you can
+invoke methods on it:
+
+</P>
+<P>
+<PRE>    $Object-&gt;Show();
+</PRE>
+</P>
+<P>
+A different approach is possible with <STRONG>Controls</STRONG>. Usually, once you created your <CODE>$Window</CODE> object, you will add
+controls in it with this construct:
+
+</P>
+<P>
+<PRE>    $Window-&gt;AddButton( &lt;options&gt; );
+</PRE>
+</P>
+<P>
+This function will return a <CODE>$Button</CODE> object as you may expect,
+but you don't need to store it in a variable: Win32::GUI will use the very
+special
+<CODE>-name</CODE> option to store the object reference in the window as a named key (or
+sub-object):
+
+</P>
+<P>
+<PRE>    $Window-&gt;AddButton( -name =&gt; &quot;Button1&quot; );
+    $Window-&gt;Button1-&gt;Show();
+    # or
+    $Window-&gt;{'Button1'}-&gt;Show();
+</PRE>
+</P>
+<P>
+These sub-objects are really hash keys, but for your convenience are also
+AUTOLOAD'ed as if they were subroutines (see AutoLoader.pm for details);
+this can introduce some confusion if you name an object with the same name
+as a Win32::GUI function.
+
+</P>
+<P>
+<PRE>    $Window-&gt;AddButton( -name =&gt; &quot;Show&quot; );
+    $Window-&gt;Show-&gt;Show();
+</PRE>
+</P>
+<P>
+This syntax will not work because ``Show'' is already defined as a method
+of your <CODE>$Window</CODE> object. The advice is to use a different name
+for your object, but if you <STRONG>really</STRONG>
+can't renounce to it, you can still use the safer syntax:
+
+</P>
+<P>
+<PRE>    $Window-&gt;{'Show'}-&gt;Show();
+</PRE>
+</P>
+<P>
+It is of course always possible, if you don't mind using too much
+variables, to use the less elegant form:
+
+</P>
+<P>
+<PRE>    $Button1 = $Window-&gt;AddButton( ... );
+    $Button1-&gt;Show();
+</PRE>
+</P>
+<P>
+<HR>
+<H3><A NAME="Options">Options</A></H3>
+<P>
+The definition of an object is made up of
+<STRONG>options</STRONG>, which are pretty much like an associative array; option names are always
+lowercase and preceded by a dash (-), while their value vary (can be
+strings, numbers, objects or array references).
+
+</P>
+<P>
+A number of options is common to any window (and control), and they're
+documented in 
+<A HREF="././guioptions.html#">Common options</A>; furthermore, different objects have different specific options,
+documented in the single packages reference.
+
+</P>
+<P>
+The most important option for a window is
+<CODE>-name</CODE>; this defines the name of the object in its container (as explained above)
+and the name used in the <A HREF="#Events">Events</A> naming convention:
+
+</P>
+<P>
+<PRE>    $Window-&gt;AddButton( -name =&gt; &quot;Button1&quot; );
+    
+    $Window-&gt;Button1-&gt;Show();
+    
+    sub Button1_Click { print &quot;ouch!\n&quot;; }
+</PRE>
+</P>
+<P>
+An example of using a complete set of options:
+
+</P>
+<P>
+<PRE>    $Window = new Win32::GUI::Window(
+        -name   =&gt; &quot;Window&quot;,
+        -title  =&gt; &quot;Perl Window Example&quot;,
+        -left   =&gt; 100,  
+        -top    =&gt; 100,
+        -width  =&gt; 500, 
+        -height =&gt; 400,         
+        -menu   =&gt; $Menu,
+    );
+</PRE>
+</P>
+<P>
+<HR>
+<H3><A NAME="The_dialog_phase">The dialog phase</A></H3>
+<P>
+After creating your windows and done all the needed initialization
+processes, you may probably want your script to present the user with a
+window and await for his actions; in other words, you want to interact with
+the user. This is done in the dialog phase.
+
+</P>
+<P>
+To enter the dialog phase simply call this instruction:
+
+</P>
+<P>
+<PRE>    Win32::GUI::Dialog();
+</PRE>
+</P>
+<P>
+or better yet, if you want to check the exit code of your GUI program:
+
+</P>
+<P>
+<PRE>    $exitcode = Win32::GUI::Dialog();
+</PRE>
+</P>
+<P>
+When the script encounter this instruction, its execution halts and the
+user has the ability to interact with what's on the screen. Since windows
+are by default created in an invisible state, you may probably call before
+something like:
+
+</P>
+<P>
+<PRE>    $Window-&gt;Show();
+</PRE>
+</P>
+<P>
+if your program is supposed to start with <CODE>$Window</CODE> as its entry
+point.
+
+</P>
+<P>
+While in the dialog phase, user's actions will generate <STRONG>Events</STRONG> as needed. This phase ends when an event returns -1 or you press Cancel in
+response to a program error (see below for more details); when it ends, the
+control returns to the main body of your script (at the line after the one
+with the Win32::GUI::Dialog call) and it can go on normally.
+
+</P>
+<P>
+<HR>
+<H3><A NAME="Events">Events</A></H3>
+<P>
+Events are Perl subs that are called in response to an event occurred in
+the user interface, usually generated by an action of the user. For
+example, a button has a Click event that is called when the user pushes it.
+The naming convention for events follows the Microsoft Visual Basic's one;
+its form is:
+
+</P>
+<P>
+<PRE>    OBJECTNAME_Eventname
+</PRE>
+</P>
+<P>
+(note there's an underscore in between), where <STRONG>OBJECTNAME</STRONG> is the value of the <CODE>-name</CODE>
+option used when creating the object, and 
+<STRONG>Eventname</STRONG> is the event name, eg. Click. So if you have a button named <CODE>Button1</CODE>, your Click event will be defined as follows:
+
+</P>
+<P>
+<PRE>    sub Button1_Click {
+        # ...do something...
+    }
+</PRE>
+</P>
+<P>
+The code inside will be executed when <CODE>Button1</CODE>
+gets pressed.
+
+</P>
+<P>
+Win32::GUI also interprets the value returned by the sub; unless otherwise
+documented in the event description, the meaning of the return value is:
+
+</P>
+<UL>
+<LI><STRONG><A NAME="item_1">1 (one, or a true value)</A></STRONG>
+<P>
+the script proceeds normally and the event is passed to the underlying
+default event processor.
+
+</P>
+<LI><STRONG><A NAME="item_0">0 (zero)</A></STRONG>
+<P>
+the dialog phase continues but the event is not passed to the default event
+processor (what this means effectively depends on the event).
+
+</P>
+<LI><STRONG><A NAME="item__1_minus_one_">-1 (minus one)</A></STRONG>
+<P>
+the dialog phase ends, and control returns to the main body of your script.
+You will much probably use this to end your program:
+
+</P>
+<P>
+<PRE>    sub Window_Terminate {
+        return -1;
+    }
+</PRE>
+</P>
+</UL>
+<P>
+The behaviour of the default event processor depends on the control and the
+event; in case of doubt, is always a good idea to end your event with an
+explicit:
+
+</P>
+<P>
+<PRE>    return 1;
+</PRE>
+</P>
+<P>
+Finally, you should note that events are really
+<STRONG>evaluated</STRONG> (as if they were called with <CODE>eval()</CODE>), so that errors are trapped, and a message box is shown. This box reports
+the offending event name on the title bar, the error message in its body
+and has OK and Cancel buttons. If you press OK, Win32::GUI will ignore the
+error and go on with the dialog (the event, of course, doesn't take place);
+if you press Cancel instead the dialog will end (with return code -1). This
+means that for example if you define an event like:
+
+</P>
+<P>
+<PRE>    sub Button1_Click {
+        die();
+    }
+</PRE>
+</P>
+<P>
+your script will not die immediately at the click of a button, but the
+message box will appear, reporting for example ``Died at script.pl line
+73''.
+
+</P>
+<P>
+<HR>
+<H3><A NAME="Windows">Windows</A></H3>
+<P>
+In its widest acception, windows include what you normally call a window
+(sometimes referred to as a ``top level window''), controls (sometimes
+referred to as ``child windows'') and even 
+<A HREF="#Non_owned_windows">Non-owned windows</A> (not created by Win32::GUI).
+
+</P>
+<P>
+Real (top level) windows are the container of your user interface;
+Win32::GUI defines two packages, <A HREF="././Window.html#">Window</A>
+and <A HREF="././DialogBox.html#">DialogBox</A>. By default, a Window has a title bar, the usual minimize/maximize/close
+buttons, a system menu (the button on the top left corner) and resizable
+borders. A DialogBox is very similar, except that by default it cannot be
+resized and it doesn't have the minimize and maximize buttons. The main
+difference between the two packages is in the dialog phase; DialogBox
+intercepts the tab and arrow keys to switch between controls, the use of
+Return and Esc for the Ok and Cancel button and accelerators, while Window
+not.
+
+</P>
+<P>
+<HR>
+<H3><A NAME="Controls">Controls</A></H3>
+<P>
+Also known as ``widgets'' , these represent the content of your windows,
+and includes almost all the controls provided by Windows:
+
+</P>
+<UL>
+<LI>
+<P>
+<A HREF="././Animation.html#">Animation</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Button.html#">Button</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Checkbox.html#">Checkbox</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Combobox.html#">Combobox</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Label.html#">Label</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././ListView.html#">ListView</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Listbox.html#">Listbox</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././NotifyIcon.html#">NotifyIcon</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././ProgressBar.html#">ProgressBar</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././RadioButton.html#">RadioButton</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Rebar.html#">Rebar</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././RichEdit.html#">RichEdit</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Slider.html#">Slider</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././StatusBar.html#">StatusBar</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././TabStrip.html#">TabStrip</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Textfield.html#">Textfield</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Timer.html#">Timer</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Toolbar.html#">Toolbar</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Tooltip.html#">Tooltip</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././TreeView.html#">TreeView</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././UpDown.html#">UpDown</A>
+
+
+
+</P>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Resources">Resources</A></H3>
+<UL>
+<LI>
+<P>
+<A HREF="././Bitmap.html#">Bitmap</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Brush.html#">Brush</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Cursor.html#">Cursor</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Font.html#">Font</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Icon.html#">Icon</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././ImageList.html#">ImageList</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Menu.html#">Menu</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././MenuButton.html#">MenuButton</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././MenuItem.html#">MenuItem</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Pen.html#">Pen</A>
+
+
+
+</P>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Others">Others</A></H3>
+<UL>
+<LI>
+<P>
+<A HREF="././Class.html#">Class</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././DC.html#">DC</A>
+
+
+
+</P>
+</UL>
+<P>
+<HR>
+<H3><A NAME="Non_owned_windows">Non-owned windows</A></H3>
+<P>
+Every window, even windows not created by your Perl script, can be
+referenced by Win32::GUI; all you need to know is its ``handle'', a
+numerical value that identifies that window. Many functions in the
+Win32::GUI package return such handles, as for example:
+
+</P>
+<P>
+<PRE>    $First = Win32::GUI::GetForegroundWindow();
+</PRE>
+</P>
+<P>
+This value can then be passed to any function that requires a window
+object; but of course, not being an object, you can't call it as a method:
+
+</P>
+<P>
+<PRE>    Win32::GUI::Hide($First); # correct
+    $First-&gt;Hide();           # wrong
+</PRE>
+</P>
+<P>
+Should you need to know the numerical handle of a window created by
+Win32::GUI, it is stored in its <CODE>-handle</CODE> key (this is the value that almost all function really use):
+
+</P>
+<P>
+<PRE>    print &quot;Window handle is $Window-&gt;{-handle} \n&quot;;
+</PRE>
+</P>
+<P>
+<HR>
+<H3><A NAME="Colors">Colors</A></H3>
+<P>
+Wherever you need to express a color, there are two possibilities: 
+
+</P>
+<DL>
+<DT><STRONG><A NAME="item_first">first:</A></STRONG><DD>
+<P>
+Use a numeric value that contains red, green and blue components (that's
+the form Windows uses); expressing this form in hexadecimal, components are
+reversed with respect to the traditional (RGB) order:
+
+</P>
+<P>
+<PRE>    0xBBGGRR
+</PRE>
+</P>
+<P>
+Each components range is 0 to 0xFF, or 255; a value of 0, 0, 0 (0x000000)
+represents black, while a value of 255, 255, 255 (0xFFFFFF) represents
+white. The following are all valid color definitions in hexadecimal and
+decimal format (for practical reasons, you would probably prefer the
+hexadecimal notation):
+
+</P>
+<P>
+<PRE>    $color = 0xFF0000;  # blue
+    $color = 16711680;  # blue
+    $color = 255 &lt;&lt; 16; # blue
+    $color = 0x00FF00;  # green
+    $color = 65280;     # green
+    $color = 0x80FFFF;  # pale yellow
+    $color = 8454143;   # pale yellow
+</PRE>
+</P>
+<DT><STRONG><A NAME="item_second">second:</A></STRONG><DD>
+<P>
+Use a reference to a list with 3 values that express the red, green and
+blue components as above:
+
+</P>
+<P>
+<PRE>    [ R, G, B ]
+</PRE>
+</P>
+<P>
+Note that this is NOT a plain list (since a color is usually one parameter
+in a list of parameters to a function, it wouldn't make much sense); so the
+following forms are valid:
+
+</P>
+<P>
+<PRE>    [ 0, 0, 0 ]
+    [ 255, 255, 255]
+    [ 0x80, 0xFF, 0xFF ]
+    \@color
+</PRE>
+</P>
+</DL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/guioptions.html perl-libwin32-0.191/GUI/docs/html/guioptions.html
--- libwin32-0.191/GUI/docs/html/guioptions.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/guioptions.html	2004-01-12 16:46:41.312500000 -0800
@@ -0,0 +1,235 @@
+<HTML>
+<HEAD>
+<TITLE>Win32::GUI Common Options</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Win32_GUI_Common_Options">Win32::GUI Common Options</A></LI>
+		<UL>
+
+			<LI><A HREF="#List_of_available_options">List of available options</A></LI>
+			<UL>
+
+				<LI><A HREF="#_background_COLOR">-background =&gt; COLOR</A></LI>
+				<LI><A HREF="#_class_CLASS">-class =&gt; CLASS</A></LI>
+				<LI><A HREF="#_disabled_0_1">-disabled =&gt; 0/1</A></LI>
+				<LI><A HREF="#_font_FONT">-font =&gt; FONT</A></LI>
+				<LI><A HREF="#_foreground_COLOR">-foreground =&gt; COLOR</A></LI>
+				<LI><A HREF="#_group_0_1">-group =&gt; 0/1</A></LI>
+				<LI><A HREF="#_height_NUMBER">-height =&gt; NUMBER</A></LI>
+				<LI><A HREF="#_left_NUMBER">-left =&gt; NUMBER</A></LI>
+				<LI><A HREF="#_menu_MENU">-menu =&gt; MENU</A></LI>
+				<LI><A HREF="#_name_STRING">-name =&gt; STRING</A></LI>
+				<LI><A HREF="#_style_NUMBER">-style =&gt; NUMBER</A></LI>
+				<LI><A HREF="#_tabstop_0_1">-tabstop =&gt; 0/1</A></LI>
+				<LI><A HREF="#_text_STRING">-text =&gt; STRING</A></LI>
+				<LI><A HREF="#_title_STRING">-title =&gt; STRING</A></LI>
+				<LI><A HREF="#_top_NUMBER">-top =&gt; NUMBER</A></LI>
+				<LI><A HREF="#_visible_0_1">-visible =&gt; 0/1</A></LI>
+				<LI><A HREF="#_width_NUMBER">-width =&gt; NUMBER</A></LI>
+			</UL>
+
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Win32_GUI_Common_Options">Win32::GUI Common Options</A></H2>
+<P>
+<EM>Back to the index</EM>
+
+
+
+</P>
+<P>
+This document illustrates the options available when creating an object (in
+particular, windows and controls). Here you'll find the general options,
+the ones that apply to every window class; for class-specific options,
+refer to that package reference.
+
+</P>
+<P>
+<HR>
+<H3><A NAME="List_of_available_options">List of available options</A></H3>
+<P>
+<HR>
+<H4><A NAME="_background_COLOR">-background =&gt; COLOR</A></H4>
+<P>
+Defines the background color for the control. Note that not all controls
+support background and foreground colors.
+
+</P>
+<P>
+<HR>
+<H4><A NAME="_class_CLASS">-class =&gt; CLASS</A></H4>
+<P>
+Specifies the window class (which is different from the Perl's object
+class, eg. Win32::GUI::Button) for the window; all the predefined objects
+have hardcoded class names (eg. ``BUTTON'' for Win32::GUI::Button), so you
+shouldn't want to pick a different one unless you are familiar with window
+classes and you want to subclass an existing one. This technique is
+documented in the Microsoft Platform SDK Reference, and (at a lighter
+level) in <EM>guiclasses.pod</EM>. The CLASS parameter can be either a name or a reference to a <A HREF="././Class.html#">Win32::GUI::Class</A> object. As for many other options in Win32::GUI, its use is <STRONG>not recommended</STRONG> unless you know what you're doing.
+
+</P>
+<P>
+<HR>
+<H4><A NAME="_disabled_0_1">-disabled =&gt; 0/1</A></H4>
+<P>
+Sets the initial enabled state for the control; by default this option is 0
+(the control is enabled). Set it to 1 to create a control which is
+initially disabled.
+
+</P>
+<P>
+<HR>
+<H4><A NAME="_font_FONT">-font =&gt; FONT</A></H4>
+<P>
+Defines the font for the control; must be a Win32::GUI::Font object.
+
+</P>
+<P>
+<HR>
+<H4><A NAME="_foreground_COLOR">-foreground =&gt; COLOR</A></H4>
+<P>
+Defines the foreground color for the control. Note that not all controls
+support background and foreground colors.
+
+</P>
+<P>
+<HR>
+<H4><A NAME="_group_0_1">-group =&gt; 0/1</A></H4>
+<P>
+[TBD]
+
+</P>
+<P>
+<HR>
+<H4><A NAME="_height_NUMBER">-height =&gt; NUMBER</A></H4>
+<P>
+Specifies the height of the window in pixels.
+
+</P>
+<P>
+<HR>
+<H4><A NAME="_left_NUMBER">-left =&gt; NUMBER</A></H4>
+<P>
+Specifies the left position (X coordinate) for the window, in pixels. For
+Windows and DialogBoxes is absolute (screen position), while for controls
+is relative to the client area of their parent window.
+
+</P>
+<P>
+<HR>
+<H4><A NAME="_menu_MENU">-menu =&gt; MENU</A></H4>
+<P>
+[TBD]
+
+</P>
+<P>
+<HR>
+<H4><A NAME="_name_STRING">-name =&gt; STRING</A></H4>
+<P>
+Defines the name for the control. The name is used to callback its events
+and to access its methods, so it is absolutely <STRONG>necessary</STRONG>, and each name must be unique in your application.
+
+</P>
+<P>
+Example:
+
+</P>
+<P>
+<PRE>        $Window-&gt;AddButton(
+                -name =&gt; &quot;Button1&quot;,
+                # ...
+        );
+</PRE>
+</P>
+<P>
+<PRE>        # methods...
+        $Window-&gt;Button1-&gt;Hide();
+</PRE>
+</P>
+<P>
+<PRE>        # events...
+        sub Button1_Click {
+                # ...
+        }
+</PRE>
+</P>
+<P>
+<HR>
+<H4><A NAME="_style_NUMBER">-style =&gt; NUMBER</A></H4>
+<P>
+[TBD]
+
+</P>
+<P>
+<HR>
+<H4><A NAME="_tabstop_0_1">-tabstop =&gt; 0/1</A></H4>
+<P>
+If 1, the control can be enabled by pressing the TAB key to switch between
+controls. Note that this functionality is available in DialogBox objects
+only, not in Window, so the control must be child of a DialogBox for this
+option to be effective.
+
+</P>
+<P>
+<HR>
+<H4><A NAME="_text_STRING">-text =&gt; STRING</A></H4>
+<P>
+Specifies the STRING that will appear on the window's caption or in the
+control's body (eg. a Label text, a Button caption, a Textfield content,
+and so on). Its use depends of course on the control type; some controls,
+like ProgressBars, makes no use of it at all.
+
+</P>
+<P>
+<HR>
+<H4><A NAME="_title_STRING">-title =&gt; STRING</A></H4>
+<P>
+A synonim for <A HREF="#_text_STRING">-text</A>.
+
+</P>
+<P>
+<HR>
+<H4><A NAME="_top_NUMBER">-top =&gt; NUMBER</A></H4>
+<P>
+Specifies the top position (Y coordinate) for the window, in pixels. For
+Windows and DialogBoxes is absolute (screen position), while for controls
+is relative to the client area of their parent window.
+
+</P>
+<P>
+<HR>
+<H4><A NAME="_visible_0_1">-visible =&gt; 0/1</A></H4>
+<P>
+Sets the initial visibility state for the control; by default this option
+is 1 (the control is visible). Set it to 0 to create a control which is
+initially hidden.
+
+</P>
+<P>
+<HR>
+<H4><A NAME="_width_NUMBER">-width =&gt; NUMBER</A></H4>
+<P>
+Specifies the width of the window in pixels.
+
+</P>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/guipacks.html perl-libwin32-0.191/GUI/docs/html/guipacks.html
--- libwin32-0.191/GUI/docs/html/guipacks.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/guipacks.html	2004-01-12 16:46:41.328125000 -0800
@@ -0,0 +1,373 @@
+<HTML>
+<HEAD>
+<TITLE>Win32::GUI Packages</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<UL>
+
+		<LI><A HREF="#Win32_GUI_Packages">Win32::GUI Packages</A></LI>
+		<UL>
+
+			<LI><A HREF="#Packages">Packages</A></LI>
+		</UL>
+
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H2><A NAME="Win32_GUI_Packages">Win32::GUI Packages</A></H2>
+<P>
+<EM>Back to the index</EM>
+
+
+
+</P>
+<P>
+<HR>
+<H3><A NAME="Packages">Packages</A></H3>
+<UL>
+<LI>
+<P>
+<A HREF="././Win32_GUI.html#">Win32::GUI</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././AcceleratorTable.html#">Win32::GUI::AcceleratorTable</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Animation.html#">Win32::GUI::Animation</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Bitmap.html#">Win32::GUI::Bitmap</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Brush.html#">Win32::GUI::Brush</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Button.html#">Win32::GUI::Button</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Checkbox.html#">Win32::GUI::Checkbox</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Class.html#">Win32::GUI::Class</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Combobox.html#">Win32::GUI::Combobox</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././ComboboxEx.html#">Win32::GUI::ComboboxEx</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Cursor.html#">Win32::GUI::Cursor</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././DC.html#">Win32::GUI::DC</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././DateTime.html#">Win32::GUI::DateTime</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././DialogBox.html#">Win32::GUI::DialogBox</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Font.html#">Win32::GUI::Font</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Graphic.html#">Win32::GUI::Graphic</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Groupbox.html#">Win32::GUI::Groupbox</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Header.html#">Win32::GUI::Header</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Icon.html#">Win32::GUI::Icon</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././ImageList.html#">Win32::GUI::ImageList</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Label.html#">Win32::GUI::Label</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././ListView.html#">Win32::GUI::ListView</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././ListView_Item.html#">Win32::GUI::ListView::Item</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././ListView_SubItem.html#">Win32::GUI::ListView::SubItem</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Listbox.html#">Win32::GUI::Listbox</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Listbox_Item.html#">Win32::GUI::Listbox::Item</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././MDI.html#">Win32::GUI::MDI</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Menu.html#">Win32::GUI::Menu</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././MenuButton.html#">Win32::GUI::MenuButton</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././MenuItem.html#">Win32::GUI::MenuItem</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././NotifyIcon.html#">Win32::GUI::NotifyIcon</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Pen.html#">Win32::GUI::Pen</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././ProgressBar.html#">Win32::GUI::ProgressBar</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././RadioButton.html#">Win32::GUI::RadioButton</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Rebar.html#">Win32::GUI::Rebar</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././RichEdit.html#">Win32::GUI::RichEdit</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Slider.html#">Win32::GUI::Slider</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Splitter.html#">Win32::GUI::Splitter</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././StatusBar.html#">Win32::GUI::StatusBar</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././TabStrip.html#">Win32::GUI::TabStrip</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Textfield.html#">Win32::GUI::Textfield</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Timer.html#">Win32::GUI::Timer</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Toolbar.html#">Win32::GUI::Toolbar</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Tooltip.html#">Win32::GUI::Tooltip</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././TreeView.html#">Win32::GUI::TreeView</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././UpDown.html#">Win32::GUI::UpDown</A>
+
+
+
+</P>
+<LI>
+<P>
+<A HREF="././Window.html#">Win32::GUI::Window</A>
+
+
+
+</P>
+</UL>
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/methods.html perl-libwin32-0.191/GUI/docs/html/methods.html
--- libwin32-0.191/GUI/docs/html/methods.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/methods.html	2004-01-12 16:46:41.343750000 -0800
@@ -0,0 +1,2637 @@
+<HTML>
+<HEAD>
+<TITLE>Win32::GUI methods</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<LI><A HREF="#Win32_GUI_methods">Win32::GUI methods</A></LI>
+	<UL>
+
+		<LI><A HREF="#AbsLeft_">AbsLeft()</A></LI>
+		<LI><A HREF="#AbsTop_">AbsTop()</A></LI>
+		<LI><A HREF="#Add_STRING_STRING_STRING_">Add(STRING, STRING .. STRING)</A></LI>
+		<LI><A HREF="#AddString_STRING_">AddString( STRING )</A></LI>
+		<LI><A HREF="#Arrange_FLAG_">Arrange( [FLAG] )</A></LI>
+		<LI><A HREF="#BackColor_COLOR_">BackColor( [COLOR] )</A></LI>
+		<LI><A HREF="#BandCount_">BandCount()</A></LI>
+		<LI><A HREF="#BringWindowToTop_">BringWindowToTop()</A></LI>
+		<LI><A HREF="#BrowseForFolder_OPTIONS_">BrowseForFolder( OPTIONS )</A></LI>
+		<LI><A HREF="#Caption_TEXT_">Caption( [TEXT] )</A></LI>
+		<LI><A HREF="#ChangeCursor_CURSOR_">ChangeCursor( CURSOR )</A></LI>
+		<LI><A HREF="#ChangeIcon_ICON_">ChangeIcon( ICON )</A></LI>
+		<LI><A HREF="#ChangeSmallIcon_ICON_">ChangeSmallIcon( ICON )</A></LI>
+		<LI><A HREF="#Clear_">Clear()</A></LI>
+		<LI><A HREF="#ClipCursor_LEFT_TOP_RIGHT_B">ClipCursor( [LEFT, TOP, RIGHT, BOTTOM] )</A></LI>
+		<LI><A HREF="#Close_">Close()</A></LI>
+		<LI><A HREF="#CloseWindow_">CloseWindow()</A></LI>
+		<LI><A HREF="#CommDlgExtendedError_">CommDlgExtendedError()</A></LI>
+		<LI><A HREF="#Count_">Count()</A></LI>
+		<LI><A HREF="#DeleteBand_">DeleteBand()</A></LI>
+		<LI><A HREF="#Dialog_">Dialog()</A></LI>
+		<LI><A HREF="#Disable_">Disable()</A></LI>
+		<LI><A HREF="#DoEvents_">DoEvents()</A></LI>
+		<LI><A HREF="#DrawMenuBar_">DrawMenuBar()</A></LI>
+		<LI><A HREF="#Enable_FLAG_">Enable( [FLAG] )</A></LI>
+		<LI><A HREF="#EnsureVisible_ITEM_FLAG_">EnsureVisible( ITEM, [FLAG] )</A></LI>
+		<LI><A HREF="#Expand_NODE_FLAG_">Expand( NODE, [FLAG] )</A></LI>
+		<LI><A HREF="#FindString_STRING_INDEX_">FindString( STRING, [INDEX] )</A></LI>
+		<LI><A HREF="#FindStringExact_STRING_INDEX_">FindStringExact( STRING, [INDEX] )</A></LI>
+		<LI><A HREF="#FindWindow_CLASSNAME_TITLE_">FindWindow( CLASSNAME, TITLE )</A></LI>
+		<LI><A HREF="#FirstVisible_NODE_">FirstVisible( [NODE] )</A></LI>
+		<LI><A HREF="#FirstVisibleItem_INDEX_">FirstVisibleItem( [INDEX] )</A></LI>
+		<LI><A HREF="#GetActiveWindow_">GetActiveWindow()</A></LI>
+		<LI><A HREF="#GetClassName_">GetClassName()</A></LI>
+		<LI><A HREF="#GetClientRect_">GetClientRect()</A></LI>
+		<LI><A HREF="#GetCursor_">GetCursor()</A></LI>
+		<LI><A HREF="#GetCursorPos_">GetCursorPos()</A></LI>
+		<LI><A HREF="#GetFocus_">GetFocus()</A></LI>
+		<LI><A HREF="#GetFont_FONT_">GetFont(FONT)</A></LI>
+		<LI><A HREF="#GetFontName_">GetFontName()</A></LI>
+		<LI><A HREF="#GetLastVisible_">GetLastVisible()</A></LI>
+		<LI><A HREF="#GetMenu_">GetMenu()</A></LI>
+		<LI><A HREF="#GetMessage_MIN_MAX_">GetMessage( [MIN, MAX] )</A></LI>
+		<LI><A HREF="#GetNextVisible_NODE_">GetNextVisible( NODE )</A></LI>
+		<LI><A HREF="#GetOpenFileName_OPTIONS_">GetOpenFileName( OPTIONS )</A></LI>
+		<LI><A HREF="#GetPerlWindow_">GetPerlWindow()</A></LI>
+		<LI><A HREF="#GetPrevVisible_NODE_">GetPrevVisible(NODE)</A></LI>
+		<LI><A HREF="#GetStockObject_OBJECT_">GetStockObject( OBJECT )</A></LI>
+		<LI><A HREF="#GetStringWidth_STRING_">GetStringWidth( STRING )</A></LI>
+		<LI><A HREF="#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32( STRING, [FONT] )</A></LI>
+		<LI><A HREF="#GetWindowRect_">GetWindowRect()</A></LI>
+		<LI><A HREF="#Height_HEIGHT_">Height( [HEIGHT] )</A></LI>
+		<LI><A HREF="#Hide_">Hide()</A></LI>
+		<LI><A HREF="#HitTest_X_Y_">HitTest( X, Y )</A></LI>
+		<LI><A HREF="#Indent_VALUE_">Indent( [VALUE] )</A></LI>
+		<LI><A HREF="#InsertBand_OPTIONS_">InsertBand( OPTIONS )</A></LI>
+		<LI><A HREF="#Interval_ELAPSE_">Interval( [ELAPSE] )</A></LI>
+		<LI><A HREF="#InvalidateRect_">InvalidateRect(...)</A></LI>
+		<LI><A HREF="#InvertRect_LEFT_TOP_RIGHT_BO">InvertRect( LEFT, TOP, RIGHT, BOTTOM )</A></LI>
+		<LI><A HREF="#IsEnabled_">IsEnabled()</A></LI>
+		<LI><A HREF="#IsIconic_">IsIconic()</A></LI>
+		<LI><A HREF="#IsVisible_">IsVisible()</A></LI>
+		<LI><A HREF="#IsWindow_">IsWindow()</A></LI>
+		<LI><A HREF="#IsZoomed_">IsZoomed()</A></LI>
+		<LI><A HREF="#ItemCheck_ITEM_VALUE_">ItemCheck( ITEM, [VALUE] )</A></LI>
+		<LI><A HREF="#ItemFromPoint_X_Y_">ItemFromPoint( X, Y )</A></LI>
+		<LI><A HREF="#ItemPosition_INDEX_X_Y_">ItemPosition( INDEX, [X, Y] )</A></LI>
+		<LI><A HREF="#Kill_">Kill()</A></LI>
+		<LI><A HREF="#Left_LEFT_">Left ( [LEFT] )</A></LI>
+		<LI><A HREF="#LineFromChar_INDEX_">LineFromChar( INDEX )</A></LI>
+		<LI><A HREF="#ListIndex_">ListIndex()</A></LI>
+		<LI><A HREF="#Load_FILENAME_FORMAT_">Load( FILENAME, [FORMAT] )</A></LI>
+		<LI><A HREF="#MaxLength_CHARS_">MaxLength( [CHARS] )</A></LI>
+		<LI><A HREF="#Minimize_">Minimize()</A></LI>
+		<LI><A HREF="#Modified_FLAG_">Modified( [FLAG] )</A></LI>
+		<LI><A HREF="#Move_X_Y_">Move( X, Y )</A></LI>
+		<LI><A HREF="#MoveItem_INDEX_X_Y_">MoveItem( INDEX, X, Y )</A></LI>
+		<LI><A HREF="#Open_FILE_">Open( FILE )</A></LI>
+		<LI><A HREF="#OpenIcon_">OpenIcon()</A></LI>
+		<LI><A HREF="#PasswordChar_CHAR_">PasswordChar( [CHAR] )</A></LI>
+		<LI><A HREF="#Play_FROM_TO_REPEAT_">Play( [FROM], [TO], [REPEAT] )</A></LI>
+		<LI><A HREF="#ReadOnly_FLAG_">ReadOnly( [FLAG] )</A></LI>
+		<LI><A HREF="#Rectangle_LEFT_TOP_RIGHT_BOT">Rectangle( LEFT, TOP, RIGHT, BOTTOM )</A></LI>
+		<LI><A HREF="#ReplaceSel_STRING_FLAG_">ReplaceSel( STRING, [FLAG] )</A></LI>
+		<LI><A HREF="#Reset_">Reset()</A></LI>
+		<LI><A HREF="#Resize_X_Y_">Resize( X, Y )</A></LI>
+		<LI><A HREF="#Restore_">Restore()</A></LI>
+		<LI><A HREF="#RowCount_">RowCount()</A></LI>
+		<LI><A HREF="#Save_FILENAME_FORMAT_">Save( FILENAME, [FORMAT] )</A></LI>
+		<LI><A HREF="#ScaleHeight_">ScaleHeight()</A></LI>
+		<LI><A HREF="#ScaleWidth_">ScaleWidth()</A></LI>
+		<LI><A HREF="#Scroll_COMMAND_LINE_HORIZON">Scroll( COMMAND | LINE | HORIZONTAL, VERTICAL )</A></LI>
+		<LI><A HREF="#Seek_FRAME_">Seek( FRAME )</A></LI>
+		<LI><A HREF="#SelectAll_">SelectAll()</A></LI>
+		<LI><A HREF="#SelectCount_">SelectCount()</A></LI>
+		<LI><A HREF="#SelectString_STRING_INDEX_">SelectString( STRING, [INDEX] )</A></LI>
+		<LI><A HREF="#SelectedItem_">SelectedItem()</A></LI>
+		<LI><A HREF="#Selection_">Selection()</A></LI>
+		<LI><A HREF="#SetCursor_CURSOR_">SetCursor( CURSOR )</A></LI>
+		<LI><A HREF="#SetCursorPos_X_Y_">SetCursorPos( X, Y )</A></LI>
+		<LI><A HREF="#SetRange_MIN_MAX_">SetRange( [MIN], MAX )</A></LI>
+		<LI><A HREF="#Show_COMMAND_">Show( [COMMAND] )</A></LI>
+		<LI><A HREF="#Stop_">Stop()</A></LI>
+		<LI><A HREF="#Text_TEXT_">Text( [TEXT] )</A></LI>
+		<LI><A HREF="#TextOut_X_Y_TEXT_">TextOut( X, Y, TEXT )</A></LI>
+		<LI><A HREF="#Top_TOP_">Top( [TOP] )</A></LI>
+		<LI><A HREF="#Undo_">Undo()</A></LI>
+		<LI><A HREF="#Update_">Update()</A></LI>
+		<LI><A HREF="#View_MODE_">View( [MODE] )</A></LI>
+		<LI><A HREF="#VisibleCount_">VisibleCount()</A></LI>
+		<LI><A HREF="#Width_WIDTH_">Width( [WIDTH] )</A></LI>
+		<LI><A HREF="#WindowFromPoint_X_Y_">WindowFromPoint( X, Y )</A></LI>
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H1><A NAME="Win32_GUI_methods">Win32::GUI methods</A></H1>
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="AbsLeft_">AbsLeft()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the absolute (screen) window x coordinate; use this to get the
+onscreen position of a child window, eg. a button or a label. This method
+returns -1 on errors.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="#Left">Left</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Class">Class</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>, <A HREF="././packages.html#Tooltip">Tooltip(*)</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="AbsTop_">AbsTop()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the absolute (screen) window y coordinate; use this to get the
+onscreen position of a child window, eg. a button or a label. This method
+returns -1 on errors.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#Top_TOP_">Top()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Class">Class</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>, <A HREF="././packages.html#Tooltip">Tooltip(*)</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Add_STRING_STRING_STRING_">Add(STRING, STRING .. STRING)</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Adds one or more items at the end of the control's list.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#Listbox">Listbox</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="AddString_STRING_">AddString( STRING )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Adds an item at the end of the control's list.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#Listbox">Listbox</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Arrange_FLAG_">Arrange( [FLAG] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Arranges items in the ListView; the optional FLAG parameter can be one of
+the following values:
+
+</P>
+<P>
+<PRE>        0  uses the current alignment style (this is the default)
+        1  align items along the left edge of the window
+        2  align items along the top edge of the window
+        5  snaps icons to the nearest grid position
+</PRE>
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#ListView">ListView</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="BackColor_COLOR_">BackColor( [COLOR] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Sets the background color of the RichEdit control; if no COLOR is
+specified, the background color is reset to the default system color.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#RichEdit">RichEdit</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="BandCount_">BandCount()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the number of bands in the Rebar control.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Rebar">Rebar</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="BringWindowToTop_">BringWindowToTop()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Brings the window to the foreground.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="BrowseForFolder_OPTIONS_">BrowseForFolder( OPTIONS )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Displays the standard ``Browse For Folder'' dialog box. Returns the
+selected item's name, or undef if no item was selected or an error
+occurred.
+
+</P>
+<P>
+Note that BrowseForFolder must be called as a standalone function, not as a
+method.
+
+</P>
+<P>
+Example:
+
+</P>
+<P>
+<PRE>        $folder = Win32::GUI::BrowseForFolder(
+                -root =&gt; &quot;C:\\Program Files&quot;,
+                -includefiles =&gt; 1,
+        );
+</PRE>
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_computeronly_0_1">-computeronly</A>, <A HREF="././options.html#_domainonly_0_1">-domainonly</A>, <A HREF="././options.html#_driveonly_0_1">-driveonly</A>, <A HREF="././options.html#_editbox_0_1">-editbox</A>, <A HREF="././options.html#_folderonly_0_1">-folderonly</A>, <A HREF="././options.html#_includefiles_0_1">-includefiles</A>, <A HREF="././options.html#_owner_WINDOW">-owner</A>, <A HREF="././options.html#_printeronly_0_1">-printeronly</A>, <A HREF="././options.html#_root_PATH_or_CONSTANT">-root</A>, <A HREF="././options.html#_title_STRING">-title</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Caption_TEXT_">Caption( [TEXT] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+See <A HREF="././methods.html#Text_">Text().</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="ChangeCursor_CURSOR_">ChangeCursor( CURSOR )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Changes the default cursor for a window to CURSOR (a Win32::GUI::Cursor
+object). Returns the handle of the previous default cursor.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Class">Class</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="ChangeIcon_ICON_">ChangeIcon( ICON )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Changes the default icon for a window to ICON (a Win32::GUI::Icon object).
+Returns the handle of the previous default icon. 
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#ChangeSmallIcon_ICON_">ChangeSmallIcon()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="ChangeSmallIcon_ICON_">ChangeSmallIcon( ICON )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Changes the default small icon for a window to ICON (a Win32::GUI::Icon
+object). Returns the handle of the previous default small icon. 
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#ChangeIcon_ICON_">ChangeIcon()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Clear_">Clear()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+See <A HREF="././methods.html#Reset_">Reset().</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="ClipCursor_LEFT_TOP_RIGHT_B">ClipCursor( [LEFT, TOP, RIGHT, BOTTOM] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Confines the cursor to the specified screen rectangle. Call it without
+parameters to release the cursor. Returns nonzero on success, zero on
+failure.
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Close_">Close()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Closes the opened AVI file.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#Open_FILE_">Open()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="CloseWindow_">CloseWindow()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Minimizes a window.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="CommDlgExtendedError_">CommDlgExtendedError()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the last common dialog library error code. 
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Count_">Count()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the number of items in the control.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#Listbox">Listbox</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="DeleteBand_">DeleteBand()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Deletes the zero-based INDEX band from the Rebar.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Rebar">Rebar</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Dialog_">Dialog()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Enter the GUI dialog phase: the script halts, the user can interact with
+the created windows and events subroutines are triggered as necessary; note
+that this function must be called without ANY parameter or instantiation
+(eg. don't call it as method of a created object):
+
+</P>
+<P>
+<PRE>    Win32::GUI::Dialog(); # correct
+    $Window-&gt;Dialog();    # !!!WRONG!!!
+</PRE>
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Disable_">Disable()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Disables a window. 
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#Enable_FLAG_">Enable()</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Class">Class</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="DoEvents_">DoEvents()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Just like <CODE>Dialog(),</CODE> but returns when there are no more events
+to process.
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="DrawMenuBar_">DrawMenuBar()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Forces redrawing of the menu bar.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Enable_FLAG_">Enable( [FLAG] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Enables a window (or disables it if FLAG is FALSE). 
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#Disable_">Disable()</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Class">Class</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="EnsureVisible_ITEM_FLAG_">EnsureVisible( ITEM, [FLAG] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+For TreeView, ensures that the specified ITEM (a node handle) is visible in
+the control.
+
+</P>
+<P>
+For ListView, ensures that the specified ITEM (zero-based index) is visible
+in the control (FLAG to be defined...).
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#TreeView">TreeView</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Expand_NODE_FLAG_">Expand( NODE, [FLAG] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Opens a NODE of the TreeView; the optional FLAG parameter can indicate
+different operations:
+
+</P>
+<P>
+<PRE>    1 expand (this is the default)
+    2 collapse
+    3 toggle (expand if it was collapsed and collapse if it was expanded)
+</PRE>
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#TreeView">TreeView</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="FindString_STRING_INDEX_">FindString( STRING, [INDEX] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Searches the control for an item that begins with the specified STRING. The
+optional INDEX parameter tells to start the search from the specified
+position; if no parameter is given, the whole list is searched. Returns the
+zero-based index of the found item or -1 if no matching item was found.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#SelectString_STRING_INDEX_">SelectString()</A>, <A HREF="././methods.html#FindStringExact_STRING_INDEX_">FindStringExact()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#Listbox">Listbox</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="FindStringExact_STRING_INDEX_">FindStringExact( STRING, [INDEX] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Searches the control for an item that exactly matches the specified STRING
+(case insensitively). The optional INDEX parameter tells to start the
+search from the specified position; if no parameter is given, the whole
+list is searched. Returns the zero-based index of the found item or -1 if
+no matching item was found.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#FindString_STRING_INDEX_">FindString()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#Listbox">Listbox</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="FindWindow_CLASSNAME_TITLE_">FindWindow( CLASSNAME, TITLE )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the handle of the window whose class name and window title match
+the specified strings; both strings can be empty. Note that the function
+does not search child windows, only top level windows. If no matching
+windows is found, the return value is zero. 
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="FirstVisible_NODE_">FirstVisible( [NODE] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Gets or sets the first visible NODE in the TreeView; if a NODE is given, it
+is selected and, if possible, it becomes the first visible one; the return
+value is the handle of the previously first visible. If no NODE is given,
+returns the handle of the current first visible one.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#TreeView">TreeView</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="FirstVisibleItem_INDEX_">FirstVisibleItem( [INDEX] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Gets the zero-based index of the first visible item in the control, or sets
+it to the specified INDEX.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#Listbox">Listbox</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetActiveWindow_">GetActiveWindow()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the handle of the active window. 
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetClassName_">GetClassName()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the classname of the specified window, or undef on errors.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Class">Class</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetClientRect_">GetClientRect()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns a four elements array defining the windows client area rectangle
+(left, top, right, bottom) or undef on errors. 
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#GetWindowRect_">GetWindowRect()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Class">Class</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetCursor_">GetCursor()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the handle of the current cursor. 
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetCursorPos_">GetCursorPos()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns a two elements array containing the x and y position of the cursor,
+or undef on errors. 
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#SetCursorPos_X_Y_">SetCursorPos()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetFocus_">GetFocus()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the handle of the window that has the keyboard focus. 
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetFont_FONT_">GetFont(FONT)</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Gets the font of the window (returns an handle; use 
+
+</P>
+<P>
+<PRE>  $Font = $W-&gt;GetFont();
+  %details = Win32::GUI::Font::Info( $Font );
+</PRE>
+</P>
+<P>
+to get font details). 
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetFontName_">GetFontName()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the name of the font used in the window.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetLastVisible_">GetLastVisible()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the handle of the last expanded node in the TreeView.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#TreeView">TreeView</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetMenu_">GetMenu()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the handle of the menu associated with the window (note: the
+handle, not the Win32::GUI::Menu object).
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetMessage_MIN_MAX_">GetMessage( [MIN, MAX] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Retrieves a message sent to the window, optionally considering only
+messages identifiers in the range MIN..MAX; if a message is found, the
+function returns a 7 elements array containing: 
+
+</P>
+<UL>
+<LI><STRONG><A NAME="item_the">the result code of the message</A></STRONG>
+<LI><STRONG><A NAME="item_the">the message identifier</A></STRONG>
+<LI><STRONG><A NAME="item_the">the wParam argument</A></STRONG>
+<LI><STRONG><A NAME="item_the">the lParam argument</A></STRONG>
+<LI><STRONG><A NAME="item_the">the time when message occurred</A></STRONG>
+<LI><STRONG><A NAME="item_the">the x coordinate at which message occurred</A></STRONG>
+<LI><STRONG><A NAME="item_the">the y coordinate at which message occurred</A></STRONG>
+</UL>
+<P>
+If the result code of the message was -1 the function returns undef. Note
+that this function should not be normally used unless you know very well
+what you're doing. 
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetNextVisible_NODE_">GetNextVisible( NODE )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the handle of the next visible node for the given NODE.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#TreeView">TreeView</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetOpenFileName_OPTIONS_">GetOpenFileName( OPTIONS )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Displays the standard 'Open File' dialog box; the return value is the name
+of the choosen file or undef on errors.
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_directory_STRING">-directory</A>, <A HREF="././options.html#_file_STRING">-file</A>, <A HREF="././options.html#_filter_ARRAY_REFERENCE">-filter</A>, <A HREF="././options.html#_owner_WINDOW">-owner</A>, <A HREF="././options.html#_title_STRING">-title</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetPerlWindow_">GetPerlWindow()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the handle of the DOS Prompt window your perl script is running in;
+if called in an array context, returns the handle and the HINSTANCE of your
+perl process.
+
+</P>
+<P>
+Example:
+
+</P>
+<P>
+<PRE>        $DosPrompt = Win32::GUI::GetPerlWindow();
+        Win32::GUI::Hide( $DosPrompt );
+</PRE>
+</P>
+<P>
+<PRE>        # your program goes here...
+</PRE>
+</P>
+<P>
+<PRE>        Win32::GUI::Show( $DosPrompt );
+</PRE>
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetPrevVisible_NODE_">GetPrevVisible(NODE)</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the handle of the previous visible node for the given NODE.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#TreeView">TreeView</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetStockObject_OBJECT_">GetStockObject( OBJECT )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the handle of the specified predefined system object (pen, brush or
+font). OBJECT can have one of the following values:
+
+</P>
+<P>
+<PRE>         0      WHITE_BRUSH
+         1      GRAY_BRUSH
+         2      LTGRAY_BRUSH
+         3      DKGRAY_BRUSH
+         4      BLACK_BRUSH
+         5      NULL_BRUSH (also HOLLOW_BRUSH)
+         6      WHITE_PEN
+         7      BLACK_PEN
+         8      NULL_PEN
+        10      OEM_FIXED_FONT
+        11      ANSI_FIXED_FONT
+        12      ANSI_VAR_FONT
+        13      SYSTEM_FONT
+        14      DEVICE_DEFAULT_FONT
+        15      DEFAULT_PALETTE
+        16      SYSTEM_FIXED_FONT
+        17      DEFAULT_GUI_FONT
+</PRE>
+</P>
+<P>
+The returned handle can be referenced as if it was a Win32::GUI object of
+the corresponding type (eg. a Win32::GUI::Brush or Win32::GUI::Font), but
+note that it is not blessed, so you can't directly invoke methods on it:
+
+</P>
+<P>
+<PRE>    $Font = Win32::GUI::GetStockObject(17);    # DEFAULT_GUI_FONT
+    print $Font-&gt;GetMetrics();                 # !!!WRONG!!!
+    print Win32::GUI::Font::GetMetrics($Font); # correct
+    $Window-&gt;SetFont($Font);                   # correct
+</PRE>
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetStringWidth_STRING_">GetStringWidth( STRING )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the width, in pixels, needed to display the specified STRING in the
+ListView area.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#ListView">ListView</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetTextExtentPoint32_STRING_F">GetTextExtentPoint32( STRING, [FONT] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns a two elements array containing the x and y size of the specified
+STRING in the window (eventually with the speficied FONT), or undef on
+errors.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="GetWindowRect_">GetWindowRect()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns a four elements array defining the windows (external) rectangle
+(left, top, right, bottom) or undef on errors.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#GetClientRect_">GetClientRect()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Class">Class</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Height_HEIGHT_">Height( [HEIGHT] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Gets or sets the window height.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="#Width">Width</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Hide_">Hide()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Hides a window.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="HitTest_X_Y_">HitTest( X, Y )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Checks if the specified point in the control area is occupied by an item;
+it returns the identifier of the found item or zero if none was found. If
+called in an array context, it returns an additional value containing more
+info about the position of the specified point [TBD].
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#TreeView">TreeView</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Indent_VALUE_">Indent( [VALUE] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Gets or sets the indentation width, in pixels, between parents and child
+nodes; if the VALUE is less than the system-defined minimum, it is set to
+the system-defined minimum.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#TreeView">TreeView</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="InsertBand_OPTIONS_">InsertBand( OPTIONS )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Inserts a new band in the Rebar control.
+
+</P>
+<P>
+<PRE>    #   -index =&gt; position or -1 to add it at the end, default -1
+    #   -image =&gt; index of an image from the associated ImageList
+    #   -bitmap =&gt; Win32::GUI::Bitmap object
+    #   -child =&gt; child control
+    #   -foreground =&gt; COLOR
+    #   -background  =&gt; COLOR
+    #   -width =&gt; pixels
+    #   -minwidth =&gt; pixels
+    #   -minheight =&gt; pixels
+    #   -text =&gt; string
+</PRE>
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Rebar">Rebar</A>
+
+
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_background">-background</A>, <A HREF="././options.html#_bitmap">-bitmap</A>, <A HREF="././options.html#_child">-child</A>, <A HREF="././options.html#_foreground">-foreground</A>, <A HREF="././options.html#_image">-image</A>, <A HREF="././options.html#_index">-index</A>, <A HREF="././options.html#_minheight">-minheight</A>, <A HREF="././options.html#_minwidth">-minwidth</A>, <A HREF="././options.html#_text_STRING">-text</A>, <A HREF="././options.html#_width">-width</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Interval_ELAPSE_">Interval( [ELAPSE] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Changes the timeout value of the Timer to ELAPSE milliseconds, or returns
+the current timeout value if no parameter is specified. If ELAPSE is 0, the
+Timer is disabled; can also be used to resume a Timer after a
+<CODE>Kill().</CODE>
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#Kill_">Kill()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Timer">Timer</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="InvalidateRect_">InvalidateRect(...)</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Forces a refresh of a window, or a rectangle of it. The parameters can be
+(FLAG) for the whole area of the window, or (LEFT, TOP, RIGHT, BOTTOM,
+[FLAG]) to specify a rectangle. If the FLAG parameter is set to TRUE, the
+background is erased before the window is refreshed (this is the default).
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#Update_">Update()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="InvertRect_LEFT_TOP_RIGHT_BO">InvertRect( LEFT, TOP, RIGHT, BOTTOM )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Inverts the content of the rectangle from LEFT, TOP to RIGHT, BOTTOM.
+Returns nonzero if succesful, zero on errors.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#DC">DC</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="IsEnabled_">IsEnabled()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns TRUE if the window is enabled, FALSE otherwise.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="IsIconic_">IsIconic()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns TRUE if the window is minimized, FALSE otherwise.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="IsVisible_">IsVisible()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns TRUE if the window is visible, FALSE otherwise.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="IsWindow_">IsWindow()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns TRUE if the window is a window, FALSE otherwise.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="IsZoomed_">IsZoomed()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns TRUE if the window is maximized, FALSE otherwise.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="ItemCheck_ITEM_VALUE_">ItemCheck( ITEM, [VALUE] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+For TreeView, gets or sets the check state of the given ITEM (a node
+handle).
+
+</P>
+<P>
+For ListView, gets the check state of the given item (zero-based index);
+ListView does not support setting check states, so you can't pass a VALUE.
+
+</P>
+<P>
+In both cases is valid only if the control was created with the -checkboxes
+=&gt; 1 option.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#TreeView">TreeView</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="ItemFromPoint_X_Y_">ItemFromPoint( X, Y )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the zero-based index of the item nearest to the specified point; if
+called in a list context, returns an additional element which is TRUE if
+the point is inside the control area, FALSE if it's outside.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Listbox">Listbox</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="ItemPosition_INDEX_X_Y_">ItemPosition( INDEX, [X, Y] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Moves the specified zero-based INDEX item to the specified position, or
+returns its current X and Y position if X and Y are not given.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#MoveItem_INDEX_X_Y_">MoveItem()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#ListView">ListView</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Kill_">Kill()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Disables the Timer.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#Interval_ELAPSE_">Interval()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Timer">Timer</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Left_LEFT_">Left ( [LEFT] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Gets or sets the window X coordinate. If the window is a top level window
+(a <A HREF="././packages.html#Window">Window</A> or a
+<A HREF="././packages.html#DialogBox">DialogBox</A>) the value is relative to the screen (absolute), otherwise it is relative
+to the container of the control. To get the absolute (screen position) of a
+child control, use <CODE>AbsLeft()</CODE> instead.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft()</A>, <A HREF="././methods.html#Top_TOP_">Top()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="LineFromChar_INDEX_">LineFromChar( INDEX )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the line number (starting from zero) where the zero-based INDEX
+char appears.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Textfield">Textfield</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="ListIndex_">ListIndex()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+See <A HREF="././methods.html#SelectedItem_">SelectedItem()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Load_FILENAME_FORMAT_">Load( FILENAME, [FORMAT] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Loads a file named FILENAME into the RichEdit control. By default the file
+is a RTF (Rich Text Format) file; if you want to load a plain text file,
+you can set FORMAT to 1.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#RichEdit">RichEdit</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="MaxLength_CHARS_">MaxLength( [CHARS] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Limits the number of characters that the Textfield accept to CHARS, or
+returns the current limit if no argument is given. To remove the limit (eg.
+set it to the maximum allowed which is 32k for a single-line Textfield and
+64k for a multiline one) set CHARS to 0.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Textfield">Textfield</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Minimize_">Minimize()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+See <A HREF="././methods.html#CloseWindow_">CloseWindow()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Modified_FLAG_">Modified( [FLAG] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Gets or sets the modified flag on the control.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Textfield">Textfield</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Move_X_Y_">Move( X, Y )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Moves the window to the specified position.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="MoveItem_INDEX_X_Y_">MoveItem( INDEX, X, Y )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Moves the specified zero-based INDEX item to the specified position, if the
+ListView is in big or small icon view mode; X and Y coordinates are
+relative to the ListView client area.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#ItemPosition_INDEX_X_Y_">ItemPosition()</A>, <A HREF="././methods.html#View_MODE_">View()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#ListView">ListView</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Open_FILE_">Open( FILE )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Opens the specified AVI file in the Animation control; note that the AVI
+file must not contain sound data.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#Close_">Close()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="OpenIcon_">OpenIcon()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Restores a minimized window.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="PasswordChar_CHAR_">PasswordChar( [CHAR] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Gets or sets the character displayed in place of normal text; if the
+control has been created with the -password option, the default character
+is an asterisk (*). Note that by setting this value the text in the control
+will be redrawn using the specified character; if the character is set to
+zero instead, text will be redrawn as normal
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Textfield">Textfield</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Play_FROM_TO_REPEAT_">Play( [FROM], [TO], [REPEAT] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Plays the animation (eventually from the FROM frame to the TO frame)
+looping it REPEAT times. Defaults are FROM 0 (the first frame) to -1 (the
+last frame) and REPEAT -1 (loop forever).
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="ReadOnly_FLAG_">ReadOnly( [FLAG] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Gets or sets the readonly flag on the control.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Textfield">Textfield</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Rectangle_LEFT_TOP_RIGHT_BOT">Rectangle( LEFT, TOP, RIGHT, BOTTOM )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Draws a rectangle from LEFT, TOP to RIGHT, BOTTOM; the rectangle is
+outlined with the current pen and filled with the current brush. Returns
+nonzero if succesful, zero on errors.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#DC">DC</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="ReplaceSel_STRING_FLAG_">ReplaceSel( STRING, [FLAG] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Replaces the current selection in the control with STRING.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Textfield">Textfield</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Reset_">Reset()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Deletes the content of the control.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#Listbox">Listbox</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Resize_X_Y_">Resize( X, Y )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Resizes the window to the specified dimension.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Restore_">Restore()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+See <A HREF="././methods.html#OpenIcon_">OpenIcon()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="RowCount_">RowCount()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the number of rows in the Rebar control.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Rebar">Rebar</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Save_FILENAME_FORMAT_">Save( FILENAME, [FORMAT] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Saves the content of the RichEdit control in a file named FILENAME. By
+default the file is a RTF (Rich Text Format) file; if you want to save in a
+plain text file, you can set FORMAT to 1.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#RichEdit">RichEdit</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="ScaleHeight_">ScaleHeight()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the windows client area height.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#ScaleWidth_">ScaleWidth()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="ScaleWidth_">ScaleWidth()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the windows client area width.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#ScaleHeight_">ScaleHeight()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Scroll_COMMAND_LINE_HORIZON">Scroll( COMMAND | LINE | HORIZONTAL, VERTICAL )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Scrolls the text in the control; you have the following options:
+
+</P>
+<DL>
+<DT><STRONG><A NAME="item_COMMAND">COMMAND</A></STRONG><DD>
+<P>
+the following commands are recognized (their meaning is self-explanatory):
+
+</P>
+<P>
+<PRE>        up
+        down
+        pageup          
+        pagedown        
+        top
+        bottom
+</PRE>
+</P>
+<DT><STRONG><A NAME="item_LINE">LINE</A></STRONG><DD>
+<P>
+scrolls up or down the specified number of lines; use negative to scroll up
+and positive to scroll down.
+
+</P>
+<DT><STRONG><A NAME="item_HORIZONTAL">HORIZONTAL, VERTICAL</A></STRONG><DD>
+<P>
+scrolls VERTICAL lines vertically and HORIZONTAL characters horizontally;
+note that the RichEdit control does not support horizontal scroll.
+
+</P>
+</DL>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Textfield">Textfield</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Seek_FRAME_">Seek( FRAME )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Positions the AVI file to the specified FRAME.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="SelectAll_">SelectAll()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Selects all the text.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Textfield">Textfield</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="SelectCount_">SelectCount()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the number of currently selected items.
+
+</P>
+<P>
+For Listbox, the control must have been created with the -multisel option.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="SelectString_STRING_INDEX_">SelectString( STRING, [INDEX] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Searches the control for an item that begins with the specified STRING and,
+if found, selects that item. The optional INDEX parameter tells to start
+the search from the specified position; if no parameter is given, the whole
+list is searched. Returns the zero-based index of the selected item or -1
+if no matching item was found.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#FindString_STRING_INDEX_">FindString()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Listbox">Listbox</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="SelectedItem_">SelectedItem()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the zero-based index of the currently selected item, or -1 if no
+item is selected.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#Listbox">Listbox</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Selection_">Selection()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns a two elements array containing the current selection start and
+end.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Textfield">Textfield</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="SetCursor_CURSOR_">SetCursor( CURSOR )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Draws the specified CURSOR (a Win32::GUI::Cursor object). Returns the
+handle of the previously displayed cursor. Note that the cursor will change
+back to the default one as soon as the mouse moves or a system command is
+performed. To change the cursor stablily, use <CODE>ChangeCursor()</CODE>
+instead.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="SetCursorPos_X_Y_">SetCursorPos( X, Y )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Moves the cursor to the specified coordinates.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#GetCursorPos_">GetCursorPos()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="SetRange_MIN_MAX_">SetRange( [MIN], MAX )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Sets the range of values (from MIN to MAX) for the control; if MIN is not
+specified, it defaults to 0.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#ProgressBar">ProgressBar</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Show_COMMAND_">Show( [COMMAND] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Shows a window (or change its showing state to COMMAND); available COMMANDs
+are:
+
+</P>
+<P>
+<PRE>   SW_HIDE
+   SW_MAXIMIZE
+   SW_MINIMIZE
+   SW_RESTORE
+   SW_SHOW
+   SW_SHOWDEFAULT
+   SW_SHOWMAXIMIZED
+   SW_SHOWMINIMIZED
+   SW_SHOWMINNOACTIVE
+   SW_SHOWNA
+   SW_SHOWNOACTIVATE
+   SW_SHOWNORMAL
+</PRE>
+</P>
+<P>
+The default COMMAND, if none specified, is SW_SHOWNORMAL.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Stop_">Stop()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Stops the animation currently playing.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#Play_FROM_TO_REPEAT_">Play()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Text_TEXT_">Text( [TEXT] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Gets or sets the text of a window. 
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="TextOut_X_Y_TEXT_">TextOut( X, Y, TEXT )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Draws the specified TEXT string at X, Y, using the currently selected font.
+Returns nonzero if succesful, zero on errors.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#DC">DC</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Top_TOP_">Top( [TOP] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Gets or sets the window Y coordinate. If the window is a top level window
+(a <A HREF="././packages.html#Window">Window</A> or a
+<A HREF="././packages.html#DialogBox">DialogBox</A>) the value is relative to the screen (absolute), otherwise it is relative
+to the container of the control. To get the absolute (screen position) of a
+child control, use <CODE>AbsTop()</CODE> instead.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#AbsTop_">AbsTop()</A>, <A HREF="#Left">Left</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Undo_">Undo()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Undoes the last change in the control.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Textfield">Textfield</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Update_">Update()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Refreshes the content of a window.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././methods.html#InvalidateRect_">InvalidateRect()</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="View_MODE_">View( [MODE] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Gets or sets the viewing mode of the ListView control; the returned or
+given MODE can have one of the following values:
+
+</P>
+<P>
+<PRE>    0  big icons
+    1  details
+    2  small icons
+    3  list
+</PRE>
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#ListView">ListView</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="VisibleCount_">VisibleCount()</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the number of items that can be fully visible in a page of the
+control; for ListView, if the current view state is big or small icons, the
+function always returns the total number of items in the control.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#TreeView">TreeView</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Width_WIDTH_">Width( [WIDTH] )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Gets or sets the window width.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="#Height">Height</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="WindowFromPoint_X_Y_">WindowFromPoint( X, Y )</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Returns the handle of the window at the specified screen position.
+
+</P>
+</BLOCKQUOTE>
+
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/options.html perl-libwin32-0.191/GUI/docs/html/options.html
--- libwin32-0.191/GUI/docs/html/options.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/options.html	2004-01-12 16:46:41.375000000 -0800
@@ -0,0 +1,1283 @@
+<HTML>
+<HEAD>
+<TITLE>Win32::GUI options</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<LI><A HREF="#Win32_GUI_options">Win32::GUI options</A></LI>
+	<UL>
+
+		<LI><A HREF="#_align_left_center_right">-align =&gt; left/center/right</A></LI>
+		<LI><A HREF="#_autoplay_0_1">-autoplay =&gt; 0/1</A></LI>
+		<LI><A HREF="#_bandborders_0_1">-bandborders =&gt; 0/1</A></LI>
+		<LI><A HREF="#_buttons_0_1">-buttons =&gt; 0/1</A></LI>
+		<LI><A HREF="#_cancel_0_1">-cancel =&gt; 0/1</A></LI>
+		<LI><A HREF="#_center_0_1">-center =&gt; 0/1</A></LI>
+		<LI><A HREF="#_computeronly_0_1">-computeronly =&gt; 0/1</A></LI>
+		<LI><A HREF="#_default_0_1">-default =&gt; 0/1</A></LI>
+		<LI><A HREF="#_directory_STRING">-directory =&gt; STRING</A></LI>
+		<LI><A HREF="#_domainonly_0_1">-domainonly =&gt; 0/1</A></LI>
+		<LI><A HREF="#_driveonly_0_1">-driveonly =&gt; 0/1</A></LI>
+		<LI><A HREF="#_editbox_0_1">-editbox =&gt; 0/1</A></LI>
+		<LI><A HREF="#_file_STRING">-file =&gt; STRING</A></LI>
+		<LI><A HREF="#_fill_black_gray_white_none">-fill =&gt; black/gray/white/none</A></LI>
+		<LI><A HREF="#_filter_ARRAY_REFERENCE">-filter =&gt; ARRAY REFERENCE</A></LI>
+		<LI><A HREF="#_fixedorder_0_1">-fixedorder =&gt; 0/1</A></LI>
+		<LI><A HREF="#_folderonly_0_1">-folderonly =&gt; 0/1</A></LI>
+		<LI><A HREF="#_includefiles_0_1">-includefiles =&gt; 0/1</A></LI>
+		<LI><A HREF="#_maxsize_X_Y_">-maxsize =&gt; [X, Y]</A></LI>
+		<LI><A HREF="#_minsize_X_Y_">-minsize =&gt; [X, Y]</A></LI>
+		<LI><A HREF="#_multiline_0_1">-multiline =&gt; 0/1</A></LI>
+		<LI><A HREF="#_multisel_0_1_2">-multisel =&gt; 0/1/2</A></LI>
+		<LI><A HREF="#_name_STRING">-name =&gt; STRING</A></LI>
+		<LI><A HREF="#_notify_0_1">-notify =&gt; 0/1</A></LI>
+		<LI><A HREF="#_ok_0_1">-ok =&gt; 0/1</A></LI>
+		<LI><A HREF="#_owner_WINDOW">-owner =&gt; WINDOW</A></LI>
+		<LI><A HREF="#_password_0_1">-password =&gt; 0/1</A></LI>
+		<LI><A HREF="#_passwordchar_CHAR">-passwordchar =&gt; CHAR</A></LI>
+		<LI><A HREF="#_pos_X_Y_">-pos =&gt; [ X, Y ]</A></LI>
+		<LI><A HREF="#_printeronly_0_1">-printeronly =&gt; 0/1</A></LI>
+		<LI><A HREF="#_prompt_STRING_or_STRING_W">-prompt =&gt; STRING or [ STRING, WIDTH ]</A></LI>
+		<LI><A HREF="#_readonly_0_1">-readonly =&gt; 0/1</A></LI>
+		<LI><A HREF="#_root_PATH_or_CONSTANT">-root =&gt; PATH or CONSTANT</A></LI>
+		<LI><A HREF="#_size_X_Y_">-size =&gt; [ X, Y ]</A></LI>
+		<LI><A HREF="#_smooth_0_1">-smooth =&gt; 0/1</A></LI>
+		<LI><A HREF="#_sunken_0_1">-sunken =&gt; 0/1</A></LI>
+		<LI><A HREF="#_text_STRING">-text =&gt; STRING</A></LI>
+		<LI><A HREF="#_tip_STRING">-tip =&gt; STRING</A></LI>
+		<LI><A HREF="#_title_STRING">-title =&gt; STRING</A></LI>
+		<LI><A HREF="#_topmost_0_1">-topmost =&gt; 0/1</A></LI>
+		<LI><A HREF="#_transparent_0_1">-transparent =&gt; 0/1</A></LI>
+		<LI><A HREF="#_truncate_0_1_word_path">-truncate =&gt; 0/1/word/path</A></LI>
+		<LI><A HREF="#_valign_top_center_bottom">-valign =&gt; top/center/bottom</A></LI>
+		<LI><A HREF="#_wrap_0_1">-wrap =&gt; 0/1</A></LI>
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H1><A NAME="Win32_GUI_options">Win32::GUI options</A></H1>
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_align_left_center_right">-align =&gt; left/center/right</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>center for Button, otherwise left</CODE>
+
+
+
+</P>
+<P>
+Aligns the text in the control accordingly. 
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Textfield">Textfield</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_autoplay_0_1">-autoplay =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+Starts playing the animation as soon as an AVI clip is loaded.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_bandborders_0_1">-bandborders =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+Display a border to separate bands. 
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Rebar">Rebar</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_buttons_0_1">-buttons =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>1 for TreeView, otherwise 0</CODE>
+
+
+
+</P>
+<P>
+For TreeViews, enables or disables the +/- buttons to expand/collapse tree
+items.
+
+</P>
+<P>
+For Headers, if enabled header items look like push buttons and can be
+clicked.
+
+</P>
+<P>
+For TabStrips, if enabled items look like push buttons.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#TreeView">TreeView</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_cancel_0_1">-cancel =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+If 1, the button will correspond to the CANCEL action of a dialog, and its
+Click event will be fired by pressing the ESC key.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="#_dialogui">-dialogui</A>, <A HREF="././options.html#_cancel_0_1">-cancel</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Button">Button</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_center_0_1">-center =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+Centers the animation in the control area.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_computeronly_0_1">-computeronly =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+Only enable computers to be selected.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././methods.html#BrowseForFolder_OPTIONS_">BrowseForFolder()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_default_0_1">-default =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+Identify the item as the default one; a default Button has a black border
+drawn around it; a default MenuItem is printed with a bold font.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#MenuItem">MenuItem</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_directory_STRING">-directory =&gt; STRING</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Specifies the initial directory.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././methods.html#GetOpenFileName_OPTIONS_">GetOpenFileName()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_domainonly_0_1">-domainonly =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+Only show computers in the current domain or workgroup.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././methods.html#BrowseForFolder_OPTIONS_">BrowseForFolder()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_driveonly_0_1">-driveonly =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+Only enable drives to be selected.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././methods.html#BrowseForFolder_OPTIONS_">BrowseForFolder()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_editbox_0_1">-editbox =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+If 1, the dialog will include an edit field in which the user can type the
+name of an item.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././methods.html#BrowseForFolder_OPTIONS_">BrowseForFolder()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_file_STRING">-file =&gt; STRING</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Specifies a name that will appear on the dialog's edit field.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././methods.html#GetOpenFileName_OPTIONS_">GetOpenFileName()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_fill_black_gray_white_none">-fill =&gt; black/gray/white/none</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>none</CODE>
+
+
+
+</P>
+<P>
+Fills the control rectangle (``black'', ``gray'' and ``white'' are the
+window frame color, the desktop color and the window background color
+respectively). 
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Label">Label</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_filter_ARRAY_REFERENCE">-filter =&gt; ARRAY REFERENCE</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+[TBD]
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././methods.html#GetOpenFileName_OPTIONS_">GetOpenFileName()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_fixedorder_0_1">-fixedorder =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+Band position cannot be swapped.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Rebar">Rebar</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_folderonly_0_1">-folderonly =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+Only enable folders to be selected (eg. no computers or printers).
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././methods.html#BrowseForFolder_OPTIONS_">BrowseForFolder()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_includefiles_0_1">-includefiles =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+The list will include files as well folders.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././methods.html#BrowseForFolder_OPTIONS_">BrowseForFolder()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_maxsize_X_Y_">-maxsize =&gt; [X, Y]</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Specifies the maximum size (width and height) in pixels; X and Y must be
+passed in an array reference.
+
+</P>
+<P>
+Example:
+
+</P>
+<P>
+<PRE>    $Window = new Win32::GUI::Window(
+        # ...
+        -maxsize =&gt; [ 200, 200 ],
+    );
+</PRE>
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="#_maxwidth">-maxwidth</A>, <A HREF="#_maxheight">-maxheight</A>, <A HREF="././options.html#_minsize_X_Y_">-minsize</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_minsize_X_Y_">-minsize =&gt; [X, Y]</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Specifies the minimum size (width and height) in pixels; X and Y must be
+passed in an array reference.
+
+</P>
+<P>
+Example:
+
+</P>
+<P>
+<PRE>    $Window = new Win32::GUI::Window(
+        # ...
+        -minsize =&gt; [ 100, 100 ],
+    );
+</PRE>
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="#_minwidth">-minwidth</A>, <A HREF="#_minheight">-minheight</A>, <A HREF="././options.html#_maxsize_X_Y_">-maxsize</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_multiline_0_1">-multiline =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+The control can have more than one line (note that in Textfield and
+RichEdit controls, newline is ``\r\n'', not ``\n''!). 
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#ToolBar">ToolBar</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_multisel_0_1_2">-multisel =&gt; 0/1/2</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+Specifies the selection type: 
+
+</P>
+<P>
+<PRE>    0 single selection
+    1 multiple selection
+    2 multiple selection ehnanced (with Shift, Control, etc.)
+</PRE>
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Listbox">Listbox</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_name_STRING">-name =&gt; STRING</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Defines the name for the control. The name is used to callback its events
+and to access its methods, so it is absolutely <STRONG>necessary</STRONG>, and each name must be unique in your application. 
+
+</P>
+<P>
+Example: 
+
+</P>
+<P>
+<PRE>    $Window-&gt;AddButton(
+        -name =&gt; &quot;Button1&quot;,
+        # ...
+    );
+</PRE>
+</P>
+<P>
+<PRE>    # methods...
+    $Window-&gt;Button1-&gt;Hide();
+</PRE>
+</P>
+<P>
+<PRE>    # events...
+    sub Button1_Click {
+        # ...
+    }
+</PRE>
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Class">Class</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#NotifyIcon">NotifyIcon</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_notify_0_1">-notify =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+Enables the <CODE>Click(),</CODE> <CODE>DblClick(),</CODE> etc. events. 
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Label">Label</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_ok_0_1">-ok =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+If 1, the button will correspond to the OK action of a dialog, and its
+Click event will be fired by pressing the ENTER key.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="#_dialogui">-dialogui</A>, <A HREF="././options.html#_cancel_0_1">-cancel</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Button">Button</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_owner_WINDOW">-owner =&gt; WINDOW</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+[TBD]
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././methods.html#BrowseForFolder_OPTIONS_">BrowseForFolder()</A>, <A HREF="././methods.html#GetOpenFileName_OPTIONS_">GetOpenFileName()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_password_0_1">-password =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+Masks the user input (like password prompts). 
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././options.html#_passwordchar_CHAR">-passwordchar</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Textfield">Textfield</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_passwordchar_CHAR">-passwordchar =&gt; CHAR</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>'*'</CODE>
+
+
+
+</P>
+<P>
+The specified CHAR that is shown instead of the text with <CODE>-password =</CODE> 1&gt;.
+
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="././options.html#_password_0_1">-password</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Textfield">Textfield</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_pos_X_Y_">-pos =&gt; [ X, Y ]</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Defines the position for the window; note that X and Y must be passed in an
+array reference, eg:
+
+</P>
+<P>
+<PRE>    -pos =&gt; [ 100, 100 ],    # correct
+    -pos =&gt;   100, 100,      # WRONG
+    -pos =&gt; @coords,         # WRONG
+    -pos =&gt; \@coors,         # correct
+</PRE>
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="#_left">-left</A>, <A HREF="#_top">-top</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_printeronly_0_1">-printeronly =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+Only enable printers to be selected
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././methods.html#BrowseForFolder_OPTIONS_">BrowseForFolder()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_prompt_STRING_or_STRING_W">-prompt =&gt; STRING or [ STRING, WIDTH ]</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+The -prompt option is very special; if a string is passed, a
+Win32::GUI::Label object (with text set to the STRING passed) is created to
+the left of the Textfield. 
+
+</P>
+<P>
+Example: 
+
+</P>
+<P>
+<PRE>    $Window-&gt;AddTextfield(
+        -name   =&gt; &quot;Username&quot;,
+        -left   =&gt; 75,
+        -top    =&gt; 150,
+        -prompt =&gt; &quot;Your name:&quot;,
+    );
+</PRE>
+</P>
+<P>
+Furthermore, the value to <CODE>-prompt</CODE> can be a reference to a list containing the string and an additional
+parameter, which sets the width for the Label. If WIDTH is negative, it is
+calculated relative to the Textfield left coordinate. 
+
+</P>
+<P>
+Example: 
+
+</P>
+<P>
+<PRE>                                        (Label left)    (Textfield left)
+    -left   =&gt; 75,
+    -prompt =&gt; [ &quot;Your name:&quot;, 30 ],    75              105 (75+30)
+ 
+    -left   =&gt; 75,
+    -prompt =&gt; [ &quot;Your name:&quot;, -30 ],   45 (75-30)      75    
+</PRE>
+</P>
+<P>
+Note that the Win32::GUI::Label object is named like the Textfield, with a
+``_Prompt'' suffix (in the example above, the Label is named
+``Username_Prompt''). 
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Textfield">Textfield</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_readonly_0_1">-readonly =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+Text can't be changed.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Textfield">Textfield</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_root_PATH_or_CONSTANT">-root =&gt; PATH or CONSTANT</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+The root directory for browsing; this can be either a path or one of the
+CSIDL_* constants for special folders (see the Win32::FileOp module by
+Jenda for a list of such constants).
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././methods.html#BrowseForFolder_OPTIONS_">BrowseForFolder()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_size_X_Y_">-size =&gt; [ X, Y ]</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Defines the size for the window; note that X and Y must be passed in an
+array reference, eg:
+
+</P>
+<P>
+<PRE>    -size =&gt; [ 100, 100 ],    # correct
+    -size =&gt;   100, 100,      # WRONG
+    -size =&gt; @coords,         # WRONG
+    -size =&gt; \@coors,         # correct
+</PRE>
+</P>
+<P>
+<STRONG>See also</STRONG>: <A HREF="#_width">-width</A>, <A HREF="#_height">-height</A>
+
+
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_smooth_0_1">-smooth =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+Uses a smooth bar instead of the default segmented bar. 
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#ProgressBar">ProgressBar</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_sunken_0_1">-sunken =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+Draws a half-sunken border around the control. 
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Label">Label</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_text_STRING">-text =&gt; STRING</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+The text that will appear in the control or item.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>, <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#Checkbox">Checkbox</A>, <A HREF="././packages.html#Combobox">Combobox</A>, <A HREF="././packages.html#ComboboxEx">ComboboxEx</A>, <A HREF="././packages.html#DateTime">DateTime</A>, <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Graphic">Graphic</A>, <A HREF="././packages.html#Groupbox">Groupbox</A>, <A HREF="././packages.html#Header">Header</A>, <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#Listbox">Listbox</A>, <A HREF="././packages.html#ListView">ListView</A>, <A HREF="././packages.html#ProgressBar">ProgressBar</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>, <A HREF="././packages.html#Rebar">Rebar</A>, <A HREF="././packages.html#RichEdit">RichEdit</A>, <A HREF="././packages.html#Slider">Slider</A>, <A HREF="././packages.html#Splitter">Splitter</A>, <A HREF="././packages.html#StatusBar">StatusBar</A>, <A HREF="././packages.html#TabStrip">TabStrip</A>, <A HREF="././packages.html#Textfield">Textfield</A>, <A HREF="././packages.html#Toolbar">Toolbar</A>, <A HREF="././packages.html#TreeView">TreeView</A>, <A HREF="././packages.html#UpDown">UpDown</A>, <A HREF="././packages.html#Window">Window</A>, <A HREF="././methods.html#InsertBand_OPTIONS_">InsertBand()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_tip_STRING">-tip =&gt; STRING</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+The text that will appear as tooltip when the mouse is on the NotifyIcon.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#NotifyIcon">NotifyIcon</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_title_STRING">-title =&gt; STRING</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+The title for the window or dialog box.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Window">Window</A>, <A HREF="././methods.html#BrowseForFolder_OPTIONS_">BrowseForFolder()</A>, <A HREF="././methods.html#GetOpenFileName_OPTIONS_">GetOpenFileName()</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_topmost_0_1">-topmost =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+The window ``stays on top'' even when deactivated.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#DialogBox">DialogBox</A>, <A HREF="././packages.html#Window">Window</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_transparent_0_1">-transparent =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+Draws the animation using a transparent background.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Animation">Animation</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_truncate_0_1_word_path">-truncate =&gt; 0/1/word/path</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>0</CODE>
+
+
+
+</P>
+<P>
+Specifies how the text is to be truncated:
+
+</P>
+<P>
+<PRE>           0    the text is not truncated
+           1    the text is truncated at the end.
+        word    the text is truncated at the end of a word.
+        path    the text is truncated before the last &quot;\&quot; 
+                (used to shorten paths).
+</PRE>
+</P>
+
+<P>
+NOTE: this style does not seem to be working.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Label">Label</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_valign_top_center_bottom">-valign =&gt; top/center/bottom</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>center</CODE>
+
+
+
+</P>
+<P>
+Defines the vertical alignment for the text in the Button.
+
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Button">Button</A>, <A HREF="././packages.html#CheckBox">CheckBox</A>, <A HREF="././packages.html#RadioButton">RadioButton</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="_wrap_0_1">-wrap =&gt; 0/1</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+<STRONG>Default value</STRONG>: <CODE>1 for Label, 0 for UpDown</CODE>
+
+
+
+</P>
+<P>
+For Labels, the text wraps automatically to a new line. For UpDown
+controls, the counter wraps when it reaches the lower or upper limit.
+
+</P>
+<P>
+<PRE> 
+</PRE>
+</P>
+<P>
+<STRONG>Applies to</STRONG>: <A HREF="././packages.html#Label">Label</A>, <A HREF="././packages.html#UpDown">UpDown</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/html/packages.html perl-libwin32-0.191/GUI/docs/html/packages.html
--- libwin32-0.191/GUI/docs/html/packages.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/html/packages.html	2004-01-12 16:46:41.390625000 -0800
@@ -0,0 +1,825 @@
+<HTML>
+<HEAD>
+<TITLE>Win32::GUI packages</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!--
+
+<UL>
+
+	<LI><A HREF="#Win32_GUI_packages">Win32::GUI packages</A></LI>
+	<UL>
+
+		<LI><A HREF="#Animation">Animation</A></LI>
+		<LI><A HREF="#Button">Button</A></LI>
+		<LI><A HREF="#Checkbox">Checkbox</A></LI>
+		<LI><A HREF="#Class">Class</A></LI>
+		<LI><A HREF="#Combobox">Combobox</A></LI>
+		<LI><A HREF="#ComboboxEx">ComboboxEx</A></LI>
+		<LI><A HREF="#DateTime">DateTime</A></LI>
+		<LI><A HREF="#DialogBox">DialogBox</A></LI>
+		<LI><A HREF="#Graphic">Graphic</A></LI>
+		<LI><A HREF="#Groupbox">Groupbox</A></LI>
+		<LI><A HREF="#Header">Header</A></LI>
+		<LI><A HREF="#Label">Label</A></LI>
+		<LI><A HREF="#ListView">ListView</A></LI>
+		<LI><A HREF="#Listbox">Listbox</A></LI>
+		<LI><A HREF="#ProgressBar">ProgressBar</A></LI>
+		<LI><A HREF="#RadioButton">RadioButton</A></LI>
+		<LI><A HREF="#Rebar">Rebar</A></LI>
+		<LI><A HREF="#RichEdit">RichEdit</A></LI>
+		<LI><A HREF="#Slider">Slider</A></LI>
+		<LI><A HREF="#Splitter">Splitter</A></LI>
+		<LI><A HREF="#StatusBar">StatusBar</A></LI>
+		<LI><A HREF="#TabStrip">TabStrip</A></LI>
+		<LI><A HREF="#Textfield">Textfield</A></LI>
+		<LI><A HREF="#Timer">Timer</A></LI>
+		<LI><A HREF="#Toolbar">Toolbar</A></LI>
+		<LI><A HREF="#Tooltip">Tooltip</A></LI>
+		<LI><A HREF="#TreeView">TreeView</A></LI>
+		<LI><A HREF="#UpDown">UpDown</A></LI>
+		<LI><A HREF="#Window">Window</A></LI>
+	</UL>
+
+</UL>
+-->
+<!-- INDEX END -->
+
+<P>
+<H1><A NAME="Win32_GUI_packages">Win32::GUI packages</A></H1>
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Animation">Animation</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+The Animation control displays an AVI animation. To load an AVI file you
+can use the <A HREF="././methods.html#Open">Open()</A> method; you can then use <A HREF="././methods.html#Play">Play()</A> to start the animation (note it will start automatically with the -autoplay
+option),
+<A HREF="././methods.html#Stop">Stop()</A> to stop it and <A HREF="././methods.html#Seek">Seek()</A> to position it to a specified frame.
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_autoplay_0_1">-autoplay</A>, <A HREF="././options.html#_center_0_1">-center</A>, <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>, <A HREF="././options.html#_transparent_0_1">-transparent</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Close_">Close</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Open_FILE_">Open</A>, <A HREF="././methods.html#Play_FROM_TO_REPEAT_">Play</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Seek_FRAME_">Seek</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Stop_">Stop</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Button">Button</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_align_left_center_right">-align</A>, <A HREF="././options.html#_bitmap">-bitmap</A>, <A HREF="././options.html#_cancel_0_1">-cancel</A>, <A HREF="././options.html#_default_0_1">-default</A>, <A HREF="././options.html#_icon">-icon</A>, <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_ok_0_1">-ok</A>, <A HREF="././options.html#_picture">-picture</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>, <A HREF="././options.html#_valign_top_center_bottom">-valign</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Checkbox">Checkbox</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Class">Class</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_name_STRING">-name</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Combobox">Combobox</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#Add_STRING_STRING_STRING_">Add</A>, <A HREF="././methods.html#AddString_STRING_">AddString</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Count_">Count</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#FindString_STRING_INDEX_">FindString</A>, <A HREF="././methods.html#FindStringExact_STRING_INDEX_">FindStringExact</A>, <A HREF="././methods.html#FirstVisibleItem_INDEX_">FirstVisibleItem</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Reset_">Reset</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#SelectedItem_">SelectedItem</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="ComboboxEx">ComboboxEx</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="DateTime">DateTime</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="DialogBox">DialogBox</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+Just like Window, but with a predefined dialog box look: by default, a
+DialogBox can not be sized, has no maximize box and has <CODE>-dialogui</CODE> enabled (eg. interprets tab/enter/esc).
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_accel">-accel</A>, <A HREF="././options.html#_accelerators">-accelerators</A>, <A HREF="././options.html#_acceleratortable">-acceleratortable</A>, <A HREF="././options.html#_background">-background</A>, <A HREF="././options.html#_caption">-caption</A>, <A HREF="././options.html#_font">-font</A>, <A HREF="././options.html#_foreground">-foreground</A>, <A HREF="././options.html#_height">-height</A>, <A HREF="././options.html#_hscroll">-hscroll</A>, <A HREF="././options.html#_left">-left</A>, <A HREF="././options.html#_maxheight">-maxheight</A>, <A HREF="././options.html#_maximizebox">-maximizebox</A>, <A HREF="././options.html#_maxsize_X_Y_">-maxsize</A>, <A HREF="././options.html#_maxwidth">-maxwidth</A>, <A HREF="././options.html#_menu">-menu</A>, <A HREF="././options.html#_minheight">-minheight</A>, <A HREF="././options.html#_minimizebox">-minimizebox</A>, <A HREF="././options.html#_minsize_X_Y_">-minsize</A>, <A HREF="././options.html#_minwidth">-minwidth</A>, <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_sizable">-sizable</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_sysmenu">-sysmenu</A>, <A HREF="././options.html#_text_STRING">-text</A>, <A HREF="././options.html#_title_STRING">-title</A>, <A HREF="././options.html#_top">-top</A>, <A HREF="././options.html#_topmost_0_1">-topmost</A>, <A HREF="././options.html#_vscroll">-vscroll</A>, <A HREF="././options.html#_width">-width</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#BringWindowToTop_">BringWindowToTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#ChangeIcon_ICON_">ChangeIcon</A>, <A HREF="././methods.html#ChangeSmallIcon_ICON_">ChangeSmallIcon</A>, <A HREF="././methods.html#CloseWindow_">CloseWindow</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#DrawMenuBar_">DrawMenuBar</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetMenu_">GetMenu</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsIconic_">IsIconic</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#IsZoomed_">IsZoomed</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#OpenIcon_">OpenIcon</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Graphic">Graphic</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Groupbox">Groupbox</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Header">Header</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_buttons_0_1">-buttons</A>, <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Label">Label</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_align_left_center_right">-align</A>, <A HREF="././options.html#_bitmap">-bitmap</A>, <A HREF="././options.html#_fill_black_gray_white_none">-fill</A>, <A HREF="././options.html#_frame">-frame</A>, <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_notify_0_1">-notify</A>, <A HREF="././options.html#_picture">-picture</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_sunken_0_1">-sunken</A>, <A HREF="././options.html#_text_STRING">-text</A>, <A HREF="././options.html#_truncate_0_1_word_path">-truncate</A>, <A HREF="././options.html#_wrap_0_1">-wrap</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="ListView">ListView</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#Arrange_FLAG_">Arrange</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#EnsureVisible_ITEM_FLAG_">EnsureVisible</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetStringWidth_STRING_">GetStringWidth</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#HitTest_X_Y_">HitTest</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#ItemCheck_ITEM_VALUE_">ItemCheck</A>, <A HREF="././methods.html#ItemPosition_INDEX_X_Y_">ItemPosition</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#MoveItem_INDEX_X_Y_">MoveItem</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#SelectCount_">SelectCount</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>, <A HREF="././methods.html#View_MODE_">View</A>, <A HREF="././methods.html#VisibleCount_">VisibleCount</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Listbox">Listbox</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_multisel_0_1_2">-multisel</A>, <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_sort">-sort</A>, <A HREF="././options.html#_text_STRING">-text</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#Add_STRING_STRING_STRING_">Add</A>, <A HREF="././methods.html#AddString_STRING_">AddString</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Count_">Count</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#FindString_STRING_INDEX_">FindString</A>, <A HREF="././methods.html#FindStringExact_STRING_INDEX_">FindStringExact</A>, <A HREF="././methods.html#FirstVisibleItem_INDEX_">FirstVisibleItem</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#ItemFromPoint_X_Y_">ItemFromPoint</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Reset_">Reset</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#SelectCount_">SelectCount</A>, <A HREF="././methods.html#SelectedItem_">SelectedItem</A>, <A HREF="././methods.html#SelectString_STRING_INDEX_">SelectString</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="ProgressBar">ProgressBar</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_smooth_0_1">-smooth</A>, <A HREF="././options.html#_text_STRING">-text</A>, <A HREF="././options.html#_vertical">-vertical</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#SetRange_MIN_MAX_">SetRange</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="RadioButton">RadioButton</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>, <A HREF="././options.html#_valign_top_center_bottom">-valign</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Rebar">Rebar</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_bandborders_0_1">-bandborders</A>, <A HREF="././options.html#_fixedorder_0_1">-fixedorder</A>, <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#BandCount_">BandCount</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#DeleteBand_">DeleteBand</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InsertBand_OPTIONS_">InsertBand</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#RowCount_">RowCount</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="RichEdit">RichEdit</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_align_left_center_right">-align</A>, <A HREF="././options.html#_autohscroll">-autohscroll</A>, <A HREF="././options.html#_autovscroll">-autovscroll</A>, <A HREF="././options.html#_keepselection">-keepselection</A>, <A HREF="././options.html#_lowercase">-lowercase</A>, <A HREF="././options.html#_multiline_0_1">-multiline</A>, <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_number">-number</A>, <A HREF="././options.html#_password_0_1">-password</A>, <A HREF="././options.html#_passwordchar_CHAR">-passwordchar</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_prompt_STRING_or_STRING_W">-prompt</A>, <A HREF="././options.html#_readonly_0_1">-readonly</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>, <A HREF="././options.html#_uppercase">-uppercase</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#BackColor_COLOR_">BackColor</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#LineFromChar_INDEX_">LineFromChar</A>, <A HREF="././methods.html#Load_FILENAME_FORMAT_">Load</A>, <A HREF="././methods.html#MaxLength_CHARS_">MaxLength</A>, <A HREF="././methods.html#Modified_FLAG_">Modified</A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#PasswordChar_CHAR_">PasswordChar</A>, <A HREF="././methods.html#ReadOnly_FLAG_">ReadOnly</A>, <A HREF="././methods.html#ReplaceSel_STRING_FLAG_">ReplaceSel</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#Save_FILENAME_FORMAT_">Save</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Scroll_COMMAND_LINE_HORIZON">Scroll</A>, <A HREF="././methods.html#SelectAll_">SelectAll</A>, <A HREF="././methods.html#Selection_">Selection</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Undo_">Undo</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Slider">Slider</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Splitter">Splitter</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="StatusBar">StatusBar</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="TabStrip">TabStrip</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_bottom">-bottom</A>, <A HREF="././options.html#_buttons_0_1">-buttons</A>, <A HREF="././options.html#_flat">-flat</A>, <A HREF="././options.html#_hottrack">-hottrack</A>, <A HREF="././options.html#_imagelist">-imagelist</A>, <A HREF="././options.html#_justify">-justify</A>, <A HREF="././options.html#_multiline_0_1">-multiline</A>, <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_right">-right</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>, <A HREF="././options.html#_vertical">-vertical</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Textfield">Textfield</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_align_left_center_right">-align</A>, <A HREF="././options.html#_autohscroll">-autohscroll</A>, <A HREF="././options.html#_autovscroll">-autovscroll</A>, <A HREF="././options.html#_keepselection">-keepselection</A>, <A HREF="././options.html#_lowercase">-lowercase</A>, <A HREF="././options.html#_multiline_0_1">-multiline</A>, <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_number">-number</A>, <A HREF="././options.html#_password_0_1">-password</A>, <A HREF="././options.html#_passwordchar_CHAR">-passwordchar</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_prompt_STRING_or_STRING_W">-prompt</A>, <A HREF="././options.html#_readonly_0_1">-readonly</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>, <A HREF="././options.html#_uppercase">-uppercase</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#LineFromChar_INDEX_">LineFromChar</A>, <A HREF="././methods.html#MaxLength_CHARS_">MaxLength</A>, <A HREF="././methods.html#Modified_FLAG_">Modified</A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#PasswordChar_CHAR_">PasswordChar</A>, <A HREF="././methods.html#ReadOnly_FLAG_">ReadOnly</A>, <A HREF="././methods.html#ReplaceSel_STRING_FLAG_">ReplaceSel</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Scroll_COMMAND_LINE_HORIZON">Scroll</A>, <A HREF="././methods.html#SelectAll_">SelectAll</A>, <A HREF="././methods.html#Selection_">Selection</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Undo_">Undo</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Timer">Timer</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+The Timer object is a special kind of control: it has no appearance, its
+only purpose is to trigger an event every specified amount of time.
+
+</P>
+<P>
+The synopsis to create a Timer object is:
+
+</P>
+<P>
+<PRE>        new Win32::GUI::Timer( PARENT, NAME, ELAPSE )
+</PRE>
+</P>
+<P>
+<PRE>        PARENT-&gt;AddTimer( NAME, ELAPSE )
+</PRE>
+</P>
+<DL>
+<DT><STRONG><A NAME="item_NAME">NAME</A></STRONG><DD>
+<P>
+the name for the Timer object (used to lookup the associated event).
+
+</P>
+<DT><STRONG><A NAME="item_ELAPSE">ELAPSE</A></STRONG><DD>
+<P>
+the number of milliseconds after which the <CODE>Timer()</CODE> event will
+be triggered.
+
+</P>
+</DL>
+<P>
+Once you've created the Timer object, you can change the ELAPSE parameter
+with the <CODE>Interval()</CODE> method, or disables it with the
+<CODE>Kill()</CODE> method. Note that <CODE>Kill(),</CODE> despite of its
+name, does not destroy the Timer object, so you can re-enable it later with
+<CODE>Interval().</CODE>
+
+</P>
+<P>
+Example:
+
+</P>
+<P>
+<PRE>        # creates a Timer that is called every 1 second
+        
+        $Window-&gt;AddTimer( &quot;Clock&quot;, 1000 );
+</PRE>
+</P>
+<P>
+<PRE>        sub Clock_Timer {
+                print &quot;one second passed.\n&quot;;
+        }
+</PRE>
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#Interval_ELAPSE_">Interval</A>, <A HREF="././methods.html#Kill_">Kill</A>
+
+
+
+</P>
+<P>
+<STRONG>Events</STRONG>: <A HREF="././events.html#Timer_">Timer</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Toolbar">Toolbar</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_text_STRING">-text</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Tooltip">Tooltip</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="TreeView">TreeView</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_buttons_0_1">-buttons</A>, <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#EnsureVisible_ITEM_FLAG_">EnsureVisible</A>, <A HREF="././methods.html#Expand_NODE_FLAG_">Expand</A>, <A HREF="././methods.html#FirstVisible_NODE_">FirstVisible</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetLastVisible_">GetLastVisible</A>, <A HREF="././methods.html#GetNextVisible_NODE_">GetNextVisible</A>, <A HREF="././methods.html#GetPrevVisible_NODE_">GetPrevVisible</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#HitTest_X_Y_">HitTest</A>, <A HREF="././methods.html#Indent_VALUE_">Indent</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#ItemCheck_ITEM_VALUE_">ItemCheck</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>, <A HREF="././methods.html#VisibleCount_">VisibleCount</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="UpDown">UpDown</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+x
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_text_STRING">-text</A>, <A HREF="././options.html#_wrap_0_1">-wrap</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+<TT>
+
+<P>
+<HR>
+<H2><A NAME="Window">Window</A></H2>
+</TT><BLOCKQUOTE>
+
+<P>
+This is the main container of a regular GUI; also known as ``top level
+window''.
+
+</P>
+<P>
+<STRONG>Options</STRONG>: <A HREF="././options.html#_accel">-accel</A>, <A HREF="././options.html#_accelerators">-accelerators</A>, <A HREF="././options.html#_acceleratortable">-acceleratortable</A>, <A HREF="././options.html#_background">-background</A>, <A HREF="././options.html#_caption">-caption</A>, <A HREF="././options.html#_font">-font</A>, <A HREF="././options.html#_foreground">-foreground</A>, <A HREF="././options.html#_height">-height</A>, <A HREF="././options.html#_hscroll">-hscroll</A>, <A HREF="././options.html#_left">-left</A>, <A HREF="././options.html#_maxheight">-maxheight</A>, <A HREF="././options.html#_maximizebox">-maximizebox</A>, <A HREF="././options.html#_maxsize_X_Y_">-maxsize</A>, <A HREF="././options.html#_maxwidth">-maxwidth</A>, <A HREF="././options.html#_menu">-menu</A>, <A HREF="././options.html#_minheight">-minheight</A>, <A HREF="././options.html#_minimizebox">-minimizebox</A>, <A HREF="././options.html#_minsize_X_Y_">-minsize</A>, <A HREF="././options.html#_minwidth">-minwidth</A>, <A HREF="././options.html#_name_STRING">-name</A>, <A HREF="././options.html#_pos_X_Y_">-pos</A>, <A HREF="././options.html#_sizable">-sizable</A>, <A HREF="././options.html#_size_X_Y_">-size</A>, <A HREF="././options.html#_sysmenu">-sysmenu</A>, <A HREF="././options.html#_text_STRING">-text</A>, <A HREF="././options.html#_title_STRING">-title</A>, <A HREF="././options.html#_top">-top</A>, <A HREF="././options.html#_topmost_0_1">-topmost</A>, <A HREF="././options.html#_vscroll">-vscroll</A>, <A HREF="././options.html#_width">-width</A>
+
+
+
+</P>
+<P>
+<STRONG>Methods</STRONG>: <A HREF="././methods.html#AbsLeft_">AbsLeft</A>, <A HREF="././methods.html#AbsTop_">AbsTop</A>, <A HREF="././methods.html#BringWindowToTop_">BringWindowToTop</A>, <A HREF="././methods.html#ChangeCursor_CURSOR_">ChangeCursor</A>, <A HREF="././methods.html#ChangeIcon_ICON_">ChangeIcon</A>, <A HREF="././methods.html#ChangeSmallIcon_ICON_">ChangeSmallIcon</A>, <A HREF="././methods.html#CloseWindow_">CloseWindow</A>, <A HREF="././methods.html#Disable_">Disable</A>, <A HREF="././methods.html#DrawMenuBar_">DrawMenuBar</A>, <A HREF="././methods.html#Enable_FLAG_">Enable</A>, <A HREF="././methods.html#GetClassName_">GetClassName</A>, <A HREF="././methods.html#GetClientRect_">GetClientRect</A>, <A HREF="././methods.html#GetFont_FONT_">GetFont</A>, <A HREF="././methods.html#GetFontName_">GetFontName</A>, <A HREF="././methods.html#GetMenu_">GetMenu</A>, <A HREF="././methods.html#GetTextExtentPoint32_STRING_F">GetTextExtentPoint32</A>, <A HREF="././methods.html#GetWindowRect_">GetWindowRect</A>, <A HREF="././methods.html#Height_HEIGHT_">Height</A>, <A HREF="././methods.html#Hide_">Hide</A>, <A HREF="././methods.html#InvalidateRect_">InvalidateRect</A>, <A HREF="././methods.html#IsEnabled_">IsEnabled</A>, <A HREF="././methods.html#IsIconic_">IsIconic</A>, <A HREF="././methods.html#IsVisible_">IsVisible</A>, <A HREF="././methods.html#IsWindow_">IsWindow</A>, <A HREF="././methods.html#IsZoomed_">IsZoomed</A>, <A HREF="././methods.html#Left_LEFT_">Left </A>, <A HREF="././methods.html#Move_X_Y_">Move</A>, <A HREF="././methods.html#OpenIcon_">OpenIcon</A>, <A HREF="././methods.html#Resize_X_Y_">Resize</A>, <A HREF="././methods.html#ScaleHeight_">ScaleHeight</A>, <A HREF="././methods.html#ScaleWidth_">ScaleWidth</A>, <A HREF="././methods.html#Show_COMMAND_">Show</A>, <A HREF="././methods.html#Update_">Update</A>
+
+
+
+</P>
+</BLOCKQUOTE>
+
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/methods.pod perl-libwin32-0.191/GUI/docs/methods.pod
--- libwin32-0.191/GUI/docs/methods.pod	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/methods.pod	2004-01-12 16:46:41.406250000 -0800
@@ -0,0 +1,1955 @@
+=head1 Win32::GUI methods
+
+=for HTML <TT>
+
+=head2 AbsLeft()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the absolute (screen) window x coordinate; use this to get the
+onscreen position of a child window, eg. a button or a label.
+This method returns -1 on errors.
+
+
+
+
+B<See also>: L</Left()>
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Class|packages/Class>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>, L<Tooltip(*)|packages/Tooltip(*)>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 AbsTop()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the absolute (screen) window y coordinate; use this to get the
+onscreen position of a child window, eg. a button or a label.
+This method returns -1 on errors.
+
+
+
+
+B<See also>: L<Top()|methods/Top_TOP_>
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Class|packages/Class>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>, L<Tooltip(*)|packages/Tooltip(*)>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Add(STRING, STRING .. STRING)
+
+=for HTML </TT><BLOCKQUOTE>
+
+Adds one or more items at the end of the control's list.
+
+
+
+
+B<Applies to>: L<Combobox|packages/Combobox>, L<Listbox|packages/Listbox>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 AddString( STRING )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Adds an item at the end of the control's list.
+
+
+
+
+B<Applies to>: L<Combobox|packages/Combobox>, L<Listbox|packages/Listbox>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Arrange( [FLAG] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Arranges items in the ListView; the optional FLAG parameter can be one
+of the following values:
+
+	0  uses the current alignment style (this is the default)
+	1  align items along the left edge of the window
+	2  align items along the top edge of the window
+	5  snaps icons to the nearest grid position
+
+
+
+
+B<Applies to>: L<ListView|packages/ListView>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 BackColor( [COLOR] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Sets the background color of the RichEdit control; if no COLOR is
+specified, the background color is reset to the default system color.
+
+
+
+
+B<Applies to>: L<RichEdit|packages/RichEdit>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 BandCount()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the number of bands in the Rebar control.
+
+
+
+
+B<Applies to>: L<Rebar|packages/Rebar>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 BringWindowToTop()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Brings the window to the foreground.
+
+
+
+
+B<Applies to>: L<DialogBox|packages/DialogBox>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 BrowseForFolder( OPTIONS )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Displays the standard "Browse For Folder" dialog box.
+Returns the selected item's name, or undef if no item was selected
+or an error occurred.
+
+Note that BrowseForFolder must be called as a standalone function, not as
+a method.
+
+Example:
+
+	$folder = Win32::GUI::BrowseForFolder(
+		-root => "C:\\Program Files",
+		-includefiles => 1,
+	);
+
+
+
+B<Options>: L<-computeronly|options/_computeronly_0_1>, L<-domainonly|options/_domainonly_0_1>, L<-driveonly|options/_driveonly_0_1>, L<-editbox|options/_editbox_0_1>, L<-folderonly|options/_folderonly_0_1>, L<-includefiles|options/_includefiles_0_1>, L<-owner|options/_owner_WINDOW>, L<-printeronly|options/_printeronly_0_1>, L<-root|options/_root_PATH_or_CONSTANT>, L<-title|options/_title_STRING>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Caption( [TEXT] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+See L<Text().|methods/Text_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 ChangeCursor( CURSOR )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Changes the default cursor for a window to CURSOR (a Win32::GUI::Cursor
+object). Returns the handle of the previous default cursor.
+
+
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Class|packages/Class>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 ChangeIcon( ICON )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Changes the default icon for a window to ICON (a Win32::GUI::Icon object). 
+Returns the handle of the previous default icon. 
+
+
+
+
+
+B<See also>: L<ChangeSmallIcon()|methods/ChangeSmallIcon_ICON_>
+
+B<Applies to>: L<DialogBox|packages/DialogBox>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 ChangeSmallIcon( ICON )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Changes the default small icon for a window to ICON (a Win32::GUI::Icon object). 
+Returns the handle of the previous default small icon. 
+
+
+
+
+
+B<See also>: L<ChangeIcon()|methods/ChangeIcon_ICON_>
+
+B<Applies to>: L<DialogBox|packages/DialogBox>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Clear()
+
+=for HTML </TT><BLOCKQUOTE>
+
+See L<Reset().|methods/Reset_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 ClipCursor( [LEFT, TOP, RIGHT, BOTTOM] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Confines the cursor to the specified screen rectangle.
+Call it without parameters to release the cursor.
+Returns nonzero on success, zero on failure.
+
+
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Close()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Closes the opened AVI file.
+
+
+
+
+
+B<See also>: L<Open()|methods/Open_FILE_>
+
+B<Applies to>: L<Animation|packages/Animation>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 CloseWindow()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Minimizes a window.
+
+
+
+
+B<Applies to>: L<DialogBox|packages/DialogBox>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 CommDlgExtendedError()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the last common dialog library error code. 
+
+
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Count()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the number of items in the control.
+
+
+
+
+B<Applies to>: L<Combobox|packages/Combobox>, L<Listbox|packages/Listbox>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 DeleteBand()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Deletes the zero-based INDEX band from the Rebar.
+
+
+
+
+B<Applies to>: L<Rebar|packages/Rebar>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Dialog()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Enter the GUI dialog phase: the script halts, the user can interact
+with the created windows and events subroutines are triggered
+as necessary; note that this function must be called
+without ANY parameter or instantiation (eg. don't call it as method
+of a created object):
+
+    Win32::GUI::Dialog(); # correct
+    $Window->Dialog();    # !!!WRONG!!!
+
+
+
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Disable()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Disables a window. 
+
+
+
+
+B<See also>: L<Enable()|methods/Enable_FLAG_>, L<IsEnabled()|methods/IsEnabled_>
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Class|packages/Class>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 DoEvents()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Just like Dialog(), but returns when there are no more events to process.
+
+
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 DrawMenuBar()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Forces redrawing of the menu bar.
+
+
+
+
+B<Applies to>: L<DialogBox|packages/DialogBox>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Enable( [FLAG] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Enables a window (or disables it if FLAG is FALSE). 
+
+
+
+
+B<See also>: L<Disable()|methods/Disable_>, L<IsEnabled()|methods/IsEnabled_>
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Class|packages/Class>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 EnsureVisible( ITEM, [FLAG] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+For TreeView, ensures that the specified ITEM (a node handle) is visible in the 
+control.
+
+For ListView, ensures that the specified ITEM (zero-based index) is visible in
+the control (FLAG to be defined...).
+
+
+
+
+B<Applies to>: L<ListView|packages/ListView>, L<TreeView|packages/TreeView>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Expand( NODE, [FLAG] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Opens a NODE of the TreeView; the optional FLAG parameter can indicate 
+different operations:
+
+    1 expand (this is the default)
+    2 collapse
+    3 toggle (expand if it was collapsed and collapse if it was expanded)
+
+
+
+
+B<Applies to>: L<TreeView|packages/TreeView>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 FindString( STRING, [INDEX] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Searches the control for an item that begins with the specified STRING.
+The optional INDEX parameter tells to start the search from the
+specified position; if no parameter is given, the whole list is searched.
+Returns the zero-based index of the found item or -1 if no matching
+item was found.
+
+
+
+
+
+B<See also>: L<SelectString()|methods/SelectString_STRING_INDEX_>, L<FindStringExact()|methods/FindStringExact_STRING_INDEX_>
+
+B<Applies to>: L<Combobox|packages/Combobox>, L<Listbox|packages/Listbox>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 FindStringExact( STRING, [INDEX] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Searches the control for an item that exactly matches the specified
+STRING (case insensitively).
+The optional INDEX parameter tells to start the search from the
+specified position; if no parameter is given, the whole list is searched.
+Returns the zero-based index of the found item or -1 if no matching
+item was found.
+
+
+
+
+
+B<See also>: L<FindString()|methods/FindString_STRING_INDEX_>
+
+B<Applies to>: L<Combobox|packages/Combobox>, L<Listbox|packages/Listbox>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 FindWindow( CLASSNAME, TITLE )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the handle of the window whose class name and window title match the 
+specified strings; both strings can be empty. Note that the function does 
+not search child windows, only top level windows. If no matching windows 
+is found, the return value is zero. 
+
+
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 FirstVisible( [NODE] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Gets or sets the first visible NODE in the TreeView; if a NODE is given,
+it is selected and, if possible, it becomes the first visible one; the
+return value is the handle of the previously first visible.
+If no NODE is given, returns the handle of the current first visible one.
+
+
+
+
+
+B<Applies to>: L<TreeView|packages/TreeView>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 FirstVisibleItem( [INDEX] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Gets the zero-based index of the first visible item in the control,
+or sets it to the specified INDEX.
+
+
+
+
+B<Applies to>: L<Combobox|packages/Combobox>, L<Listbox|packages/Listbox>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetActiveWindow()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the handle of the active window. 
+
+
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetClassName()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the classname of the specified window, or undef on errors.
+
+
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Class|packages/Class>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetClientRect()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns a four elements array defining the windows client area rectangle 
+(left, top, right, bottom) or undef on errors. 
+
+
+
+
+B<See also>: L<GetWindowRect()|methods/GetWindowRect_>
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Class|packages/Class>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetCursor()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the handle of the current cursor. 
+
+
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetCursorPos()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns a two elements array containing the x and y position of the cursor, 
+or undef on errors. 
+
+
+
+
+B<See also>: L<SetCursorPos()|methods/SetCursorPos_X_Y_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetFocus()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the handle of the window that has the keyboard focus. 
+
+
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetFont(FONT)
+
+=for HTML </TT><BLOCKQUOTE>
+
+Gets the font of the window (returns an handle; use 
+
+
+  $Font = $W->GetFont();
+  %details = Win32::GUI::Font::Info( $Font );
+
+to get font details). 
+
+
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetFontName()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the name of the font used in the window.
+
+
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetLastVisible()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the handle of the last expanded node in the TreeView.
+
+
+
+
+B<Applies to>: L<TreeView|packages/TreeView>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetMenu()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the handle of the menu associated with the window (note: the handle,
+not the Win32::GUI::Menu object).
+
+
+
+
+
+B<Applies to>: L<DialogBox|packages/DialogBox>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetMessage( [MIN, MAX] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Retrieves a message sent to the window, optionally considering only messages 
+identifiers in the range MIN..MAX; if a message is found, the function returns 
+a 7 elements array containing: 
+
+=over 4
+
+=item * the result code of the message
+
+=item * the message identifier
+
+=item * the wParam argument
+
+=item * the lParam argument
+
+=item * the time when message occurred
+
+=item * the x coordinate at which message occurred
+
+=item * the y coordinate at which message occurred
+
+=back
+
+If the result code of the message was -1 the function returns undef. 
+Note that this function should not be normally used unless you know very 
+well what you're doing. 
+
+
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetNextVisible( NODE )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the handle of the next visible node for the given NODE.
+
+
+
+
+B<Applies to>: L<TreeView|packages/TreeView>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetOpenFileName( OPTIONS )
+
+=for HTML </TT><BLOCKQUOTE>
+
+
+Displays the standard 'Open File' dialog box; the return value is the
+name of the choosen file or undef on errors.
+
+
+
+
+B<Options>: L<-directory|options/_directory_STRING>, L<-file|options/_file_STRING>, L<-filter|options/_filter_ARRAY_REFERENCE>, L<-owner|options/_owner_WINDOW>, L<-title|options/_title_STRING>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetPerlWindow()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the handle of the DOS Prompt window your perl script
+is running in; if called in an array context, returns the
+handle and the HINSTANCE of your perl process.
+
+Example:
+
+	$DosPrompt = Win32::GUI::GetPerlWindow();
+	Win32::GUI::Hide( $DosPrompt );
+
+	# your program goes here...
+
+	Win32::GUI::Show( $DosPrompt );
+
+
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetPrevVisible(NODE)
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the handle of the previous visible node for the given NODE.
+
+
+
+
+B<Applies to>: L<TreeView|packages/TreeView>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetStockObject( OBJECT )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the handle of the specified predefined system object (pen,
+brush or font). OBJECT can have one of the following values:
+
+	 0	WHITE_BRUSH
+	 1	GRAY_BRUSH
+	 2	LTGRAY_BRUSH
+	 3	DKGRAY_BRUSH
+	 4	BLACK_BRUSH
+	 5	NULL_BRUSH (also HOLLOW_BRUSH)
+	 6	WHITE_PEN
+	 7	BLACK_PEN
+	 8	NULL_PEN
+	10	OEM_FIXED_FONT
+	11	ANSI_FIXED_FONT
+	12	ANSI_VAR_FONT
+	13	SYSTEM_FONT
+	14	DEVICE_DEFAULT_FONT
+	15	DEFAULT_PALETTE
+	16	SYSTEM_FIXED_FONT
+	17	DEFAULT_GUI_FONT
+
+The returned handle can be referenced as if it was a Win32::GUI
+object of the corresponding type (eg. a Win32::GUI::Brush or 
+Win32::GUI::Font), but note that it is not blessed, so you can't 
+directly invoke methods on it:
+
+    $Font = Win32::GUI::GetStockObject(17);    # DEFAULT_GUI_FONT
+    print $Font->GetMetrics();                 # !!!WRONG!!!
+    print Win32::GUI::Font::GetMetrics($Font); # correct
+    $Window->SetFont($Font);                   # correct
+
+
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetStringWidth( STRING )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the width, in pixels, needed to display the specified STRING
+in the ListView area.
+
+
+
+
+B<Applies to>: L<ListView|packages/ListView>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetTextExtentPoint32( STRING, [FONT] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns a two elements array containing the x and y size of the
+specified STRING in the window (eventually with the speficied FONT), or
+undef on errors.
+
+
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 GetWindowRect()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns a four elements array defining the windows (external) rectangle
+(left, top, right, bottom) or undef on errors.
+
+
+
+
+B<See also>: L<GetClientRect()|methods/GetClientRect_>
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Class|packages/Class>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Height( [HEIGHT] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Gets or sets the window height.
+
+
+
+
+
+B<See also>: L</Width>
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Hide()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Hides a window.
+
+
+
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 HitTest( X, Y )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Checks if the specified point in the control area is occupied by an item;
+it returns the identifier of the found item or zero if none was found.
+If called in an array context, it returns an additional value containing
+more info about the position of the specified point [TBD].
+
+
+
+
+B<Applies to>: L<ListView|packages/ListView>, L<TreeView|packages/TreeView>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Indent( [VALUE] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Gets or sets the indentation width, in pixels, between parents and child
+nodes; if the VALUE is less than the system-defined minimum, it is set to
+the system-defined minimum.
+
+
+
+
+
+B<Applies to>: L<TreeView|packages/TreeView>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 InsertBand( OPTIONS )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Inserts a new band in the Rebar control.
+
+    #   -index => position or -1 to add it at the end, default -1
+    #   -image => index of an image from the associated ImageList
+    #   -bitmap => Win32::GUI::Bitmap object
+    #   -child => child control
+    #   -foreground => COLOR
+    #   -background  => COLOR
+    #   -width => pixels
+    #   -minwidth => pixels
+    #   -minheight => pixels
+    #   -text => string
+
+
+
+B<Applies to>: L<Rebar|packages/Rebar>
+
+B<Options>: L<-background|options/-background>, L<-bitmap|options/-bitmap>, L<-child|options/-child>, L<-foreground|options/-foreground>, L<-image|options/-image>, L<-index|options/-index>, L<-minheight|options/-minheight>, L<-minwidth|options/-minwidth>, L<-text|options/_text_STRING>, L<-width|options/-width>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Interval( [ELAPSE] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Changes the timeout value of the Timer to ELAPSE milliseconds, or returns
+the current timeout value if no parameter is specified.
+If ELAPSE is 0, the Timer is disabled; can also be used to resume a Timer 
+after a Kill().
+
+
+
+
+
+B<See also>: L<Kill()|methods/Kill_>
+
+B<Applies to>: L<Timer|packages/Timer>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 InvalidateRect(...)
+
+=for HTML </TT><BLOCKQUOTE>
+
+Forces a refresh of a window, or a rectangle of it.
+The parameters can be (FLAG) for the whole area of the window,
+or (LEFT, TOP, RIGHT, BOTTOM, [FLAG]) to specify a rectangle.
+If the FLAG parameter is set to TRUE, the background is erased before the
+window is refreshed (this is the default).
+
+
+
+
+
+B<See also>: L<Update()|methods/Update_>
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 InvertRect( LEFT, TOP, RIGHT, BOTTOM )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Inverts the content of the rectangle from LEFT, TOP to RIGHT, BOTTOM.
+Returns nonzero if succesful, zero on errors.
+
+
+
+
+B<Applies to>: L<DC|packages/DC>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 IsEnabled()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns TRUE if the window is enabled, FALSE otherwise.
+
+
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 IsIconic()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns TRUE if the window is minimized, FALSE otherwise.
+
+
+
+
+B<Applies to>: L<DialogBox|packages/DialogBox>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 IsVisible()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns TRUE if the window is visible, FALSE otherwise.
+
+
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 IsWindow()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns TRUE if the window is a window, FALSE otherwise.
+
+
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 IsZoomed()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns TRUE if the window is maximized, FALSE otherwise.
+
+
+
+
+B<Applies to>: L<DialogBox|packages/DialogBox>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 ItemCheck( ITEM, [VALUE] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+For TreeView, gets or sets the check state of the given ITEM (a node handle).
+
+For ListView, gets the check state of the given item (zero-based index); 
+ListView does not support setting check states, so you can't pass a VALUE.
+
+In both cases is valid only if the control was created with the -checkboxes => 1 
+option.
+
+
+
+
+B<Applies to>: L<ListView|packages/ListView>, L<TreeView|packages/TreeView>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 ItemFromPoint( X, Y )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the zero-based index of the item nearest to the specified
+point; if called in a list context, returns an additional element which
+is TRUE if the point is inside the control area, FALSE if it's outside.
+
+
+
+
+B<Applies to>: L<Listbox|packages/Listbox>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 ItemPosition( INDEX, [X, Y] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Moves the specified zero-based INDEX item to the specified position,
+or returns its current X and Y position if X and Y are not given.
+
+
+
+
+
+B<See also>: L<MoveItem()|methods/MoveItem_INDEX_X_Y_>
+
+B<Applies to>: L<ListView|packages/ListView>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Kill()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Disables the Timer.
+
+
+
+
+
+B<See also>: L<Interval()|methods/Interval_ELAPSE_>
+
+B<Applies to>: L<Timer|packages/Timer>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Left ( [LEFT] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Gets or sets the window X coordinate.
+If the window is a top level window (a L<Window|packages/Window> or a
+L<DialogBox|packages/DialogBox>) the value is relative to the screen (absolute),
+otherwise it is relative to the container of the control.
+To get the absolute (screen position) of a child control, use AbsLeft()
+instead.
+
+
+
+
+
+B<See also>: L<AbsLeft()|methods/AbsLeft_>, L<Top()|methods/Top_TOP_>
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 LineFromChar( INDEX )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the line number (starting from zero) where the zero-based INDEX char 
+appears.
+
+
+
+
+B<Applies to>: L<RichEdit|packages/RichEdit>, L<Textfield|packages/Textfield>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 ListIndex()
+
+=for HTML </TT><BLOCKQUOTE>
+
+See L<SelectedItem()|methods/SelectedItem_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Load( FILENAME, [FORMAT] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Loads a file named FILENAME into the RichEdit control.
+By default the file is a RTF (Rich Text Format) file; if you want to load
+a plain text file, you can set FORMAT to 1.
+
+
+
+
+B<Applies to>: L<RichEdit|packages/RichEdit>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 MaxLength( [CHARS] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Limits the number of characters that the Textfield accept to CHARS,
+or returns the current limit if no argument is given.
+To remove the limit (eg. set it to the maximum allowed which is 32k
+for a single-line Textfield and 64k for a multiline one) set CHARS
+to 0.
+
+
+
+
+B<Applies to>: L<RichEdit|packages/RichEdit>, L<Textfield|packages/Textfield>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Minimize()
+
+=for HTML </TT><BLOCKQUOTE>
+
+See L<CloseWindow()|methods/CloseWindow_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Modified( [FLAG] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Gets or sets the modified flag on the control.
+
+
+
+
+B<Applies to>: L<RichEdit|packages/RichEdit>, L<Textfield|packages/Textfield>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Move( X, Y )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Moves the window to the specified position.
+
+
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 MoveItem( INDEX, X, Y )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Moves the specified zero-based INDEX item to the specified position,
+if the ListView is in big or small icon view mode; X and Y coordinates
+are relative to the ListView client area.
+
+
+
+
+
+B<See also>: L<ItemPosition()|methods/ItemPosition_INDEX_X_Y_>, L<View()|methods/View_MODE_>
+
+B<Applies to>: L<ListView|packages/ListView>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Open( FILE )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Opens the specified AVI file in the Animation control;
+note that the AVI file must not contain sound data.
+
+
+
+
+
+B<See also>: L<Close()|methods/Close_>
+
+B<Applies to>: L<Animation|packages/Animation>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 OpenIcon()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Restores a minimized window.
+
+
+
+
+B<Applies to>: L<DialogBox|packages/DialogBox>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 PasswordChar( [CHAR] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Gets or sets the character displayed in place of normal text; if the
+control has been created with the -password option, the default
+character is an asterisk (*).
+Note that by setting this value the text in the control will be
+redrawn using the specified character; if the character is set to
+zero instead, text will be redrawn as normal
+
+
+
+
+B<Applies to>: L<RichEdit|packages/RichEdit>, L<Textfield|packages/Textfield>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Play( [FROM], [TO], [REPEAT] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Plays the animation (eventually from the FROM frame to the TO frame)
+looping it REPEAT times.
+Defaults are FROM 0 (the first frame) to -1 (the last frame)
+and REPEAT -1 (loop forever).
+
+
+
+
+B<Applies to>: L<Animation|packages/Animation>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 ReadOnly( [FLAG] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Gets or sets the readonly flag on the control.
+
+
+
+
+B<Applies to>: L<RichEdit|packages/RichEdit>, L<Textfield|packages/Textfield>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Rectangle( LEFT, TOP, RIGHT, BOTTOM )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Draws a rectangle from LEFT, TOP to RIGHT, BOTTOM; the rectangle is
+outlined with the current pen and filled with the current brush.
+Returns nonzero if succesful, zero on errors.
+
+
+
+
+B<Applies to>: L<DC|packages/DC>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 ReplaceSel( STRING, [FLAG] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Replaces the current selection in the control with STRING.
+
+
+
+
+B<Applies to>: L<RichEdit|packages/RichEdit>, L<Textfield|packages/Textfield>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Reset()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Deletes the content of the control.
+
+
+
+
+B<Applies to>: L<Combobox|packages/Combobox>, L<Listbox|packages/Listbox>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Resize( X, Y )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Resizes the window to the specified dimension.
+
+
+
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Restore()
+
+=for HTML </TT><BLOCKQUOTE>
+
+See L<OpenIcon()|methods/OpenIcon_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 RowCount()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the number of rows in the Rebar control.
+
+
+
+
+B<Applies to>: L<Rebar|packages/Rebar>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Save( FILENAME, [FORMAT] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Saves the content of the RichEdit control in a file named FILENAME.
+By default the file is a RTF (Rich Text Format) file; if you want to save
+in a plain text file, you can set FORMAT to 1.
+
+
+
+
+B<Applies to>: L<RichEdit|packages/RichEdit>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 ScaleHeight()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the windows client area height.
+
+
+
+
+B<See also>: L<ScaleWidth()|methods/ScaleWidth_>
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 ScaleWidth()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the windows client area width.
+
+
+
+
+B<See also>: L<ScaleHeight()|methods/ScaleHeight_>
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Scroll( COMMAND | LINE | HORIZONTAL, VERTICAL )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Scrolls the text in the control; you have the following options:
+
+=over 4
+
+=item COMMAND
+
+the following commands are recognized (their meaning is self-explanatory):
+
+	up
+	down
+	pageup		
+	pagedown	
+	top
+	bottom
+
+=item LINE
+
+scrolls up or down the specified number of lines; use negative to scroll up and
+positive to scroll down.
+
+=item HORIZONTAL, VERTICAL
+
+scrolls VERTICAL lines vertically and HORIZONTAL characters horizontally; note 
+that the RichEdit control does not support horizontal scroll.
+
+=back
+
+
+
+
+B<Applies to>: L<RichEdit|packages/RichEdit>, L<Textfield|packages/Textfield>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Seek( FRAME )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Positions the AVI file to the specified FRAME.
+
+
+
+
+B<Applies to>: L<Animation|packages/Animation>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 SelectAll()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Selects all the text.
+
+
+
+
+
+B<Applies to>: L<RichEdit|packages/RichEdit>, L<Textfield|packages/Textfield>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 SelectCount()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the number of currently selected items.
+
+For Listbox, the control must have been created with the -multisel option.
+
+
+
+
+B<Applies to>: L<Listbox|packages/Listbox>, L<ListView|packages/ListView>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 SelectString( STRING, [INDEX] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Searches the control for an item that begins with the specified STRING
+and, if found, selects that item.
+The optional INDEX parameter tells to start the search from the
+specified position; if no parameter is given, the whole list is searched.
+Returns the zero-based index of the selected item or -1 if no matching
+item was found.
+
+
+
+
+
+B<See also>: L<FindString()|methods/FindString_STRING_INDEX_>
+
+B<Applies to>: L<Listbox|packages/Listbox>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 SelectedItem()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the zero-based index of the currently selected item, or -1 if
+no item is selected.
+
+
+
+
+B<Applies to>: L<Combobox|packages/Combobox>, L<Listbox|packages/Listbox>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Selection()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns a two elements array containing the current selection start
+and end.
+
+
+
+
+B<Applies to>: L<RichEdit|packages/RichEdit>, L<Textfield|packages/Textfield>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 SetCursor( CURSOR )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Draws the specified CURSOR (a Win32::GUI::Cursor object). Returns the
+handle of the previously displayed cursor. Note that the cursor will
+change back to the default one as soon as the mouse moves or a
+system command is performed. To change the cursor stablily, use ChangeCursor()
+instead.
+
+
+
+
+B<See also>: L<ChangeCursor()|methods/ChangeCursor_CURSOR_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 SetCursorPos( X, Y )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Moves the cursor to the specified coordinates.
+
+
+
+
+B<See also>: L<GetCursorPos()|methods/GetCursorPos_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 SetRange( [MIN], MAX )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Sets the range of values (from MIN to MAX) for the control; if MIN
+is not specified, it defaults to 0.
+
+
+
+
+B<Applies to>: L<ProgressBar|packages/ProgressBar>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Show( [COMMAND] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Shows a window (or change its showing state to COMMAND); available
+COMMANDs are:
+
+   SW_HIDE
+   SW_MAXIMIZE
+   SW_MINIMIZE
+   SW_RESTORE
+   SW_SHOW
+   SW_SHOWDEFAULT
+   SW_SHOWMAXIMIZED
+   SW_SHOWMINIMIZED
+   SW_SHOWMINNOACTIVE
+   SW_SHOWNA
+   SW_SHOWNOACTIVATE
+   SW_SHOWNORMAL
+
+The default COMMAND, if none specified, is SW_SHOWNORMAL.
+
+
+
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Stop()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Stops the animation currently playing.
+
+
+
+
+
+
+B<See also>: L<Play()|methods/Play_FROM_TO_REPEAT_>
+
+B<Applies to>: L<Animation|packages/Animation>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Text( [TEXT] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Gets or sets the text of a window. 
+
+
+
+B<Applies to>: L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<RadioButton|packages/RadioButton>, L<RichEdit|packages/RichEdit>, L<StatusBar|packages/StatusBar>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 TextOut( X, Y, TEXT )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Draws the specified TEXT string at X, Y, using the currently selected font.
+Returns nonzero if succesful, zero on errors.
+
+
+
+
+B<Applies to>: L<DC|packages/DC>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Top( [TOP] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Gets or sets the window Y coordinate.
+If the window is a top level window (a L<Window|packages/Window> or a
+L<DialogBox|packages/DialogBox>) the value is relative to the screen (absolute),
+otherwise it is relative to the container of the control.
+To get the absolute (screen position) of a child control, use AbsTop()
+instead.
+
+
+
+
+
+B<See also>: L<AbsTop()|methods/AbsTop_>, L</Left()>
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Undo()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Undoes the last change in the control.
+
+
+
+
+B<Applies to>: L<RichEdit|packages/RichEdit>, L<Textfield|packages/Textfield>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Update()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Refreshes the content of a window.
+
+
+
+
+
+B<See also>: L<InvalidateRect()|methods/InvalidateRect_>
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 View( [MODE] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Gets or sets the viewing mode of the ListView control; the returned or given 
+MODE can have one of the following values:
+
+    0  big icons
+    1  details
+    2  small icons
+    3  list
+
+
+
+
+B<Applies to>: L<ListView|packages/ListView>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 VisibleCount()
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the number of items that can be fully visible in a page of the
+control; for ListView, if the current view state is big or small icons, the
+function always returns the total number of items in the control.
+
+
+
+
+B<Applies to>: L<ListView|packages/ListView>, L<TreeView|packages/TreeView>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Width( [WIDTH] )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Gets or sets the window width.
+
+
+
+
+
+B<See also>: L</Height>
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 WindowFromPoint( X, Y )
+
+=for HTML </TT><BLOCKQUOTE>
+
+Returns the handle of the window at the specified screen position.
+
+
+
+=for HTML </BLOCKQUOTE>
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/newbuild.pl perl-libwin32-0.191/GUI/docs/newbuild.pl
--- libwin32-0.191/GUI/docs/newbuild.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/newbuild.pl	2004-01-12 16:46:41.421875000 -0800
@@ -0,0 +1,458 @@
+
+use Pod::Html;
+
+my %pod;
+my %apply;
+my %aka;
+my %see;
+my %opt;
+my %def;
+my %met;
+my %evt;
+my %type;
+my %opt_name;
+my %met_name;
+
+@files = qw( packages events methods options );
+
+foreach $file (@files) { preprocess($file); }
+
+foreach $item (sort keys %{$pod{'options'}}) {
+    $name = $item;
+    $name =~ s/\s*=>.*$//;
+    $name =~ s/^\s+//;
+    $name =~ s/\s+$//;
+    $opt_name{$name} = $item;
+}
+
+foreach $item (sort keys %{$pod{'methods'}}) {
+    $name = $item;
+    $name =~ s/\(.*$//;
+    $met_name{$name."()"} = $item;
+}
+
+foreach $item (sort keys %{$pod{'events'}}) {
+    $name = $item;
+    $name =~ s/\(.*$//;
+    $evt_name{$name."()"} = $item;
+}
+
+foreach $item (sort keys %{$apply{'options'}}) {
+    $newapp = "";
+    $comma = 0;
+    foreach $option (split /\s*,\s*/, $apply{'options'}{$item}) {
+        if($option =~ /\[(.)\]/) {
+            $type = $1;
+            foreach $package (sort keys %{$type{'packages'}}) {
+                if( $type{'packages'}{$package} =~ /$type/) {
+                    $newapp .= ", " if $comma;
+                    $newapp .= $package;
+                    $comma = 1;
+                }
+            }
+        } else {
+            $newapp .= ", " if $comma;
+            $newapp .= $option;
+            $comma = 1;
+        }
+    }
+    $apply{'options'}{$item} = $newapp;
+}
+
+foreach $item (sort keys %{$apply{'methods'}}) {
+    $newapp = "";
+    $comma = 0;
+    foreach $option (split /\s*,\s*/, $apply{'methods'}{$item}) {
+        if($option =~ /\[(.)\]/) {
+            $type = $1;
+            foreach $package (sort keys %{$type{'packages'}}) {
+                if( $type{'packages'}{$package} =~ /$type/) {
+                    $newapp .= ", " if $comma;
+                    $newapp .= $package;
+                    $comma = 1;
+                }
+            }
+        } else {
+            $newapp .= ", " if $comma;
+            $newapp .= $option;
+            $comma = 1;
+        }
+    }
+    $apply{'methods'}{$item} = $newapp;
+}
+
+
+# cross-refencing methods-options...
+foreach $item (sort keys %{$pod{'methods'}}) {
+    if(exists $opt{'methods'}{$item}) {
+        $method = $item;
+        $method =~ s/\([^)]+\)/()/;
+        foreach $other (split /\s*,\s*/, $opt{'methods'}{$item}) {
+            $other =~ s/^\s+//;
+            $other =~ s/\s+$//;         
+            if(exists $opt_name{$other}) {
+                $option = $opt_name{$other};
+                if(not grep(/$method/, $apply{'options'}{$option})) {
+#                   print "cross_ref: ADDING $method to APPLY_LIST of $option\n";
+                    $apply{'options'}{$option} .= ", " if $apply{'options'}{$option};
+                    $apply{'options'}{$option} .= $method;
+                }
+            }
+        }
+    }
+}
+
+
+# cross-refencing packages-options...
+foreach $item (sort keys %{$pod{'options'}}) {
+    if(exists $apply{'options'}{$item}) {
+        foreach $other (split /\s*,\s*/, $apply{'options'}{$item}) {            
+            # print "cross_ref: OPTION: '$item' APPLY_TO: '$other'\n";
+            $item_name = $item;
+            $item_name =~ s/\s*=>.*$//;
+            $item_name =~ s/^\s+//;
+            $item_name =~ s/\s+$//;
+            if(not grep(/$item_name/, $opt{'packages'}{$other})) {
+#               print "cross_ref: ADDING $item to APPLY_LIST of $other\n";
+                $opt{'packages'}{$other} .= ", " if $opt{'packages'}{$other};
+                $opt{'packages'}{$other} .= $item_name;
+            }
+        }
+    }
+}
+
+# cross-refencing packages-methods...
+foreach $item (sort keys %{$pod{'methods'}}) {
+    $method = $item;
+    $method =~ s/\([^)]+\)/()/;
+    foreach $package (split(", ", $apply{'methods'}{$item})) {
+        if(not grep(/$method/, $met{'packages'}{$package})) {
+#           print "cross_ref: ADDING $method to METHODS of $package\n";
+            $met{'packages'}{$package} .= ", " if $met{'packages'}{$package};
+            $met{'packages'}{$package} .= $method;
+        }
+    }   
+}
+
+
+foreach $file (@files) { spit_out($file); }
+
+sub preprocess {
+    my($file) = @_;
+    
+    $pod{$file} = {};
+    $apply{$file} = {};
+    $aka{$file} = {};
+    $see{$file} = {};
+    $opt{$file} = {};
+    $def{$file} = {};
+    $met{$file} = {};
+    $evt{$file} = {};
+
+    my $looking_for = 'NOTHING';
+
+    open(IN, "<$file.txt");
+    while(<IN>) {
+        chomp;
+    #   print  "$. $looking_for\n";
+
+        if(/^=+$/) {  # separator
+            $looking_for = 'NAME';
+            $this = '';
+
+        } elsif(/^=APPLY\s*(.*)$/) {
+            if($1) {
+                $apply{$file}{$this} = $1;
+            } else {
+                $looking_for = 'APPLY';
+            }
+        
+        } elsif(/^=END_APPLY/) {
+            if($looking_for eq 'APPLY') {
+                $looking_for = 'NOTHING';
+            } else {
+                warn "unexpected =END_APPLY at line $. in file $file.txt\n";
+            }
+
+        } elsif(/^=SEE_ALSO\s*(.*)$/) {
+            if($1) {
+                $see{$file}{$this} = $1;
+            } else {
+                $looking_for = 'SEE_ALSO';
+            }
+
+        } elsif(/^=AKA\s*(.*)$/) {
+            if($1) {
+                $aka{$file}{$this} = $1;                
+            } else {
+                $looking_for = 'AKA';
+            }
+            $pod{$file}{$this} = '';
+        
+        } elsif(/^=OPTIONS\s*(.*)$/) {
+            if($1) {
+                $opt{$file}{$this} = $1;
+            } else {
+                $looking_for = 'OPTIONS';
+            }
+        
+        } elsif(/^=END_OPTIONS/) {
+            if($looking_for eq 'OPTIONS') {
+                $looking_for = 'NOTHING';
+            } else {
+                warn "unexpected =END_OPTIONS at line $. in file $file.txt\n";
+            }
+
+        } elsif(/^=METHODS\s*(.*)$/) {
+            if($1) {
+                $met{$file}{$this} = $1;
+            } else {
+                $looking_for = 'METHODS';
+            }
+        
+        } elsif(/^=END_METHODS/) {
+            if($looking_for eq 'METHODS') {
+                $looking_for = 'NOTHING';
+            } else {
+                warn "unexpected =END_METHODS at line $. in file $file.txt\n";
+            }
+
+        } elsif(/^=EVENTS\s*(.*)$/) {
+            if($1) {
+                $evt{$file}{$this} = $1;
+            } else {
+                $looking_for = 'EVENTS';
+            }
+        
+        } elsif(/^=END_EVENTS/) {
+            if($looking_for eq 'EVENTS') {
+                $looking_for = 'NOTHING';
+            } else {
+                warn "unexpected =END_EVENTS at line $. in file $file.txt\n";
+            }
+
+        } elsif(/^=TYPE\s*(.*)$/) {
+            if($1) {
+                $type{$file}{$this} = $1;
+            } else {
+                warn "undefined =TYPE at line $. in file $file.txt\n";
+            }
+
+        #} elsif(/^=(APPLY, SEE_ALSO, ...)
+
+        } else {
+
+            if($looking_for eq 'NAME') {
+                if(/^\s*$/) {
+                    $looking_for = 'CONTENT';
+                } else {
+                    if($this) {
+                        $alias{$file}{$this} = [] unless exists $alias{$this};
+                        push(@{$alias{$file}{$this}}, $_);
+                    } else {
+                        if(s/\(default ([^)]+)\)//) {
+                            $tdef = $1;
+                        } else {
+                            $tdef = "";
+                        }
+                        s/^\s+//;
+                        s/\s+$//;
+                        $this = $_;
+                        $def{$file}{$this} = $tdef if $tdef ne undef;
+
+                    }
+                }
+            } elsif($looking_for eq 'CONTENT') {
+                chomp;
+                $pod{$file}{$this} .= $_."\n";
+            } elsif($looking_for eq 'APPLY') {
+                chomp;
+                $apply{$file}{$this} .= " " if $apply{$file}{$this};
+                s/^\s+//;
+                s/\s+$//;
+                $apply{$file}{$this} .= $_;
+            } elsif($looking_for eq 'AKA') {
+                chomp;
+                $aka{$file}{$this} .= " " if $aka{$file}{$this};
+                s/^\s+//;
+                s/\s+$//;
+                $aka{$file}{$this} .= $_;
+            } elsif($looking_for eq 'SEE_ALSO') {
+                chomp;
+                $see{$file}{$this} .= " " if $see{$file}{$this};
+                s/^\s+//;
+                s/\s+$//;
+                $see{$file}{$this} .= $_;
+            } elsif($looking_for eq 'OPTIONS') {
+                chomp;
+                $opt{$file}{$this} .= " " if $opt{$file}{$this};
+                s/^\s+//;
+                s/\s+$//;
+                $opt{$file}{$this} .= $_;
+            } elsif($looking_for eq 'METHODS') {
+                chomp;
+                $met{$file}{$this} .= " " if $met{$file}{$this};
+                s/^\s+//;
+                s/\s+$//;
+                $met{$file}{$this} .= $_;
+            } elsif($looking_for eq 'EVENTS') {
+                chomp;
+                $evt{$file}{$this} .= " " if $evt{$file}{$this};
+                s/^\s+//;
+                s/\s+$//;
+                $evt{$file}{$this} .= $_;
+            } else {
+                # print "skipping...\n";
+            }
+        }
+    }
+    close(IN);
+}
+
+sub spit_out {
+    my($file) = @_;
+
+    open(POD, ">$file.pod");
+
+    print POD "=head1 Win32::GUI $file\n\n";
+#   print POD "=over 4\n\n";
+
+    foreach $item (sort keys %{$pod{$file}}) {
+        if($] < 5.006) {
+            print POD "=for HTML <TT>\n\n";
+        } else {
+            print POD "=for HTML <HR><TT>\n\n";
+        }
+        
+        print POD "=head2 $item";
+        if(exists $alias{$file}{$item}) {
+            foreach $alias (@{$alias{$file}{$item}}) {
+                print POD "\n\n=head2 $alias";
+
+            }
+        }
+        print POD "\n\n";
+        print POD "=for HTML </TT><BLOCKQUOTE>\n\n";
+        if(exists $aka{$file}{$item}) {
+            $real_link = Pod::Html::htmlify(0, $aka{$file}{$item});
+            $link = "L<$other|methods/$real_link>";
+            print POD "See L<$aka{$file}{$item}|methods/$real_link>\n\n";
+        } else {
+            if(exists $def{$file}{$item}) {
+                print POD "B<Default value>: C<$def{$file}{$item}>\n\n";
+            }
+            $pod{$file}{$item} =~ s/(METHOD|EVENT|OPTION)_LINK<([^>]+)>/smart_link($1, $2)/ge;
+            print POD "$pod{$file}{$item}\n\n";
+            
+            if(exists $see{$file}{$item}) {
+                print POD "B<See also>: ";
+                $comma = 0;
+                foreach $other (split /\s*,\s*/, $see{$file}{$item}) {
+                    $other =~ s/\s+$//;
+                    $other =~ s/\(+$//;
+                    if(exists $opt_name{$other}) {
+                        $real_link = Pod::Html::htmlify(0, $opt_name{$other});
+                        $link = "L<$other|options/$real_link>";
+                    } elsif(exists $met_name{$other}) {
+                        $real_link = Pod::Html::htmlify(0, $met_name{$other});
+                        $link = "L<$other|methods/$real_link>";
+                    } else {
+                        $link = "L</$other>";
+                    }
+                    print POD ", " if $comma;
+                    print POD $link;
+                    $comma = 1;
+                }
+                print POD "\n\n";
+            }
+            
+            print_pod_list( \*POD, \%apply, \%met_name, $file, $item, ["methods", "packages"], "Applies to");       
+            print_pod_list( \*POD, \%opt, \%opt_name, $file, $item, "options");
+            print_pod_list( \*POD, \%met, \%met_name, $file, $item, "methods");
+            print_pod_list( \*POD, \%evt, \%evt_name, $file, $item, "events");
+        }
+        print POD "=for HTML </BLOCKQUOTE>\n\n";
+    }
+
+#   print POD "=back\n\n\n";
+
+    close(POD);
+
+    pod2html( "--infile=$file.pod", "--outfile=$file.html", "--htmlroot=.", "--podpath=.");
+
+    open(OLD, "<$file.html");
+    open(NEW, ">$file.html.new");
+    while(<OLD>) {
+        s{</HEAD>}{<LINK REL="stylesheet" TYPE="text/css" HREF="style.css"></HEAD>};
+        print NEW $_;
+    }
+    close(OLD);
+    close(NEW);
+    unlink("$file.html");
+    rename("$file.html.new", "$file.html");
+}
+
+
+sub print_pod_list {
+
+    my $OUTPUT = shift;
+    my $hash = shift;
+    my $namehash = shift;
+    my $file = shift;
+    my $item = shift;
+    my $otherfile = shift;
+    my $list_title = shift;
+    my $comma = 0;
+
+    $list_title = ucfirst($otherfile) unless defined $list_title;
+
+    my @otherfiles;
+    if(ref($otherfile)) 
+        { @otherfiles = @$otherfile;  }
+    else
+        { @otherfiles = ($otherfile, $otherfile); }     
+
+    #print "print_pod_list: OUTPUT=$OUTPUT\n";
+    #print "print_pod_list: hash=", $hash, "\n";
+
+    if(exists $$hash{$file}{$item}) {
+        print $OUTPUT "B<$list_title>: ";
+        foreach $other (sort smarty split /\s*,\s*/, $$hash{$file}{$item}) {
+            $other =~ s/\s+$//;
+            if(exists $$namehash{$other}) {
+                $real_link = Pod::Html::htmlify(0, $$namehash{$other});
+                $other =~ s/\(.*$// if $file ne "options";
+                $link = "L<$other|$otherfiles[0]/$real_link>";
+            } else {
+                $link = "L<$other|$otherfiles[1]/$other>";
+            }
+            print $OUTPUT ", " if $comma;
+            print $OUTPUT "$link";
+            $comma = 1;
+        }
+        print $OUTPUT "\n\n";
+    }
+}
+
+sub smarty {
+    if($a =~ /\(/ and $b !~ /\(/) { return 1; }
+    if($a !~ /\(/ and $b =~ /\(/) { return -1; }
+    return lc($a) cmp lc($b);
+}
+    
+    
+sub smart_link {
+    my($page, $item) = @_;
+    my $real_link;
+    my %pagemap = (
+        METHOD => [qw( methods \%met_name )],
+        EVENT  => [qw( events  \%evt_name )],
+        OPTION => [qw( options \%opt_name )],
+    );
+    if(exists ${$pagemap{$page}[1]}{$item}) {
+        $real_link = Pod::Html::htmlify(0, ${$pagemap{$page}[1]}{$item});
+    } else {
+        $real_link = $item;
+    }
+    return "L<$item|$pagemap{$page}[0]/$real_link>";
+}
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/options.pod perl-libwin32-0.191/GUI/docs/options.pod
--- libwin32-0.191/GUI/docs/options.pod	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/options.pod	2004-01-12 16:46:41.437500000 -0800
@@ -0,0 +1,842 @@
+=head1 Win32::GUI options
+
+=for HTML <TT>
+
+=head2 -align => left/center/right
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<center for Button, otherwise left>
+
+Aligns the text in the control accordingly. 
+
+
+
+
+B<Applies to>: L<Button|packages/Button>, L<Label|packages/Label>, L<RichEdit|packages/RichEdit>, L<Textfield|packages/Textfield>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -autoplay => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+Starts playing the animation as soon as an AVI clip is loaded.
+
+
+
+
+B<Applies to>: L<Animation|packages/Animation>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -bandborders => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+Display a border to separate bands. 
+
+
+
+
+B<Applies to>: L<Rebar|packages/Rebar>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -buttons => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<1 for TreeView, otherwise 0>
+
+For TreeViews, enables or disables the +/- buttons to expand/collapse tree
+items.
+
+For Headers, if enabled header items look like push buttons and can be clicked.
+
+For TabStrips, if enabled items look like push buttons.
+
+
+
+
+B<Applies to>: L<Header|packages/Header>, L<TabStrip|packages/TabStrip>, L<TreeView|packages/TreeView>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -cancel => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+If 1, the button will correspond to the CANCEL action of a dialog, and its Click
+event will be fired by pressing the ESC key.
+
+
+
+
+B<See also>: L</-dialogui>, L<-cancel|options/_cancel_0_1>
+
+B<Applies to>: L<Button|packages/Button>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -center => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+Centers the animation in the control area.
+
+
+
+
+B<Applies to>: L<Animation|packages/Animation>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -computeronly => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+Only enable computers to be selected.
+
+
+
+
+B<Applies to>: L<BrowseForFolder()|methods/BrowseForFolder_OPTIONS_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -default => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+Identify the item as the default one; a default Button has a black border drawn
+around it; a default MenuItem is printed with a bold font.
+
+
+
+
+B<Applies to>: L<Button|packages/Button>, L<MenuItem|packages/MenuItem>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -directory => STRING
+
+=for HTML </TT><BLOCKQUOTE>
+
+Specifies the initial directory.
+
+
+
+
+B<Applies to>: L<GetOpenFileName()|methods/GetOpenFileName_OPTIONS_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -domainonly => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+Only show computers in the current domain or workgroup.
+
+
+
+
+B<Applies to>: L<BrowseForFolder()|methods/BrowseForFolder_OPTIONS_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -driveonly => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+Only enable drives to be selected.
+
+
+
+
+B<Applies to>: L<BrowseForFolder()|methods/BrowseForFolder_OPTIONS_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -editbox => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+If 1, the dialog will include an edit field in which
+the user can type the name of an item.
+
+
+
+
+B<Applies to>: L<BrowseForFolder()|methods/BrowseForFolder_OPTIONS_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -file => STRING
+
+=for HTML </TT><BLOCKQUOTE>
+
+Specifies a name that will appear on the dialog's edit field.
+
+
+
+
+B<Applies to>: L<GetOpenFileName()|methods/GetOpenFileName_OPTIONS_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -fill => black/gray/white/none
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<none>
+
+Fills the control rectangle ("black", "gray" and "white" are the window frame 
+color, the desktop color and the window background color respectively). 
+
+
+
+
+B<Applies to>: L<Label|packages/Label>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -filter => ARRAY REFERENCE
+
+=for HTML </TT><BLOCKQUOTE>
+
+[TBD]
+
+
+
+B<Applies to>: L<GetOpenFileName()|methods/GetOpenFileName_OPTIONS_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -fixedorder => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+Band position cannot be swapped.
+
+
+
+
+B<Applies to>: L<Rebar|packages/Rebar>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -folderonly => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+Only enable folders to be selected (eg. no computers or printers).
+
+
+
+
+B<Applies to>: L<BrowseForFolder()|methods/BrowseForFolder_OPTIONS_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -includefiles => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+The list will include files as well folders.
+
+
+
+
+B<Applies to>: L<BrowseForFolder()|methods/BrowseForFolder_OPTIONS_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -maxsize => [X, Y]
+
+=for HTML </TT><BLOCKQUOTE>
+
+Specifies the maximum size (width and height) in pixels; X and Y must be passed 
+in an array reference.
+
+Example:
+
+    $Window = new Win32::GUI::Window(
+        # ...
+        -maxsize => [ 200, 200 ],
+    );
+
+
+
+
+B<See also>: L</-maxwidth>, L</-maxheight>, L<-minsize|options/_minsize_X_Y_>
+
+B<Applies to>: L<DialogBox|packages/DialogBox>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -minsize => [X, Y]
+
+=for HTML </TT><BLOCKQUOTE>
+
+Specifies the minimum size (width and height) in pixels; X and Y must be passed 
+in an array reference.
+
+Example:
+
+    $Window = new Win32::GUI::Window(
+        # ...
+        -minsize => [ 100, 100 ],
+    );
+
+
+
+
+B<See also>: L</-minwidth>, L</-minheight>, L<-maxsize|options/_maxsize_X_Y_>
+
+B<Applies to>: L<DialogBox|packages/DialogBox>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -multiline => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+The control can have more than one line (note that in Textfield and RichEdit
+controls, newline is "\r\n", not "\n"!). 
+
+
+
+
+B<Applies to>: L<RichEdit|packages/RichEdit>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<ToolBar|packages/ToolBar>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -multisel => 0/1/2
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+Specifies the selection type: 
+
+    0 single selection
+    1 multiple selection
+    2 multiple selection ehnanced (with Shift, Control, etc.)
+
+
+
+
+B<Applies to>: L<Listbox|packages/Listbox>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -name => STRING
+
+=for HTML </TT><BLOCKQUOTE>
+
+Defines the name for the control. The name is used to callback its events and 
+to access its methods, so it is absolutely B<necessary>, and each name must be 
+unique in your application. 
+
+Example: 
+
+    $Window->AddButton(
+        -name => "Button1",
+        # ...
+    );
+
+    # methods...
+    $Window->Button1->Hide();
+
+
+    # events...
+    sub Button1_Click {
+        # ...
+    }
+
+
+
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Class|packages/Class>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<NotifyIcon|packages/NotifyIcon>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -notify => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+Enables the Click(), DblClick(), etc. events. 
+
+
+
+
+B<Applies to>: L<Label|packages/Label>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -ok => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+If 1, the button will correspond to the OK action of a dialog, and its Click
+event will be fired by pressing the ENTER key.
+
+
+
+
+B<See also>: L</-dialogui>, L<-cancel|options/_cancel_0_1>
+
+B<Applies to>: L<Button|packages/Button>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -owner => WINDOW
+
+=for HTML </TT><BLOCKQUOTE>
+
+[TBD]
+
+
+
+
+B<Applies to>: L<BrowseForFolder()|methods/BrowseForFolder_OPTIONS_>, L<GetOpenFileName()|methods/GetOpenFileName_OPTIONS_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -password => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+Masks the user input (like password prompts). 
+
+
+
+
+B<See also>: L<-passwordchar|options/_passwordchar_CHAR>
+
+B<Applies to>: L<RichEdit|packages/RichEdit>, L<Textfield|packages/Textfield>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -passwordchar => CHAR
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<'*'>
+
+The specified CHAR that is shown instead of the text with C<-password => 1>.
+
+
+
+
+B<See also>: L<-password|options/_password_0_1>
+
+B<Applies to>: L<RichEdit|packages/RichEdit>, L<Textfield|packages/Textfield>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -pos => [ X, Y ]
+
+=for HTML </TT><BLOCKQUOTE>
+
+Defines the position for the window; note that X and Y must be passed in an
+array reference, eg:
+
+    -pos => [ 100, 100 ],    # correct
+    -pos =>   100, 100,      # WRONG
+    -pos => @coords,         # WRONG
+    -pos => \@coors,         # correct
+
+
+
+
+B<See also>: L</-left>, L</-top>
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -printeronly => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+Only enable printers to be selected
+
+
+
+
+B<Applies to>: L<BrowseForFolder()|methods/BrowseForFolder_OPTIONS_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -prompt => STRING or [ STRING, WIDTH ]
+
+=for HTML </TT><BLOCKQUOTE>
+
+The -prompt option is very special; if a string is passed, a Win32::GUI::Label 
+object (with text set to the STRING passed) is created to the left of the 
+Textfield. 
+
+Example: 
+
+    $Window->AddTextfield(
+        -name   => "Username",
+        -left   => 75,
+        -top    => 150,
+        -prompt => "Your name:",
+    );
+
+Furthermore, the value to C<-prompt> can be a reference to a list containing the 
+string and an additional parameter, which sets the width for the Label. 
+If WIDTH is negative, it is calculated relative to the Textfield left coordinate. 
+
+Example: 
+
+                                        (Label left)    (Textfield left)
+    -left   => 75,
+    -prompt => [ "Your name:", 30 ],    75              105 (75+30)
+ 
+    -left   => 75,
+    -prompt => [ "Your name:", -30 ],   45 (75-30)      75    
+
+Note that the Win32::GUI::Label object is named like the Textfield, with a 
+"_Prompt" suffix (in the example above, the Label is named "Username_Prompt"). 
+
+
+
+
+B<Applies to>: L<RichEdit|packages/RichEdit>, L<Textfield|packages/Textfield>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -readonly => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+Text can't be changed.
+
+
+
+
+B<Applies to>: L<RichEdit|packages/RichEdit>, L<Textfield|packages/Textfield>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -root => PATH or CONSTANT
+
+=for HTML </TT><BLOCKQUOTE>
+
+The root directory for browsing; this can be either a path or one of the 
+CSIDL_* constants for special folders (see the Win32::FileOp module by Jenda for 
+a list of such constants).
+
+
+
+
+B<Applies to>: L<BrowseForFolder()|methods/BrowseForFolder_OPTIONS_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -size => [ X, Y ]
+
+=for HTML </TT><BLOCKQUOTE>
+
+Defines the size for the window; note that X and Y must be passed in an
+array reference, eg:
+
+    -size => [ 100, 100 ],    # correct
+    -size =>   100, 100,      # WRONG
+    -size => @coords,         # WRONG
+    -size => \@coors,         # correct
+
+
+
+
+B<See also>: L</-width>, L</-height>
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -smooth => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+Uses a smooth bar instead of the default segmented bar. 
+
+
+
+
+B<Applies to>: L<ProgressBar|packages/ProgressBar>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -sunken => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+Draws a half-sunken border around the control. 
+
+
+
+
+B<Applies to>: L<Label|packages/Label>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -text => STRING
+
+=for HTML </TT><BLOCKQUOTE>
+
+The text that will appear in the control or item.
+
+
+
+
+B<Applies to>: L<Animation|packages/Animation>, L<Button|packages/Button>, L<Checkbox|packages/Checkbox>, L<Combobox|packages/Combobox>, L<ComboboxEx|packages/ComboboxEx>, L<DateTime|packages/DateTime>, L<DialogBox|packages/DialogBox>, L<Graphic|packages/Graphic>, L<Groupbox|packages/Groupbox>, L<Header|packages/Header>, L<Label|packages/Label>, L<Listbox|packages/Listbox>, L<ListView|packages/ListView>, L<ProgressBar|packages/ProgressBar>, L<RadioButton|packages/RadioButton>, L<Rebar|packages/Rebar>, L<RichEdit|packages/RichEdit>, L<Slider|packages/Slider>, L<Splitter|packages/Splitter>, L<StatusBar|packages/StatusBar>, L<TabStrip|packages/TabStrip>, L<Textfield|packages/Textfield>, L<Toolbar|packages/Toolbar>, L<TreeView|packages/TreeView>, L<UpDown|packages/UpDown>, L<Window|packages/Window>, L<InsertBand()|methods/InsertBand_OPTIONS_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -tip => STRING
+
+=for HTML </TT><BLOCKQUOTE>
+
+The text that will appear as tooltip when the mouse is on the NotifyIcon.
+
+
+
+
+B<Applies to>: L<NotifyIcon|packages/NotifyIcon>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -title => STRING
+
+=for HTML </TT><BLOCKQUOTE>
+
+The title for the window or dialog box.
+
+
+
+
+B<Applies to>: L<DialogBox|packages/DialogBox>, L<Window|packages/Window>, L<BrowseForFolder()|methods/BrowseForFolder_OPTIONS_>, L<GetOpenFileName()|methods/GetOpenFileName_OPTIONS_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -topmost => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+The window "stays on top" even when deactivated.
+
+
+
+
+B<Applies to>: L<DialogBox|packages/DialogBox>, L<Window|packages/Window>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -transparent => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+Draws the animation using a transparent background.
+
+
+
+
+B<Applies to>: L<Animation|packages/Animation>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -truncate => 0/1/word/path
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<0>
+
+Specifies how the text is to be truncated:
+
+=over 4
+
+	   0	the text is not truncated
+	   1	the text is truncated at the end.
+	word	the text is truncated at the end of a word.
+	path	the text is truncated before the last "\" 
+	        (used to shorten paths).
+
+=back
+
+NOTE: this style does not seem to be working.
+
+
+
+
+B<Applies to>: L<Label|packages/Label>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -valign => top/center/bottom
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<center>
+
+Defines the vertical alignment for the text in the Button.
+
+
+
+
+B<Applies to>: L<Button|packages/Button>, L<CheckBox|packages/CheckBox>, L<RadioButton|packages/RadioButton>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 -wrap => 0/1
+
+=for HTML </TT><BLOCKQUOTE>
+
+B<Default value>: C<1 for Label, 0 for UpDown>
+
+For Labels, the text wraps automatically to a new line.
+For UpDown controls, the counter wraps when it reaches the lower or upper
+limit.
+
+ 
+
+
+
+B<Applies to>: L<Label|packages/Label>, L<UpDown|packages/UpDown>
+
+=for HTML </BLOCKQUOTE>
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/packages.pod perl-libwin32-0.191/GUI/docs/packages.pod
--- libwin32-0.191/GUI/docs/packages.pod	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/packages.pod	2004-01-12 16:46:41.453125000 -0800
@@ -0,0 +1,535 @@
+=head1 Win32::GUI packages
+
+=for HTML <TT>
+
+=head2 Animation
+
+=for HTML </TT><BLOCKQUOTE>
+
+The Animation control displays an AVI animation.
+To load an AVI file you can use the L<Open()|methods/Open()> method; 
+you can then use L<Play()|methods/Play()> to start the animation
+(note it will start automatically with the -autoplay option),
+L<Stop()|methods/Stop()> to stop it
+and L<Seek()|methods/Seek()> to position it to a specified frame.
+
+
+
+
+
+B<Options>: L<-autoplay|options/_autoplay_0_1>, L<-center|options/_center_0_1>, L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>, L<-transparent|options/_transparent_0_1>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Close|methods/Close_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Open|methods/Open_FILE_>, L<Play|methods/Play_FROM_TO_REPEAT_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Seek|methods/Seek_FRAME_>, L<Show|methods/Show_COMMAND_>, L<Stop|methods/Stop_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Button
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-align|options/_align_left_center_right>, L<-bitmap|options/-bitmap>, L<-cancel|options/_cancel_0_1>, L<-default|options/_default_0_1>, L<-icon|options/-icon>, L<-name|options/_name_STRING>, L<-ok|options/_ok_0_1>, L<-picture|options/-picture>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>, L<-valign|options/_valign_top_center_bottom>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Checkbox
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Class
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+B<Options>: L<-name|options/_name_STRING>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetWindowRect|methods/GetWindowRect_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Combobox
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<Add|methods/Add_STRING_STRING_STRING_>, L<AddString|methods/AddString_STRING_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Count|methods/Count_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<FindString|methods/FindString_STRING_INDEX_>, L<FindStringExact|methods/FindStringExact_STRING_INDEX_>, L<FirstVisibleItem|methods/FirstVisibleItem_INDEX_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Reset|methods/Reset_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<SelectedItem|methods/SelectedItem_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 ComboboxEx
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 DateTime
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 DialogBox
+
+=for HTML </TT><BLOCKQUOTE>
+
+Just like Window, but with a predefined dialog box look: by default, a DialogBox
+can not be sized, has no maximize box and has C<-dialogui> enabled (eg. 
+interprets tab/enter/esc).
+
+
+
+
+B<Options>: L<-accel|options/-accel>, L<-accelerators|options/-accelerators>, L<-acceleratortable|options/-acceleratortable>, L<-background|options/-background>, L<-caption|options/-caption>, L<-font|options/-font>, L<-foreground|options/-foreground>, L<-height|options/-height>, L<-hscroll|options/-hscroll>, L<-left|options/-left>, L<-maxheight|options/-maxheight>, L<-maximizebox|options/-maximizebox>, L<-maxsize|options/_maxsize_X_Y_>, L<-maxwidth|options/-maxwidth>, L<-menu|options/-menu>, L<-minheight|options/-minheight>, L<-minimizebox|options/-minimizebox>, L<-minsize|options/_minsize_X_Y_>, L<-minwidth|options/-minwidth>, L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-sizable|options/-sizable>, L<-size|options/_size_X_Y_>, L<-sysmenu|options/-sysmenu>, L<-text|options/_text_STRING>, L<-title|options/_title_STRING>, L<-top|options/-top>, L<-topmost|options/_topmost_0_1>, L<-vscroll|options/-vscroll>, L<-width|options/-width>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<BringWindowToTop|methods/BringWindowToTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<ChangeIcon|methods/ChangeIcon_ICON_>, L<ChangeSmallIcon|methods/ChangeSmallIcon_ICON_>, L<CloseWindow|methods/CloseWindow_>, L<Disable|methods/Disable_>, L<DrawMenuBar|methods/DrawMenuBar_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetMenu|methods/GetMenu_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsIconic|methods/IsIconic_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<IsZoomed|methods/IsZoomed_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<OpenIcon|methods/OpenIcon_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Graphic
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Groupbox
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Header
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-buttons|options/_buttons_0_1>, L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Label
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-align|options/_align_left_center_right>, L<-bitmap|options/-bitmap>, L<-fill|options/_fill_black_gray_white_none>, L<-frame|options/-frame>, L<-name|options/_name_STRING>, L<-notify|options/_notify_0_1>, L<-picture|options/-picture>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-sunken|options/_sunken_0_1>, L<-text|options/_text_STRING>, L<-truncate|options/_truncate_0_1_word_path>, L<-wrap|options/_wrap_0_1>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 ListView
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<Arrange|methods/Arrange_FLAG_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<EnsureVisible|methods/EnsureVisible_ITEM_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetStringWidth|methods/GetStringWidth_STRING_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<HitTest|methods/HitTest_X_Y_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<ItemCheck|methods/ItemCheck_ITEM_VALUE_>, L<ItemPosition|methods/ItemPosition_INDEX_X_Y_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<MoveItem|methods/MoveItem_INDEX_X_Y_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<SelectCount|methods/SelectCount_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>, L<View|methods/View_MODE_>, L<VisibleCount|methods/VisibleCount_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Listbox
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-multisel|options/_multisel_0_1_2>, L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-sort|options/-sort>, L<-text|options/_text_STRING>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<Add|methods/Add_STRING_STRING_STRING_>, L<AddString|methods/AddString_STRING_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Count|methods/Count_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<FindString|methods/FindString_STRING_INDEX_>, L<FindStringExact|methods/FindStringExact_STRING_INDEX_>, L<FirstVisibleItem|methods/FirstVisibleItem_INDEX_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<ItemFromPoint|methods/ItemFromPoint_X_Y_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Reset|methods/Reset_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<SelectCount|methods/SelectCount_>, L<SelectedItem|methods/SelectedItem_>, L<SelectString|methods/SelectString_STRING_INDEX_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 ProgressBar
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+
+B<Options>: L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-smooth|options/_smooth_0_1>, L<-text|options/_text_STRING>, L<-vertical|options/-vertical>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<SetRange|methods/SetRange_MIN_MAX_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 RadioButton
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>, L<-valign|options/_valign_top_center_bottom>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Rebar
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-bandborders|options/_bandborders_0_1>, L<-fixedorder|options/_fixedorder_0_1>, L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<BandCount|methods/BandCount_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<DeleteBand|methods/DeleteBand_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InsertBand|methods/InsertBand_OPTIONS_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Resize|methods/Resize_X_Y_>, L<RowCount|methods/RowCount_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 RichEdit
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-align|options/_align_left_center_right>, L<-autohscroll|options/-autohscroll>, L<-autovscroll|options/-autovscroll>, L<-keepselection|options/-keepselection>, L<-lowercase|options/-lowercase>, L<-multiline|options/_multiline_0_1>, L<-name|options/_name_STRING>, L<-number|options/-number>, L<-password|options/_password_0_1>, L<-passwordchar|options/_passwordchar_CHAR>, L<-pos|options/_pos_X_Y_>, L<-prompt|options/_prompt_STRING_or_STRING_W>, L<-readonly|options/_readonly_0_1>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>, L<-uppercase|options/-uppercase>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<BackColor|methods/BackColor_COLOR_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<LineFromChar|methods/LineFromChar_INDEX_>, L<Load|methods/Load_FILENAME_FORMAT_>, L<MaxLength|methods/MaxLength_CHARS_>, L<Modified|methods/Modified_FLAG_>, L<Move|methods/Move_X_Y_>, L<PasswordChar|methods/PasswordChar_CHAR_>, L<ReadOnly|methods/ReadOnly_FLAG_>, L<ReplaceSel|methods/ReplaceSel_STRING_FLAG_>, L<Resize|methods/Resize_X_Y_>, L<Save|methods/Save_FILENAME_FORMAT_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Scroll|methods/Scroll_COMMAND_LINE_HORIZON>, L<SelectAll|methods/SelectAll_>, L<Selection|methods/Selection_>, L<Show|methods/Show_COMMAND_>, L<Undo|methods/Undo_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Slider
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Splitter
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 StatusBar
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 TabStrip
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-bottom|options/-bottom>, L<-buttons|options/_buttons_0_1>, L<-flat|options/-flat>, L<-hottrack|options/-hottrack>, L<-imagelist|options/-imagelist>, L<-justify|options/-justify>, L<-multiline|options/_multiline_0_1>, L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-right|options/-right>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>, L<-vertical|options/-vertical>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Textfield
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-align|options/_align_left_center_right>, L<-autohscroll|options/-autohscroll>, L<-autovscroll|options/-autovscroll>, L<-keepselection|options/-keepselection>, L<-lowercase|options/-lowercase>, L<-multiline|options/_multiline_0_1>, L<-name|options/_name_STRING>, L<-number|options/-number>, L<-password|options/_password_0_1>, L<-passwordchar|options/_passwordchar_CHAR>, L<-pos|options/_pos_X_Y_>, L<-prompt|options/_prompt_STRING_or_STRING_W>, L<-readonly|options/_readonly_0_1>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>, L<-uppercase|options/-uppercase>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<LineFromChar|methods/LineFromChar_INDEX_>, L<MaxLength|methods/MaxLength_CHARS_>, L<Modified|methods/Modified_FLAG_>, L<Move|methods/Move_X_Y_>, L<PasswordChar|methods/PasswordChar_CHAR_>, L<ReadOnly|methods/ReadOnly_FLAG_>, L<ReplaceSel|methods/ReplaceSel_STRING_FLAG_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Scroll|methods/Scroll_COMMAND_LINE_HORIZON>, L<SelectAll|methods/SelectAll_>, L<Selection|methods/Selection_>, L<Show|methods/Show_COMMAND_>, L<Undo|methods/Undo_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Timer
+
+=for HTML </TT><BLOCKQUOTE>
+
+The Timer object is a special kind of control: it has no appearance, its only 
+purpose is to trigger an event every specified amount of time.
+
+The synopsis to create a Timer object is:
+
+	new Win32::GUI::Timer( PARENT, NAME, ELAPSE )
+
+	PARENT->AddTimer( NAME, ELAPSE )
+
+=over 4
+
+=item C<NAME>
+
+the name for the Timer object (used to lookup the associated event).
+
+=item C<ELAPSE>
+
+the number of milliseconds after which the Timer() event will
+be triggered.
+
+=back
+
+Once you've created the Timer object, you can change the ELAPSE parameter 
+with the Interval() method, or disables it with the Kill() method.
+Note that Kill(), despite of its name, does not destroy the Timer object, 
+so you can re-enable it later with Interval().
+
+Example:
+
+	# creates a Timer that is called every 1 second
+	
+	$Window->AddTimer( "Clock", 1000 );
+
+	sub Clock_Timer {
+		print "one second passed.\n";
+	}
+
+
+
+
+
+
+B<Methods>: L<Interval|methods/Interval_ELAPSE_>, L<Kill|methods/Kill_>
+
+B<Events>: L<Timer|events/Timer_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Toolbar
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-name|options/_name_STRING>, L<-text|options/_text_STRING>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Move|methods/Move_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Tooltip
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 TreeView
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-buttons|options/_buttons_0_1>, L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<EnsureVisible|methods/EnsureVisible_ITEM_FLAG_>, L<Expand|methods/Expand_NODE_FLAG_>, L<FirstVisible|methods/FirstVisible_NODE_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetLastVisible|methods/GetLastVisible_>, L<GetNextVisible|methods/GetNextVisible_NODE_>, L<GetPrevVisible|methods/GetPrevVisible_NODE_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<HitTest|methods/HitTest_X_Y_>, L<Indent|methods/Indent_VALUE_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<ItemCheck|methods/ItemCheck_ITEM_VALUE_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>, L<VisibleCount|methods/VisibleCount_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 UpDown
+
+=for HTML </TT><BLOCKQUOTE>
+
+x
+
+
+
+
+B<Options>: L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-size|options/_size_X_Y_>, L<-text|options/_text_STRING>, L<-wrap|options/_wrap_0_1>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<Disable|methods/Disable_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
+=for HTML <TT>
+
+=head2 Window
+
+=for HTML </TT><BLOCKQUOTE>
+
+This is the main container of a regular GUI; also known as "top level window".
+
+
+
+
+B<Options>: L<-accel|options/-accel>, L<-accelerators|options/-accelerators>, L<-acceleratortable|options/-acceleratortable>, L<-background|options/-background>, L<-caption|options/-caption>, L<-font|options/-font>, L<-foreground|options/-foreground>, L<-height|options/-height>, L<-hscroll|options/-hscroll>, L<-left|options/-left>, L<-maxheight|options/-maxheight>, L<-maximizebox|options/-maximizebox>, L<-maxsize|options/_maxsize_X_Y_>, L<-maxwidth|options/-maxwidth>, L<-menu|options/-menu>, L<-minheight|options/-minheight>, L<-minimizebox|options/-minimizebox>, L<-minsize|options/_minsize_X_Y_>, L<-minwidth|options/-minwidth>, L<-name|options/_name_STRING>, L<-pos|options/_pos_X_Y_>, L<-sizable|options/-sizable>, L<-size|options/_size_X_Y_>, L<-sysmenu|options/-sysmenu>, L<-text|options/_text_STRING>, L<-title|options/_title_STRING>, L<-top|options/-top>, L<-topmost|options/_topmost_0_1>, L<-vscroll|options/-vscroll>, L<-width|options/-width>
+
+B<Methods>: L<AbsLeft|methods/AbsLeft_>, L<AbsTop|methods/AbsTop_>, L<BringWindowToTop|methods/BringWindowToTop_>, L<ChangeCursor|methods/ChangeCursor_CURSOR_>, L<ChangeIcon|methods/ChangeIcon_ICON_>, L<ChangeSmallIcon|methods/ChangeSmallIcon_ICON_>, L<CloseWindow|methods/CloseWindow_>, L<Disable|methods/Disable_>, L<DrawMenuBar|methods/DrawMenuBar_>, L<Enable|methods/Enable_FLAG_>, L<GetClassName|methods/GetClassName_>, L<GetClientRect|methods/GetClientRect_>, L<GetFont|methods/GetFont_FONT_>, L<GetFontName|methods/GetFontName_>, L<GetMenu|methods/GetMenu_>, L<GetTextExtentPoint32|methods/GetTextExtentPoint32_STRING_F>, L<GetWindowRect|methods/GetWindowRect_>, L<Height|methods/Height_HEIGHT_>, L<Hide|methods/Hide_>, L<InvalidateRect|methods/InvalidateRect_>, L<IsEnabled|methods/IsEnabled_>, L<IsIconic|methods/IsIconic_>, L<IsVisible|methods/IsVisible_>, L<IsWindow|methods/IsWindow_>, L<IsZoomed|methods/IsZoomed_>, L<Left |methods/Left_LEFT_>, L<Move|methods/Move_X_Y_>, L<OpenIcon|methods/OpenIcon_>, L<Resize|methods/Resize_X_Y_>, L<ScaleHeight|methods/ScaleHeight_>, L<ScaleWidth|methods/ScaleWidth_>, L<Show|methods/Show_COMMAND_>, L<Update|methods/Update_>
+
+=for HTML </BLOCKQUOTE>
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/style.css perl-libwin32-0.191/GUI/docs/style.css
--- libwin32-0.191/GUI/docs/style.css	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/style.css	2004-01-12 16:46:41.468750000 -0800
@@ -0,0 +1,4 @@
+HR { color: darkgreen; height: 1px; size: 1px; }
+H2 { font-family: Lucida Console, Courier New, Courier; font-size: 14pt;  }
+BODY { background-color: white; font-family: Tahoma; font-size: 11pt; }
+CODE { font-family: Lucida Console, Courier New, Courier; }
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/tut/guitut1-1.gif perl-libwin32-0.191/GUI/docs/tut/guitut1-1.gif
--- libwin32-0.191/GUI/docs/tut/guitut1-1.gif	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/tut/guitut1-1.gif	2004-01-12 16:46:41.484375000 -0800
@@ -0,0 +1,7 @@
+GIF89ap d        {!!!1 111999BBBJJJRRRZBcccsZsss{c{s{{{Zk,    p d   9H*\C 8xH3jD(S\0c0R8s4)Rb @
+JH*]4$3 ]@aX\`-I *4Xm
+@]wSAdxa.SE"f(ob @5d{v(baJ)B %M< A#mR1]IW/`$yP)Cw9C=LP`Wq,{9Vr$]t	f vVCFy'H^czWSe! @ nh(k9ZIFY~@>%"K&\Ht2&c!naaBdyCr,	!1>YEU
+  )TsIXZr	Pz diai(+9iW\g'8~N4vz +> eLXP0jT'pLpAPakf(ybl(Q+'v_2HHN{|"yg(+r1y,wK$7sBiApP7j11BI*v$}LfS]//t'=rJd7]1xs9o*=]K3.hkustGfw*9s&~?xwKt\6y}w;hj7Q/K|[=*;M?Ns~G+XN> ~Ze?ydj8 y0_
+A D"EwvC!yB/U4c<&%'6G=	.qLXBMqz[A-/'FY]/h0zo=vn}A"GqQ<dNG0%g|`?@Lq]d%GJ$~z#=J&1)c(	RjYAyK[ /D2^\Jf&iLd,7Aa3<&ILT(X?z0X<e;S=y/<6bc3*]]4	[fCzr}L'txOj.'0CTN.T9]+7Ts,aK|wHi'k2TPhI{fH?]}E^X#rP^)Z'09/
+D |k@Z35*'	YtbjV_;,"	Z7J
+[KTj=(Ju&mI{,s;YF&u2;n<eZr]	xKIuOaRttZQ[roj?wdYE\67+o 1D(NO  ;
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/tut/guitut1-2.gif perl-libwin32-0.191/GUI/docs/tut/guitut1-2.gif
--- libwin32-0.191/GUI/docs/tut/guitut1-2.gif	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/tut/guitut1-2.gif	2004-01-12 16:46:41.500000000 -0800
@@ -0,0 +1,6 @@
+GIF89ap (        {!!!1 111999BBBJJJRRRZBcccsZsss{c{s{{{Zk,    p (   9H*\C 8xH3jD(S\0c0R8s4)Rb @
+JH*]4$3 ]@aX\`-I *4Xm
+@]wSAdxa.SE"f(ob @5d{v(baND% RVMr.imm.  &LCIR1u;I]O`VhiNK|9 R>>?vePVTy04g)\EQtX|6vqw
+ 'Y-|T Jv_v^#|%`Md @  AH&?laj:&eR 
+R7V(8uv9&R$R%Ts\tA"FEn
+`9'ErB*Tu!9Iiz dbjiXrXt]$+ND4 v->Pe XPjGz#p\ \@F,qRA;NwML\r&',D08ca8c;<4xgLIO7Rgq	7-4/ii4CtQf:[-7<7#5f]8(gI+ywD$GN;)2=w=S7>28zSS^:*S]:.;w.3k#}+>xf_bT{Ow}]zRtQ0|+	_ GH0   ;
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/tut/guitut1-3.gif perl-libwin32-0.191/GUI/docs/tut/guitut1-3.gif
--- libwin32-0.191/GUI/docs/tut/guitut1-3.gif	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/tut/guitut1-3.gif	2004-01-12 16:46:41.531250000 -0800
@@ -0,0 +1,6 @@
+GIF89ap 3        {!!!1 111999BBBJJJRRRZBcccsZsss{c{s{{{Zk  ,    p 3   9H*\C 8|H3jD(S\0c0R8s4)Rb @
+JH*]4$3 ]@aX\`-I *4Xm
+@]wSAdxa.E"f(ob @5d{v(baND% RVMr.imm.  &LCIR1u;I]O`VhiNK|9 R>>?vePVT}04g)\EQtX|6vqw
+ 'Y-|T Jv_v^#|%`Md @  AH&?laj:&eR 
+R7V(8uv9&R$R%Ts\tA"FEn
+`9'ErB*Tu!9Ii~ dbjiXrXt]$+ND4 v->Pe XPjGz#p\ \@F,qRA;NwML\r&',D08c9N<gltH|I=s,5Am5y|ZL+4_c^]Raw]6e-x)]Q8=4mwx5ux?~ =6i_e,dG~9St:~Vw;Y_{Q-<;x~]_|$g5>%mw?~?=[_>J<{v7 Z5-O8tvag9H gqo!|2!{#]qo%_rE	GF2>n^AmsX6=%;85#82!.;rdICvq%cRM>r;*Ku-wKp\EbL1 ;
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/tut/guitut1.html perl-libwin32-0.191/GUI/docs/tut/guitut1.html
--- libwin32-0.191/GUI/docs/tut/guitut1.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/tut/guitut1.html	2004-01-12 16:46:41.546875000 -0800
@@ -0,0 +1,521 @@
+<HTML>
+<HEAD>
+<TITLE>Win32::GUI Tutorial - Part 1 - Our first Win32::GUI Program</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+
+<UL>
+
+	<LI><A HREF="#Win32_GUI_Tutorial_Part_1_O">Win32::GUI Tutorial - Part 1 - Our first Win32::GUI Program</A>
+	<UL>
+
+		<LI><A HREF="#Hello_GUI_world">Hello, GUI world</A>
+		<LI><A HREF="#Some_extra_touches">Some extra touches</A>
+		<LI><A HREF="#Changing_the_appearance_of_the_t">Changing the appearance of the text</A>
+		<LI><A HREF="#Centring_the_window_and_the_text">Centring the window and the text</A>
+		<LI><A HREF="#Restricting_the_minimum_size_of_">Restricting the minimum size of the window</A>
+		<LI><A HREF="#Putting_it_all_together">Putting it all together</A>
+	</UL>
+
+</UL>
+<!-- INDEX END -->
+
+<HR>
+<P>
+<H1><A NAME="Win32_GUI_Tutorial_Part_1_O">Win32::GUI Tutorial - Part 1 - Our first Win32::GUI Program</A></H1>
+<P>
+<HR>
+<H2><A NAME="Hello_GUI_world">Hello, GUI world</A></H2>
+<P>
+OK, let's begin. The traditional ``first program'' for any programming
+environment prints ``Hello, world'', so let's go with that.
+
+<P>
+To start with, we load Win32::GUI.
+
+<P>
+<PRE>    use Win32::GUI;
+</PRE>
+<P>
+We are working in a windowing environment, so we need a window. Main
+windows are created using Win32::GUI::Window-&gt;new(). The parameters to
+<CODE>new()</CODE> are a list of key =&gt; value pairs, which define the
+properties of the window. For our simple example, all we need are a width
+and a height (if we don't specify the window size, the default is to make
+the window as small as possible - so there is no space for the text!).
+
+<P>
+<PRE>   $main = Win32::GUI::Window-&gt;new(-width =&gt; 100, -height =&gt; 100);
+</PRE>
+<P>
+We save the window in the variable <CODE>$main</CODE> so that we can refer
+to it later.
+
+<P>
+Now, what about the text? Text can be put into a window using a ``label''
+control. To add a label to a window, use the <CODE>AddLabel()</CODE>
+method. <CODE>AddLabel()</CODE> takes a list of options, similar to the
+<CODE>new()</CODE> call above. In this case, the only option we need is <CODE>-text</CODE>, which specifies the text to display. By default, the label's size is just
+big enough to fit its text, and its position is in the top left of its
+containing window. This is fine for us.
+
+<P>
+<PRE>    $main-&gt;AddLabel(-text =&gt; &quot;Hello, world&quot;);
+</PRE>
+<P>
+OK, now we need make sure the window will be displayed. By default, windows
+start hidden, so they won't be visible on screen. To make them visible, we
+need to use the <CODE>Show()</CODE> method.
+
+<P>
+<PRE>    $main-&gt;Show();
+</PRE>
+<P>
+Finally, we need to start up a Windows ``message loop''. This shows the
+application windows, and waits for user interaction. The Win32::GUI message
+loop is implemented in the Win32::GUI::Dialog() function. All that is
+needed is to call that function, and wait for it to return.
+
+<P>
+<PRE>    Win32::GUI::Dialog();
+</PRE>
+<P>
+One thing remains. At the moment, we are displaying the window, and waiting
+for user interaction. However, we haven't said what to do if any user
+interaction (called an <EM>event</EM>) occurs! Worse still, we haven't even said what to do when the window
+closes, so the message loop keeps on spinning, even after the window closes
+- so we never return from Win32::GUI::Dialog...
+
+<P>
+So we need to react to events. How do we do that? Well, the first thing we
+need is for any window or control which is to react to events to have a
+name. This name is specified using the <CODE>-name</CODE> option. So we change the statement which creates our main window as follows
+
+<P>
+<PRE>    $main = Win32::GUI::Window-&gt;new(
+                -name   =&gt; 'Main',
+                -width  =&gt; 100,
+                -height =&gt; 100,
+        );
+</PRE>
+<P>
+Now, we define <EM>event handlers</EM> for the window. Event handlers are simply Perl subroutines with specific
+names - &lt;window name&gt;_&lt;event name&gt;. For example, the event which happens when the window is
+closed is the <CODE>Terminate</CODE>
+event, so the event handler we need for our main window is <CODE>Main_Terminate</CODE>.
+
+<P>
+Event handlers should return one of three specific values:
+
+<UL>
+<LI>
+<P>
+1: Proceed, taking the default action defined for the event.
+
+<LI>
+<P>
+0: Proceed, but <STRONG>do not</STRONG> take the default action.
+
+<LI>
+<P>
+-1: Terminate the message loop.
+
+</UL>
+<P>
+Obviously, what we want for the Main_Terminate event is to return -1
+(terminate the message loop). So, we have
+
+<P>
+<PRE>    sub Main_Terminate {
+        -1;
+    }
+</PRE>
+<P>
+More generally, we could do some processing before returning from the event
+handler, but we don't need to here.
+
+<P>
+So, let's put it all together.
+
+<P>
+<PRE>    use Win32::GUI;
+    $main = Win32::GUI::Window-&gt;new(
+                -name   =&gt; 'Main',
+                -width  =&gt; 100,
+                -height =&gt; 100,
+        );
+    $main-&gt;AddLabel(-text =&gt; &quot;Hello, world&quot;);
+    $main-&gt;Show();
+    Win32::GUI::Dialog();
+</PRE>
+<P>
+<PRE>    sub Main_Terminate {
+        -1;
+    }
+</PRE>
+<P>
+Put that in a file (say, hello.plx) and run it using <CODE>perl hello.plx</CODE>. 
+
+<BR><CENTER><IMG SRC="guitut1-1.gif"></CENTER>
+
+<P>
+Notice how you can resize and move the window, maximize and minimize it,
+just like any other application window.
+
+<P>
+So that's it. Ten lines of code to produce a fully working Windows
+application.
+
+<P>
+<HR>
+<H2><A NAME="Some_extra_touches">Some extra touches</A></H2>
+<P>
+Now, we'll add some simple improvements to make our application look more
+polished.
+
+<P>
+You will notice that the application window has no title. To include a
+title, all we need is to add a <CODE>-text</CODE> option to the main window.
+
+<P>
+<PRE>    $main = Win32::GUI::Window-&gt;new(
+                -name   =&gt; 'Main',
+                -width  =&gt; 100,
+                -height =&gt; 100,
+                -text   =&gt; 'Perl',
+        );
+</PRE>
+<P>
+Now, suppose we want the window to be just big enough to hold the label,
+rather than being a fixed size. This is a bit more complicated, because we
+need to take note of the difference between the total window size, and the
+<EM>client area</EM>, which is the area of the window excluding the title bar, the system,
+minimize, maximize, and close icons, and the window border. In other words,
+it is the area in which we can actually display information.
+
+<P>
+We can get the window size using the <CODE>Height()</CODE> and
+<CODE>Width()</CODE> methods, and we can get the client area size using the
+<CODE>ScaleHeight()</CODE> and <CODE>ScaleWidth()</CODE> methods.
+
+<P>
+We can get the label size similarly, using <CODE>Height()</CODE> and
+<CODE>Width()</CODE> (labels do not have borders, so the label area and its
+client area are the same).
+
+<P>
+To get the dimensions of the non-client area of the main window, we just
+need
+
+<P>
+<PRE>    $ncw = $main-&gt;Width() - $main-&gt;ScaleWidth();
+    $nch = $main-&gt;Height() - $main-&gt;ScaleHeight();
+</PRE>
+<P>
+Now, we get the required size as
+
+<P>
+<PRE>    $w = $label-&gt;Width() + $ncw;
+    $h = $label-&gt;Height() + $nch;
+</PRE>
+<P>
+As we are getting properties of the label, we should save the return value
+of the <CODE>AddLabel()</CODE> call - which is a reference to the label -
+in a variable $label.
+
+<P>
+And we set the main window's size using <CODE>Resize()</CODE>
+
+<P>
+<PRE>    $main-&gt;Resize($w, $h);
+</PRE>
+<P>
+We have to resize after we have created the window, because we need to
+create the window first in order to calculate the non-client dimensions.
+But we do it before we show the window, to avoid any flicker.
+
+<P>
+OK, let's put all this together. We'll add the ability to specify the label
+text on the command line, just to be fancy (it also shows that the values
+of options can be set using variables, not just constant values).
+
+<P>
+<PRE>    use Win32::GUI;
+</PRE>
+<P>
+<PRE>    $text = defined($ARGV[0]) ? $ARGV[0] : &quot;Hello, world&quot;;
+</PRE>
+<P>
+<PRE>    $main = Win32::GUI::Window-&gt;new(-name =&gt; 'Main', -text =&gt; 'Perl');
+    $label = $main-&gt;AddLabel(-text =&gt; $text);
+</PRE>
+<P>
+<PRE>    $ncw = $main-&gt;Width()  - $main-&gt;ScaleWidth();
+    $nch = $main-&gt;Height() - $main-&gt;ScaleHeight();
+    $w = $label-&gt;Width()  + $ncw;
+    $h = $label-&gt;Height() + $nch;
+</PRE>
+<P>
+<PRE>    $main-&gt;Resize($w, $h);
+    $main-&gt;Show();
+    Win32::GUI::Dialog();
+</PRE>
+<P>
+<PRE>    sub Main_Terminate {
+        -1;
+    }
+</PRE>
+<P>
+Run this version and see the results. Note that if you supply a short
+string, the window will not shrink beyond a minimum size sufficient to show
+the window icons.
+
+<BR><CENTER><IMG SRC="guitut1-2.gif"></CENTER>
+
+<P>
+<HR>
+<H2><A NAME="Changing_the_appearance_of_the_t">Changing the appearance of the text</A></H2>
+<P>
+Now, suppose we want to change the colour in which the text is displayed.
+This is easy. You just specify the colour as the value of the <CODE>-foreground</CODE>
+attribute of the label. Colours can be specified either as hex values in
+the format 0xBBGGRR, or as list references in the format [ R, G, B ].
+
+<P>
+So, to make the text red, use <CODE>-foreground =&amp;gt; 0x0000FF</CODE> or <CODE>-foreground
+=&amp;gt; [ 255, 0, 0 ]</CODE>.
+
+<P>
+To change the font, you need to specify the <CODE>-font</CODE> attribute. But in this case, the value of the attribute is a
+Win32::GUI::Font object. To create a font object, use
+
+<P>
+<PRE>    $font = Win32::GUI::Font-&gt;new(...);
+</PRE>
+<P>
+As usual, the parameters to <CODE>new()</CODE> are a set of options. The
+most important ones are
+
+<UL>
+<LI><STRONG><A NAME="item__size">-size</A></STRONG>
+<P>
+The font size in points.
+
+<P>
+
+<LI><STRONG><A NAME="item__name">-name</A></STRONG>
+<P>
+The font name, such as ``Times New Roman'', ``Arial'', ``Verdana'' or
+``Comic Sans MS''.
+
+<P>
+
+<LI><STRONG><A NAME="item__bold">-bold</A></STRONG>
+<P>
+One for bold, zero (the default) for non-bold.
+
+<P>
+
+<LI><STRONG><A NAME="item__italic">-italic</A></STRONG>
+<P>
+One for italic, zero (the default) for non-italic.
+
+</UL>
+<P>
+So, to change the format of our label, all we need is
+
+<P>
+<PRE>    $font = Win32::GUI::Font-&gt;new(
+                -name =&gt; &quot;Comic Sans MS&quot;, 
+                -size =&gt; 24,
+        );
+    $label = $main-&gt;AddLabel(
+                -text       =&gt; $text,
+                -font       =&gt; $font,
+                -foreground =&gt; [255, 0, 0],
+        );
+</PRE>
+<BR><CENTER><IMG SRC="guitut1-3.gif"></CENTER>
+
+<P>
+Simple, isn't it?
+
+<P>
+<HR>
+<H2><A NAME="Centring_the_window_and_the_text">Centring the window and the text</A></H2>
+<P>
+To centre the main window on the screen, we need to know the screen size.
+We get this using the <EM>desktop window</EM>. You can get the handle of the desktop window using
+Win32::GUI::GetDesktopWindow(). One point to note is that window handles
+are <STRONG>not</STRONG> Win32::GUI::Window objects, so they cannot be used to call Win32::GUI
+methods like <CODE>Height().</CODE> However, these methods are overloaded
+so that they can be called directly (as Win32::GUI::Height()) with a window
+handle as an extra first parameter. See the code below for an example.
+
+<P>
+The rest of the work is just arithmetic. To reposition the main window, use
+the <CODE>Move()</CODE> method.
+
+<P>
+<PRE>    # Assume we have the main window size in ($w, $h) as before
+    $desk = Win32::GUI::GetDesktopWindow();
+    $dw = Win32::GUI::Width($desk);
+    $dh = Win32::GUI::Height($desk);
+    $x = ($dw - $w) / 2;
+    $y = ($dh - $h) / 2;
+    $main-&gt;Move($x, $y);
+</PRE>
+<P>
+Now, we will look at centring the label in the window (you will notice that
+if you increase the size of the window, the text stays at the top left of
+the window).
+
+<P>
+The process is similar to the calculations for centring the window above.
+There are two main differences. First of all, the label needs to be
+recentred every time the window changes size - so we need to do the
+calculations in a Resize event handler. The second difference (which in
+theory applies to the window as well, but which we ignored above), is that
+we need to watch out for the case where the window is too small to contain
+the label. Just to make things interesting, we'll stop the main window
+getting that small, by resizing it in the event handler if that is about to
+happen. As the width could be too small while the height is OK, we have to
+reset the width and height individually. We can do this using variations on
+the <CODE>Width()</CODE> and <CODE>Height()</CODE> methods, with a single
+parameter which specifies the value to set.
+
+<P>
+OK, let's just do it.
+
+<P>
+<PRE>    sub Main_Resize {
+        my $w = $main-&gt;Width();
+        my $h = $main-&gt;Height();
+        my $lw = $label-&gt;Width();
+        my $lh = $label-&gt;Height();
+        if ($lw &gt; $w) {
+            $main-&gt;Width($lw) + $ncw; # Remember the non-client width!
+        }
+        else {
+            $label-&gt;Left(($w - $lw) / 2);
+        }
+        if ($lh &gt; $h) {
+            $main-&gt;Height($lh) + $nch; # Remember the non-client height!
+        }
+        else {
+            $label-&gt;Top(($h - $lh) / 2);
+        }
+    }
+</PRE>
+<P>
+This does not work in build 340 of Win32::GUI, as there is a bug in the
+<CODE>Left()</CODE> and <CODE>Top()</CODE> methods for client windows (such
+as the label used here). Hopefully, this bug will be fixed in the next
+version.
+
+<P>
+Note that co-ordinates are calculated from the top left of the enclosing
+window.
+
+<P>
+<HR>
+<H2><A NAME="Restricting_the_minimum_size_of_">Restricting the minimum size of the window</A></H2>
+<P>
+Suppose we wanto to ensure that our main window never gets smaller than
+100x100 pixels. We could include code in a resize event, like we did in the
+previous section to make sure the window never got smaller than the label.
+However, this can result in fairly bad flickering. A better solution is to
+use the <CODE>-minsize</CODE> option.
+
+<P>
+<PRE>    $main = Win32::GUI::Window-&gt;new(
+                -name =&gt; 'Main',
+                -text =&gt; 'Perl',
+                -minsize =&gt; [100, 100],
+        );
+</PRE>
+<P>
+Simple! But in the previous example, we wanted to restrict the window size
+to the size of the label. We can't do this when we create the window,
+because we haven't created the label yet. But we can still do this - we
+just have to set the window's <CODE>-minsize</CODE> option after the label has been created. We do this with the
+<CODE>Change()</CODE> method. We just specify this before resizing the
+window, in our initial setup.
+
+<P>
+<PRE>    $main-&gt;Change(-minsize =&gt; [$w, $h]);
+</PRE>
+<P>
+<HR>
+<H2><A NAME="Putting_it_all_together">Putting it all together</A></H2>
+<P>
+OK, we now have a nice, fully working GUI application. Here it is, in all
+its glory.
+
+<P>
+<PRE>    use Win32::GUI;
+</PRE>
+<P>
+<PRE>    $text = defined($ARGV[0]) ? $ARGV[0] : &quot;Hello, world&quot;;
+</PRE>
+<P>
+<PRE>    $main = Win32::GUI::Window-&gt;new(
+                -name =&gt; 'Main',
+                -text =&gt; 'Perl',
+        );
+    $font = Win32::GUI::Font-&gt;new(
+                -name =&gt; &quot;Comic Sans MS&quot;, 
+                -size =&gt; 24,
+        );
+    $label = $main-&gt;AddLabel(
+                -text =&gt; $text,
+                -font =&gt; $font,
+                -foreground =&gt; [255, 0, 0],
+        );
+</PRE>
+<P>
+<PRE>    $ncw = $main-&gt;Width() -  $main-&gt;ScaleWidth();
+    $nch = $main-&gt;Height() - $main-&gt;ScaleHeight();
+    $w = $label-&gt;Width()  + $ncw;
+    $h = $label-&gt;Height() + $nch;
+</PRE>
+<P>
+<PRE>    $desk = Win32::GUI::GetDesktopWindow();
+    $dw = Win32::GUI::Width($desk);
+    $dh = Win32::GUI::Height($desk);
+    $x = ($dw - $w) / 2;
+    $y = ($dh - $h) / 2;
+</PRE>
+<P>
+<PRE>    $main-&gt;Change(-minsize =&gt; [$w, $h]);
+    $main-&gt;Move($x, $y);
+    $main-&gt;Show();
+</PRE>
+<P>
+<PRE>    Win32::GUI::Dialog();
+</PRE>
+<P>
+<PRE>    sub Main_Terminate {
+        -1;
+    }
+</PRE>
+<P>
+<PRE>    sub Main_Resize {
+        my $w = $main-&gt;ScaleWidth();
+        my $h = $main-&gt;ScaleHeight();
+        my $lw = $label-&gt;Width();
+        my $lh = $label-&gt;Height();
+                $label-&gt;Left(int(($w - $lw) / 2));
+                $label-&gt;Top(int(($h - $lh) / 2));
+    }
+</PRE>
+<P>
+That's it for this tutorial. In part 2, we will start looking at some other
+controls.
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/tut/guitut1.pod perl-libwin32-0.191/GUI/docs/tut/guitut1.pod
--- libwin32-0.191/GUI/docs/tut/guitut1.pod	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/tut/guitut1.pod	2004-01-12 16:46:41.562500000 -0800
@@ -0,0 +1,406 @@
+=head1 Win32::GUI Tutorial - Part 1 - Our first Win32::GUI Program
+
+=head2 Hello, GUI world
+
+OK, let's begin. The traditional "first program" for any programming
+environment prints "Hello, world", so let's go with that.
+
+To start with, we load Win32::GUI.
+
+    use Win32::GUI;
+
+We are working in a windowing environment, so we need a window. Main windows
+are created using Win32::GUI::Window->new(). The parameters to new() are a
+list of key => value pairs, which define the properties of the window. For our
+simple example, all we need are a width and a height (if we don't specify the
+window size, the default is to make the window as small as possible - so there
+is no space for the text!).
+
+   $main = Win32::GUI::Window->new(-width => 100, -height => 100);
+
+We save the window in the variable $main so that we can refer to it later.
+
+Now, what about the text? Text can be put into a window using a "label"
+control. To add a label to a window, use the AddLabel() method. AddLabel()
+takes a list of options, similar to the new() call above. In this case, the
+only option we need is C<-text>, which specifies the text to display. By
+default, the label's size is just big enough to fit its text, and its position
+is in the top left of its containing window. This is fine for us.
+
+    $main->AddLabel(-text => "Hello, world");
+
+OK, now we need make sure the window will be displayed. By default, windows
+start hidden, so they won't be visible on screen. To make them visible, we
+need to use the Show() method.
+
+    $main->Show();
+
+Finally, we need to start up a Windows "message loop". This shows the
+application windows, and waits for user interaction. The Win32::GUI message
+loop is implemented in the Win32::GUI::Dialog() function. All that is needed
+is to call that function, and wait for it to return.
+
+    Win32::GUI::Dialog();
+
+One thing remains. At the moment, we are displaying the window, and waiting
+for user interaction. However, we haven't said what to do if any user
+interaction (called an I<event>) occurs! Worse still, we haven't even said what
+to do when the window closes, so the message loop keeps on spinning, even
+after the window closes - so we never return from Win32::GUI::Dialog...
+
+So we need to react to events. How do we do that? Well, the first thing we
+need is for any window or control which is to react to events to have a name.
+This name is specified using the C<-name> option. So we change the statement
+which creates our main window as follows
+
+    $main = Win32::GUI::Window->new(
+		-name   => 'Main',
+		-width  => 100,
+		-height => 100,
+	);
+
+Now, we define I<event handlers> for the window. Event handlers are simply
+Perl subroutines with specific names - <window name>_<event name>. For
+example, the event which happens when the window is closed is the C<Terminate>
+event, so the event handler we need for our main window is C<Main_Terminate>.
+
+Event handlers should return one of three specific values:
+
+=over 4
+
+=item *
+
+1: Proceed, taking the default action defined for the event.
+
+=item *
+
+0: Proceed, but B<do not> take the default action.
+
+=item *
+
+-1: Terminate the message loop.
+
+=back
+
+Obviously, what we want for the Main_Terminate event is to return -1
+(terminate the message loop). So, we have
+
+    sub Main_Terminate {
+        -1;
+    }
+
+More generally, we could do some processing before returning from the event
+handler, but we don't need to here.
+
+So, let's put it all together.
+
+    use Win32::GUI;
+    $main = Win32::GUI::Window->new(
+		-name   => 'Main',
+		-width  => 100,
+		-height => 100,
+	);
+    $main->AddLabel(-text => "Hello, world");
+    $main->Show();
+    Win32::GUI::Dialog();
+
+    sub Main_Terminate {
+        -1;
+    }
+
+Put that in a file (say, hello.plx) and run it using C<perl hello.plx>. 
+
+=for HTML <BR><CENTER><IMG SRC="guitut1-1.gif"></CENTER>
+
+Notice how you can resize and move the window, maximize and minimize it, 
+just like any other application window.
+
+So that's it. Ten lines of code to produce a fully working Windows
+application.
+
+=head2 Some extra touches
+
+Now, we'll add some simple improvements to make our application look more
+polished.
+
+You will notice that the application window has no title. To include a title,
+all we need is to add a C<-text> option to the main window.
+
+    $main = Win32::GUI::Window->new(
+		-name   => 'Main',
+		-width  => 100,
+		-height => 100,
+		-text   => 'Perl',
+	);
+
+Now, suppose we want the window to be just big enough to hold the label,
+rather than being a fixed size. This is a bit more complicated, because we
+need to take note of the difference between the total window size, and the
+I<client area>, which is the area of the window excluding the title bar, the
+system, minimize, maximize, and close icons, and the window border. In other
+words, it is the area in which we can actually display information.
+
+We can get the window size using the Height() and Width() methods, and
+we can get the client area size using the ScaleHeight() and ScaleWidth()
+methods.
+
+We can get the label size similarly, using Height() and Width() (labels do not
+have borders, so the label area and its client area are the same).
+
+To get the dimensions of the non-client area of the main window, we just need
+
+    $ncw = $main->Width() - $main->ScaleWidth();
+    $nch = $main->Height() - $main->ScaleHeight();
+
+Now, we get the required size as
+
+    $w = $label->Width() + $ncw;
+    $h = $label->Height() + $nch;
+
+As we are getting properties of the label, we should save the return value of
+the AddLabel() call - which is a reference to the label - in a variable
+$label.
+
+And we set the main window's size using Resize()
+
+    $main->Resize($w, $h);
+
+We have to resize after we have created the window, because we need to create
+the window first in order to calculate the non-client dimensions. But we do it
+before we show the window, to avoid any flicker.
+
+OK, let's put all this together. We'll add the ability to specify the label
+text on the command line, just to be fancy (it also shows that the values of
+options can be set using variables, not just constant values).
+
+    use Win32::GUI;
+
+    $text = defined($ARGV[0]) ? $ARGV[0] : "Hello, world";
+
+    $main = Win32::GUI::Window->new(-name => 'Main', -text => 'Perl');
+    $label = $main->AddLabel(-text => $text);
+
+    $ncw = $main->Width()  - $main->ScaleWidth();
+    $nch = $main->Height() - $main->ScaleHeight();
+    $w = $label->Width()  + $ncw;
+    $h = $label->Height() + $nch;
+
+    $main->Resize($w, $h);
+    $main->Show();
+    Win32::GUI::Dialog();
+
+    sub Main_Terminate {
+        -1;
+    }
+
+Run this version and see the results. Note that if you supply a short string,
+the window will not shrink beyond a minimum size sufficient to show the window
+icons.
+
+=for HTML <BR><CENTER><IMG SRC="guitut1-2.gif"></CENTER>
+
+=head2 Changing the appearance of the text
+
+Now, suppose we want to change the colour in which the text is displayed. This
+is easy. You just specify the colour as the value of the C<-foreground>
+attribute of the label. Colours can be specified either as hex values in the
+format 0xBBGGRR, or as list references in the format [ R, G, B ].
+
+So, to make the text red, use C<-foreground =E<gt> 0x0000FF> or C<-foreground
+=E<gt> [ 255, 0, 0 ]>.
+
+To change the font, you need to specify the C<-font> attribute. But in this
+case, the value of the attribute is a Win32::GUI::Font object. To create a
+font object, use
+
+    $font = Win32::GUI::Font->new(...);
+
+As usual, the parameters to new() are a set of options. The most important
+ones are
+
+=over 4
+
+=item * -size
+
+The font size in points.
+
+=for HTML <P>
+
+=item * -name
+
+The font name, such as "Times New Roman", "Arial", "Verdana" or
+"Comic Sans MS".
+
+=for HTML <P>
+
+=item * -bold
+
+One for bold, zero (the default) for non-bold.
+
+=for HTML <P>
+
+=item * -italic
+
+One for italic, zero (the default) for non-italic.
+
+=back
+
+So, to change the format of our label, all we need is
+
+    $font = Win32::GUI::Font->new(
+		-name => "Comic Sans MS", 
+		-size => 24,
+	);
+    $label = $main->AddLabel(
+		-text       => $text,
+		-font       => $font,
+		-foreground => [255, 0, 0],
+	);
+
+=for HTML <BR><CENTER><IMG SRC="guitut1-3.gif"></CENTER>
+
+Simple, isn't it?
+
+=head2 Centring the window and the text
+
+To centre the main window on the screen, we need to know the screen size. We
+get this using the I<desktop window>. You can get the handle of the desktop
+window using Win32::GUI::GetDesktopWindow(). One point to note is that window
+handles are B<not> Win32::GUI::Window objects, so they cannot be used to call
+Win32::GUI methods like Height(). However, these methods are overloaded so
+that they can be called directly (as Win32::GUI::Height()) with a window
+handle as an extra first parameter. See the code below for an example.
+
+The rest of the work is just arithmetic. To reposition the main window, use
+the Move() method.
+
+    # Assume we have the main window size in ($w, $h) as before
+    $desk = Win32::GUI::GetDesktopWindow();
+    $dw = Win32::GUI::Width($desk);
+    $dh = Win32::GUI::Height($desk);
+    $x = ($dw - $w) / 2;
+    $y = ($dh - $h) / 2;
+    $main->Move($x, $y);
+
+Now, we will look at centring the label in the window (you will notice that if
+you increase the size of the window, the text stays at the top left of the
+window).
+
+The process is similar to the calculations for centring the window above.
+There are two main differences. First of all, the label needs to be recentred
+every time the window changes size - so we need to do the calculations in a
+Resize event handler. The second difference (which in theory applies to the
+window as well, but which we ignored above), is that we need to watch out for
+the case where the window is too small to contain the label. Just to make
+things interesting, we'll stop the main window getting that small, by resizing
+it in the event handler if that is about to happen. As the width could be too
+small while the height is OK, we have to reset the width and height
+individually. We can do this using variations on the Width() and Height()
+methods, with a single parameter which specifies the value to set.
+
+OK, let's just do it.
+
+    sub Main_Resize {
+        my $w = $main->Width();
+        my $h = $main->Height();
+        my $lw = $label->Width();
+        my $lh = $label->Height();
+        if ($lw > $w) {
+            $main->Width($lw) + $ncw; # Remember the non-client width!
+        }
+        else {
+            $label->Left(($w - $lw) / 2);
+        }
+        if ($lh > $h) {
+            $main->Height($lh) + $nch; # Remember the non-client height!
+        }
+        else {
+            $label->Top(($h - $lh) / 2);
+        }
+    }
+
+This does not work in build 340 of Win32::GUI, as there is a bug in the Left()
+and Top() methods for client windows (such as the label used here). Hopefully,
+this bug will be fixed in the next version.
+
+Note that co-ordinates are calculated from the top left of the enclosing
+window.
+
+=head2 Restricting the minimum size of the window
+
+Suppose we wanto to ensure that our main window never gets smaller than
+100x100 pixels. We could include code in a resize event, like we did in the
+previous section to make sure the window never got smaller than the label.
+However, this can result in fairly bad flickering. A better solution is to use
+the C<-minsize> option.
+
+    $main = Win32::GUI::Window->new(
+		-name => 'Main',
+		-text => 'Perl',
+		-minsize => [100, 100],
+	);
+
+Simple! But in the previous example, we wanted to restrict the window size to
+the size of the label. We can't do this when we create the window, because we
+haven't created the label yet. But we can still do this - we just have to set
+the window's C<-minsize> option after the label has been created. We do this
+with the Change() method. We just specify this before resizing the window, in
+our initial setup.
+
+    $main->Change(-minsize => [$w, $h]);
+
+=head2 Putting it all together
+
+OK, we now have a nice, fully working GUI application. Here it is, in all its
+glory.
+
+    use Win32::GUI;
+
+    $text = defined($ARGV[0]) ? $ARGV[0] : "Hello, world";
+
+    $main = Win32::GUI::Window->new(
+		-name => 'Main',
+		-text => 'Perl',
+	);
+    $font = Win32::GUI::Font->new(
+		-name => "Comic Sans MS", 
+		-size => 24,
+	);
+    $label = $main->AddLabel(
+		-text => $text,
+		-font => $font,
+		-foreground => [255, 0, 0],
+	);
+
+    $ncw = $main->Width() -  $main->ScaleWidth();
+    $nch = $main->Height() - $main->ScaleHeight();
+    $w = $label->Width()  + $ncw;
+    $h = $label->Height() + $nch;
+
+    $desk = Win32::GUI::GetDesktopWindow();
+    $dw = Win32::GUI::Width($desk);
+    $dh = Win32::GUI::Height($desk);
+    $x = ($dw - $w) / 2;
+    $y = ($dh - $h) / 2;
+
+    $main->Change(-minsize => [$w, $h]);
+    $main->Move($x, $y);
+    $main->Show();
+
+    Win32::GUI::Dialog();
+
+    sub Main_Terminate {
+	-1;
+    }
+
+    sub Main_Resize {
+        my $w = $main->ScaleWidth();
+        my $h = $main->ScaleHeight();
+        my $lw = $label->Width();
+        my $lh = $label->Height();
+		$label->Left(int(($w - $lw) / 2));
+		$label->Top(int(($h - $lh) / 2));
+    }
+
+That's it for this tutorial. In part 2, we will start looking at some other
+controls.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/tut/guitut2.html perl-libwin32-0.191/GUI/docs/tut/guitut2.html
--- libwin32-0.191/GUI/docs/tut/guitut2.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/tut/guitut2.html	2004-01-12 16:46:41.578125000 -0800
@@ -0,0 +1,195 @@
+<HTML>
+<HEAD>
+<TITLE>Win32::GUI Tutorial - Part 2 - Adding functionality</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+
+<UL>
+
+	<LI><A HREF="#Win32_GUI_Tutorial_Part_2_A">Win32::GUI Tutorial - Part 2 - Adding functionality</A>
+	<UL>
+
+		<LI><A HREF="#Some_more_control_types">Some more control types</A>
+		<LI><A HREF="#Summary_of_the_Available_Control">Summary of the Available Controls</A>
+		<LI><A HREF="#Some_control_specific_issues">Some control-specific issues</A>
+	</UL>
+
+</UL>
+<!-- INDEX END -->
+
+<HR>
+<P>
+<H1><A NAME="Win32_GUI_Tutorial_Part_2_A">Win32::GUI Tutorial - Part 2 - Adding functionality</A></H1>
+<P>
+<HR>
+<H2><A NAME="Some_more_control_types">Some more control types</A></H2>
+<P>
+In part 1 of this tutorial, we covered the basics of Win32::GUI
+programming, using a simple label control to display information. But
+real-world applications don't just display information as labels. We need
+to be able to obtain information from the user, respond to mouse clicks,
+etc etc.
+
+<P>
+Some of the basic Windows controls supported by Win32::GUI include
+
+<UL>
+<LI>
+<P>
+Buttons, for taking actions.
+
+<LI>
+<P>
+Edit boxes, for data entry.
+
+<LI>
+<P>
+Checkboxes, for selecting options from a list.
+
+<LI>
+<P>
+Radio buttons, for choosing from mutually exclusive options.
+
+<LI>
+<P>
+Combo boxes and list boxes, for selection from lists.
+
+<LI>
+<P>
+And many other more complex controls, such as list views, tree views,
+status bars, tab strips, etc.
+
+</UL>
+<P>
+We have already covered nearly all of the programming techniques for using
+these controls in our discussion of the label control in part 1. The
+following section summarises the basic controls available, and any
+important issues regarding their use. Armed with this and the main
+Win32::GUI documentation, it should be possible to develop reasonably
+complex applications.
+
+<P>
+<HR>
+<H2><A NAME="Summary_of_the_Available_Control">Summary of the Available Controls</A></H2>
+<P>
+For this part of the tutorial, we will use a very basic ``framework''
+application, to which we can add functionality. We won't worry about issues
+like positioning, layout, resizing, etc, as these will only distract from
+the main point, which is the control handling.
+
+<P>
+So, our basic application is
+
+<P>
+<PRE>    use Win32::GUI;
+</PRE>
+<P>
+<PRE>    $main = Win32::GUI::Window-&gt;new(-name =&gt; 'Main', -text =&gt; 'Perl',
+                                    -width =&gt; 200, -height =&gt; 200);
+</PRE>
+<P>
+<PRE>    $main-&gt;Show();
+    Win32::GUI::Dialog();
+</PRE>
+<P>
+<PRE>    sub Main_Terminate {
+        -1;
+    }
+</PRE>
+<P>
+Now, the basic approach to adding any control to a window is the same. We
+saw it before, when we added a label. We simply use the window's
+<CODE>AddXXX()</CODE> method, where <CODE>XXX</CODE> is the control type we want to add. So, we have, <CODE>AddButton(),</CODE>
+<CODE>AddTextfield(),</CODE> <CODE>AddCheckbox(),</CODE>
+<CODE>AddCombobox(),</CODE> <CODE>AddListbox(),</CODE>
+<CODE>AddRadioButton(),</CODE> etc.
+
+<P>
+All of these methods work the same way, in that they take a series of
+options, which define the appearance and behaviour of the control. Many of
+the options are common to all Win32::GUI controls (such as <CODE>-width</CODE> and <CODE>-height</CODE>) but a few are control-specific.
+
+<P>
+The controls themselves support events, much like the main window with its
+<CODE>Terminate</CODE> event. Events are control-specific, but tend to be fairly general (many
+controls have a <CODE>Click</CODE> event, which occurs when the user clicks the mouse on the control, for
+example).
+
+<P>
+<HR>
+<H2><A NAME="Some_control_specific_issues">Some control-specific issues</A></H2>
+<DL>
+<DT><STRONG><A NAME="item_Labels">Labels</A></STRONG><DD>
+<P>
+None. We saw labels in some detail in the last part of this tutorial. Most
+of what we learnt applies equally to all other controls.
+
+<DT><STRONG><A NAME="item_Buttons">Buttons</A></STRONG><DD>
+<P>
+None. To make a button do something, add a handler for the <CODE>Click</CODE> event.
+
+<DT><STRONG><A NAME="item_Check">Check Boxes</A></STRONG><DD>
+<P>
+To get or set the ``checked'' state, use the <CODE>Checked()</CODE> method.
+There are three states - unchecked (0), checked (1) and indeterminate or
+grayed (2). Use the
+<CODE>Click</CODE> event to respond to changes in state.
+
+<DT><STRONG><A NAME="item_Text">Text Fields</A></STRONG><DD>
+<P>
+To get or set the contents of the text field, use the <CODE>-text</CODE> option. The
+<CODE>-multiline</CODE> option allows entry of more than one line of text (but beware - the <CODE>-text</CODE> option contains a CRLF sequence (``\r\n'') at the end of each line, not
+just LF (``\n'') as is normal for Perl. See the documentation for the
+<CODE>-prompt</CODE> option to automatically add a label to a text field.
+
+<DT><STRONG><A NAME="item_Progress">Progress Bars</A></STRONG><DD>
+<P>
+A display-only control. Set the parameters with the <CODE>SetRange()</CODE>
+and <CODE>SetStep()</CODE> methods, and update the display using the
+<CODE>SetPos()</CODE> or <CODE>StepIt()</CODE> methods.
+
+<DT><STRONG><A NAME="item_List">List Boxes</A></STRONG><DD>
+<P>
+By default, there are no items in the list. Fill the list box using the
+<CODE>AddString()</CODE> method. Get the selected item using the
+<CODE>SelectedItem()</CODE> method. Multiple-selection listboxes are
+created using the <CODE>-multisel</CODE> option -- in that case, use the <CODE>SelectedItems()</CODE> method to get
+a list of all the selected items.
+
+<DT><STRONG><A NAME="item_Combo">Combo Boxes</A></STRONG><DD>
+<P>
+Similar to single-selection list boxes (although they display differently).
+
+<DT><STRONG><A NAME="item_UpDown">UpDown Controls</A></STRONG><DD>
+<P>
+This is the little double-arrow control you often see attached to numeric
+text fields in dialog boxes. Clicking the up arrow increases the value of
+the text field, whereas clicking the down arrow decreases it.
+
+<P>
+The only significant complication with using an UpDown control is the need
+to associate it with a text box. This is done using the
+<CODE>Buddy()</CODE> method, as
+
+<P>
+<PRE>    $updown-&gt;Buddy($text)
+</PRE>
+<P>
+Methods exist to set the range of values for the control, and to explicitly
+set the value of the control. The control supports a <CODE>Scroll</CODE> event, which is fired when the control value changes (but not when the
+associated text box changes!) The UpDown control's size is ignored, as it
+is attached to its buddy when it is created.
+
+</DL>
+<P>
+This covers the basic controls available in Win32::GUI. In part 3, we will
+cover some of the subtleties of dialog boxes and main windows, and then in
+part 4, we will be ready to cover some of the more complex user interface
+options.
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/tut/guitut2.pod perl-libwin32-0.191/GUI/docs/tut/guitut2.pod
--- libwin32-0.191/GUI/docs/tut/guitut2.pod	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/tut/guitut2.pod	2004-01-12 16:46:41.593750000 -0800
@@ -0,0 +1,150 @@
+=head1 Win32::GUI Tutorial - Part 2 - Adding functionality
+
+=head2 Some more control types
+
+In part 1 of this tutorial, we covered the basics of Win32::GUI programming,
+using a simple label control to display information. But real-world
+applications don't just display information as labels. We need to be able to
+obtain information from the user, respond to mouse clicks, etc etc.
+
+Some of the basic Windows controls supported by Win32::GUI include
+
+=over 4
+
+=item *
+
+Buttons, for taking actions.
+
+=item *
+
+Edit boxes, for data entry.
+
+=item *
+
+Checkboxes, for selecting options from a list.
+
+=item *
+
+Radio buttons, for choosing from mutually exclusive options.
+
+=item *
+
+Combo boxes and list boxes, for selection from lists.
+
+=item *
+
+And many other more complex controls, such as list views, tree views, status
+bars, tab strips, etc.
+
+=back
+
+We have already covered nearly all of the programming techniques for using
+these controls in our discussion of the label control in part 1. The following
+section summarises the basic controls available, and any important issues
+regarding their use. Armed with this and the main Win32::GUI documentation, it
+should be possible to develop reasonably complex applications.
+
+=head2 Summary of the Available Controls
+
+For this part of the tutorial, we will use a very basic "framework"
+application, to which we can add functionality. We won't worry about issues
+like positioning, layout, resizing, etc, as these will only distract from the
+main point, which is the control handling.
+
+So, our basic application is
+
+    use Win32::GUI;
+
+    $main = Win32::GUI::Window->new(-name => 'Main', -text => 'Perl',
+				    -width => 200, -height => 200);
+
+    $main->Show();
+    Win32::GUI::Dialog();
+
+    sub Main_Terminate {
+	-1;
+    }
+
+Now, the basic approach to adding any control to a window is the same. We saw
+it before, when we added a label. We simply use the window's AddXXX() method,
+where C<XXX> is the control type we want to add. So, we have, AddButton(),
+AddTextfield(), AddCheckbox(), AddCombobox(), AddListbox(), AddRadioButton(),
+etc.
+
+All of these methods work the same way, in that they take a series of options,
+which define the appearance and behaviour of the control. Many of the options
+are common to all Win32::GUI controls (such as C<-width> and C<-height>) but a
+few are control-specific.
+
+The controls themselves support events, much like the main window with its
+C<Terminate> event. Events are control-specific, but tend to be fairly general
+(many controls have a C<Click> event, which occurs when the user clicks the
+mouse on the control, for example).
+
+=head2 Some control-specific issues
+
+=over 4
+
+=item Labels
+
+None. We saw labels in some detail in the last part of this tutorial. Most of
+what we learnt applies equally to all other controls.
+
+=item Buttons
+
+None. To make a button do something, add a handler for the C<Click> event.
+
+=item Check Boxes
+
+To get or set the "checked" state, use the Checked() method. There are three
+states - unchecked (0), checked (1) and indeterminate or grayed (2). Use the
+C<Click> event to respond to changes in state.
+
+=item Text Fields
+
+To get or set the contents of the text field, use the C<-text> option. The
+C<-multiline> option allows entry of more than one line of text (but beware -
+the C<-text> option contains a CRLF sequence ("\r\n") at the end of each line,
+not just LF ("\n") as is normal for Perl. See the documentation for the
+C<-prompt> option to automatically add a label to a text field.
+
+=item Progress Bars
+
+A display-only control. Set the parameters with the SetRange() and SetStep()
+methods, and update the display using the SetPos() or StepIt() methods.
+
+=item List Boxes
+
+By default, there are no items in the list. Fill the list box using the
+AddString() method. Get the selected item using the SelectedItem() method.
+Multiple-selection listboxes are created using the C<-multisel> option -- in
+that case, use the SelectedItems() method to get a list of all the selected
+items.
+
+=item Combo Boxes
+
+Similar to single-selection list boxes (although they display differently).
+
+=item UpDown Controls
+
+This is the little double-arrow control you often see attached to numeric text
+fields in dialog boxes. Clicking the up arrow increases the value of the text
+field, whereas clicking the down arrow decreases it.
+
+The only significant complication with using an UpDown control is the need to
+associate it with a text box. This is done using the Buddy() method, as
+
+    $updown->Buddy($text)
+
+Methods exist to set the range of values for the control, and to explicitly
+set the value of the control. The control supports a C<Scroll> event, which is
+fired when the control value changes (but not when the associated text box
+changes!) The UpDown control's size is ignored, as it is attached to its buddy
+when it is created.
+
+=back
+
+This covers the basic controls available in Win32::GUI. In part 3, we will
+cover some of the subtleties of dialog boxes and main windows, and then in
+part 4, we will be ready to cover some of the more complex user interface
+options.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/tut/guitut3.html perl-libwin32-0.191/GUI/docs/tut/guitut3.html
--- libwin32-0.191/GUI/docs/tut/guitut3.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/tut/guitut3.html	2004-01-12 16:46:41.609375000 -0800
@@ -0,0 +1,134 @@
+<HTML>
+<HEAD>
+<TITLE>Win32::GUI Tutorial - Part 3 - Dialog Boxes and Main Windows</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+
+<UL>
+
+	<LI><A HREF="#Win32_GUI_Tutorial_Part_3_D">Win32::GUI Tutorial - Part 3 - Dialog Boxes and Main Windows</A>
+	<UL>
+
+		<LI><A HREF="#What_is_a_Dialog_Box_">What is a Dialog Box?</A>
+		<LI><A HREF="#Keyboard_handling">Keyboard handling</A>
+		<LI><A HREF="#Other_Differences">Other Differences</A>
+	</UL>
+
+</UL>
+<!-- INDEX END -->
+
+<HR>
+<P>
+<H1><A NAME="Win32_GUI_Tutorial_Part_3_D">Win32::GUI Tutorial - Part 3 - Dialog Boxes and Main Windows</A></H1>
+<P>
+<HR>
+<H2><A NAME="What_is_a_Dialog_Box_">What is a Dialog Box?</A></H2>
+<P>
+So far, in this tutorial, we have been creating our main window using the
+Win32::GUI::Window-&gt;new() constructor. While this works fine, Win32::GUI
+actually offers <EM>two</EM> classes of main window.
+
+<P>
+The first of these is the Win32::GUI::Window we have been using all along,
+and the second is Win32::GUI::DialogBox.
+
+<P>
+``Why two classes?'', you may ask. Basically, the reason is that a
+DialogBox adds extra functionality to the window which is not available
+with a simple Window. But the extra functionality has a cost, which means
+that we still make WIndow available for people who don't want the extra
+functionality of a DialogBox, or who don't want to pay the extra cost.
+(Actually, there's a further reason, which is that a Win32::GUI::DialogBox
+loses some of the flexibility which a Win32::GUI::Window has - this is a
+limitation of Win32::GUI, not of Windows itself, and may go away in a
+future version - there may even be workarounds available already. See below
+for a more complete picture.
+
+<P>
+<HR>
+<H2><A NAME="Keyboard_handling">Keyboard handling</A></H2>
+<P>
+The main advantage that a DialogBox has over a basic Window, is that
+Win32::GUI automatically performs certain types of keyboard handling for
+you if you use a DialogBox. (The handling in question is the standard
+Windows actions - Tab moves between controls, Shift-Tab moves backwards,
+Escape cancels the dialog, and Return does the ``default'' action).
+
+<P>
+To make the keyboard handling work properly, you need to add a number of
+options to your controls.
+
+<DL>
+<DT><STRONG><A NAME="item_Tab">Tab and Shift-Tab</A></STRONG><DD>
+<P>
+To make the tab keys work as expected, you need to add the <CODE>-tabstop =&amp;gt;
+1</CODE> option to your controls. The tab keys move the focus between the controls
+with the <CODE>-tabstop</CODE> option set. Other controls will be ignored when tabbing.
+
+<DT><STRONG><A NAME="item_Escape">Escape</A></STRONG><DD>
+<P>
+To make the escape key work as expected, you need to define a button with
+the
+<CODE>-cancel =&amp;gt; 1</CODE> option. When the user presses the escape key, Windows will translate that
+action into a <CODE>Click</CODE> event on the cancel button. It is normal to give this button a caption of <CODE>&quot;Cancel&quot;</CODE> and to make its click event handler close the window without applying any
+changes - but this is up to you to implement. Windows just fires the
+relevant event.
+
+<DT><STRONG><A NAME="item_Return">Return</A></STRONG><DD>
+<P>
+To make the return key work as expected, you need to give one of your
+dialog's buttons the <CODE>-default =&amp;gt; 1</CODE> option. When the return key is pressed, it is translated into a click event
+on the default button. The default button is also highlighted differently
+from the other buttons (it has a dark border).
+<STRONG>Note:</STRONG> There is a related option, <CODE>-ok =&amp;gt; 1</CODE>, which has a similar effect as <CODE>-default</CODE>. However, the two seem to conflict in their effects. I would recommend
+that if your default button has the caption <CODE>&quot;OK&quot;</CODE>, you should set both the <CODE>-ok</CODE> and <CODE>-default</CODE> options. Otherwise, stick with just
+<CODE>-default</CODE>.
+
+</DL>
+<P>
+There are other default keyboard actions which occur, but you either don't
+need to, or can't, write code to handle them.
+
+<P>
+<HR>
+<H2><A NAME="Other_Differences">Other Differences</A></H2>
+<P>
+As well as the keyboard handling, the main difference between a DialogBox
+and a basic Window is that a DialogBox has a much more limited set of
+options available for controlling its appearance. Specifically
+
+<UL>
+<LI>
+<P>
+A DialogBox has no Minimize or Maximize icons.
+
+<LI>
+<P>
+A DialogBox has a ``?'' (help) icon.
+
+<LI>
+<P>
+A DialogBox has a slightly different look.
+
+<LI>
+<P>
+A DialogBox cannot be resized.
+
+</UL>
+<P>
+In most cases, the key issues will be whether you need the keyboard
+handling, and whether you need the user to be able to resize your windows.
+Otherwise, the choice is arbitrary. To switch types, the only change you
+need to make is the name of the constructor you use to create your
+application's main window.
+
+<P>
+In the next part, we will cover some further ways in which you can increase
+your application's functionality.
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/tut/guitut3.pod perl-libwin32-0.191/GUI/docs/tut/guitut3.pod
--- libwin32-0.191/GUI/docs/tut/guitut3.pod	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/tut/guitut3.pod	2004-01-12 16:46:41.625000000 -0800
@@ -0,0 +1,100 @@
+=head1 Win32::GUI Tutorial - Part 3 - Dialog Boxes and Main Windows
+
+=head2 What is a Dialog Box?
+
+So far, in this tutorial, we have been creating our main window using the
+Win32::GUI::Window->new() constructor. While this works fine, Win32::GUI
+actually offers I<two> classes of main window.
+
+The first of these is the Win32::GUI::Window we have been using all along, and
+the second is Win32::GUI::DialogBox.
+
+"Why two classes?", you may ask. Basically, the reason is that a DialogBox
+adds extra functionality to the window which is not available with a simple
+Window. But the extra functionality has a cost, which means that we still make
+WIndow available for people who don't want the extra functionality of a
+DialogBox, or who don't want to pay the extra cost. (Actually, there's a
+further reason, which is that a Win32::GUI::DialogBox loses some of the
+flexibility which a Win32::GUI::Window has - this is a limitation of
+Win32::GUI, not of Windows itself, and may go away in a future version - there
+may even be workarounds available already. See below for a more complete
+picture.
+
+=head2 Keyboard handling
+
+The main advantage that a DialogBox has over a basic Window, is that
+Win32::GUI automatically performs certain types of keyboard handling for you
+if you use a DialogBox. (The handling in question is the standard Windows
+actions - Tab moves between controls, Shift-Tab moves backwards, Escape
+cancels the dialog, and Return does the "default" action).
+
+To make the keyboard handling work properly, you need to add a number of
+options to your controls.
+
+=over 4
+
+=item Tab and Shift-Tab
+
+To make the tab keys work as expected, you need to add the C<-tabstop =E<gt>
+1> option to your controls. The tab keys move the focus between the controls
+with the C<-tabstop> option set. Other controls will be ignored when tabbing.
+
+=item Escape
+
+To make the escape key work as expected, you need to define a button with the
+C<-cancel =E<gt> 1> option. When the user presses the escape key, Windows will
+translate that action into a C<Click> event on the cancel button. It is normal
+to give this button a caption of C<"Cancel"> and to make its click event
+handler close the window without applying any changes - but this is up to you
+to implement. Windows just fires the relevant event.
+
+=item Return
+
+To make the return key work as expected, you need to give one of your dialog's
+buttons the C<-default =E<gt> 1> option. When the return key is pressed, it is
+translated into a click event on the default button. The default button is
+also highlighted differently from the other buttons (it has a dark border).
+B<Note:> There is a related option, C<-ok =E<gt> 1>, which has a similar
+effect as C<-default>. However, the two seem to conflict in their effects. I
+would recommend that if your default button has the caption C<"OK">, you
+should set both the C<-ok> and C<-default> options. Otherwise, stick with just
+C<-default>.
+
+=back
+
+There are other default keyboard actions which occur, but you either don't
+need to, or can't, write code to handle them.
+
+=head2 Other Differences
+
+As well as the keyboard handling, the main difference between a DialogBox and
+a basic Window is that a DialogBox has a much more limited set of options
+available for controlling its appearance. Specifically
+
+=over 4
+
+=item *
+
+A DialogBox has no Minimize or Maximize icons.
+
+=item *
+
+A DialogBox has a "?" (help) icon.
+
+=item *
+
+A DialogBox has a slightly different look.
+
+=item *
+
+A DialogBox cannot be resized.
+
+=back
+
+In most cases, the key issues will be whether you need the keyboard handling,
+and whether you need the user to be able to resize your windows. Otherwise,
+the choice is arbitrary. To switch types, the only change you need to make is
+the name of the constructor you use to create your application's main window.
+
+In the next part, we will cover some further ways in which you can increase
+your application's functionality.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/tut/guitut4.html perl-libwin32-0.191/GUI/docs/tut/guitut4.html
--- libwin32-0.191/GUI/docs/tut/guitut4.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/tut/guitut4.html	2004-01-12 16:46:41.640625000 -0800
@@ -0,0 +1,215 @@
+<HTML>
+<HEAD>
+<TITLE>Win32::GUI Tutorial - Part 4 - Further Features of Win32::GUI</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+
+<UL>
+
+	<LI><A HREF="#Win32_GUI_Tutorial_Part_4_F">Win32::GUI Tutorial - Part 4 - Further Features of Win32::GUI</A>
+	<UL>
+
+		<LI><A HREF="#Timers">Timers</A>
+		<LI><A HREF="#Status_Bars">Status Bars</A>
+		<LI><A HREF="#System_Tray_Icons">System Tray Icons</A>
+	</UL>
+
+</UL>
+<!-- INDEX END -->
+
+<HR>
+<P>
+<H1><A NAME="Win32_GUI_Tutorial_Part_4_F">Win32::GUI Tutorial - Part 4 - Further Features of Win32::GUI</A></H1>
+<P>
+<HR>
+<H2><A NAME="Timers">Timers</A></H2>
+<P>
+Many types of application need to be able to perform an action at regular
+intervals. The obvious example is a clock application, but other examples
+might be
+
+<UL>
+<LI>
+<P>
+A file viewer, which watches at regular intervals to see if the file being
+displayed has changed, and shows the new contents if it has.
+
+<LI>
+<P>
+A monitor application (like the WIndows NT performance monitor) which
+displays updated information every second.
+
+<LI>
+<P>
+A network ``ping'' utility, which polls a remote server at regular
+intervals, to see that it is still running.
+
+</UL>
+<P>
+Adding a timer to your application is easy. All you do is call the
+<CODE>AddTimer()</CODE> method on the window you want to ``own'' the timer.
+When the timer expires, its
+<CODE>Timer</CODE> event is fired, which you can catch in the normal way.
+
+<P>
+For example,
+
+<P>
+<PRE>    $t1 = $main-&gt;AddTimer('T1', 1000);
+</PRE>
+<P>
+<PRE>    sub T1_Timer {
+        print &quot;Timer went off!\n&quot;;
+    }
+</PRE>
+<P>
+Some things to note:
+
+<UL>
+<LI>
+<P>
+The <CODE>AddTimer()</CODE> method takes two explicit parameters, the timer
+name and the interval (in milliseconds). The normal <CODE>option =&amp;gt; value</CODE> syntax is <STRONG>not</STRONG>
+used.
+
+<LI>
+<P>
+The timer keeps firing repeatedly. To disable a timer, use
+$timer-&gt;Kill().
+
+<LI>
+<P>
+To reset the interval of a timer, use $timer-&gt;Interval(n). Setting an
+interval of zero disables the timer.
+
+</UL>
+<P>
+That's about all there is to timers.
+
+<P>
+<HR>
+<H2><A NAME="Status_Bars">Status Bars</A></H2>
+<P>
+To add a status bar to your window, just use
+
+<P>
+<PRE>    $sb = $main-&gt;AddStatusBar();
+</PRE>
+<P>
+The normal options are available, but in general you don't need them.
+
+<P>
+The only surprise is that your status bar will <STRONG>not</STRONG> resize automatically when your main window resizes. You need to include
+code in your main window resize event handler to resize the status bar. The
+following code will do the job:
+
+<P>
+<PRE>    sub Main_Resize {
+        $sb-&gt;Move(0, $main-&gt;ScaleHeight - $sb-&gt;Height);
+        $sb-&gt;Resize($main-&gt;ScaleWidth, $sb-&gt;Height);
+    }
+</PRE>
+<P>
+You can write text to your status bar using the <CODE>Text()</CODE> method.
+
+<P>
+<PRE>    $sb-&gt;Text(&quot;This appears in the status bar&quot;);
+</PRE>
+<P>
+To clear the status bar, just write an empty string.
+
+<P>
+<HR>
+<H2><A NAME="System_Tray_Icons">System Tray Icons</A></H2>
+<P>
+Many utility programs these days add an icon to the Windows ``System Tray''
+- the small area on the taskbar near the clock. Once again, this is easy
+with Win32::GUI - you simply use the <CODE>AddNotifyIcon()</CODE> method. A
+notify icon has four key properties - a name (which is used for event
+handling, just like for any other Win32::GUI object), an ID (which is just
+a unique number, used internally, you specify it and then ignore it), a
+tooltip (a string which is displayed when you hold the mouse pointer over
+the icon) and an icon (a Win32::GUI::Icon object - you create this using
+the <CODE>new()</CODE> constructor, passing the name of the .ico file to
+use). Notify icons have Click and RightClick events, to let you process
+mouse clicks.
+
+<P>
+The normal protocol for an application which uses a notify icon is for the
+main window to start hidden, and to show the window when the icon is
+clicked. When the main window is minimised, it hides itself, leaving just
+the notify icon visible.
+
+<P>
+The simplest way to demonstrate this is to show some working code...
+
+<P>
+<PRE>    use Win32::GUI;
+</PRE>
+<P>
+<PRE>    $main = Win32::GUI::Window-&gt;new(-name =&gt; 'Main', -text =&gt; 'Perl',
+                                    -width =&gt; 200, -height =&gt; 200);
+</PRE>
+<P>
+<PRE>    $icon = new Win32::GUI::Icon('GUIPERL.ICO');
+    $ni = $main-&gt;AddNotifyIcon(-name =&gt; &quot;NI&quot;, -id =&gt; 1,
+                               -icon =&gt; $icon, -tip =&gt; &quot;Hello&quot;);
+</PRE>
+<P>
+<PRE>    Win32::GUI::Dialog();
+</PRE>
+<P>
+<PRE>    sub Main_Terminate {
+        -1;
+    }
+</PRE>
+<P>
+<PRE>    sub Main_Minimize {
+        $main-&gt;Disable();
+        $main-&gt;Hide();
+        1;
+    }
+</PRE>
+<P>
+<PRE>    sub NI_Click {
+        $main-&gt;Enable();
+        $main-&gt;Show();
+        1;
+    }
+</PRE>
+<P>
+Some points to note
+
+<UL>
+<LI>
+<P>
+To remove the window's icon from the taskbar, it is necessary to diable the
+window as well as hiding it. And hence, when we show the window again, we
+need to re-enable it.
+
+<LI>
+<P>
+There is a small bug in this program. The tray icon does not disappear
+immediately when the program terminates. Instead, it remains in the system
+tray until you point the mouse cursor at it, when it disappears. This is a
+bug in Win32::GUI - when you close your program, you should explicitly
+remove any system tray icons you still have displayed. Win32::GUI does not
+(yet) have a way of removing a tray icon. Hopefully, this will be fixed in
+a later version.
+
+</UL>
+<P>
+That's it for the simpler objects available in the Win32::GUI package. Even
+though I have referred to them as simple, it is possible to create some
+fairly complicated applications using just what we have seen so far.
+
+<P>
+In the next couple of tutorials, I will move on to the more sophisticated
+controls available - list views and tree views.
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/tut/guitut4.pod perl-libwin32-0.191/GUI/docs/tut/guitut4.pod
--- libwin32-0.191/GUI/docs/tut/guitut4.pod	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/tut/guitut4.pod	2004-01-12 16:46:41.656250000 -0800
@@ -0,0 +1,165 @@
+=head1 Win32::GUI Tutorial - Part 4 - Further Features of Win32::GUI
+
+=head2 Timers
+
+Many types of application need to be able to perform an action at regular
+intervals. The obvious example is a clock application, but other examples
+might be
+
+=over 4
+
+=item *
+
+A file viewer, which watches at regular intervals to see if the file being
+displayed has changed, and shows the new contents if it has.
+
+=item *
+
+A monitor application (like the WIndows NT performance monitor) which displays
+updated information every second.
+
+=item *
+
+A network "ping" utility, which polls a remote server at regular intervals, to
+see that it is still running.
+
+=back
+
+Adding a timer to your application is easy. All you do is call the AddTimer()
+method on the window you want to "own" the timer. When the timer expires, its
+C<Timer> event is fired, which you can catch in the normal way.
+
+For example,
+
+    $t1 = $main->AddTimer('T1', 1000);
+
+    sub T1_Timer {
+        print "Timer went off!\n";
+    }
+
+Some things to note:
+
+=over 4
+
+=item *
+
+The AddTimer() method takes two explicit parameters, the timer name and the
+interval (in milliseconds). The normal C<option =E<gt> value> syntax is B<not>
+used.
+
+=item *
+
+The timer keeps firing repeatedly. To disable a timer, use $timer->Kill().
+
+=item *
+
+To change the interval of a timer (or to re-enable it after a Kill), use 
+$timer->Interval(n). Setting an interval of zero disables the timer, just
+like Kill.
+
+=back
+
+That's about all there is to timers.
+
+=head2 Status Bars
+
+To add a status bar to your window, just use
+
+    $sb = $main->AddStatusBar();
+
+The normal options are available, but in general you don't need them.
+
+The only surprise is that your status bar will B<not> resize automatically
+when your main window resizes. You need to include code in your main window
+resize event handler to resize the status bar. The following code will do the
+job:
+
+    sub Main_Resize {
+        $sb->Move(0, $main->ScaleHeight - $sb->Height);
+        $sb->Resize($main->ScaleWidth, $sb->Height);
+    }
+
+You can write text to your status bar using the Text() method.
+
+    $sb->Text("This appears in the status bar");
+
+To clear the status bar, just write an empty string.
+
+=head2 System Tray Icons
+
+Many utility programs these days add an icon to the Windows "System Tray" -
+the small area on the taskbar near the clock. Once again, this is easy with
+Win32::GUI - you simply use the AddNotifyIcon() method. A notify icon has four
+key properties - a name (which is used for event handling, just like for any
+other Win32::GUI object), an ID (which is just a unique number, used
+internally, you specify it and then ignore it), a tooltip (a string which is
+displayed when you hold the mouse pointer over the icon) and an icon (a
+Win32::GUI::Icon object - you create this using the new() constructor, passing
+the name of the .ico file to use). Notify icons have Click and RightClick
+events, to let you process mouse clicks.
+
+The normal protocol for an application which uses a notify icon is for the
+main window to start hidden, and to show the window when the icon is clicked.
+When the main window is minimised, it hides itself, leaving just the notify
+icon visible.
+
+The simplest way to demonstrate this is to show some working code...
+
+    use Win32::GUI;
+
+    $main = Win32::GUI::Window->new(-name => 'Main', -text => 'Perl',
+				    -width => 200, -height => 200);
+
+    $icon = new Win32::GUI::Icon('GUIPERL.ICO');
+    $ni = $main->AddNotifyIcon(-name => "NI", -id => 1,
+			       -icon => $icon, -tip => "Hello");
+
+    Win32::GUI::Dialog();
+
+    sub Main_Terminate {
+	-1;
+    }
+
+    sub Main_Minimize {
+	$main->Disable();
+	$main->Hide();
+	1;
+    }
+
+    sub NI_Click {
+	$main->Enable();
+	$main->Show();
+	1;
+    }
+
+Some points to note
+
+=over 4
+
+=item *
+
+To remove the window's icon from the taskbar, it is necessary to diable the
+window as well as hiding it. And hence, when we show the window again, we need
+to re-enable it.
+
+=item *
+
+There is a small bug in this program. The tray icon does not disappear
+immediately when the program terminates. Instead, it remains in the system
+tray until you point the mouse cursor at it, when it disappears. This is a bug
+in Win32::GUI - when you close your program, you should explicitly remove any
+system tray icons you still have displayed. Referring to the example above,
+you should place this line after the Win32::GUI::Dialog() call:
+
+	$main->NI->Delete(-id => 1);
+
+Hopefully, this will be fixed in a later version.
+
+=back
+
+That's it for the simpler objects available in the Win32::GUI package. Even
+though I have referred to them as simple, it is possible to create some fairly
+complicated applications using just what we have seen so far.
+
+In the next couple of tutorials, I will move on to the more sophisticated
+controls available - list views and tree views.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/tut/guitut5-1.gif perl-libwin32-0.191/GUI/docs/tut/guitut5-1.gif
--- libwin32-0.191/GUI/docs/tut/guitut5-1.gif	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/tut/guitut5-1.gif	2004-01-12 16:46:41.671875000 -0800
@@ -0,0 +1,42 @@
+GIF89a^        !!!111999BBBJJJRRRZBcccscsss{c{s{{{s{{,    ^   9H*\#JHx Ca(S\0cI5e@
+JH*]P:Sju`KvhMvpKwa3P
+s^ Lx+NxKLy/kyr  Xu
+|o{o<Gf7
++_.:UD	 Xl47@-`o>9{hH? 1tyzG^J9GP $^yabm'b$gT +&uShHU=\  <@ P 
+&eM8RfbZ5r",WW*%X O <GVWg!Q:dT
+(h1
+%FZe%
+&J	X
+"Hy'S**%jY +^H"x_f@D.d+a'+bj&i|+uZ=zRzh9P 0  Az-{ajEnWj9$HV=< nI&0KIjv$	(*`w!Z3Cwx#G]2u/;&l<R{ ^?>@-4Cs.vR=dar,X}%6RL$z{gx'nmzt/8Hds@dJgmf<p$=p0
+o2a+bAf[J}GG}@\ `s}0 0 4P>3L	YG2D_jUz,[B,7,\Y
+C E$"}D&"qFL]
+AC(V!gP_e$#6z\|HGqvd#XG>Tcgq]d"8CVcD)Zr$&7N>m#&mr$H-alg>R|-i^qa.yd<5"#()9LVdd"LH_!9JF<qIw&*Yd#:OXM'6Pj6]C'
+QJS#?1jo3,YNx<i>R!u%5Jc29SzfPJTmRh^"yRr$:>cS%""JYRt.jWR5eNV^f%+j^Z'\aU:edXRKQTe%'Wuy--j-vi8[PgmppSeg8iXvk:Wnj{6S~WitYI>6{_*mfmTJvEi|Exg[^C.t'rodA<vYy/4XTfV[+]
+8P~/Q,M}aY<\ e/gh]K&s)wFm<d-kmE'q<i.$		F3w-Nl&w}NUm\atZGnthZh6_L9Rj$uwt+j=1aTdr^k1F_[.FS:cMqao&1km+S|t#'N[w E1gB%yGN_&uB0gN\((p\e/w	:.FO:7&[X{`NhO"Zz R#5Y|rqx49'Os];zv{;zS=WZxbh!|
+KCz8z6EhBW7|lz_Ok=yA\tgBG  0">/tkK5+dr{Fpx k&'0'yGy]}CD8@( ])rGWs ,))2*ugX=CF};PvTY",o21%sOX<[,2-r-h-MG8NxrtyxO~{UD/CdY#5yoq'
+01r}E|{(koxhx"J(w4,r4,P?x;39uz8:8HDukX}Z*^:{Oaqb~	12 j1WFX|sH8fC{2 S_{ %u<e#9R9O8 }2"2rJ9;;8}B_<<'x2;uV+=":PivfS>r3yQYq/&S?D?j\G@n	@U+Eb=hAt ATA9eH ~`vsy4_n[t5][Sfu9Eo)	iY[yFn{9[VyiAsFg=dYoM6';_Iyid]jFkcNaFyh Jzgmz_tVj:jdU["*D(JFFbtJ.*GV0j/4z<3FSDzKz.1uH
+i	4O0J]AV8la`MnjkHm
+o:DqJskxgY%]kFG:hFb
+fyp%j*GLmFIa
+,Z(#*^CW{Q*J{'&hRjKVfRhJT>J*cj]%
+n`]jxm&jJ
+p*GvTG&fQJRvhb:fo(YfZ(D	quXkXjkyK	hskK6k 8;7
+mPz$; KN;P\:a}e)+[Cz@h?r:9={5l+ddZ-r{nc*mLkU{Zux)wisZX
+tKj{oKvtv&GRmRkl`;h+k+n6[62dCK][[{k[lK[~gn;nj/'*;z.Qk+{ZL"
+Ve,-\
+e|J;F\HNZj;l2:
+k/. lh|kzjpY[YG\ILlkM`QWi^+eg|H:Lk, k+Tv<"[|_+RY;*],Z
+zJ6:rLvXZ,<obl,Zi!|<|jiXkB<RIK,fOrg1zM\!}l&
+Lz\*790D-wH];zg+%M\&t\-<Iz2[,]|=mjSRx\&*&pO#qea+',d};oC<u}YR}m~m+	u\k):f=iC$<\r	f5Q{NL._daK}6lH]ixzSWS*[4
+Mi-LZ+|P=yk}C$.,l|Q;n.'m SlZ.o\pE^X=;wYko+qG=aFz&i
+m|#I>;y W[>`^.qM-n=3K-E}r[.Ji<BFN.I Z4Xvm	?}/-=>).I*N^]/4>/bF>cwLnb ~V&?Z(<.10~g~:mnTF|<!Ol)/-X{zQ^?.5#n	~N	?]n`6n^N)AC?L7`L<Q_~UF}l
+?g_cOOg2p_oq\n/T//2hX`A&x C:(aEB#F;Z9 Frh%A;t9r9q3M<SI"%Z16TCZU
+5IB%!M[r[%*V.c:tW'6IuzM(P>Fv9Q[2iS<9.`
+m*l]2wo_W{xk:u+1YHsw^`k]^8/OC	1zOB;mCsCDApnm{D@5,d,`(T)>(3MW$1,sP,bF*CR'M$q0"SOR
+dQ
+Jq24Rt v3F:u?WM4tPZq%tVdB4K3kG/(TS/CML4Z;KJMTSm[l =%W+%oXV=bUSjYc=SD.mv]8SQ;wOkax5>r\MxoCL{4YNv^VZfeG9&7O%%cvuZ _uN CWyUi&g[g1L6YipO3YUJZS;fEu	5IvV.vXNXcwq;n=l*/AgE7=]yEUWb}CO/wMi$%1#/'x-]&bv4^t=#%ls!\4?ma)W`C b@
+|5i979:	"!	}.`w!Q{>thrsOCJw}aCGEL%`B+^b/P@[c4QT]5B8(,rX>r FH:GCLrdI3R|LQ iYNRD<;#$."cxAM.]EIbvoMB\GF"9(s1cYI4$D_Fp:	@cW27X59S,) ThzBT;'@t
+GR)Q$i6~ 'UF0]]MwtaOyUQv,4Rs+5TRhlv4JdWlt@M
+UFOOg4T	(OeQUYf)U|2U=)KKtDXR&~+s2]tIIgp9\U>\=htaE2@v]}ExUqW
+E|elynm	9LU?>x&MQV8] .CT$%p d(?Srd,[9G[YbVzd*Wec
+ kfsf8YoN$~UKvio<b&YP'@}hD'Zf4er-iGX*ihPZ3/CcaA*umM	cT84I Z.5uTthsX]I=cbvk{zgj|nw{rmi]sYV;osvvl{jtG\+t]f+zp}67NVw\v11'[u%lZM8M'1iN7lm@z=]uMI/=h3v/M/K@~wenSj;Ga^v3m;Emc>V$W*;_4KOtqyT~]d=x~'9RINp}}x;g>}/R+9|^tH/yC.gC+;>K>$[k+^?0-3?Hs8N@>{+3?<5|@o@A?|xyA=+A;A# 3Ac?B++sBE;RB$=/27&Ak;9,BN>6tC<?";"DSCBCA	CF|>DDz40R2T\MlD7	L:9<8KAIC<MD/6!C,B6OLZ=tDYDJ\d]$^_\AS,,F"DkAkl|Cht[Z|IDN?Go<BzD>Gq,FcLddCe@W={uDHdGP0<13~Gn\H.HXA:LHi'&tkB{FI2cTly4SIcG,U|81,JHH4cRG,htG<lx,;IICE"t8KIYKKt?T,@:H",2L++&LL)LLM,L7MdDM<dlMLt9MMNN,N<NLN\N  ;
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/tut/guitut5-2.gif perl-libwin32-0.191/GUI/docs/tut/guitut5-2.gif
--- libwin32-0.191/GUI/docs/tut/guitut5-2.gif	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/tut/guitut5-2.gif	2004-01-12 16:46:41.687500000 -0800
@@ -0,0 +1,40 @@
+GIF89a^        !!!111999BBBJJJRRRZBcccscsss{c{s{{{s{{,    ^   9H*\#JHx Ca(S\0cI5e@
+JH*]P:Sju`KvhMvpKwa3P
+s^ Lx+NxKLy/kyr  Xu
+|o{o<Gf7
++_.:UD	 Xl47@-`o>9{hH? 1tyzG^J9GP $'ac'b~#Qe ,\wXMx qWp  @FXh!g!(eSJ_[)ex=p+vfxJ	j < w :SteQRg
+&#QYqofy;z@ADAenOeUbvjbZ^}jk]Vy Z_6hVd:^8@d` Jjj->y[.CSV2lH.   pB8^pcko
+kRuz@+vc3Sjf{L\BZ[2#`{ @>u<qxl{,1dx;ZzF\*Z]]wDF9,t`jbL2yy/km7'R13Fs@d@2@uhx?=b[b%]\S_B^(\ `}hP p/@'3~G(t~]Lv!~<0D
+w9ED"B# FohOt[E-RJ"u'hJF3~ktc:wv~i#EA8b84,"Q\IHRP$3)N
+Uc^GQr[!IIF9+JYr%.=~)Tdi1[,%1NZ3+If>SD/gB&giLfe-{IvS;uYuLp2F!o^sL(4:4
+=!0C!46,	Y}P)=9y$)K)s Ub?;asd4QOMu)Q53(d!#O*R)EJ	]{iTV,eTo
+=*\W6Sy`Q8o\`JJQp#druu,]7Qe&_=VWbLlP@*2Xxns[(+f9;ve^E+;M\;XZelzvKrEpf[]^dS/Dk"kOuw>tR7=pV/J
+/ZxLWnTj&e+	o%,pZ]7-u&+@8tfWEXFu<!YfceVSescbe9}{\2c%
+X<>AqfB'bLi'8NJk[NQo-XN5mG{N+r9 q/[M?3Llyft6iRNL+'tcf|n,u\h06Q6Xq][pCr7sZ8DwFL@Q
+W6-kA1U|6e2=;g}a#7cZSy2\.{`_ tlUA)_q7	Ew|u{
+Dwy/;#O>_{GOOW_T7N~h|jZ{&6O=l> @r$?zh n{$_O?V!B_yeZ]|a 2!XzXx\?%"d7~Vy@~R  $ Db$H WG:zS64:\nXV&m&q" s02~8x|xUxz6\hG'p:v(f xy#x{Ba))"T8AQ wX8u0{H|X](W BXcBi8v`OQx-B621H~Xx[zWaxCVSF5(kxCS00zy~x8z#UC~Cn_ejtP63
+tY8hGZ8gebofXX{aD!b02 fsSh	"I,:8=$87/xmqB9}XXIX 9F}:: M/[G;;/hzx`bQ25%cCQiHqA=+=]wzbwr3 A	I~Ia S${YizZy"HQGAt @4Ata#Y9&5x]SMqT5HePetID	9V94sH)qV)JRqy5M% IRj{EmuLLAkmTS:jkZYh'K|GxiD,m-:y1(4k
+P*G5)z.J2jIzHjdIiY#Dx/5Tu4VJbZPcdzf=km
+S
+NeQZWS1*J:bjLtYFbPx!W FJ
+
+O*tIwQt*U,t*HRAmBJGF
+jN&9SGmI7zQJs
+\OS}JpJNtywo8zS*t{zGZN$XvkFVJ*TzitZ`_8tJOJ0Uyj0f
+JyQBfSFoD+EH;FI{J[gWkkT+f5bCVYte(fgtfbTo+:Jr[fdQj-U"JxRT"7b
+j2pt(/'lX+g{:VkZd;5bk~XM:+[j;x:V"wOoU(+WlhkcEZeeK\xj+Fcg=&8p2fY3,jh
+z;8S.Qkhk&d5ghflh[O;W8Uk{E;kml#8Fh6l|j9u:{vsUec\tFelr+\dH(+&%{tQB[6vjl,m5n3A*e
+F |t{0Iv
+_CC\n?6j`|ovcs
+Cm-,t%9\j<iynAJt{n,J2Z LSc^e<L<3xfACFZ|z<hdfAb<"=}eMb;|+m,#h:o|qILO>Z[wqw~yv>y/@G4kB;W
+xzdST\kt7Bv1x99LIl$uis]TaMj0|]W}*YL}tN=L=y+oZJmGG[
+mnE[^Smqym7U]N]L=U<jzMR'g};{umML[(Y+N:M N]kMI*-IU]0~G~=y"tOR]frS<u`'>dpaHXZudM>.uM4NR!>_Z<M>-XNpt$GUQ~t_QNjnq=Nj-MZ..?z^*KNn^^mu2M.U.N./<TF~p,~N6KEJ1~'o;-=+MiX:?LR<\B`{+]oH2n=TkZnD7t
+r[V,fOy=jL^}nY^a|_L9Z@sM
+?^hOT<!?[w_J{_No?tx,Z7T./W/O<>
+2X0 <dHp !8CBtbEE$9AUdQJ1]zQ"M(9lXaM7ysP@FQ[,)SnfaCLJTYha=`bmmX(.+*\%pa^vWifM~4g{7z]U{5UVTv{upGEO~U&z*FK\E_ZE_oNi;msoOz^go|=o9{[0:?/**lM6CCOKd-8[hCEv("B%m@KpH3qE`$>4^\
+`q24E--<\J0 }N5ksO<$s	4JF-?+OP6edIz@S"4n&ALl:({Q:k,Iu5Pa-i`\>]X~%URQ].Vg)]mB5rW4KFaQS(YjY}U<v[NE]1F4Hq)X'4u#sc$w|+CWMxXbXYO5Su=4[_KV6*vS/+&UP9@	5~SM2y+z-N8c.HMAV8-lMuhc){9O%fjqy%kqFbQ129Fygq3wKq5wd|QcS4s7W2V:4W"{F}xzh{^oxv{q!M}pVY{lgY[*KVOxI3)P;U O{ 6ji<:;Jv(e AM~TFUl(ley11}1q"
+)*B{XH0N;O*LB,V+W$vJj`xAKx!@@0+zPbXR4{,dFmo*m8%(;."W-j\6Sgs' sf&XLvOe3R{"4kxbS)C6T uBMT'q~vwspF7:M`'i&T)E1s)GDeMOKx"&ACVKeNq-EFn@:Fg2sT=]9%vODS&S}H.1JVUWuVzBpV%_MN2Ip.vk?Ez ug$#\;nVfV9U=j9bQKJA-nJOrsn6)Lr	U7Um/SL]V}]c3-Vl%*6kgeP9j_]]-}+|6ua
+#`	M*obT"|903<rJk8ch{W,~F^P;oFdXoj?3I)k9ocx11-p_c,_'/y,-gsOmSh&TsfnYc3g-Y%!9gV4Kg|TK_W_QhXk2ymp[&]npUlDO^XmB wo\+-m Za!x-~qg\8k.{c?zgy]nW/H9S0%_swywk0y+N<Sy{<sN[l%+.Rz7^Q{Kv9|G&~xv&^K-c=j?z:w=Wh4G!^~<<$"};oFcrN}yL{CQiKzg3s~g`_^C S<:S!9, {c=XzcA
+|KQ>V#>{b@:@3K+?tB9VR+(9KjZAKI{8$t?=#3V#-d%dB(BA06B4,=%9 <C B|2@>7C-D	
+ZgH?@$9@SF4Cl.MHDJ48FdAMQ.zDE[.<EBEB>`<"@_WCZdc$EdB;\BA2F[LF/,2>jt6;4T2*\Z%qnt =C\tEuTFflG#\3!IDGlGd@41{,A?03HH\ulREytXl||H~"*<JEsE@"Q>dIlEXBc"IKI}IR[A@4SA6Td!DT&lw{llJE$c20	kJB\J,AqBrA#,H]G.$3|I$\uH0tGVChD>4(Ad.j%m<?fMdtMM4m;ZMznrtNC=.Gd?<t:CH"l4PN
+dN|NR9LP9:,N2*$R[tOJ4!LJ|#Dc t;_7*} uuR,+R-R.70/-0=sR5R15S0eStR3S:]S9:MS-S<US(TATB-TC=TDMTE]TFmTG}TE  ;
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/tut/guitut5.html perl-libwin32-0.191/GUI/docs/tut/guitut5.html
--- libwin32-0.191/GUI/docs/tut/guitut5.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/tut/guitut5.html	2004-01-12 16:46:41.718750000 -0800
@@ -0,0 +1,245 @@
+<HTML>
+<HEAD>
+<TITLE>Win32::GUI Tutorial - Part 5 - More than one window</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+
+<UL>
+
+	<LI><A HREF="#Win32_GUI_Tutorial_Part_5_M">Win32::GUI Tutorial - Part 5 - More than one window</A>
+	<UL>
+
+		<LI><A HREF="#A_simple_multi_window_program">A simple multi-window program</A>
+		<LI><A HREF="#Main_and_popup_windows">Main and popup windows</A>
+		<LI><A HREF="#Keeping_popup_windows_alive">Keeping popup windows alive</A>
+		<LI><A HREF="#Simulating_modal_windows">Simulating &quot;modal&quot; windows</A>
+	</UL>
+
+</UL>
+<!-- INDEX END -->
+
+<HR>
+<P>
+<H1><A NAME="Win32_GUI_Tutorial_Part_5_M">Win32::GUI Tutorial - Part 5 - More than one window</A></H1>
+<P>
+<HR>
+<H2><A NAME="A_simple_multi_window_program">A simple multi-window program</A></H2>
+<P>
+Before going further into control details, we'll explore the case of
+applications that make use of more than one window.
+
+<P>
+In principle, Win32::GUI does not limit the number of windows a program can
+have: we've seen that the usual procedure for a program is:
+
+<OL>
+<LI>
+<P>
+create the main window, eg:
+
+<P>
+<PRE>        $Window = new Win32::GUI::Window(...);
+</PRE>
+<LI>
+<P>
+create controls, eg:
+
+<P>
+<PRE>        $Window-&gt;Add...(...);
+</PRE>
+<LI>
+<P>
+show the window, eg:
+
+<P>
+<PRE>        $Window-&gt;Show();
+</PRE>
+<LI>
+<P>
+call the dialog phase, eg:
+
+<P>
+<PRE>        Win32::GUI::Dialog();
+</PRE>
+</OL>
+<P>
+Steps 1, 2 and 3 can be repeated how many times you like, to create several
+independent windows:
+
+<P>
+<PRE>        use Win32::GUI;
+        
+        $W1 = new Win32::GUI::Window(
+                -name  =&gt; &quot;W1&quot;,
+                -title =&gt; &quot;First Window&quot;,
+                -pos   =&gt; [ 100, 100 ],
+                -size  =&gt; [ 300, 200 ],
+        );
+        $W2 = new Win32::GUI::Window(
+                -name  =&gt; &quot;W2&quot;,
+                -title =&gt; &quot;Second Window&quot;,
+                -pos   =&gt; [ 150, 150 ],
+                -size  =&gt; [ 300, 200 ],
+        );
+</PRE>
+<P>
+<PRE>        $W1-&gt;Show();
+        $W2-&gt;Show();
+        
+        Win32::GUI::Dialog();
+</PRE>
+<P>
+the two windows we've created are displayed on the screen and are both able
+to intercept events and user interaction, with the rather obvious
+limitation that while the code for a window's event is executing, the other
+one is frozen; whis is due to the single-threaded nature of Perl, although
+work is being done for a full featured multithreaded Perl).
+
+<BR><BR><CENTER><IMG SRC="guitut5-1.gif"></CENTER>
+
+<P>
+One thing to note is that even if the windows are two, they belong to the
+same process and share a single message loop, so when you exit from one
+window (or when the program terminates for whatever reason), they both
+disappear:
+
+<P>
+<PRE>        sub W1_Terminate { return -1; }
+</PRE>
+<P>
+<HR>
+<H2><A NAME="Main_and_popup_windows">Main and popup windows</A></H2>
+<P>
+A much more common case is to have a program using a main window, initially
+shown, and one or more popup windows (generally DialogBoxes) that are shown
+in response to a precise function; to make an example, you can imagine the
+Windows Explorer as your main window and the File Properties dialog as a
+popup window.
+
+<P>
+We'll modify our program so that the second window appears when the user
+clicks the button on the first window:
+
+<P>
+<PRE>        use Win32::GUI;
+        
+        $W1 = new Win32::GUI::Window(
+                -name  =&gt; &quot;W1&quot;,
+                -title =&gt; &quot;Main Window&quot;,
+                -pos   =&gt; [ 100, 100 ],
+                -size  =&gt; [ 300, 200 ],
+        );
+        $W1-&gt;AddButton(
+                -name =&gt; &quot;Button1&quot;,
+                -text =&gt; &quot;Open popup window&quot;,
+                -pos  =&gt; [ 10, 10 ],
+        );
+        
+        $W2 = new Win32::GUI::Window(
+                -name  =&gt; &quot;W2&quot;,
+                -title =&gt; &quot;Popup Window&quot;,
+                -pos   =&gt; [ 150, 150 ],
+                -size  =&gt; [ 300, 200 ],
+        );
+</PRE>
+<P>
+<PRE>        $W1-&gt;Show();
+        
+        Win32::GUI::Dialog();
+</PRE>
+<P>
+<PRE>        sub Button1_Click { $W2-&gt;Show(); }
+        
+        sub W1_Terminate { return -1; }
+</PRE>
+<P>
+Furthermore, we put a button on the second window to make it go away:
+
+<P>
+<PRE>        $W2-&gt;AddButton(
+                -name =&gt; &quot;Button2&quot;,
+                -text =&gt; &quot;Close this window&quot;,
+                -pos  =&gt; [ 10, 10 ],
+        );
+        
+        sub Button2_Click { $W2-&gt;Hide(); }
+</PRE>
+<BR><BR><CENTER><IMG SRC="guitut5-2.gif"></CENTER>
+
+<P>
+This rather basic example shows the skeleton framework for a typical
+multi-window application; but there are still two issues we want to
+address: the mortality of popup windows and their ``modal'' behaviour.
+
+<P>
+<HR>
+<H2><A NAME="Keeping_popup_windows_alive">Keeping popup windows alive</A></H2>
+<P>
+If you choose to close the second window with the Close (little X) button
+on the upper right corner, you'll notice that the window disappear, and
+that it does not show anymore when you press the button on the main window!
+
+<P>
+What's happening here is that we requested a <CODE>W2_Terminate</CODE> action, and since we didn't provide an event for this, Win32::GUI proceeds
+with the default behaviour for the close button, which is to destroy the
+window. The result is that you can't show <CODE>$W2</CODE> anymore, because
+it does not exists anymore as a valid window (although it still exists as a
+Perl object). To let our window survive the close action, we need to
+provide a customary <CODE>Terminate</CODE> event:
+
+<P>
+<PRE>        sub W2_Terminate {
+                $W2-&gt;Hide();
+                return 0;
+        }
+</PRE>
+<P>
+The <CODE>return 0</CODE> is <STRONG>very important</STRONG> in this case, because it tells Windows to avoid the destruction of our
+window (it is just hidden), so that we can show it again using the button
+in <CODE>$W1</CODE>.
+
+<P>
+<HR>
+<H2><A NAME="Simulating_modal_windows">Simulating &quot;modal&quot; windows</A></H2>
+<P>
+Here is another very common functionality you may want to implement: when a
+popup window is open, you don't want the user to interact with the main
+window; this is known as using a ``modal'' window, a window that gets all
+your attention and does not let you go forward with the program unless you
+have disposed of it.
+
+<P>
+Win32::GUI does not have direct support for modal windows, but you can
+simulate the behaviour with this trick:
+
+<P>
+<PRE>        sub W1_Activate {
+                if($W2-&gt;IsVisible) {
+                        $W2-&gt;SetForegroundWindow();
+                        return 0;
+                }
+                return 1;
+        }
+</PRE>
+<P>
+The meaning should be obvious enough: if the popup window is shown, trying
+to activate the main window automatically reports you to the popup window;
+otherwise, the main window becomes the active one as normal. Of course, if
+you have more than one popup window, you should add code for everyone of
+them:
+
+<P>
+<PRE>        sub W1_Activate {
+                if($W2-&gt;IsVisible) { $W2-&gt;SetForegroundWindow(); return 0; }
+                if($W3-&gt;IsVisible) { $W3-&gt;SetForegroundWindow(); return 0; }
+                # ... and so on
+                return 1;
+        }
+</PRE>
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/tut/guitut5.pod perl-libwin32-0.191/GUI/docs/tut/guitut5.pod
--- libwin32-0.191/GUI/docs/tut/guitut5.pod	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/tut/guitut5.pod	2004-01-12 16:46:41.734375000 -0800
@@ -0,0 +1,188 @@
+=head1 Win32::GUI Tutorial - Part 5 - More than one window
+
+=head2 A simple multi-window program
+
+Before going further into control details, we'll explore the case of
+applications that make use of more than one window.
+
+In principle, Win32::GUI does not limit the number of windows a program
+can have: we've seen that the usual procedure for a program is:
+
+=over 4
+
+=item 1
+
+create the main window, eg:
+
+	$Window = new Win32::GUI::Window(...);
+
+=item 2
+
+create controls, eg:
+
+	$Window->Add...(...);
+
+=item 3
+
+show the window, eg:
+
+	$Window->Show();
+
+=item 4
+
+call the dialog phase, eg:
+
+	Win32::GUI::Dialog();
+
+=back
+
+Steps 1, 2 and 3 can be repeated how many times you like, to create
+several independent windows:
+
+	use Win32::GUI;
+	
+	$W1 = new Win32::GUI::Window(
+		-name  => "W1",
+		-title => "First Window",
+		-pos   => [ 100, 100 ],
+		-size  => [ 300, 200 ],
+	);
+	$W2 = new Win32::GUI::Window(
+		-name  => "W2",
+		-title => "Second Window",
+		-pos   => [ 150, 150 ],
+		-size  => [ 300, 200 ],
+	);
+
+	$W1->Show();
+	$W2->Show();
+	
+	Win32::GUI::Dialog();
+
+
+the two windows we've created are displayed on the screen and are both 
+able to intercept events and user interaction, with the rather obvious 
+limitation that while the code for a window's event is executing, the
+other one is frozen; whis is due to the single-threaded nature of Perl,
+although work is being done for a full featured multithreaded Perl).
+
+=for HTML <BR><BR><CENTER><IMG SRC="guitut5-1.gif"></CENTER>
+
+One thing to note is that even if the windows are two, they belong to
+the same process and share a single message loop, so when you exit from
+one window (or when the program terminates for whatever reason), they
+both disappear:
+
+	sub W1_Terminate { return -1; }
+
+=head2 Main and popup windows
+
+A much more common case is to have a program using a main window, 
+initially shown, and one or more popup windows (generally DialogBoxes)
+that are shown in response to a precise function; to make an example,
+you can imagine the Windows Explorer as your main window and the File
+Properties dialog as a popup window.
+
+We'll modify our program so that the second window appears when the
+user clicks the button on the first window:
+
+	use Win32::GUI;
+	
+	$W1 = new Win32::GUI::Window(
+		-name  => "W1",
+		-title => "Main Window",
+		-pos   => [ 100, 100 ],
+		-size  => [ 300, 200 ],
+	);
+	$W1->AddButton(
+		-name => "Button1",
+		-text => "Open popup window",
+		-pos  => [ 10, 10 ],
+	);
+	
+	$W2 = new Win32::GUI::Window(
+		-name  => "W2",
+		-title => "Popup Window",
+		-pos   => [ 150, 150 ],
+		-size  => [ 300, 200 ],
+	);
+
+	$W1->Show();
+	
+	Win32::GUI::Dialog();
+
+	sub Button1_Click { $W2->Show(); }
+	
+	sub W1_Terminate { return -1; }
+
+Furthermore, we put a button on the second window to make it go away:
+
+	$W2->AddButton(
+		-name => "Button2",
+		-text => "Close this window",
+		-pos  => [ 10, 10 ],
+	);
+	
+	sub Button2_Click { $W2->Hide(); }
+
+=for HTML <BR><BR><CENTER><IMG SRC="guitut5-2.gif"></CENTER>
+
+This rather basic example shows the skeleton framework for a typical
+multi-window application; but there are still two issues we want to
+address: the mortality of popup windows and their "modal" behaviour.
+
+=head2 Keeping popup windows alive
+
+If you choose to close the second window with the Close (little X)
+button on the upper right corner, you'll notice that the window
+disappear, and that it does not show anymore when you press the
+button on the main window!
+
+What's happening here is that we requested a C<W2_Terminate> action,
+and since we didn't provide an event for this, Win32::GUI proceeds
+with the default behaviour for the close button, which is to destroy
+the window. The result is that you can't show $W2 anymore, because
+it does not exists anymore as a valid window (although it still exists
+as a Perl object). To let our window survive the close action, we need
+to provide a customary C<Terminate> event:
+
+	sub W2_Terminate {
+		$W2->Hide();
+		return 0;
+	}
+
+The C<return 0> is B<very important> in this case, because it tells
+Windows to avoid the destruction of our window (it is just hidden), so
+that we can show it again using the button in C<$W1>.
+
+=head2 Simulating "modal" windows
+
+Here is another very common functionality you may want to implement:
+when a popup window is open, you don't want the user to interact with
+the main window; this is known as using a "modal" window, a window that
+gets all your attention and does not let you go forward with the 
+program unless you have disposed of it.
+
+Win32::GUI does not have direct support for modal windows, but you can
+simulate the behaviour with this trick:
+
+	sub W1_Activate {
+		if($W2->IsVisible) {
+			$W2->SetForegroundWindow();
+			return 0;
+		}
+		return 1;
+	}
+
+The meaning should be obvious enough: if the popup window is shown,
+trying to activate the main window automatically reports you to the
+popup window; otherwise, the main window becomes the active one as
+normal. Of course, if you have more than one popup window, you should
+add code for everyone of them:
+
+	sub W1_Activate {
+		if($W2->IsVisible) { $W2->SetForegroundWindow(); return 0; }
+		if($W3->IsVisible) { $W3->SetForegroundWindow(); return 0; }
+		# ... and so on
+		return 1;
+	}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/tut/guitut9.html perl-libwin32-0.191/GUI/docs/tut/guitut9.html
--- libwin32-0.191/GUI/docs/tut/guitut9.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/tut/guitut9.html	2004-01-12 16:46:41.750000000 -0800
@@ -0,0 +1,103 @@
+<HTML>
+<HEAD>
+<TITLE>Win32::GUI Tutorial - Part 9 - Some peripheral issues</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+
+<UL>
+
+	<LI><A HREF="#Win32_GUI_Tutorial_Part_9_S">Win32::GUI Tutorial - Part 9 - Some peripheral issues</A>
+	<UL>
+
+		<LI><A HREF="#What_about_that_console_window_">What about that console window?</A>
+	</UL>
+
+</UL>
+<!-- INDEX END -->
+
+<HR>
+<P>
+<H1><A NAME="Win32_GUI_Tutorial_Part_9_S">Win32::GUI Tutorial - Part 9 - Some peripheral issues</A></H1>
+<P>
+<HR>
+<H2><A NAME="What_about_that_console_window_">What about that console window?</A></H2>
+<P>
+One thing I have glossed over in all of the above is precisely how we run
+our Win32::GUI Perl program. There are a number of possibilities you might
+have used.
+
+<UL>
+<LI>
+<P>
+Enter the command ``perl MyApp.plx'' from a Windows console window.
+
+<LI>
+<P>
+Enter the command ``perl MyApp.plx'' in the Windows ``Run'' box.
+
+<LI>
+<P>
+Double click on the file ``MyApp.plx'' (assuming you have .plx files
+associated with the perl.exe application).
+
+</UL>
+<P>
+In the first case, you will notice that the command prompt does not return
+until you close your GUI application's window. In the second and third
+case, it's worse - a console window opens and stays visible until the GUI
+application terminates.
+
+<P>
+This is ugly. Unfortunately, it's fairly inevitable, because of the way
+Windows works. Perl itself is a Windows ``console'' application, and so it
+behaves the way we see. You can't change this without changing Perl itself.
+
+<P>
+There is a fix for this, if you have Windows development tools available.
+Simply take a copy of perl.exe, call it perlw.exe, and change its
+``subsystem'' setting from ``console'' to ``windows''. With Microsoft
+Visual Studio, the command to do this is
+
+<P>
+<PRE>    editbin /subsystem:windows perlw.exe
+</PRE>
+<P>
+There is also an all-perl way to achieve the same result on Jenda's site:
+<A
+HREF="http://jenda.krynicky.cz/perl/GUIscripts.html">http://jenda.krynicky.cz/perl/GUIscripts.html</A>
+
+
+<P>
+If you can't (or don't want to) create a perlw.exe, then a compromise is to
+hide the console window while your application is running. This is
+reasonable for the second and third cases above, but less so for the first
+(where the application is run from an existing console window).
+
+<P>
+The code to do this is
+
+<P>
+<PRE>    my ($DOS) = Win32::GUI::GetPerlWindow();
+    Win32::GUI::Hide($DOS);
+</PRE>
+<P>
+Do this as early as possible. Obviously, if we hide the console, we must
+show it when we finish (otherwise, someone who runs your program from a
+command prompt will be <STRONG>very</STRONG> cross with you!)
+
+<P>
+To do this, we need to put
+
+<P>
+<PRE>    Win32::GUI::Show($DOS);
+</PRE>
+<P>
+just before our program terminates. After the Win32::GUI::Dialog() call is
+usually the right place.
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/tut/guitut9.pod perl-libwin32-0.191/GUI/docs/tut/guitut9.pod
--- libwin32-0.191/GUI/docs/tut/guitut9.pod	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/tut/guitut9.pod	2004-01-12 16:46:41.765625000 -0800
@@ -0,0 +1,64 @@
+=head1 Win32::GUI Tutorial - Part 9 - Some peripheral issues
+
+=head2 What about that console window?
+
+One thing I have glossed over in all of the above is precisely how we run our
+Win32::GUI Perl program. There are a number of possibilities you might have
+used.
+
+=over 4
+
+=item *
+
+Enter the command "perl MyApp.plx" from a Windows console window.
+
+=item *
+
+Enter the command "perl MyApp.plx" in the Windows "Run" box.
+
+=item *
+
+Double click on the file "MyApp.plx" (assuming you have .plx files associated
+with the perl.exe application).
+
+=back
+
+In the first case, you will notice that the command prompt does not return
+until you close your GUI application's window. In the second and third case,
+it's worse - a console window opens and stays visible until the GUI
+application terminates.
+
+This is ugly. Unfortunately, it's fairly inevitable, because of the way
+Windows works. Perl itself is a Windows "console" application, and so it
+behaves the way we see. You can't change this without changing Perl itself.
+
+There is a fix for this, if you have Windows development tools available.
+Simply take a copy of perl.exe, call it perlw.exe, and change its "subsystem"
+setting from "console" to "windows". With Microsoft Visual Studio, the command
+to do this is
+
+    editbin /subsystem:windows perlw.exe
+
+There is also an all-perl way to achieve the same result on Jenda's site:
+http://jenda.krynicky.cz/perl/GUIscripts.html
+
+If you can't (or don't want to) create a perlw.exe, then a compromise is to hide 
+the console window while your application is running. This is reasonable for the 
+second and third cases above, but less so for the first (where the application 
+is run from an existing console window).
+
+The code to do this is
+
+    my ($DOS) = Win32::GUI::GetPerlWindow();
+    Win32::GUI::Hide($DOS);
+
+Do this as early as possible. Obviously, if we hide the console, we must show
+it when we finish (otherwise, someone who runs your program from a command
+prompt will be B<very> cross with you!)
+
+To do this, we need to put
+
+    Win32::GUI::Show($DOS);
+
+just before our program terminates. After the Win32::GUI::Dialog() call is
+usually the right place.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/docs/tut/morethanone.pl perl-libwin32-0.191/GUI/docs/tut/morethanone.pl
--- libwin32-0.191/GUI/docs/tut/morethanone.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/docs/tut/morethanone.pl	2004-01-12 16:46:41.781250000 -0800
@@ -0,0 +1,40 @@
+	use Win32::GUI;
+	
+	$W1 = new Win32::GUI::Window(
+		-name  => "W1",
+		-title => "Main Window",
+		-pos   => [ 100, 100 ],
+		-size  => [ 300, 200 ],
+	);
+	$W1->AddButton(
+		-name => "Button1",
+		-text => "Open popup window",
+		-pos  => [ 10, 10 ],
+	);
+	
+	$W2 = new Win32::GUI::Window(
+		-name  => "W2",
+		-title => "Popup Window",
+		-pos   => [ 150, 150 ],
+		-size  => [ 300, 200 ],
+	);
+
+	$W2->AddButton(
+		-name => "Button2",
+		-text => "Close this window",
+		-pos  => [ 10, 10 ],
+	);
+	
+	$W1->Show();
+	
+	Win32::GUI::Dialog();
+
+	sub Button1_Click { $W2->Show(); }
+	sub Button2_Click { $W2->Hide(); }
+
+	sub W1_Terminate { return -1; }
+
+	sub W2_Terminate {
+		$W2->Hide();
+		return 0;
+	}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/guiperl.ico perl-libwin32-0.191/GUI/guiperl.ico
--- libwin32-0.191/GUI/guiperl.ico	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/guiperl.ico	2004-01-12 16:46:41.796875000 -0800
@@ -0,0 +1 @@
+             &               (       @                                                                                                                      wp                                                        w            w                                                            p                          w              wpp        wx        wx        www       wwwp      wwww  x        ww  x      p x p                  p                                                                                          ?  ?  ?               ?  ?  ?   (       @                                                    k H %      z  b  Js  2P    k Hs %W  U  I  =  1  %s  P    kk HH %%               s   P    k sH W% U  I  =  1  % s  P    k H %     z  b  J s 2 P    k H %         s s P P    k H %      z  b s J P 2    k Hs %W  U  I  =  1 s % P     kk HH %%             s   P      k sH W% U  I  =  1  s%  P     k H %     z  b  sJ  P2     k H %         ss  PP     k H %     z  b  Js  2P     k sH W% U  I  =  1  %s  P     kk HH %%              s   P     k Hs %W  U  I  =  1  s%  P    k H %      z  b  sJ  P2    k H %          ss  PP           zzz nnn bbb VVV JJJ >>> 222 &&&                                                                                                                                                                                                                                                                                                      gggggggggggggggggggggggggggggggggggggggggggggggg                                                                                                                                
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/hsplit.cur perl-libwin32-0.191/GUI/hsplit.cur
--- libwin32-0.191/GUI/hsplit.cur	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/hsplit.cur	2004-01-12 16:46:41.812500000 -0800
@@ -0,0 +1 @@
+          0  &          V  (       @                                                                              %  U      U  %                                               (                                                  -  M      M  -                                                
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/resource.h perl-libwin32-0.191/GUI/resource.h
--- libwin32-0.191/GUI/resource.h	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/resource.h	2004-01-12 16:46:41.828125000 -0800
@@ -0,0 +1,5 @@
+// Used by GUI.rc
+//
+#define IDI_DEFAULTICON                 102
+#define IDC_HSPLIT 	                    103
+#define IDC_VSPLIT 	                    104
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/DateTime.pl perl-libwin32-0.191/GUI/samples/DateTime.pl
--- libwin32-0.191/GUI/samples/DateTime.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/DateTime.pl	2004-01-12 16:46:41.843750000 -0800
@@ -0,0 +1,122 @@
+#perl -w
+
+use strict;
+use Win32::GUI;
+
+# main Window
+my $Window = new Win32::GUI::Window (
+    -name     => "Window",
+    -title    => "DateTime Test",
+    -pos      => [100, 100],
+    -size     => [400, 400],
+) or die "new Window";
+
+# Date time control
+my $DateTime = $Window->AddDateTime (
+    -name     => "DateTime",
+    -pos      => [10, 10],
+    -size     => [180, 20],
+    -updown   => 1,
+);
+
+$DateTime->Format('dd-MMM-yyyy HH:mm:ss');
+
+# Date time control
+my $DateTime1 = $Window->AddDateTime (
+    -name     => "DateTime1",
+    -pos      => [10, 30],
+    -size     => [180, 20],
+    -format   => "time",
+);
+
+# Date time control
+my $DateTime2 = $Window->AddDateTime (
+    -name     => "DateTime2",
+    -pos      => [10, 50],
+    -size     => [180, 20],
+    -format   => "shortdate",
+);
+
+# Date time control
+my $DateTime3 = $Window->AddDateTime (
+    -name     => "DateTime3",
+    -pos      => [10, 70],
+    -size     => [180, 20],
+    -format   => "longdate",
+);
+
+# Date time control
+my $DateTime3 = $Window->AddDateTime (
+    -name     => "DateTime3",
+    -pos      => [10, 70],
+    -size     => [180, 20],
+    -format   => "longdate",
+);
+
+# Date time control
+my $DateTime4 = $Window->AddDateTime (
+    -name     => "DateTime4",
+    -pos      => [10, 90],
+    -size     => [180, 20],
+    -format   => "shortdate",
+    -shownone => 1,
+    -align    => "right",
+);
+
+# Test Buttons
+my $Button = $Window->AddButton  (
+    -name     => "Gettime",
+    -text     => "Get the time",
+    -pos      => [200, 10],
+    -size     => [90, 25],
+);
+
+my $Button1 = $Window->AddButton  (
+    -name     => "Settime",
+    -text     => "Set the time",
+    -pos      => [300, 10],
+    -size     => [90, 25],
+);
+
+my $Button2 = $Window->AddButton  (
+    -name     => "SetNone",
+    -text     => "Set None",
+    -pos      => [200, 90],
+    -size     => [90, 25],
+);
+
+my $Button3 = $Window->AddButton  (
+    -name     => "IsNone",
+    -text     => "Is None",
+    -pos      => [300, 90],
+    -size     => [90, 25],
+);
+
+# Event loop
+$Window->Show();
+Win32::GUI::Dialog();
+
+# Main window event handler
+sub Window_Terminate {
+  return -1;
+}
+
+# Button events
+sub Gettime_Click {
+  my ($mday, $mon, $year, undef, $hour, $min,$sec) = $DateTime->GetDateTime();
+  print "Year $year Month $mon Day $mday Hour $hour Min $min Sec $sec \n";
+
+}
+sub Settime_Click {
+  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
+  $year += 1900;
+  $DateTime->SetDateTime($year, $mon, $mday, $hour,$min, $sec);
+}
+
+sub SetNone_Click {
+  $DateTime4->SetNone();
+}
+
+sub IsNone_Click {
+  print "Is None : " . $DateTime4->IsNone() . "\n";
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/Pod/RTF.pm perl-libwin32-0.191/GUI/samples/Pod/RTF.pm
--- libwin32-0.191/GUI/samples/Pod/RTF.pm	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/Pod/RTF.pm	2004-01-12 16:46:41.859375000 -0800
@@ -0,0 +1,343 @@
+package Pod::RTF;
+=head1 NAME
+
+Pod::RTF - convert POD data to Rich Text Format
+
+=head1 SYNOPSIS
+
+    use Pod::RTF;
+
+    pod2rtf("perlfunc.pod");
+
+=head1 DESCRIPTION
+
+Pod::RTF is a module that can convert documentation in the POD format (such
+as can be found throughout the Perl distribution) into Rich Text Format.
+
+=head1 METHODS
+
+The base method is C<pod2rtf>, which does the actual POD to RTF conversion.
+Additional settings can be changed before this step with the following
+methods:
+
+    set_normal_color(RED, GREEN, BLUE);
+    
+This sets the normal text font color (black by default).
+
+    set_head_color(RED, GREEN, BLUE);
+    
+This sets the head font color (green by default).
+
+    set_link_color(RED, GREEN, BLUE);
+
+This sets the link font color (blue by default).
+
+All color components (RED, GREEN and BLUE) are in the range 0-255.
+
+=head1 AUTHOR
+
+Martin Hosken E<lt>F<Martin_Hosken@sil.org>E<gt>.
+Based on Pod::Text by Tom Christiansen.
+Additional coding by Aldo Calpini E<lt>F<dada@divinf.it>E<gt>.
+
+=head1 TODO
+
+A lot of cleanup work, support user defined fonts and colors, and maybe 
+learn something more on Rich Text Format.
+
+=cut
+
+$baseindent = 4;
+$fntnorm = "swiss Arial";
+$fntone = "roman Times New Roman";
+$fnttwo = "charset2 Symbol";
+$fntlit = "modern Courier New";
+@clrnorm = (  0,   0,   0); # black
+@clrhead = (  0, 128,   0); # green
+@clrlink = (  0,   0, 255); # blue
+$parhd = "\n" . '\pard\plain';              # hand hold double-spacing
+$parhd = '\pard\plain';
+$head[1] = '\par\f0\cf1\fs28\b ';
+$head[2] = '\par\f0\cf1\fs24\b ';
+$head[3] = '\par\f0\cf1\fs20\b ';
+$head[4] = '\par\f0\cf1\fs20\b ';
+$head[5] = '\par\f0\cf1\fs20\b ';
+$head[6] = '\par\f0\cf1\fs20\b ';
+$lithd = '\par\f3\fs18 ';
+$normconthd = '\f0\fs20 ';
+$normhd = '\par\f0\fs20 ';
+$itemhd = '\f0\fs20\b';
+# $itemhd = '\f0\fs20\b ';
+@heads = ();
+
+sub pod2rtf {
+    @_ = ("<&STDIN") unless @_;
+    local($file,*OUTFILE) = @_;
+    *OUTFILE = *STDOUT if @_<2;
+
+    open(INFILE, "$file") || die "Unable to open $file";
+    
+    my $f0 = "\\f0\\fswiss $fzeroname";
+    my $c0 = "\\red$clrnorm[0]\\green$clrnorm[1]\\blue$clrnorm[2]";
+    my $c1 = "\\red$clrhead[0]\\green$clrhead[1]\\blue$clrhead[2]";
+    my $c2 = "\\red$clrlink[0]\\green$clrlink[1]\\blue$clrlink[2]";
+    
+    print OUTFILE qq(
+{\\rtf1\\ansi\\deff0\\deftab720{\\fonttbl{\\f0\\fswiss
+Arial;}{\\f1\\froman Times New Roman;}
+{\\f2\\froman\\fcharset2 Symbol;}{\\f3\\fmodern Courier
+New;}}{\\colortbl$c0;$c1;$c2;}\\deflang1033
+);
+    $podlength = 0;
+    $head = 0;
+    @heads = ();
+    @indent = ();
+    $state = "hunt1";
+    $indent = $baseindent;
+    $/ = "\n";
+main:    
+    while (<INFILE>) {
+        if ($state eq "hunt1") {
+            if (m/^=(head1|head2|pod|item|begin|end|for|back|over)\s+/oi) { 
+                $state = "sop"; 
+            } elsif (m/^\s*$/oi) { 
+                next main; 
+            } else { 
+                $state = "hunt"; 
+                next main; 
+            }
+        } elsif ($state eq "hunt") {
+            $state = "hunt1" if (m/^\s*$/oi);
+            next main;
+        }
+
+        1 while s/^(.*?)(\t+)(.*)$/$1 . (' ' x (length($2)*8 - length($1)%8)) . $3/me;
+        s/([\\\{\}])/\\$1/oig;
+
+        if (m/^\s+$/oi) {
+            #print OUTFILE "@";
+            endpar(0); 
+        } elsif (m/^=(\S+)/oi and $state eq "sop") {
+            $cmd = $1;
+            $parm = $';
+            endpar(0);
+            if ($cmd =~ m/^head(\d).*?$/oi) {
+                $head = $1;
+                $tag = "";
+                $_ = $parm;
+                s/^\s*//oi;
+                $state = "head";
+                redo main;
+            } elsif ($cmd =~ m/^for/oi) {
+                if ($parm =~ /^text$/oi) {
+                    print OUTFILE $parhd . '\li' . ($indent * 90) . $lithd;
+                    $podlength += 2;
+                    $state = "litpar";
+                } else { 
+                    $state = "dump"; 
+                }
+            } elsif ($cmd =~ /^begin/oi) {
+                if ($parm =~ /^text$/oi) {
+                    print OUTFILE $parhd . '\li' . ($indent * 90) . $lithd;
+                    $podlength += 2;
+                    $state = "litgrp";
+                } else { 
+                    $state = "dump"; 
+                }
+            } elsif ($cmd =~ /^end/oi) {
+                $state = "sop";
+            } elsif ($cmd =~ /^over/oi) {
+                $parm = 4 unless $parm =~ /\d/;
+                push (@indent, $indent);
+                $indent += $parm;
+                $state = "sop";
+            } elsif ($cmd =~ /^back/oi) {
+                $indent = pop(@indent) or $baseindent;
+                $state = "sop";
+            } elsif ($cmd =~ /^item/oi) {                
+                $_ = $parm;
+                s/^\s*//oi;                
+                $tag = $_;
+                $tag = "";
+                $state = "soi";
+                redo main;
+            } elsif ($cmd =~ /^cut/oi) { 
+                $state = "hunt";
+            } elsif ($cmd =~ /^pod/oi) { 
+                $state = "sop"; 
+            } else { 
+                print STDERR "Unrecognised POD directive: $cmd\n"; 
+            }
+        } elsif (m/^\s+/oi && $state ne "inp" && $state ne "head" && $state ne "soi") {
+            if ($state eq "litpar" || $state eq "litgrp") { 
+                print OUTFILE '\line ' . $_; 
+                $podlength += length($_);
+            }
+            elsif ($state ne "sop") { 
+                endpar(1); 
+                $state = "sop"; 
+            }
+            if ($state eq "sop") {
+                print OUTFILE $parhd . '\li' . ($indent * 90) . $lithd . $_ ;
+                $podlength += length($_) + 2;
+                $state = "litpar";
+            }
+        } elsif ($state eq "litpar" || $state eq "litgrp") {
+            print OUTFILE '\line ' . $_ ;
+            $podlength += length($_) + 1;
+        } elsif ($state ne "dump") {
+            $out = "";
+            $outlength = 0;
+            s/^\s+//oig;                    # strip spaces from start of continuation lines
+            if ($state eq "sop") {
+                print OUTFILE $parhd . '\li' . ($indent * 90) . $normhd;
+                $podlength += 2;
+                $state = "inp";
+            }
+            # now for the inline stuff!
+            while (m/(>|[IBSLFXZEC]<)/o) {
+                $out .= $`;
+                $outlength += length($`);
+                $found = $1;
+                $_ = $';
+                if ($found eq ">") {
+                    if (--$inside <= -1) {
+                        $inside = 0;
+                        $out .= '>';
+                        $outlength += 1;
+                    } else { 
+                        $out .= "}"; 
+                    }
+                } else {
+                    $inside++;
+                    $type = substr($found, 0, 1);
+                    if ($type eq "I") { 
+                        $out .= '{\i '; 
+                    } elsif ($type eq "B") { 
+                        $out .= '{\b '; 
+                    } elsif ($type eq "C" || $type eq "F") { 
+                        $out .= '{\f3 '; 
+                    } elsif ($type eq "L") { 
+                        $out .= '{\cf2 ';   # wimp out
+                        if(m/^([^|]+)\|([^\/]+)\/([^>]*)>/) {
+                            $out .= $1;
+                            $outlength += length($1);
+                            $inside--;
+                            $_ = $';                            
+                        }
+                    } elsif ($type eq "E") {
+                        if (m/^(\d+)>/oi) { 
+                            $out .= sprintf("\\'%02x ", $1); 
+                            $outlength += 2;
+                            $inside--; 
+                            $_ = $'; 
+                        } elsif (m/^lt>/oi) { 
+                            $out .= '<'; 
+                            $outlength += 1;
+                            $inside--; 
+                            $_ = $'; 
+                        } elsif (m/^gt>/oi) { 
+                            $out .= '>'; 
+                            $outlength += 1;
+                            $inside--; 
+                            $_ = $'; 
+                        }
+                    } else { 
+                        $out .= "{"; 
+                    }
+# Can't be bothered with the rest. Just print the stuff out.
+                }
+                
+            }
+            if ($state eq "soi" || $state eq "head") { 
+                $tag .= $out . $_; 
+            } else { 
+                print OUTFILE $out . $_ . " "; 
+                $podlength += $outlength+length($_)+1;                
+            }
+        }
+    }
+    endpar(1);
+    print OUTFILE "}";
+
+    close(INFILE);
+
+}
+
+sub endpar {
+    my ($strict) = @_;
+
+    my $soiseen = 0;
+
+    $inside = 0;
+
+    $soiseen = 1 if ($state eq "soi");
+
+    return if ($state eq "sop");
+
+    if ($state eq "soi" and not $strict) {
+
+        $tagindent = $indent[-1] || $baseindent;
+
+        # this is the correct solution. But the RichEdit control isn't up to correct RTF
+        #   print OUTFILE $parhd . '\li' . ($indent * 90) . '\fi' . (($tagindent - $indent) * 90);
+        #   print OUTFILE $itemhd . $tag . ((length($tag) > $indent - $tagindent) ? '\line ' : '\tab ');
+
+        my $ctag;
+        ($ctag = $tag) =~ s/[\r\n]//g;
+        print "item '$ctag' indent=$indent tagindent=$tagindent state=$state lastwasitem=$lastwasitem\n";
+      
+        if (length($tag) > $indent - $tagindent) {
+            print OUTFILE '\par' unless $lastwasitem;       
+            # $tag =~ s/[\r\n]//g;
+            print OUTFILE '\pard\plain' . '\li' . ($tagindent * 90) . $itemhd . ' ' .$tag;
+            print OUTFILE '\par\pard\plain' . '\li' . ($indent * 90) . $normconthd;
+            $podlength += length($tag) + 4;
+            $state = "sop";
+            
+        } else {                        # can do it properly
+            # print OUTFILE '\par' unless $lastwasitem;       
+            $tag =~ s/[\r\n]//g;
+            #print OUTFILE $parhd . '\li' . ($indent * 90) . '\fi' . (($tagindent - $indent) * 90);
+            print OUTFILE '\pard\plain' . '\li' . ($indent * 90) . '\fi' . (($tagindent - $indent) * 90);
+            print OUTFILE '\par ' . $itemhd . $tag . '\tab\plain' . $normconthd ;
+            $podlength += length($tag) + 4;
+            $state = "inp";
+        }
+        push(@heads, "".(3+$#indent).";$podlength;$ctag");
+        
+    } elsif ($state eq "head") {
+        print OUTFILE $parhd . $head[$head] . $tag . '\par';
+        $podlength += 1;
+        chomp($tag);
+        push(@heads, "$head;$podlength;$tag");
+        $state = "sop";
+        $podlength += length($tag) + 1;
+        # print "POD::RTF::endpar adding head(\n$tag\nPOD::RTF::endpar podlength now $podlength\n";
+    } elsif ($state eq "dummy") { 
+        $state = "sop"; 
+    } elsif ($state eq "litgrp") { 
+        print OUTFILE '\par'; 
+        $podlength += 1;
+    } else {
+        print OUTFILE '\par';
+        $podlength += 1;
+        $state = "sop";
+    }
+    if($soiseen) {
+        $lastwasitem = 1;
+    } else {
+        $lastwasitem = 0;
+    }
+    
+}
+
+sub set_normal_color { @clrnorm = @_; }
+sub set_head_color { @clrhead = @_; }
+sub set_link_color { @clrlink = @_; }
+
+1;
+
+
+
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/Zapotec.bmp perl-libwin32-0.191/GUI/samples/Zapotec.bmp
--- libwin32-0.191/GUI/samples/Zapotec.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/Zapotec.bmp	2004-01-12 16:46:41.875000000 -0800
@@ -0,0 +1,261 @@
+BM2%      2  (   `   `          $      ?   ?    ) 9 B 9 B  9 )R  ) ) B 9 !R ) 1 !B !J )R !1{ !B 1 J 9 9 )Z !Z !9 !R !J 9 9 B B 1{ 1 9 9 9  1 ) J B  1 !Z !R )Z ! B  9 !R 1 ) J !1 J R 9 )Z ){ ! B ! J R 
+
+ 
+ 
+
+
+
+
+
+
+
+
+
+
+++  +'55 .
+
+
+
+ 
+ 
+
+
+!
+
+
+ 3'5 
+ 
+..
+
+
+
+
+
+
++4483'5
+
+
+ 
+
+
+
+
+
+
+
+
+
+!+## 
+
+
+
+
+
+
+
+!
++8
+
+
+
+
+
+!
+
+
+
+3**,'
+
+
+
+
+
+
+
+
+
+**,,+33#
+
+
+
+
+
+
+!
+!+++,00 ***#"
+
+
+&!!&!&!&#	-#"1"1"1"'
+
+
+
+
+
+&!!&!!&&			'		0"1"11"5
+
+
+!&!&!&2	#""""1
+
+
+!&&!2##											1"11'
+
+
+
+
+
+&!2&&'			9	'	"1""1
+
+
+!&&&2															#"""#5
+!!&2		'	-				'	';""#
+
+
+
+
+&2##		0						'	'1"
+!
+
+
+&'			(								"###'
+!!/          %/%
+
+!2(//      %/)/#!!!!/           )!!!%       %/)#!2               22.#%           "2./         '#               	33;##	                 	3###               %	##("("	/)%%            '	+;	()              %%		'##		("(%%                       	(	'	'#	((%/%%%              (			#		(		7%                % (3(		'		%)                  			"(		+	(		"		%%))%                         %  % 				-		)%                  				+,: %)                        							"<	    )                     %	(	-		%  ))                       			)  )                       ( ,    ))                      -	-           	$          ,,0          	7	7$	           :,  *,     )     7			$			            *       ) $		$$$        9*,-       )   			$	            *0      ) 	$			$		$        -46       )  $7	$	$          9      	$$7         -*         )  	$$	$$		                         $$	$				             -6  0&          )$$$	           ,066,2-          		$	$$$           0,*--            	$$		            ,6 6<             	$$			            6,,-           $	$$$$          9-*4(        	          )		>(	                            		+6*	                           -		(                         )  							(			                       	(			=.+8'				 )                      							8	0				%                    									% %                   		'	'#3			                					0		                    			0	'	%                	8	            		3	             			'	%              		             ## )                /8          %
+            %%#+#           /!
+
+%           )/
+
+/)          )  /+
+
+
+)%)        /)
+
+
+	(				(		-"7					
+
+
+
+
+#0					"((		
+
+
+	(			-((		
+
+
+&!				(9::(				""
+
+
+
+
+&&#					((""(	1'
+
+
+
+!&&		0						-					"'.
+
+
+&!!&!#				-		#1"
+
+
+
+2&&2&							""'
+
+
+
+
+
+
+&!&!&	9	"	#". .
+
+
+
+
+
+6**0,,5.
+
+
+
+***0*,+'
+
+
+
+
+
+
+
+
+
+**,*38+
+
+  
+
+
+
+
+
+
+
+
+
+
+33*,
+
+
+
+
+
+
+
+
+
+++     +''. ..
+
+
+
+!
+4
+ .
+ 
+
+
+
+
+
+
+
+.  5
+
+
+ 
+. 
+
+
+
+
+
+
+
+
+  '
+ 
+ .
+
+
+
+
+
+!
++4    '5' .
+
+
+
+
+
+
+
+!
+
+
+
+44   4 44
+
+diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/alarm.bmp perl-libwin32-0.191/GUI/samples/alarm.bmp
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/alarm.bmp perl-libwin32-0.191/GUI/samples/alarm.bmp
--- libwin32-0.191/GUI/samples/alarm.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/alarm.bmp	2004-01-12 16:46:41.890625000 -0800
@@ -0,0 +1 @@
+BM6      6   (                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/bitmap.pl perl-libwin32-0.191/GUI/samples/bitmap.pl
--- libwin32-0.191/GUI/samples/bitmap.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/bitmap.pl	2004-01-12 16:46:41.906250000 -0800
@@ -0,0 +1,156 @@
+
+use Win32::GUI;
+
+$M = Win32::GUI::MakeMenu(
+    "&File"     => "File",
+    " > &Open"  => "Open",
+    " > E&xit"  => "Exit",
+    "&Bitmap"   => "Bitmap",
+    " > &Info"  => "Info",
+    " > &Resize window to bitmap" => "Resize",
+);
+
+$W = new Win32::GUI::Window(
+    -title    => "Win32::GUI::Bitmap test",
+    -left     => 100, 
+    -top      => 100, 
+    -width    => 400, 
+    -height   => 400,
+    -style    => WS_OVERLAPPEDWINDOW,
+    -menu     => $M,
+    -name     => "Window",
+) or print_and_die("new Window");
+
+$B = new Win32::GUI::Bitmap('zapotec.bmp') or print_and_die("new Bitmap");
+
+($width, $height) = ($W->GetClientRect)[2..3];
+
+$BITMAP = $W->AddLabel(
+    -left => 0, 
+    -top => 0,
+    -width => $width, 
+    -height => $height,
+    -style => 14,
+    -name => "Bitmap",
+    -visible => 1,
+    -text => "ouch",
+);
+
+$BITMAP->SetImage($B);
+$BITMAP->Resize($width, $height);
+
+$I = new Win32::GUI::DialogBox(
+    -title  => "Bitmap info",
+    -left   => 110,
+    -top    => 110,
+    -width => 300,
+    -height => 200,
+    -name => "InfoWindow",
+);
+
+$ttop = 10;
+$I_Width  = MakeInfoControls("Width", "Width:");
+$I_Height = MakeInfoControls("Height", "Height:");
+$I_Depth  = MakeInfoControls("Depth", "Color depth:");
+$I_Compr  = MakeInfoControls("Compr", "Compression:");
+$I_Size   = MakeInfoControls("Size", "Image size:");
+
+sub MakeInfoControls {
+    my($name, $text) = @_;
+    my $Lbl = $I->AddLabel(
+        -text => $text,
+        -left => 10,
+        -top => $ttop,
+        -name => $name."_Label",
+    );
+    my $Ctrl = $I->AddLabel(
+        -text => "I'm a placeholder",
+        -left => 110,
+        -top => $ttop,
+        -name => $name,
+    );
+    $ttop += 22;
+    return $Ctrl;
+}
+
+$I_Close = $I->AddButton(
+    -text   => "Close",
+    -left   => $I->ScaleWidth-70,
+    -top    => $I->ScaleHeight-35,
+    -width  => 60,
+    -height => 25,
+    -name   => "InfoClose",
+);
+
+
+$W->Show;
+
+Win32::GUI::Dialog();
+
+sub Window_Resize {
+    $BITMAP->Resize($W->ScaleWidth, $W->ScaleHeight);
+}
+
+sub Window_Terminate {
+    $W->PostQuitMessage(0);
+}
+
+sub Open_Click {
+    my $file = "*.bmp\0" . " " x 260;
+    $file = GUI::GetOpenFileName(-file => $file);
+    print $file, "\n";
+    undef $B;
+    $B = new GUI::Bitmap($file);
+    if($B) {
+        $BITMAP->SetImage($B);
+        Window_Resize();
+    }
+}
+
+sub Info_Click {
+    $W->Disable();
+    my ($x, $y, $depth, $compr, $size) = $B->Info();
+
+    my @compr = qw( Uncompressed RLE-8bit RLE-4bit Uncompressed );
+    print "X = $x\nI_Width = $I_Width\n";
+    $I_Width->Text($x);
+    $I_Height->Text($y);
+    $I_Depth->Text($depth);
+    $I_Compr->Text($compr[$compr]);
+    $I_Size->Text($size);
+    $I->Show();
+}
+
+sub InfoWindow_Terminate {
+    $W->Enable();
+    $W->SetForegroundWindow();
+    $I->Hide();
+    return 0;
+}
+
+sub InfoClose_Click {
+    InfoWindow_Terminate();
+}
+sub Resize_Click {
+    my ($x, $y) = $B->Info();
+    my $ax = $W->Width - $W->ScaleWidth;
+    my $ay = $W->Height - $W->ScaleHeight;
+    if($x and $y) {
+        print "Bitmap size is $x x $y\n";
+        $W->Resize($x+$ax, $y+$ay);
+    } else {
+        print "Can't get bitmap size...\n";
+        print "LastError=", Win32::GetLastError(), "\n";
+    }
+}
+
+sub Exit_Click {
+    $W->PostQuitMessage(0);
+}
+
+sub print_and_die {
+    my($text) = @_;
+    my $err = Win32::GetLastError();
+    die "$text: Error $err\n";
+}
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/buttons.pl perl-libwin32-0.191/GUI/samples/buttons.pl
--- libwin32-0.191/GUI/samples/buttons.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/buttons.pl	2004-01-12 16:46:41.921875000 -0800
@@ -0,0 +1,209 @@
+
+use blib;
+use Win32::GUI;
+
+$F = new Win32::GUI::Font(
+	-name => "Arial",
+	-size => 14,
+	-bold => 1,
+);
+
+$W = new Win32::GUI::Window(
+    -title  => "Win32::GUI::Button (and variants) test",
+    -left   => 100, 
+    -top    => 100, 
+    -width  => 280, 
+    -height => 260,
+    -name   => "Window",
+#    -font   => $F,
+);
+
+$W->{-dialogui} = 1;
+
+$W->TrackMouse();
+
+$BC = new Win32::GUI::Class(
+	-name => '_Button',
+	-widget => 'Button',
+	-extends => 'BUTTON',
+);	
+print "BC=$BC\n";
+
+
+$W->AddButton(
+    -name    => "Simple",
+    -left    => 5,
+    -top     => 5,
+	-text    => "Click button",
+	-tabstop => 1,
+	# -class   => $BC,
+);
+
+$Timer = $W->AddTimer("SimpleTimer", 0);
+
+$W->AddLabel(
+	-name   => "SimpleLabel",
+	-left   => 120,
+	-top    => 10,
+	-width  => 150,
+	-height => 22,
+);
+
+$W->AddGroupbox(
+	-name   => "CheckGroup",
+	-left   => 2,
+	-top    => 35,
+	-width  => 115,
+	-height => 85,
+	-text   => "Checkboxes",
+);
+
+$W->AddCheckbox(
+    -name    => "Check1",
+    -left    => 8,
+    -top     => 50,
+    -text    => "Checkbox 1",
+    -tabstop => 1,
+    -checked => 1,
+);
+
+$W->AddCheckbox(
+    -name    => "Check2",
+    -left    => 8,
+    -top     => 70,
+    -text    => "Checkbox 2",
+    -tabstop => 1,
+    -checked => 1,
+);
+
+$W->AddCheckbox(
+    -name    => "Check3",
+    -left    => 8,
+    -top     => 90,
+    -text    => "Checkbox 3",
+    -tabstop => 1,
+);
+
+$W->AddLabel(
+	-name   => "CheckLabel",
+	-left   => 120,
+	-top    => 55,
+	-width  => 150,
+	-height => 44,
+);
+
+$W->AddGroupbox(
+	-name   => "RadioGroup",
+	-left   => 2,
+	-top    => 120,
+	-width  => 115,
+	-height => 85,
+	-text   => "Radiobuttons",
+);
+
+$W->AddRadioButton(
+    -name    => "Radio1",
+    -left    => 8,
+    -top     => 135,
+    -text    => "Radiobutton 1",
+    -tabstop => 1,
+);
+
+$W->AddRadioButton(
+    -name    => "Radio2",
+    -left    => 8,
+    -top     => 155,
+    -text    => "Radiobutton 2",
+    -tabstop => 1,
+    -checked => 1,
+);
+
+$W->AddRadioButton(
+    -name    => "Radio3",
+    -left    => 8,
+    -top     => 175,
+    -text    => "Radiobutton 3",
+    -tabstop => 1,
+);
+
+$W->AddLabel(
+	-name   => "RadioLabel",
+	-left   => 120,
+	-top    => 140,
+	-width  => 150,
+	-height => 22,
+);
+
+$W->AddButton(
+	-name    => "Close",
+	-left    => 150, 
+	-top     => 210, 
+	-width   => 100,
+	-text    => "Close", 
+	-cancel  => 1,
+	-default => 1,
+	-tabstop => 1,
+);
+
+$W->Show;
+
+Win32::GUI::Dialog();
+
+sub Window_Terminate {
+    return -1;
+}
+
+sub Close_Click {
+    Window_Terminate();
+}
+
+sub Simple_Click {
+	$W->SimpleLabel->Text("Got a click");
+	$Timer->Interval(1000);
+}
+
+sub SimpleTimer_Timer {
+	$W->SimpleLabel->Text("");
+	$Timer->Kill();
+}
+
+sub Check1_Click {
+	my $text = "";
+	if($W->Check1->Checked()) {
+		$text .= (($text)? ", " : "")."Checkbox 1";
+	}
+	if($W->Check2->Checked()) {
+		$text .= (($text)? ", " : "")."Checkbox 2";
+	}
+	if($W->Check3->Checked()) {
+		$text .= (($text)? ", " : "")."Checkbox 3";
+	}
+	$W->CheckLabel->Text($text);
+}
+sub Check2_Click { Check1_Click(); }
+sub Check3_Click { Check1_Click(); }
+
+
+sub Radio1_Click {
+	my $text = "";
+	if($W->Radio1->Checked()) {
+		$text = "Radiobutton 1";
+	} elsif($W->Radio2->Checked()) {
+		$text = "Radiobutton 2";
+	} elsif($W->Radio3->Checked()) {
+		$text = "Radiobutton 3";
+	}
+	$W->RadioLabel->Text($text);
+}
+sub Radio2_Click { Radio1_Click(); }
+sub Radio3_Click { Radio1_Click(); }
+
+sub Window_MouseOver {
+	print "<" x 78, "\n";
+	return 1;
+}
+
+sub Window_MouseOut {
+	print ">" x 78, "\n";
+	return 1;
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/camel.ico perl-libwin32-0.191/GUI/samples/camel.ico
--- libwin32-0.191/GUI/samples/camel.ico	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/camel.ico	2004-01-12 16:46:41.937500000 -0800
@@ -0,0 +1 @@
+             &               (       @                                                                                                                      wp                                                        w            w                                                            p                          w              wpp        wx        wx        www       wwwp      wwww  x        ww  x      p x p                  p                                                                                          ?  ?  ?               ?  ?  ?   (       @                                                   k H %      z  b  Js  2P    k Hs %W  U  I  =  1  %s  P    kk HH %%               s   P    k sH W% U  I  =  1  % s  P    k H %     z  b  J s 2 P    k H %         s s P P    k H %      z  b s J P 2    k Hs %W  U  I  =  1 s % P     kk HH %%             s   P      k sH W% U  I  =  1  s%  P     k H %     z  b  sJ  P2     k H %         ss  PP     k H %     z  b  Js  2P     k sH W% U  I  =  1  %s  P     kk HH %%              s   P     k Hs %W  U  I  =  1  s%  P    k H %      z  b  sJ  P2    k H %          ss  PP           zzz nnn bbb VVV JJJ >>> 222 &&&                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ?  ?  ?               ?  ?  ?   
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/cf.pl perl-libwin32-0.191/GUI/samples/cf.pl
--- libwin32-0.191/GUI/samples/cf.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/cf.pl	2004-01-12 16:46:41.953125000 -0800
@@ -0,0 +1,42 @@
+
+
+use Win32::GUI;
+
+@ret = Win32::GUI::ChooseFont(
+    -name => "Courier New", 
+    -height => 76, 
+#    -size => 180,
+    -italic => 1,
+    -ttonly => 1,
+    -fixedonly => 1,
+    -script => 0,
+    -effects => 1,
+);
+
+if($#ret > 0) {
+    print "ChooseFont returned:\n";
+    %ret = @ret;
+    foreach $key (keys(%ret)) {
+        print "\t$key => $ret{$key}\n";
+    }
+
+	delete $ret{-size};
+
+    $F = new Win32::GUI::Font(%ret);
+
+    %ariret = $F->Info();
+
+    print "Info returned:\n";
+
+    foreach $key (keys(%ariret)) {
+        print "\t$key => $ariret{$key}\n";
+    }
+
+
+} else {
+    if(Win32::GUI::CommDlgExtendedError()) {
+        print "ERROR. CommDlgExtendedError is: ", Win32::GUI::CommDlgExtendedError(), "\n";    
+    } else {
+        print "You cancelled.\n";
+    }
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/class.pl perl-libwin32-0.191/GUI/samples/class.pl
--- libwin32-0.191/GUI/samples/class.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/class.pl	2004-01-12 16:46:41.968750000 -0800
@@ -0,0 +1,33 @@
+
+use Win32::GUI;
+
+$I = new Win32::GUI::Icon("camel.ico");
+$C = new Win32::GUI::Bitmap("harrow.cur", 2);
+
+# NOTE: $C should be Win32::GUI::Cursor...
+
+$WC = new Win32::GUI::Class(
+    -name => "simply_perl_win32_gui", 
+    -cursor => $C,
+    -icon => $I,
+    -color => 2,
+);
+if(!$WC) {
+    die "Window class creation error: ", Win32::GetLastError(), "\n";
+}
+$W = new Win32::GUI::Window(
+    -name => "Window",
+    -font => $F,
+    -title => "Win32::GUI::Class test",
+    -class => $WC,
+    -left => 100, 
+    -top => 100,
+    -width => 300, 
+    -height => 200,
+#    -cursor => $C,
+);
+if(!$W) {
+    die "Window creation error: ", Win32::GetLastError(), "\n";
+}
+$W->Show();
+$W->Dialog();
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/close.bmp perl-libwin32-0.191/GUI/samples/close.bmp
--- libwin32-0.191/GUI/samples/close.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/close.bmp	2004-01-12 16:46:41.984375000 -0800
@@ -0,0 +1 @@
+BMb      6  (               ,                                    Q          """ ))) UUU MMM BBB 999 | PP         3   f        3   33  3f  3  3  3  f   f3  ff  f  f  f     3  f           3  f        f     3   3 3 3 f 3  3  3  33  333 33f 33 33 33 3f  3f3 3ff 3f 3f 3f 3  33 3f 3 3 3 3  33 3f 3 3 3 33 3f 3 3 3 f   f 3 f f f  f  f  f3  f33 f3f f3 f3 f3 ff  ff3 fff ff ff f  f3 ff f f f f  f3 f f f f  f3 f f       3        33  f 3   f  f3 3f f f 3 3 f      3 ff      3 f        3  f     3  33 3f 3 3 3 f  f3 ff f f f   3 f      3 f      3 f     3  f   3  33 3f 3 3 3 f  f3 ff f f f   3 f      3 f    3 f   ff ff f ff f f !  ___ www                            																		  																		  																		  																		  					  				  					  						  		  						  							    							  								  								  							    							  						  		  						  					  				  					  																		  																		  																		  																		  
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/cmeta.pl perl-libwin32-0.191/GUI/samples/cmeta.pl
--- libwin32-0.191/GUI/samples/cmeta.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/cmeta.pl	2004-01-12 16:46:42.000000000 -0800
@@ -0,0 +1,63 @@
+
+use Win32::GUI;
+
+$W = new GUI::Window(
+    -left => 100,
+    -top => 100,
+    -width => 400,
+    -height => 400,
+    -title => "EMF Creator",
+    -name => "Window",
+);
+
+print "About to show...\n";
+
+$W->Show();
+
+Win32::GUI::Dialog();
+
+sub Window_Terminate {
+    return -1;
+}
+
+sub Window_Resize {
+	if($W) {
+	    $METAFILE = $W->CreateEnhMetaFile("prova.emf");
+	    print "CreateEnhMetaFile returned $DC\n";
+	    Draw($METAFILE);
+	    $META = Win32::GUI::CloseEnhMetaFile($METAFILE);
+	    print "CloseEnhMetaFile returned $META\n";
+	    $rc = Win32::GUI::DeleteEnhMetaFile($META);
+	    print "DeleteEnhMetaFile returned $rc\n";
+	    Draw($W->GetDC);
+	}
+}
+
+sub Draw {
+	my($DC) = @_;
+    $X = $W->ScaleWidth;
+    $Y = $W->ScaleHeight;
+    $r = 0;
+    $g = 0;
+    $b = 0;
+    if($X > 500) {
+        $DC->MoveTo(0, $Y/2);
+        $DC->LineTo($X, $Y/2);
+        $r = 255;
+    }
+    if($Y > 500) {
+        $DC->MoveTo(X/2, 0);
+        $DC->LineTo($X/2, $Y);
+        $g = 255;
+    }
+  
+    $DC->LineTo(0, 0);
+    $DC->LineTo($X, $Y);
+    $DC->LineTo($X, 0);
+    $DC->LineTo(0, $Y);
+    $DC->Circle(0, 0, $X, $Y);
+    $DC->SetTextColor($r, $g, $b);
+    $DC->SetBkMode(1);
+    ($TW, $TH) = $DC->GetTextExtentPoint32("$X x $Y");
+    $DC->TextOut($X/2-$TW/2, $Y/2-$TH/2, "$X x $Y");
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/combobox.pl perl-libwin32-0.191/GUI/samples/combobox.pl
--- libwin32-0.191/GUI/samples/combobox.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/combobox.pl	2004-01-12 16:46:42.015625000 -0800
@@ -0,0 +1,88 @@
+use Win32::GUI;
+
+$Window = new Win32::GUI::Window(
+    -name   => "Window",
+    -left   => 100, 
+    -top    => 100,
+    -width  => 300, 
+    -height => 300,
+    -text   => "Win32::GUI TEST - Combobox",
+);
+
+$CBsimplelbl = $Window->AddLabel(
+    -text   => "Simple Combobox:",
+    -left   => 10,
+    -top    => 10,
+);
+
+$CBsimple = $Window->AddCombobox(
+    -name   => "Simple",
+    -left   => 10, 
+    -top    => 30,
+    -width  => 250, 
+    -height => 100,
+);
+$CBsimple->InsertItem("item 1");
+$CBsimple->InsertItem("item 2");
+$CBsimple->InsertItem("item 3");
+
+$CBdropdownlbl = $Window->AddLabel(
+    -text   => "Dropdown Combobox:",
+    -left   => 10,
+    -top    => 160,
+);
+
+
+$CBdropdown = $Window->AddCombobox( 
+    -name   => "Dropdown",
+    -left   => 10, 
+    -top    => 180,
+    -width  => 250, 
+    -height => 100,
+    -style  => WS_VISIBLE | 2 | WS_NOTIFY,
+);
+$CBdropdown->InsertItem("item 1");
+$CBdropdown->InsertItem("item 2");
+$CBdropdown->InsertItem("item 3");
+
+$Status = $Window->AddStatusBar(
+    -name => "Status",
+    -text => "Win32::GUI Combobox sample",
+);
+
+$Window->Show();
+Win32::GUI::Dialog();
+
+#=====================
+sub Window_Terminate {
+#=====================
+    return -1;
+}
+
+#==================
+sub Simple_Change {
+#==================
+    $Status->Text("Simple: ".$CBsimple->GetString($CBsimple->SelectedItem));
+    
+}
+
+#====================
+sub Dropdown_Change {
+#====================
+	my $s = $CBdropdown->SelectedItem;
+    $Status->Text("Dropdown: ".$CBdropdown->GetString($s));
+}
+
+#=====================
+sub Simple_Anonymous {
+#=====================
+    my($code) = @_;
+    print "Anonymous code:$code\n";
+    if($code == 6) {
+        $simplechanged = 1;
+    } elsif($code == 9) {
+        if($simplechanged) {
+            $CBsimple->InsertItem($CBsimple->Text());
+        }
+    }
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/dc.pl perl-libwin32-0.191/GUI/samples/dc.pl
--- libwin32-0.191/GUI/samples/dc.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/dc.pl	2004-01-12 16:46:42.031250000 -0800
@@ -0,0 +1,50 @@
+
+use Win32::GUI;
+
+$Font = new Win32::GUI::Font(
+    -name => "Times New Roman",
+    -size => 10,
+    -bold => 1,
+    -italic => 1,
+);
+
+$Win = new Win32::GUI::Window(
+    -left => 100,
+    -top => 100,
+    -width => 300,
+    -height => 300,
+    -name => "Window",
+    -text => "DC Drawing Test",
+);
+
+$Win->Show();
+
+Win32::GUI::Dialog();
+
+sub Window_Resize {
+    Paint();
+}
+
+sub Window_Activate {
+    Paint();
+}
+
+sub Window_Terminate {
+    return -1;
+}
+
+sub Paint {
+    my $W = $Win->ScaleWidth;
+    my $H = $Win->ScaleHeight;
+    $Win->BeginPaint();
+    $Win->LineTo(0, 0);
+    $Win->LineTo($W, $H);
+    $Win->Circle(0, 0, $W, $H);
+    $Win->SetBkMode(1);
+    Win32::GUI::SelectObject($Win->{DC}, $Font);
+    $Win->SetTextColor([0, 0, 255]);
+    ($TW, $TH) = $Win->GetTextExtentPoint32("$W x $H");
+    $Win->TextOut($W/2-$TW/2, $H/2-$TH/2, "$W x $H");
+    $Win->EndPaint();
+}
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/dll.bmp perl-libwin32-0.191/GUI/samples/dll.bmp
--- libwin32-0.191/GUI/samples/dll.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/dll.bmp	2004-01-12 16:46:42.046875000 -0800
@@ -0,0 +1 @@
+BM       v   (                                                                           wwwwwppppppppp0p3pp  x
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/draw.pl perl-libwin32-0.191/GUI/samples/draw.pl
--- libwin32-0.191/GUI/samples/draw.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/draw.pl	2004-01-12 16:46:42.046875000 -0800
@@ -0,0 +1,129 @@
+
+use Win32::GUI;
+
+$Menu = Win32::GUI::MakeMenu(
+    "&Draw" => "&Draw",
+    ">  &Dots"   => "DrawDots",
+    ">  &Lines"   => "DrawLines",
+    ">  &Boxes"   => { -name => "DrawBoxes", -checked => 1 },
+    ">  &Circles" => "DrawCircles",
+);
+
+$Win = new Win32::GUI::Window(
+    -left   => 100,
+    -top    => 100,
+    -width  => 300,
+    -height => 300,
+    -name   => "Window",
+    -text   => "Win32::GUI drawing demo",
+    -menu   => $Menu,
+);
+
+$Timer = $Win->AddTimer("Timer1", 1);
+
+srand();
+
+$Win->Show();
+Win32::GUI::Dialog();
+
+sub Window_Terminate {
+    return -1;
+}
+
+sub DrawDots_Click {
+    $Menu->{DrawDots}->Checked(1);
+    $Menu->{DrawLines}->Checked(0);
+    $Menu->{DrawBoxes}->Checked(0);
+    $Menu->{DrawCircles}->Checked(0);
+    $Win->InvalidateRect(1);
+}
+
+sub DrawLines_Click {
+    $Menu->{DrawDots}->Checked(0);
+    $Menu->{DrawLines}->Checked(1);
+    $Menu->{DrawBoxes}->Checked(0);
+    $Menu->{DrawCircles}->Checked(0);
+    $Win->InvalidateRect(1);
+}
+
+sub DrawBoxes_Click {
+    $Menu->{DrawDots}->Checked(0);
+    $Menu->{DrawLines}->Checked(0);
+    $Menu->{DrawBoxes}->Checked(1);
+    $Menu->{DrawCircles}->Checked(0);
+    $Win->InvalidateRect(1);
+}
+
+sub DrawCircles_Click {
+    $Menu->{DrawDots}->Checked(0);
+    $Menu->{DrawLines}->Checked(0);
+    $Menu->{DrawBoxes}->Checked(0);
+    $Menu->{DrawCircles}->Checked(1);
+    $Win->InvalidateRect(1);
+}
+
+sub Timer1_Timer {
+    my $W = $Win->ScaleWidth;
+    my $H = $Win->ScaleHeight;
+    my $DC = $Win->GetDC;
+    my $left;
+    my $top;
+    my $right;
+    my $bottom;
+    my $P;
+    my $B;
+
+    if($Menu->{DrawDots}->Checked) {
+        for(1..20) {
+            $DC->SetPixel(
+                rand()*$W, 
+                rand()*$H, 
+                [ rand()*255, rand()*255, rand()*255 ],
+            );
+        }
+    } elsif($Menu->{DrawBoxes}->Checked) {
+        $P = new Win32::GUI::Pen(   
+            -color => [ rand()*255, rand()*255, rand()*255 ], 
+            -width => rand()*5,
+        );
+        $B = new Win32::GUI::Brush(
+            [ rand()*255, rand()*255, rand()*255 ]
+        );
+        $DC->SelectObject($P);
+        $DC->SelectObject($B);
+        $left   = rand()*$W;
+        $top    = rand()*$H;
+        $right  = $left + rand()*($W-$left);
+        $bottom = $top + rand()*($H-$top);
+        $DC->Rectangle($left, $top, $right, $bottom);
+    } elsif($Menu->{DrawCircles}->Checked) {
+        $P = new Win32::GUI::Pen(
+            -color => [ rand()*255, rand()*255, rand()*255 ], 
+            -width => rand()*5,
+        );
+        $B = new Win32::GUI::Brush(
+            [ rand()*255, rand()*255, rand()*255 ]
+        );
+        $DC->SelectObject($P);
+        $DC->SelectObject($B);
+        $left   = rand()*$W;
+        $top    = rand()*$H;
+        $right  = $left + rand()*($W-$left);
+        $bottom = $top + rand()*($H-$top);
+        $DC->Ellipse($left, $top, $right, $bottom);
+    } elsif($Menu->{DrawLines}->Checked) {
+        $P = new Win32::GUI::Pen(
+            -color => [ rand()*255, rand()*255, rand()*255 ], 
+            -width => rand()*5,
+        );
+        $DC->SelectObject($P);
+        $DC->BeginPath();
+        $DC->MoveTo(rand()*$W, rand()*$H);
+        $DC->LineTo(rand()*$W, rand()*$H);
+        $DC->EndPath();
+        $DC->StrokePath();
+    }
+}
+
+
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/folder.bmp perl-libwin32-0.191/GUI/samples/folder.bmp
--- libwin32-0.191/GUI/samples/folder.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/folder.bmp	2004-01-12 16:46:42.062500000 -0800
@@ -0,0 +1 @@
+BM       v   (                                      c              wwwwwwwwwwwwwwwwp      """"""EEEEDBUTTTTBUUUEEBUUTTTRUUUUEBUUUTTRUUUUUBfffffR"""wq6eQwwwwwwwwwwwwwwww
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/frm2pl.pl perl-libwin32-0.191/GUI/samples/frm2pl.pl
--- libwin32-0.191/GUI/samples/frm2pl.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/frm2pl.pl	2004-01-12 16:46:42.078125000 -0800
@@ -0,0 +1,110 @@
+#!perl -w
+use strict;
+
+my $file = shift or die "No file specified";
+
+my $twip = shift;
+
+frm2pl($file, $twip);
+
+sub frm2pl {
+    my($file, $twip) = @_;
+    my $doing = "nothing";
+    my @words;
+    my ($one, $two, $three);
+    my $FormName;
+    my $LINE;
+    $twip = 15 unless $twip;
+    
+    print "\nuse Win32::GUI;\n\n";
+
+    if(open(FRM, $file)) {
+        while($LINE = <FRM>) {
+            chomp $LINE;
+            $LINE =~ s/^\s*//;
+            $LINE =~ s/\s*$//;
+            ($one, $two, $three) = split(/\s+/, $LINE, 3);
+            if($one =~ /^BEGIN$/i) {
+                if($two =~ /^VB\.FORM$/i) {
+                    $FormName = $three;
+                    print "\$$FormName = new Win32::GUI::Window(\n";
+                    print "\t-name => \"$FormName\",\n";            
+                    $doing = "form";
+                } elsif($two =~ /^VB\.COMMANDBUTTON$/i) {
+                    print_ctl("Button");
+                } elsif($two =~ /^VB\.TEXTBOX$/i) {
+                    print_ctl("Textfield");
+                } elsif($two =~ /^VB\.CHECKBOX$/i) {
+                    print_ctl("Checkbox");
+                } elsif($two =~ /^VB\.LABEL$/i) {
+                    print_ctl("Label");
+                } elsif($two =~ /^VB\.LISTBOX$/i) {
+                    print_ctl("Listbox");
+                } elsif($two =~ /^VB\.OPTIONBUTTON$/i) {
+                    print_ctl("RadioButton");
+                } elsif($two =~ /^COMCTLLIB\.TREEVIEW$/i) {
+                    print_ctl("TreeView");
+                } elsif($two =~ /^COMCTLLIB\.IMAGELIST/i) {
+                    print_ctl("ImageList");
+                } elsif($two =~ /^COMCTLLIB\.STATUSBAR/i) {
+                    print_ctl("StatusBar");
+                } else {
+                    print ");\n" if $doing ne "nothing";
+                    $doing = "nothing";
+                }
+            } else {
+                if($doing ne "nothing") {
+                    if($one =~ /^END$/i) {
+                        print ");\n";
+                        $doing = "nothing";
+                    } elsif(index("_LEFTTOPWIDTHHEIGHT", uc($one)) > 0 and $two eq "=") {
+                        print "\t-", lc($one), " => ", int($three / $twip), ",\n";
+                    } elsif(index("_VISIBLE", uc($one)) > 0 and $two eq "=") {
+                        print "\t-visible => ", $three, ",\n";
+                    } elsif(uc($one) eq "CAPTION" and $two eq "=") {
+                        print "\t-text => quoteforperl((split(/\s*=\s*/, $LINE, 2))[1]),\n";
+                    }
+                }
+            }
+
+        }
+        close(FRM);
+        if($FormName) {
+            print "\n\$$FormName->Show;\n";
+            print "Win32::GUI::Dialog();\n\n";
+        }
+
+        print <<_END_;
+
+sub ${FormName}_Terminate {
+    return -1;
+}
+
+_END_
+
+    } else {
+        warn "Can't open file $file: $!\n";
+        return 0;
+    }
+    return 1;
+
+sub print_ctl {
+    my($ctl) = @_;
+    print ");\n" if $doing eq "form";
+    print "\$three = \$$FormName->Add$ctl(\n";
+    print "\t-name => \"$three\",\n";
+    $doing = $ctl;
+}
+
+
+}
+
+sub quoteforperl {
+    my($what) = @_;
+    $what =~ s/\$/\\\$/g;
+    $what =~ s/\@/\\\@/g;
+    $what =~ s/\%/\\\%/g;
+    return $what;
+}
+
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/harrow.cur perl-libwin32-0.191/GUI/samples/harrow.cur
--- libwin32-0.191/GUI/samples/harrow.cur	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/harrow.cur	2004-01-12 16:46:42.093750000 -0800
@@ -0,0 +1 @@
+               (       @                                                                                                     DDD@          DDD@          DDD@          DDD@          DDD@           D                                                                                                                              p          p                    w           p                                                                     w                                    `  
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/hello.pl perl-libwin32-0.191/GUI/samples/hello.pl
--- libwin32-0.191/GUI/samples/hello.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/hello.pl	2004-01-12 16:46:42.109375000 -0800
@@ -0,0 +1,48 @@
+##!perl -w
+#
+# Simple Win32::GUI script to create a button that prints "Hello, world".
+# Click on the button to terminate the program.
+#
+# (rewritten from Tk's demos/hello)
+
+#use Devel::Leak;
+use Win32::GUI;
+$MW = new Win32::GUI::Window(
+    -title   => 'hello.pl',
+    -left    => 100,
+    -top     => 100,
+    -width   => 150,
+    -height  => 100,
+    -name    => 'MainWindow',
+#    -visible => 1,
+);
+#print "MW=$MW\n";
+#print "MW.handle=", $MW->{-handle}, "\n";
+#my $count = Devel::Leak::NoteSV($MW);
+#print "NoteSV.count = $count\n";
+#print "MW=$MW\n";
+$hello = $MW->AddButton(
+    -text    => 'Hello, world',
+    -name    => 'Hello',
+    -left    => 25,
+    -top     => 25,
+);
+
+$MW->Show();
+$rc = Win32::GUI::Dialog(0);
+
+# Devel::Leak::CheckSV($MW);
+
+sub MainWindow_Terminate {
+    $MW->PostQuitMessage(1);
+    # return -1;
+}
+
+sub Hello_Click {
+    if($MW->Hello->Text eq "Hello, world") {
+        $MW->Hello->{-text} = "OneMoreTime";
+    } else {
+        print STDOUT "Hello, world\n";
+        $MW->PostQuitMessage(0);
+    }
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/listbox.pl perl-libwin32-0.191/GUI/samples/listbox.pl
--- libwin32-0.191/GUI/samples/listbox.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/listbox.pl	2004-01-12 16:46:42.125000000 -0800
@@ -0,0 +1,289 @@
+
+use Win32::GUI;
+use Win32::Sound;
+
+# $class = new GUI::Class("GUIPERL") or print_and_die("new Class");
+
+$CUR = GUI::LoadCursorFromFile("harrow.cur");
+# print "CUR = $CUR\n";
+# $OLDCUR = GUI::SetCursor($CUR);
+
+$W = new GUI::Window(
+    -title    => "Win32::GUI::Listbox text",
+    -left     => 100, 
+    -top      => 100, 
+    -width    => 360, 
+    -height   => 210,
+    -style    => 1024 | WS_BORDER | WS_CAPTION | WS_SYSMENU,
+    -name     => "Window",
+) or print_and_die("new Window");
+
+$List1 = $W->AddListbox(
+    -name => "List1",
+    # -style => WS_CHILD | WS_VISIBLE | 1,
+    -left => 5,
+    -top  => 5,
+    -height => 120,
+    -menu => 1,
+    -tabstop => 1,
+    -group => 1,
+    -width => 100,
+    -foreground => [255, 255, 255],
+    -background => [64, 64, 64],
+    -style => WS_VSCROLL | WS_VISIBLE | WS_CHILD,
+) or print_and_die("new Listbox");
+
+$List1->SendMessage(0x0195, 201, 0);
+
+$List1->AddString("Item 1 veryveryvery long");
+$List1->AddString("Item 2");
+$List1->AddString("Item 3");
+$List1->AddString("Item 4");
+$List1->AddString("Item 5");
+$List1->AddString("Item 2");
+$List1->AddString("Item 3");
+$List1->AddString("Item 4");
+$List1->AddString("Item 5");
+$List1->AddString("Item 2");
+$List1->AddString("Item 3");
+$List1->AddString("Item 4");
+$List1->AddString("Item 5");
+$List1->AddString("Item 2");
+$List1->AddString("Item 3");
+$List1->AddString("Item 4");
+$List1->AddString("Item 5");
+$List1->Select(0);
+
+$List2 = $W->AddListbox(
+    -name => "List2",
+    -addstyle => WS_CHILD | WS_VISIBLE | 1,
+    -left => 250,
+    -top  => 5,
+    -height => 120,
+    -menu => 2,
+    -tabstop => 1,
+    -group => 1, 
+    -width => 100,
+    -multisel => 1,
+    -vscroll => 1,
+);
+
+
+$B = new Win32::GUI::Brush([0, 0, 128]);
+
+$Add = $W->AddButton(
+    -text  => "Add >",
+    -left  => 125,
+    -top   => 5,
+    -width => 100,
+    -menu  => 3,
+    -tabstop => 1,
+    -group => 1,
+    -name  => "Add",
+    -foreground => [255, 255, 255],
+    -background => $B->{-handle},
+);
+
+$AddAll   = $W->AddButton(-text  => "All >>",
+                          -left  => 125,
+                          -top   => 35,
+                          -width => 100,
+                          -menu => 4,
+                          -tabstop => 1,
+                          -name  => "AddAll") or print_and_die("new Button");
+
+$Remove = $W->AddButton(-text  => "< Remove",
+                        -left  => 125,
+                        -top   => 65,
+                        -width => 100,
+                        -menu  => 5,
+                        -name  => "Remove") or print_and_die("new Button");
+
+$RemoveAll = $W->AddButton(-text  => "<< All",
+                           -left  => 125,
+                           -top   => 95,
+                           -width => 100,
+                           -menu  => 6,
+                           -name  => "RemoveAll") or print_and_die("new Button");
+
+
+$Up = $W->AddButton(-text  => "Up",
+                    -left  => 5,
+                    -top   => 150,
+                    -width => 45,
+                    -menu => 7,
+                    -tabstop => 1,
+                    -group => 1,
+                    -name  => "Up") or print_and_die("new Button");
+
+$Down = $W->AddButton(-text  => "Down",
+                      -left  => 55,
+                      -top   => 150,
+                      -width => 45,
+                      -menu => 8,
+                      -tabstop => 1,
+                      -group => 1,
+                      -name  => "Down") or print_and_die("new Button");
+                              
+$Close = $W->AddButton(-text  => "Close", 
+                       -left  => 250, 
+                       -top   => 150, 
+                       -width => 100,
+                       -name  => "Close") or print_and_die("new Button");
+
+$Edit1 = $W->AddTextfield(
+    -text => "ciao",
+    -name => "Edit1",
+    -left => 5,
+    -top  => 115,
+    -height => 20,
+    -style => WS_TABSTOP | WS_CHILD | WS_BORDER | WS_VISIBLE | ES_LEFT | DS_3DLOOK,
+    -width => 100,
+    -foreground => [255, 255, 255],
+    -background => [64, 64, 64],
+) or print_and_die("new Textfield");
+
+$Edit2 = $W->AddTextfield(
+    -text => "ciao",
+    -name => "Edit2",
+    -left => 250,
+    -top  => 115,
+    -height => 20,
+    -style => WS_TABSTOP | WS_CHILD | WS_BORDER | WS_VISIBLE | ES_LEFT | DS_3DLOOK,
+    -width => 100,
+) or print_and_die("new Textfield");
+
+
+$W->Show;
+
+$return = $W->Dialog();
+
+sub List1_Click {
+    my $sel = $List1->SelectedItem();
+    if($sel != -1) {
+        $Edit1->Text($List1->GetString($sel));
+    }
+}
+
+sub List1_DblClick {
+    Add_Click();
+}
+
+sub List2_Click {
+    my $sel = $List2->SelectedItem();
+    if($sel != -1) {
+        $Edit2->Text($List2->GetString($sel));
+    }
+    return 1;
+}
+
+sub List2_DblClick {
+    Remove_Click();
+}
+
+sub Add_Click {
+    my $sel = $List1->SelectedItem();
+    if($sel != -1) {
+        my $new = $List2->InsertItem($List1->GetString($sel));
+        $List2->Select($new);
+        $Edit2->Text($List2->GetString($List2->SelectedItem));
+    } else {
+        Win32::Sound::Play("SystemDefault", SND_ASYNC);
+    }
+    return 1;    
+}
+
+sub Remove_Click {
+    my $sel = $List2->SelectedItem();
+    if($sel != -1) {
+        $List2->RemoveItem($sel);
+        $Edit2->Text("");
+        if($List2->Count > 0) {
+            if($sel >= $List2->Count) {
+                $List2->Select($List2->Count-1);
+            } else {
+                $List2->Select($sel);
+            }
+            $Edit2->Text($List2->GetString($List2->SelectedItem));
+        }
+    } else {
+        Win32::Sound::Play("SystemDefault", SND_ASYNC);
+    }
+    return 1;    
+}
+
+sub AddAll_Click {
+    for $i (0..$List1->Count-1) {
+        $List2->InsertItem($List1->GetString($i));
+    }
+    $List2->Select($List2->Count-1);
+    $Edit2->Text($List2->GetString($List2->SelectedItem));
+    return 1;
+}
+
+sub RemoveAll_Click {
+    if($List2->Count > 0) {
+        $List2->Clear;
+        $Edit2->Text("");
+    } else {
+        Win32::Sound::Play("SystemDefault", SND_ASYNC);
+    }
+    return 1;
+}
+
+sub Edit1_Change {
+    my $sel = $List1->SelectedItem();
+    if($sel != -1) {
+        $List1->RemoveItem($sel);
+        $List1->InsertItem($Edit1->Text, $sel);
+        $List1->Select($sel);
+    }
+    return 1;
+}
+
+sub Edit2_Change {
+    my $sel = $List2->SelectedItem();
+    if($sel != -1) {
+        $List2->RemoveItem($sel);
+        $List2->InsertItem($Edit2->Text, $sel);
+        $List2->Select($sel);
+    }
+    return 1;    
+}
+
+
+sub Up_Click {
+    my $sel = $List1->SelectedItem();
+    if($sel > 0) {
+        my $string = $List1->GetString($sel);
+        $List1->RemoveItem($sel);
+        $List1->InsertItem($string, $sel-1);
+        $List1->Select($sel-1);
+    } else {
+        Win32::Sound::Play("SystemDefault", SND_ASYNC);
+    }
+    return 1;    
+}
+
+sub Down_Click {
+    my $sel = $List1->SelectedItem();
+    if($sel < $List1->Count-1) {
+        my $string = $List1->GetString($sel);
+        $List1->RemoveItem($sel);
+        $List1->InsertItem($string, $sel+1);
+        $List1->Select($sel+1);
+    } else {
+        Win32::Sound::Play("SystemDefault", SND_ASYNC);
+    }
+    return 1;    
+}
+
+sub Close_Click {
+    return -1;
+}
+
+sub print_and_die {
+    my($text) = @_;
+    my $err = Win32::GetLastError();
+    die "$text: Error $err\n";
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/listview.pl perl-libwin32-0.191/GUI/samples/listview.pl
--- libwin32-0.191/GUI/samples/listview.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/listview.pl	2004-01-12 16:46:42.140625000 -0800
@@ -0,0 +1,130 @@
+
+use Win32::GUI;
+
+$Window = new GUI::Window(
+    -name   => "Window",
+    -text   => "Win32::GUI::ListView test",
+    -width  => 300,
+    -height => 400,
+    -left   => 100,
+    -top    => 100,
+);
+
+$IL = new GUI::ImageList(16, 16, 24, 3, 10);
+$IL->Add("one.bmp");
+$IL->Add("two.bmp");
+$IL->Add("three.bmp");
+
+$Window->AddListView(
+    -name      => "ListView",
+    -text      => "hello world!",
+    -left      => 10,
+    -top       => 10,
+    -width     => 280,
+    -height    => 180,
+    -imagelist => $IL,
+    -style     => WS_CHILD | WS_VISIBLE | 1,
+    -fullrowselect => 1,
+    -gridlines => 1,
+    -checkboxes => 1,
+#    -hottrack   => 1,
+);
+
+$Window->AddButton(
+    -name => "LV1",
+    -text => "Big Icons",
+    -left => 10,
+    -top  => 200,
+);
+
+$Window->AddButton(
+    -name => "LV2",
+    -text => "Small Icons",
+    -left => 10,
+    -top  => 230,
+);
+
+$Window->AddButton(
+    -name => "LV3",
+    -text => "List",
+    -left => 10,
+    -top  => 260,
+);
+
+$Window->AddButton(
+    -name => "LV4",
+    -text => "Details",
+    -left => 10,
+    -top  => 290,
+);
+
+$width = $Window->ListView->ScaleWidth;
+
+$Window->ListView->InsertColumn(
+    -index => 0,
+    -width => $width/2,
+    -text  => "Name",
+);
+$Window->ListView->InsertColumn(
+    -index   => 1,
+    -subitem => 1,
+    -width   => $width/2,
+    -text    => "Description",
+);
+
+sub InsertListItem {
+    my($image, $name, $description) = @_;
+    my $item = $Window->ListView->InsertItem(
+        -item  => $Window->ListView->Count(),
+        -text  => $name,
+        -image => $image,
+        # -index => $Window->ListView->Count(),
+    );
+    $Window->ListView->SetItem(
+        -item    => $item,
+        -subitem => 1,
+        -text    => $description,
+    );
+}
+
+# InsertListItem(0, "ciao", "greetings");
+
+$Window->ListView->InsertItem(-text => [ "abracadabra", "magic word" ] );
+
+#InsertListItem(1, "abracadabra", "magic word");
+InsertListItem(2, "John", "first name");
+
+$Window->ListView->TextColor(hex("0000FF"));
+
+$Window->Show();
+
+$Window->Dialog();
+
+# GUI::Show($Win32::GUI::hwnd);
+
+sub LV1_Click {
+    print "BIG Icons!\n";
+    $Window->ListView->View(0);
+}
+
+sub LV2_Click {
+    print "small Icons!\n";
+    $Window->ListView->View(2);
+}
+
+sub LV3_Click {
+    print "List!\n";
+    $Window->ListView->View(3);
+}
+
+sub LV4_Click {
+    print "Details!\n";
+    $Window->ListView->View(1);
+}
+
+sub ListView_ItemClick {
+	my($item) = @_;
+	print "Item: $item\n";
+	print "GetSelectionMark: ", $Window->ListView->SendMessage(0x1000+66, 0, 0), "\n";
+	print "GetSelectionCount: ", $Window->ListView->SendMessage(0x1000+50, 0, 0), "\n";
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/module.bmp perl-libwin32-0.191/GUI/samples/module.bmp
--- libwin32-0.191/GUI/samples/module.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/module.bmp	2004-01-12 16:46:42.156250000 -0800
@@ -0,0 +1 @@
+BM       v   (                                                                                      
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/mousemove.pl perl-libwin32-0.191/GUI/samples/mousemove.pl
--- libwin32-0.191/GUI/samples/mousemove.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/mousemove.pl	2004-01-12 16:46:42.171875000 -0800
@@ -0,0 +1,84 @@
+use Win32::GUI;
+
+$W = new Win32::GUI::Window(
+    -name => "Window",
+    -title => "Mouse tracking sample",
+    -left => 100,
+    -top => 100,
+    -width => 300,
+    -height => 300,
+);
+
+$Status = $W->AddStatusBar(
+    -name => "Status",
+);
+
+$LC = new Win32::GUI::Class(
+    -name => "dadasListBoxClass",
+    -extends => "LISTBOX",
+    -widget => "Listbox",
+);
+
+$L = $W->AddListbox(
+    -class => $LC,
+    -name => "List",
+    -left => 0,
+    -top => 0,
+    -width => $W->ScaleWidth,
+    -height => $W->ScaleHeight-$Status->Height,
+);
+
+$comment = <<EOC;
+$W = new Win32::GUI::Window(
+    -name => "Window",
+    -title => "Mouse tracking sample",
+    -left => 100,
+    -top => 100,
+    -width => 300,
+    -height => 300,
+);
+
+$Status = $W->AddStatusBar(
+    -name => "Status",
+);
+
+$LC = new Win32::GUI::Class(
+    -name => "PodView_RichEdit",
+    -extends => "RichEdit",
+    -widget => "RichEdit",
+);
+
+$L = $W->AddRichEdit(
+    -class => $LC,
+    -name => "List",
+    -left => 0,
+    -top => 0,
+    -width => $W->ScaleWidth,
+    -height => $W->ScaleHeight-$Status->Height,
+    -text => "hello, I'm a RichEdit!!!\r\ndadada",
+);
+EOC
+
+$W->Show();
+Win32::GUI::Dialog();
+
+exit(0);
+
+
+
+sub Window_Terminate {
+    return -1;
+}
+
+sub Window_Resize {
+    $L->Resize($W->ScaleWidth, $W->ScaleHeight-$Status->Height);
+    $Status->Move(0, $W->ScaleHeight-$Status->Height);
+    $Status->Resize($W->ScaleWidth, $Status->Height);
+}
+
+sub List_MouseMove {
+    my($mx, $my) = Win32::GUI::GetCursorPos();
+    my $Lx = $L->Left;
+    my $Ly = $L->Top;
+    $Status->Text(($mx-$Lx).", ".($my-$Ly));
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/msk.pl perl-libwin32-0.191/GUI/samples/msk.pl
--- libwin32-0.191/GUI/samples/msk.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/msk.pl	2004-01-12 16:46:42.187500000 -0800
@@ -0,0 +1,247 @@
+
+use Win32::GUI;
+
+$file = ($ARGV[0] or "test.msk");
+
+$dummyWin = new Win32::GUI::Window();
+($OCW, $OCH) = $dummyWin->GetTextExtentPoint32("_");
+# $OCH = $OCH*1.2;
+$LH = $OCH*1.5;
+print "OneChar = ($OCW x $OCH)\n";
+undef $dummyWin;
+open(MSK, $file) or die "Can't open $file: $!\n";
+
+$layout = 0;
+$lineindex = 0;
+while(<MSK>) {
+    chomp;
+    if(/\[BEGIN\]/) {
+        $Msk = new Win32::GUI::Window(
+            -name => "Msk", 
+            -text => "Msk", 
+            -left => 100, 
+            -top => 100,
+            -font => $Font,
+        );
+        $layout = 1;
+        $maxlength = 0;
+    } elsif(/\[END\]/) {
+        $layout = 0;
+    } else {
+        if($layout == 1) {
+            $line = $_;
+            $maxlength = length($line) if length($line) > $maxlength;
+            $doing = "";
+            %this = ();
+            for $i (0..length($line)) {
+                $c = substr($line, $i, 1);
+                if($doing eq "Textfield") {
+                    if($c eq "_") {
+                        $this{length}++;
+                    } else {
+                        # end of a Textfield, we create it.
+                        $width = $this{length}*$OCW;
+                        $left = $this{start}*$OCW;
+                        $top = $lineindex*$LH-2;
+                        $height = $OCH+4;
+                        $field = $Msk->AddTextfield(
+                            -text   => "",
+                            -left   => $left,
+                            -top    => $top,
+                            -width  => $width,
+                            -height => $height,
+                        );
+                        $doing = "";
+                    }
+                } elsif($doing eq "Button") {
+                    if($c eq "}") {
+                        # end of a Button, we create it.
+                        $this{length}++;
+                        $width = $this{length}*$OCW;
+                        $left = $this{start}*$OCW;
+                        $top = $lineindex*$LH-2;
+                        $height = $OCH+4;
+                        $field = $Msk->AddButton(
+                            -text   => $this{text},
+                            -left   => $left,
+                            -top    => $top,
+                            -width  => $width,
+                            -height => $height,
+                        );
+                        $doing = "";
+                    } else {
+                        $this{text} .= $c;
+                        $this{length}++;
+                    }
+                } elsif($doing eq "Label") {
+                    if($c eq "{") {
+                        # end of a Label, start of a Button.
+                        $width = $this{length}*$OCW;
+                        $left = $this{start}*$OCW;
+                        $top = $lineindex*$LH-2;
+                        $height = $OCH+4;
+                        $field = $Msk->AddLabel(
+                            -text   => $this{text},
+                            -left   => $left,
+                            -top    => $top,
+                            -width  => $width,
+                            -height => $height,
+                        );
+                        %this = ();
+                        $this{start} = $i;
+                        $this{length} = 1;
+                        $doing = "Button";
+                    } elsif($c eq "_") {
+                        # end of a Label, start of a Textfield.
+                        $width = $this{length}*$OCW;
+                        $left = $this{start}*$OCW;
+                        $top = $lineindex*$LH-2;
+                        $height = $OCH+4;
+                        $field = $Msk->AddLabel(
+                            -text   => $this{text},
+                            -left   => $left,
+                            -top    => $top,
+                            -width  => $width,
+                            -height => $height,
+                        );
+                        %this = ();
+                        $this{start} = $i;
+                        $this{length} = 1;
+                        $doing = "Textfield";
+                    } else {
+                        $this{text} .= $c;
+                        $this{length}++;
+                    }
+
+                } elsif($doing eq "") {
+                    if($c eq "_") {
+                        %this = ();
+                        $this{start} = $i;
+                        $this{length} = 1;
+                        $doing = "Textfield";
+                    } elsif($c eq "{") {
+                        %this = ();
+                        $this{start} = $i;
+                        $this{length} = 1;
+                        $doing = "Button";
+                    } elsif($c ne " ") {
+                        %this = ();
+                        $this{start} = $i;
+                        $this{length} = 1;
+                        $this{text} = $c;
+                        $doing = "Label";
+                    }
+                }
+            }
+            $lineindex++;
+        } else {
+            ;
+        }
+    }
+}
+close(MSK);
+
+$W = $maxlength*$OCW;
+$H = $lineindex*$LH;
+$Msk->Resize($W, $H);
+while($Msk->ScaleWidth < $W) {
+    $Msk->Width($Msk->Width+1);
+}
+while($Msk->ScaleHeight < $H) {
+    $Msk->Height($Msk->Height+1);
+}
+
+$Msk->Show();
+
+Win32::GUI::Dialog();
+
+sub Msk_Terminate {
+    return -1;
+}
+
+
+# OLD STUFF
+#            $stayhere = 1;
+#            while($stayhere == 1) {
+#                $start = index($line, "{", $end);
+#                if($start > 0) {
+#                    $start++;
+#                    print "start = $start\n";
+#                    $end = index($line, "}", $start);
+#                    $end--;
+#                    print "end = $end\n";
+#                    $text = substr($line, $start, $end-$start);
+#                    print "text = $text\n";
+#                    $width = ($end - $start)*$OCW;
+#                    $left = $start*$OCW;
+#                    $top = $lineindex*$OCH-2;
+#                    $height = $OCH+4;
+#                    $button = $Msk->AddButton(
+#                        -text => $text,
+#                        -left => $left,
+#                        -top    => $top,
+#                        -width  => $width,
+#                        -height => $height,
+#                    );
+#                    #$start--;
+#                    #$end++;
+#                    $line = substr($line, 0, $start) . (" " x ($end-$start)) . substr($line, $end);
+#                } else {
+#                    $stayhere = 0;
+#                }
+#            }
+#            $stayhere = 1;
+#            $start = 0;
+#            $end = 0;
+#            while($stayhere == 1) {
+#                $start = index($line, "_", $end);
+#                if($start > 0) {
+#                    print "start = $start\n";
+#                    $end = $start;
+#                    $end++ while(substr($line, $end, 1) eq "_");
+#                    print "end = $end\n";
+#                    $text = substr($line, $start, $end-$start);
+#                    print "text = $text\n";
+#                    $width = ($end - $start)*$OCW;
+#                    $left = $start*$OCW;
+#                    $top = $lineindex*$OCH-2;
+#                    $height = $OCH+4;
+#                    $field = $Msk->AddTextfield(
+#                        -text => "",
+#                        -left => $left,
+#                        -top    => $top,
+#                        -width  => $width,
+#                        -height => $height,
+#                    );
+#                    $line = substr($line, 0, $start) . (" " x ($end-$start)) . substr($line, $end);
+#                } else {
+#                    $stayhere = 0;
+#                }
+#            }
+#
+#            $start = 0;
+#            $end = 0;
+#            while($stayhere == 1) {
+#                $start = index($line, "_", $end);
+#                if($start > 0) {
+#                    print "start = $start\n";
+#                    $end = $start;
+#                    $end++ while(substr($line, $end, 1) eq "_");
+#                    print "end = $end\n";
+#                    $text = substr($line, $start, $end-$start);
+#                    print "text = $text\n";
+#                    $width = ($end - $start)*$OCW;
+#                    $left = $start*$OCW;
+#                    $top = $lineindex*$OCH-2;
+#                    $height = $OCH+4;
+#                    $field = $Msk->AddTextfield(
+#                        -text => "",
+#                        -left => $left,
+#                        -top    => $top,
+#                        -width  => $width,
+#                        -height => $height,
+#                    );
+#                } else {
+#                    $stayhere = 0;
+#                }
+#            }
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/nem_lv.pl perl-libwin32-0.191/GUI/samples/nem_lv.pl
--- libwin32-0.191/GUI/samples/nem_lv.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/nem_lv.pl	2004-01-12 16:46:42.203125000 -0800
@@ -0,0 +1,131 @@
+
+use Win32::GUI;
+
+$Window = new GUI::Window(
+    -name   => "Window",
+    -text   => "Win32::GUI::ListView test",
+    -width  => 300,
+    -height => 400,
+    -left   => 100,
+    -top    => 100,
+);
+
+$IL = new GUI::ImageList(16, 16, 24, 3, 10);
+$IL->Add("one.bmp");
+$IL->Add("two.bmp");
+$IL->Add("three.bmp");
+
+$Window->AddListView(
+    -name      => "ListView",
+    -text      => "hello world!",
+    -left      => 10,
+    -top       => 10,
+    -width     => 280,
+    -height    => 180,
+    -imagelist => $IL,
+    -fullrowselect => 1,
+    -gridlines => 1,
+    -checkboxes => 1,
+#    -hottrack   => 1,
+	-events => { ItemClick => "NEMTEST", },
+);
+
+$Window->AddButton(
+    -name => "LV1",
+    -text => "Big Icons",
+    -left => 10,
+    -top  => 200,
+);
+
+$Window->AddButton(
+    -name => "LV2",
+    -text => "Small Icons",
+    -left => 10,
+    -top  => 230,
+);
+
+$Window->AddButton(
+    -name => "LV3",
+    -text => "List",
+    -left => 10,
+    -top  => 260,
+);
+
+$Window->AddButton(
+    -name => "LV4",
+    -text => "Details",
+    -left => 10,
+    -top  => 290,
+);
+
+$width = $Window->ListView->ScaleWidth;
+
+$Window->ListView->InsertColumn(
+    -index => 0,
+    -width => $width/2,
+    -text  => "Name",
+);
+$Window->ListView->InsertColumn(
+    -index   => 1,
+    -subitem => 1,
+    -width   => $width/2,
+    -text    => "Description",
+);
+
+sub InsertListItem {
+    my($image, $name, $description) = @_;
+    my $item = $Window->ListView->InsertItem(
+        -item  => $Window->ListView->Count(),
+        -text  => $name,
+        -image => $image,
+        # -index => $Window->ListView->Count(),
+    );
+    $Window->ListView->SetItem(
+        -item    => $item,
+        -subitem => 1,
+        -text    => $description,
+    );
+}
+
+# InsertListItem(0, "ciao", "greetings");
+
+$Window->ListView->InsertItem(-text => [ "abracadabra", "magic word" ] );
+
+#InsertListItem(1, "abracadabra", "magic word");
+InsertListItem(2, "John", "first name");
+
+$Window->ListView->TextColor(hex("0000FF"));
+
+$Window->Show();
+
+$Window->Dialog();
+
+# GUI::Show($Win32::GUI::hwnd);
+
+sub LV1_Click {
+    print "BIG Icons!\n";
+    $Window->ListView->View(0);
+}
+
+sub LV2_Click {
+    print "small Icons!\n";
+    $Window->ListView->View(2);
+}
+
+sub LV3_Click {
+    print "List!\n";
+    $Window->ListView->View(3);
+}
+
+sub LV4_Click {
+    print "Details!\n";
+    $Window->ListView->View(1);
+}
+
+sub NEMTEST {
+	my($self, $item) = @_;
+	print "Item: $item\n";
+	print "GetSelectionMark: ", $self->SendMessage(0x1000+66, 0, 0), "\n";
+	print "GetSelectionCount: ", $self->SendMessage(0x1000+50, 0, 0), "\n";
+	return 0;
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/nem_tv.pl perl-libwin32-0.191/GUI/samples/nem_tv.pl
--- libwin32-0.191/GUI/samples/nem_tv.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/nem_tv.pl	2004-01-12 16:46:42.218750000 -0800
@@ -0,0 +1,237 @@
+
+use Win32::GUI;
+
+$Menu = Win32::GUI::MakeMenu(
+    "&Options"   => "Options",
+    " > Set &indent..."  => "Indent",
+    " > Choose &font..."  => "Font",
+    " > &Lines"  => { -name => "HasLines", -checked => 1 },
+    " > &Root lines"  => { -name => "HasRootLines", -checked => 1 },
+    " > &Buttons"  => { -name => "HasButtons", -checked => 1 },
+    " > I&mage"  => { -name => "HasImages", -checked => 1 },
+    " > -"       => 0,
+    " > E&xit"   => "Exit",
+);
+
+$Window = new GUI::Window(
+    -name   => "Window",
+    -text   => "Win32::GUI TEST - TreeView",
+    -height => 200, 
+    -width  => 300,
+    -left   => 100, 
+    -top    => 100,
+    -menu   => $Menu,
+    -eventmodel => 'both',
+);
+
+$C = new Win32::GUI::Cursor("harrow.cur");
+
+Win32::GUI::SetCursor($C);
+
+$B1 = new Win32::GUI::Bitmap("node.bmp");
+$B2 = new Win32::GUI::Bitmap("node_sel.bmp");
+
+$IL = new Win32::GUI::ImageList(16, 16, 0, 2, 10);
+$IL->Add($B1, 0);
+$IL->Add($B2, 0);
+
+$TV = $Window->AddTreeView(
+    -name      => "Tree",
+    -text      => "hello world!",
+    -width     => $Window->ScaleWidth, 
+    -height    => $Window->ScaleHeight,
+    -left      => 0, 
+    -top       => 0,
+    -lines     => 1, 
+    -rootlines => 1,
+    -buttons   => 1,
+    -visible   => 1,
+    -imagelist => $IL,
+#    -checkboxes => 1,
+#    -hottrack  => 1,
+
+	-events => {
+		NodeClick => sub {
+			my($self, $node) = @_;
+		    my %node = $self->GetItem($node);
+    		print "Click on node '$node{-text}' ".
+    		      "(checkbox is ", ($self->ItemCheck($_[0]) ? "on" : "off"), ")\n";
+    		return 1;
+    	},
+    	Expand => sub {
+    		my($self, $node) = @_;
+			my %node = $self->GetItem($node);
+			print "Expanded node '$node{-text}'\n";
+			$dblclick = 1;
+			return 1;
+		},
+		Collapse => sub {
+			my($self, $node) = @_;
+			my %node = $self->GetItem($node);
+			print "Collapsed node '$node{-text}'\n";
+			$dblclick = 1;
+			return 1;
+		},
+		DblClick => sub {
+			my($self) = @_;
+		    if(!$dblclick) {
+        		my($x, $y) = Win32::GUI::GetCursorPos();
+		        print "Double click at $x, $y\n";
+        		my $node = $self->SelectedItem();
+		        if($node) {
+            		$self->ItemCheck($node, !$self->ItemCheck($node));
+		            my %t = $self->GetItem($node);
+            		foreach my $k (keys %t) {
+                		print "$k => $t{$k}\n";
+            		}
+		        }
+    		} else {
+        		"got Collapse/Expand, ignoring DblClick\n";
+		        $dblclick = 0;
+    		}
+    		return 1;
+    	},
+    },
+);
+
+$IndentWin = new GUI::Window(
+    -text   => "Treeview Indent",
+    -name   => "IndentWin",
+    -width  => 200,
+    -height => 100, 
+    -left   => 110, 
+    -top    => 110,
+);
+
+$IndentVal = $IndentWin->AddLabel(
+    -text => "Indent value = ".$TV->Indent(),
+    -name => "IndentVal",
+    -left => 10, 
+    -top  => 10,
+);
+
+$IndentNew = $IndentWin->AddTextfield(
+    -text   =>  $TV->Indent(),
+    -name   =>  "IndentNew",
+    -left   =>  10, 
+    -top    => 40,
+    -width  => 100, 
+    -height => 25,
+);
+
+$IndentSet = $IndentWin->AddButton(
+    -text => "Set", 
+    -name => "IndentSet",
+    -left => 130, 
+    -top  => 40
+);
+                            
+$TV1 = $TV->InsertItem(
+    -text          => "ROOT", 
+    -image         => 0, 
+    -selectedimage => 1,
+);
+
+$TV3 = $TV->InsertItem(
+    -parent        => $TV1, 
+    -text          => "SUB 1", 
+    -image         => 0, 
+    -selectedimage => 1
+	-selected      => 1,
+);
+
+$TV2 = $TV->InsertItem(
+    -parent        => $TV1, 
+    -text          => "SUB 2", 
+    -image         => 0, 
+    -selectedimage => 1
+	-bold          => 1,
+);
+
+$Window->Show();
+
+my $dblclick = 0;
+
+Win32::GUI::Dialog();
+
+sub Window_Terminate {
+    $Window->PostQuitMessage(0);
+}
+
+sub Window_Resize {
+    $TV->Resize($Window->ScaleWidth, $Window->ScaleHeight);
+}
+
+sub Indent_Click {
+    $Window->Disable();    
+    $IndentVal->Text("Indent value = ".$TV->Indent());
+    $IndentNew->Text($TV->Indent());
+    $IndentWin->Show();
+    $IndentNew->SetFocus();
+    $IndentNew->Select(0, length($IndentNew->Text()));
+    return 1;
+}
+
+sub IndentSet_Click {
+    $TV->Indent($IndentNew->Text());
+    $IndentWin->Hide();
+    $Window->Enable();
+    $Window->SetForegroundWindow();
+}
+
+sub IndentWin_Terminate {
+    $IndentWin->Hide();
+    $Window->Enable();
+    $Window->SetForegroundWindow();
+}
+
+sub Font_Click {
+    $Window->Disable();
+    my @font = GUI::ChooseFont();
+    if($font[0] eq "-name") {
+        undef $TreeviewFont;
+        $TreeviewFont = new GUI::Font(@font);
+        $TV->SetFont($TreeviewFont);
+        # $TV->Change(-font => $TreeviewFont);
+    }
+    $Window->Enable();
+    $Window->SetForegroundWindow();
+}
+
+sub Exit_Click {
+    $Window->PostQuitMessage(0);
+}
+
+sub HasLines_Click {
+    my $checked = !$Menu->{HasLines}->Checked;
+    printf "TV.Style is: %08X\n", $TV->GetWindowLong(-16);
+    $TV->Change(-lines => $checked);
+    printf "TV.Style after -lines => %d is: %08X\n", $checked, $TV->GetWindowLong(-16);
+    $Menu->{HasLines}->Checked($checked);
+}
+
+sub HasRootLines_Click {
+    my $checked = !$Menu->{HasRootLines}->Checked;
+    printf "TV.Style is: %08X\n", $TV->GetWindowLong(-16);
+    $TV->Change(-rootlines => $checked);
+    printf "TV.Style after -rootlines => %d is: %08X\n", $checked, $TV->GetWindowLong(-16);
+    $Menu->{HasRootLines}->Checked($checked);
+}
+
+sub HasButtons_Click {
+    my $checked = !$Menu->{HasButtons}->Checked;
+    printf "TV.Style is: %08X\n", $TV->GetWindowLong(-16);
+    $TV->Change(-buttons => $checked);
+    printf "TV.Style after -buttons => %d is: %08X\n", $checked, $TV->GetWindowLong(-16);
+    $Menu->{HasButtons}->Checked($checked);
+}
+
+sub HasImages_Click {
+    if($Menu->{HasImages}->Checked) {
+        $Menu->{HasImages}->Checked(0);
+        $TV->SetImageList(0);
+    } else {
+        $Menu->{HasImages}->Checked(1);
+        $TV->SetImageList($IL);
+    }
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/nemtimer.pl perl-libwin32-0.191/GUI/samples/nemtimer.pl
--- libwin32-0.191/GUI/samples/nemtimer.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/nemtimer.pl	2004-01-12 16:46:42.234375000 -0800
@@ -0,0 +1,17 @@
+my $win = new Win32::GUI::Window (
+    -name => "MainWin",
+    -top => 100, -left => 100, -width => 100, -height => 100,
+    -onTimer => \&timerEvent,
+);
+
+$win->AddTimer("a_timer",1000);
+$win->AddTimer("another_timer",500);
+
+$win->Show();
+
+Win32::GUI::Dialog;
+
+sub timerEvent {
+    my($win, $timername) = @_;
+    print $timername." just ticked!\n";
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/node.bmp perl-libwin32-0.191/GUI/samples/node.bmp
--- libwin32-0.191/GUI/samples/node.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/node.bmp	2004-01-12 16:46:42.250000000 -0800
@@ -0,0 +1 @@
+BM6      6   (                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/node_sel.bmp perl-libwin32-0.191/GUI/samples/node_sel.bmp
--- libwin32-0.191/GUI/samples/node_sel.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/node_sel.bmp	2004-01-12 16:46:42.250000000 -0800
@@ -0,0 +1 @@
+BM6      6   (                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/ofn.pl perl-libwin32-0.191/GUI/samples/ofn.pl
--- libwin32-0.191/GUI/samples/ofn.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/ofn.pl	2004-01-12 16:46:42.265625000 -0800
@@ -0,0 +1,49 @@
+
+
+use Win32::GUI;
+
+$ret = GUI::GetOpenFileName(
+    -title  => "Win32::GUI::GetOpenFileName test",
+    -filter => [
+        "Text documents (*.txt)" => "*.txt", 
+        "Perl stuff (*.pl, *.pm)" => "*.pl;*.pm", 
+        "All files", "*.*",
+    ],
+    -defaultfilter => 1,
+    -hidereadonly => 0,
+    -filemustexist => 0,
+    -defaultextention => 'zzz',
+);
+
+if($ret) {
+    print "GetOpenFileName returned: '$ret'\n";
+} else {
+    if(GUI::CommDlgExtendedError()) {
+        print "ERROR. CommDlgExtendedError is: ", GUI::CommDlgExtendedError(), "\n";    
+    } else {
+        print "You cancelled.\n";
+    }
+}
+
+@ret = GUI::GetOpenFileName(
+    -title  => "Win32::GUI::GetOpenFileName test",
+    -filter => [
+        "Text documents (*.txt)" => "*.txt", 
+        "Perl stuff (*.pl, *.pm)" => "*.pl;*.pm", 
+        "All files", "*.*",
+    ],
+    -multisel => 1,
+    -hidereadonly => 0,
+);
+
+if(@ret) {
+    $ret = join (',', @ret);
+    print "GetOpenFileName returned: '$ret'\n";
+} else {
+    if(GUI::CommDlgExtendedError()) {
+        print "ERROR. CommDlgExtendedError is: ", GUI::CommDlgExtendedError(), "\n";    
+    } else {
+        print "You cancelled.\n";
+    }
+}
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/one.bmp perl-libwin32-0.191/GUI/samples/one.bmp
--- libwin32-0.191/GUI/samples/one.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/one.bmp	2004-01-12 16:46:42.281250000 -0800
@@ -0,0 +1 @@
+BM6      6   (                                                                                                                                                                                                                                                                                                                
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/pmx.html perl-libwin32-0.191/GUI/samples/pmx.html
--- libwin32-0.191/GUI/samples/pmx.html	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/pmx.html	2004-01-12 16:46:42.296875000 -0800
@@ -0,0 +1,15 @@
+<HTML>
+<HEAD>
+<TITLE>pmx.pl</TITLE>
+<LINK REV="made" HREF="mailto:">
+</HEAD>
+
+<BODY>
+
+<!-- INDEX BEGIN -->
+<!-- INDEX END -->
+
+
+</BODY>
+
+</HTML>
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/pmx.pl perl-libwin32-0.191/GUI/samples/pmx.pl
--- libwin32-0.191/GUI/samples/pmx.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/pmx.pl	2004-01-12 16:46:42.312500000 -0800
@@ -0,0 +1,1147 @@
+#!perl -w
+use blib;
+
+use strict;
+
+use Win32::GUI;
+use Win32::GUI::BitmapInline ();
+use Win32::Registry qw(HKEY_LOCAL_MACHINE);
+
+my $VERSION = "0.22";
+
+my $DEBUG = 0;
+
+my %items;
+my %InfoCache;
+
+my $PmxWindow_left;
+my $PmxWindow_top;
+my $PmxWindow_width;
+my $PmxWindow_height;
+my $PmxViewExDump;
+my $PmxViewScripts;
+my $PmxSaveSettings;
+
+my $BMP_UNKFOLDER;
+my $BMP_FOLDER;
+my $BMP_MODULE;
+my $BMP_DLL;
+
+sub DumpNames(\%$$);
+
+InitBitmaps();
+ReadConfig();
+
+print "making Menu...\n";
+
+my $Menu = Win32::GUI::MakeMenu(
+    "&File"                       => "File",
+    "   > &Properties"            => "FileProps",
+    "   > &View POD"              => "FilePod",
+    "   > &Dump"                  => "FileDump",
+    "   > -"                      => 0,
+    "   > E&xit"                  => { -name => "FileExit", -onClick => "FileExit_Click" },
+    "&View"                       => "View",
+    "   > &Scripts (PL)"          => { -name => "ViewPL", -checked => $PmxViewScripts },
+    "   > E&xtended Dump"         => { -name => "ViewExtendedDump", -checked => $PmxViewExDump },
+    "   > -"                      => 0,
+    "   > &Refresh"               => "ViewRefresh",
+    "   > Perl &Version"          => "ViewPerlVersion",
+    "&Settings"                   => "Settings",
+    "   > &Save settings on exit" => { -name => "SettingsSave", -checked => $PmxSaveSettings },
+    "   > &Reset settings"        => "SettingsReset",
+    "&?"                          => "Help",
+    "   > &About PMX"             => "HelpAbout",
+);
+
+print "making PopMenu...\n";
+
+my $PopMenu = Win32::GUI::MakeMenu(
+    "POP with POD"         => "POPUP_POD",
+    "   >&Properties"      => {-name => "PopProps1", -default => 1},
+    "   >&View POD"        => "PopPod",
+    "   >&Dump"            => "PopDump1",
+    "POP without POD"      => "POPUP_NOPOD",
+    "   >&Properties"      => {-name => "PopProps2", -default => 1},
+    "   >&Dump"            => "PopDump2",
+    "POP for DLLs"         => "POPUP_DLL",
+    "   >&Properties"      => {-name => "PopProps3", -default => 1},
+);
+
+my $Window = new Win32::GUI::Window(
+    -name   => "Window",
+    -text   => "PMX version ".$VERSION,
+    -height => $PmxWindow_height,
+    -width  => $PmxWindow_width,
+    -left   => $PmxWindow_left,
+    -top    => $PmxWindow_top,
+    -menu   => $Menu,
+	-events => {
+		Terminate => "Window_Terminate",
+	},
+#	-eventmodel => "byref",
+);
+print "Window: $Window\n";
+my $Icon = new Win32::GUI::Icon("camel.ico");
+
+$Window->SetIcon($Icon);
+
+my $IL = new Win32::GUI::ImageList(16, 16, 24, 4, 10);
+my $IL_UNKFOLDER = $IL->Add($BMP_UNKFOLDER);
+my $IL_FOLDER    = $IL->Add($BMP_FOLDER);
+my $IL_MODULE    = $IL->Add($BMP_MODULE);
+my $IL_DLL       = $IL->Add($BMP_DLL);
+my $result = $IL->BackColor(hex("00FF00"));
+
+$Window->AddStatusBar(
+    -name => "Status",
+);
+
+$Window->AddTabStrip(
+    -name    => "Dirs",
+    -left    => 0,
+    -top     => 0,
+    -width   => $Window->ScaleWidth,
+    -height  => $Window->ScaleHeight - $Window->Status->Height,
+    -visible => 1,
+);
+
+my $I;
+my %dirs;
+my @Tabs;
+foreach $I (0..$#INC) {
+    if(not exists($dirs{lc($INC[$I])})) {
+        $Window->Dirs->InsertItem(-text => lc($INC[$I]));
+        $dirs{lc($INC[$I])} = 1;
+        push(@Tabs, $INC[$I]);
+    }
+}
+
+$Window->AddTreeView(
+    -name      => "Tree",
+    -text      => "hello world!",
+    -left      => 0+$Window->Dirs->Left,
+    -top       => 20+$Window->Dirs->Top,
+    -width     => $Window->Dirs->ScaleWidth,
+    -height    => $Window->Dirs->ScaleHeight,
+    -lines     => 1,
+    -rootlines => 1,
+    -buttons   => 1,
+    -imagelist => $IL,
+);
+print "Window: $Window\n";
+
+my $ModuleWindow = new Win32::GUI::DialogBox(
+    -title   => "Module Properties",
+    -left    => 110,
+    -top     => 110,
+    -width   => 400,
+    -height  => 400,
+    -name    => "ModuleWindow",
+);
+
+
+$ModuleWindow->AddTabStrip(
+    -left    => 5,
+    -top     => 5,
+    -name    => "ModuleTabs",
+    -tabstop => 1,
+    -width   => $ModuleWindow->ScaleWidth-10,
+    -height  => $ModuleWindow->ScaleHeight-45,
+#    -container => 1,
+);
+$ModuleWindow->ModuleTabs->InsertItem(-text => "General");
+$ModuleWindow->ModuleTabs->InsertItem(-text => "Dump");
+
+my($cx, $cy) = $ModuleWindow->GetTextExtentPoint32("I'm a placeholder");
+
+my $lblleft   = 15;
+my $fldleft   = 80;
+my $fldwidth  = $ModuleWindow->ScaleWidth-$fldleft-20;
+my $top       = 40;
+my $interline = $cy*1.5;
+
+$ModuleWindow->ModuleTabs->AddLabel(
+    -name => "ModuleNameLbl",
+    -text => "Name:",
+    -left => $lblleft,
+    -top  => $top,
+);
+$ModuleWindow->ModuleTabs->AddLabel(
+    -text  => "I'm a placeholder",
+    -left  => $fldleft,
+    -top   => $top,
+    -width => $fldwidth,
+    -name  => "ModuleName",
+);
+
+$top += $interline;
+
+$ModuleWindow->ModuleTabs->AddLabel(
+    -name => "ModuleVersionLbl",
+    -text => "Version:",
+    -left => $lblleft,
+    -top  => $top,
+);
+$ModuleWindow->ModuleTabs->AddLabel(
+    -name  => "ModuleVersion",
+    -text  => "I'm a placeholder",
+    -left  => $fldleft,
+    -top   => $top,
+    -width => $fldwidth,
+);
+
+$top += $interline;
+
+$ModuleWindow->ModuleTabs->AddLabel(
+    -name  => "ModuleTypeLbl",
+    -text => "Type:",
+    -left => $lblleft,
+    -top  => $top,
+);
+$ModuleWindow->ModuleTabs->AddLabel(
+    -name  => "ModuleType",
+    -text  => "I'm a placeholder",
+    -left  => $fldleft,
+    -top   => $top,
+    -width => $fldwidth,
+);
+
+$top += $interline;
+
+$ModuleWindow->ModuleTabs->AddLabel(
+    -name  => "ModuleFileLbl",
+    -text => "Filename:",
+    -left => $lblleft,
+    -top  => $top,
+);
+$ModuleWindow->ModuleTabs->AddLabel(
+    -name  => "ModuleFile",
+    -text  => "I'm a placeholder",
+    -left  => $fldleft,
+    -top   => $top,
+    -width => $fldwidth,
+);
+
+$top += $interline;
+
+$ModuleWindow->ModuleTabs->AddLabel(
+    -name  => "ModuleSizeLbl",
+    -text => "File size:",
+    -left => $lblleft,
+    -top  => $top,
+);
+$ModuleWindow->ModuleTabs->AddLabel(
+    -name  => "ModuleSize",
+    -text  => "I'm a placeholder",
+    -left  => $fldleft,
+    -top   => $top,
+    -width => $fldwidth,
+);
+
+$top += $interline*1.5;
+
+$ModuleWindow->ModuleTabs->AddLabel(
+    -name  => "ModuleCtimeLbl",
+    -text => "Creation\r\ntime:",
+    -left => $lblleft,
+    -top  => $top-$cy,
+    -height => 30,
+);
+$ModuleWindow->ModuleTabs->AddLabel(
+    -name  => "ModuleCtime",
+    -text  => "I'm a placeholder",
+    -left  => $fldleft,
+    -top   => $top,
+    -width => $fldwidth,
+);
+
+$top += $interline*1.5;
+
+$ModuleWindow->ModuleTabs->AddLabel(
+    -name  => "ModuleMtimeLbl",
+    -text => "Modification\r\ntime:",
+    -left => $lblleft,
+    -top  => $top-$cy,
+    -height => 30,
+);
+$ModuleWindow->ModuleTabs->AddLabel(
+    -name  => "ModuleMtime",
+    -text  => "I'm a placeholder",
+    -left  => $fldleft,
+    -top   => $top,
+    -width => $fldwidth,
+);
+
+$ModuleWindow->ModuleTabs->AddTextfield(
+    -name      => "ModuleDump",
+    -multiline => 1,
+    -vscroll   => 1,
+    -hscroll   => 1,
+    -top       => 40,
+    -left      => 5,
+    -width     => $ModuleWindow->ModuleTabs->ScaleWidth-10,
+    -height    => $ModuleWindow->ModuleTabs->ScaleHeight-50,
+    -tabstop   => 1,
+    -visible   => 0,
+);
+
+$ModuleWindow->ModuleTabs->AddButton(
+    -name    => "ModuleViewPod",
+    -text    => "View POD",
+    -left    => $ModuleWindow->ScaleWidth-110,
+    -top     => 300,
+    -width   => 80,
+    -tabstop => 1,
+);
+
+$ModuleWindow->AddButton(
+    -name    => "ModuleWindowClose",
+    -text    => "Close",
+    -left    => $ModuleWindow->ScaleWidth-90,
+    -top     => 345,
+    -width   => 80,
+    -tabstop => 1,
+    -menu    => 2,
+    -cancel  => 1,
+    -default => 1,
+);
+
+my $AboutWindow = new Win32::GUI::DialogBox(
+    -name    => "AboutWindow",
+    -title   => "About PMX...",
+    -left    => 110,
+    -top     => 110,
+    -width   => 200,
+    -height  => 150,
+);
+
+$AboutWindow->AddLabel(
+    -name => "AboutIcon",
+    -top => 5,
+    -left => 5,
+    -height => 32,
+    -width => 32,
+	-addstyle => 3,
+    -visible => 1,
+);
+# 368 == STM_SETICON
+$AboutWindow->{AboutIcon}->SendMessage(368, $Icon->{-handle}, 0);
+
+my $AboutTitleFont = new Win32::GUI::Font(-name => "Times New Roman", -height => 16, -bold => 1);
+
+$AboutWindow->AddLabel(
+    -name => "AboutTitle",
+    -top => 13,
+    -left => 42,
+    -height => 32,
+    -width => $AboutWindow->ScaleWidth-47,
+    -text => "PMX Version $VERSION",
+    -font => $AboutTitleFont,
+);
+
+$AboutWindow->AddLabel(
+    -name => "AboutDetails",
+    -top => 42,
+    -left => 5,
+    -height => $AboutWindow->ScaleHeight-62,
+    -width => $AboutWindow->ScaleWidth-10,
+    -text => "Author: Aldo Calpini\r\nContact: dada\@perl.it\r\nDate: 17 May 1998\r\n\r\n",
+);
+
+$AboutWindow->AddButton(
+    -name => "AboutOK",
+    -left => 0,
+    -top => 0,
+    -text => "    OK    ",
+    -visible => 1,
+    -default => 1,
+    -ok => 1,
+);
+$AboutWindow->AboutOK->Move(
+    $AboutWindow->ScaleWidth - $AboutWindow->AboutOK->Width,
+    $AboutWindow->ScaleHeight - $AboutWindow->AboutOK->Height,
+);
+
+$Window->Tree->SetRedraw(0);
+AddModules($INC[0], 0);
+$Window->Tree->SetRedraw(1);
+$Window->Tree->InvalidateRect(1);
+
+$Window->Show;
+$Window->Show; # twice to avoid being preset by a 'start minimized' shortcut
+$Window->Tree->InvalidateRect(1);
+
+#my @wins = Win32::GUI::EnumMyWindows();
+#print "I have ", scalar(@wins), " window(s):\n";
+#foreach my $win (@wins) {
+#	print "$win: ", Win32::GUI::Text($win), "(", Win32::GUI::GetClassName($win), ")\n";
+#}
+#
+#<STDIN>;
+
+my $retcode = Win32::GUI::Dialog();
+
+print "exiting with return code $retcode\n" if $DEBUG;
+
+#==================
+sub Window_Resize {
+#==================
+    $Window->Dirs->Resize($Window->ScaleWidth, $Window->ScaleHeight - $Window->Status->Height);
+    $Window->Tree->Move(0, 22);
+    $Window->Tree->Resize($Window->Dirs->ScaleWidth, $Window->Dirs->ScaleHeight-22);
+#    $Window->Status->Move(0, $Window->ScaleHeight - $Window->Status->Height);
+#    $Window->Status->Resize($Window->ScaleWidth, $Window->Status->Height);
+    return 1;
+}
+
+#=====================
+sub Window_Terminate {
+#=====================
+    if($Menu->{SettingsSave}->Checked()) {
+        my $key;
+        $main::HKEY_LOCAL_MACHINE->Open("SOFTWARE\\dada", $key)
+        or $main::HKEY_LOCAL_MACHINE->Create("SOFTWARE\\dada", $key);
+        $key->Close();
+        undef $key;
+        $main::HKEY_LOCAL_MACHINE->Open("SOFTWARE\\dada\\PMX", $key)
+        or $main::HKEY_LOCAL_MACHINE->Create("SOFTWARE\\dada\\PMX", $key);
+        if($key) {
+            $PmxWindow_left = $Window->Left;
+            $PmxWindow_top = $Window->Top;
+            $PmxWindow_width = $Window->Width;
+            $PmxWindow_height = $Window->Height;
+            $PmxViewExDump = $Menu->{ViewExtendedDump}->Checked();
+            $PmxViewScripts = $Menu->{ViewPL}->Checked();
+
+            WriteConfig($key);
+            $key->Close();
+        }
+    }
+    return -1;
+}
+
+#====================
+sub Window_Activate {
+#====================
+    $Window->Tree->SetFocus();
+    return 0;
+}
+
+#===============
+sub Dirs_Click {
+#===============
+    my $dir = $Window->Dirs->SelectedItem;
+    if(defined($dir)) {
+        $Window->Tree->SetRedraw(0);
+        $Window->Tree->Clear;
+        AddModules($Tabs[$dir], 0);
+        $Window->Tree->SetRedraw(1);
+        $Window->Tree->InvalidateRect(1);
+    }
+}
+
+#=================
+sub Tree_KeyDown {
+#=================
+    my($key) = @_;
+    #          Enter         Numpad +       Normal +
+    if($key == 13 or $key == 107 or $key == 187) {
+        my %itemdata = $Window->Tree->GetItem($Window->Tree->SelectedItem);
+        if($itemdata{-image} == $IL_UNKFOLDER) {
+            ExpandDir($Window->Tree->SelectedItem);
+            $Window->Tree->Expand($Window->Tree->SelectedItem);
+            return 0;
+        } else {
+            Tree_DblClick() if $key == 13; # Enter
+            return 0;
+        }
+    }
+    return 1;
+}
+
+#===================
+sub Tree_NodeClick {
+#===================
+    my %itemdata = $Window->Tree->GetItem($Window->Tree->SelectedItem);
+    if($itemdata{-image} == $IL_MODULE) {
+        GetInfo($Window->Tree->SelectedItem);
+        $Menu->{'FileProps'}->Enabled(1);
+        $Menu->{'FileDump'}->Enabled(1);
+    } elsif($itemdata{-image} == $IL_DLL) {
+        $Menu->{'FileProps'}->Enabled(1);
+        $Menu->{'FilePod'}->Enabled(0);
+        $Menu->{'FileDump'}->Enabled(0);
+    } else {
+        $Window->Status->Text("");
+        $Menu->{'FileProps'}->Enabled(0);
+        $Menu->{'FilePod'}->Enabled(0);
+        $Menu->{'FileDump'}->Enabled(0);
+    }
+    return 0;
+}
+
+#==================
+sub Tree_DblClick {
+#==================
+    my %itemdata = $Window->Tree->GetItem($Window->Tree->SelectedItem);
+    if($itemdata{-image} == $IL_UNKFOLDER) {
+        ExpandDir($Window->Tree->SelectedItem);
+    } elsif($itemdata{-image} == $IL_MODULE
+         or $itemdata{-image} == $IL_DLL) {
+        FileProps_Click();
+    }
+    return 0;
+}
+
+#====================
+sub Tree_RightClick {
+#====================
+    my($X, $Y) = Win32::GUI::GetCursorPos();
+    my($TVI, $flags) = $Window->Tree->HitTest( $Window->Tree->ScreenToClient($X, $Y) );  
+    if($TVI) {
+        $Window->Tree->Select($TVI);
+        my %itemdata = $Window->Tree->GetItem($TVI);
+        print "Selected Item: $itemdata{-text}\n" if $DEBUG;
+        if($itemdata{-image} == $IL_MODULE) {
+            if($ModuleWindow->ModuleTabs->ModuleViewPod->IsEnabled()) {
+                $Window->TrackPopupMenu($PopMenu->{POPUP_POD}, $X, $Y);
+            } else {
+                $Window->TrackPopupMenu($PopMenu->{POPUP_NOPOD}, $X, $Y);
+            }
+        } elsif($itemdata{-image} == $IL_DLL) {
+            $Window->TrackPopupMenu($PopMenu->{POPUP_DLL}, $X, $Y);
+        }
+    }
+    return 1;
+}
+
+#============
+sub GetInfo {
+#============
+    my($item) = @_;
+    my %itemdata = $Window->Tree->GetItem($item);
+    my $name = GetFullPath($item);
+    my $pname = GetPerlPath($item);
+    $name .= ".pm" unless $name =~ /\.(pl|pm|dll)$/i;
+    if(!exists($InfoCache{$name})) {
+        $InfoCache{$name} = {};
+        if($itemdata{-image} == $IL_MODULE) {
+            $InfoCache{$name}->{version} = $pname;
+            if(-f $name) {
+                print "GetInfo: opening $name...\n" if $DEBUG;
+                open(PM, "<$name");
+                while(<PM>) {
+                    if(/\$version\s*=\s*['"]?([^'";]*)['"]?;/i) {
+                        $InfoCache{$name}->{version} .= " Version: $1";
+                    }
+                    if(/^=head/) {
+                        $InfoCache{$name}->{haspod} = 1;
+                    }
+                }
+                close(PM);
+            }
+        } elsif($itemdata{-image} == $IL_DLL) {
+            $InfoCache{$name}->{version} = "";
+            $InfoCache{$name}->{haspod} = 0;
+        }
+    }
+    $Window->Status->{-text} = $InfoCache{$name}->{version};
+    if($InfoCache{$name}->{haspod} == 1) {
+        $ModuleWindow->ModuleTabs->ModuleViewPod->Enable();
+        $Menu->{'FilePod'}->Enabled(1);
+    } else {
+        $ModuleWindow->ModuleTabs->ModuleViewPod->Disable();
+        $Menu->{'FilePod'}->Enabled(0);
+    }
+}
+
+#==============
+sub ExpandDir {
+#==============
+    my($node) = @_;
+    if($node) {
+        my $name = "";
+        my $n = 0;
+        $name = GetFullPath($node);
+        if(-d $name) {
+            $Window->Tree->Clear($node);
+            $Window->Tree->ChangeItem($node, -image => $IL_FOLDER);
+            AddModules($name, $node);
+        }
+    }
+    return 1;
+}
+
+#================
+sub GetPerlPath {
+#================
+    my($node) = @_;
+    my $name = "";
+    my $n = $node;
+    my $delim;
+    while($items{$Window->Tree->GetParent($n)}) {
+        $delim = ($name =~ /^::/) ? "" : "::";
+        $delim = "" if $name eq "";
+        $name = $items{$Window->Tree->GetParent($n)} . $delim . $name;
+        $n = $Window->Tree->GetParent($n) if $Window->Tree->GetParent($n);
+    }
+    $delim = ($name =~ /::$/) ? "" : "::";
+    $delim = "" if $name eq "";
+    $name .= $delim . $items{$node};
+    return $name;
+}
+
+#================
+sub GetFullPath {
+#================
+    my($node) = @_;
+    my $name = "";
+    my $n = $node;
+    my $delim;
+    while($items{$Window->Tree->GetParent($n)}) {
+        $delim = ($name =~ /^\//) ? "" : "/";
+        $name = $items{$Window->Tree->GetParent($n)} . $delim . $name;
+        $n = $Window->Tree->GetParent($n) if $Window->Tree->GetParent($n);
+    }
+    $delim = ($name =~ /\/$/) ? "" : "/";
+    $name .= $delim . $items{$node};
+    $name = $Tabs[$Window->Dirs->SelectedItem]."/".$name;
+    $name =~ s/[\\\/]+/\\/g;
+    return $name;
+}
+
+#===============
+sub AddModules {
+#===============
+    my($dir, $parent) = @_;
+    my $TVI;
+    my $image;
+    opendir(LIB, $dir) or print "Can't open dir $dir!\n";
+    my @files = readdir(LIB);
+    closedir(LIB);
+    my $file;
+    my $ModulesToAdd = "p[ml]";
+    $ModulesToAdd = "pm" if $Menu->{ViewPL}->Checked() == 0;
+
+    # print "found $#files files.\n";
+    my $dirs = 0;
+    my $files = 0;
+    foreach $file (sort CaseInsensitive @files) {
+        next if $file =~ /^(.|..)$/;
+        if(-d $dir."/".$file) {
+            $TVI = $Window->Tree->InsertItem(
+                -parent => $parent,
+                -text => $file,
+                -image => $IL_UNKFOLDER,
+            );
+            $items{$TVI} = $file;
+            # $Window->Tree->Select($TVI);
+            # ExpandDir($TVI);
+            $dirs++;
+        } else {
+            # print "FILE = $file\n";
+            next unless ($file =~ /\.$ModulesToAdd$/i or $file =~ /\.[pd]ll$/i);
+            $files++;
+            $image = $IL_MODULE;
+            $image = $IL_DLL if $file =~ /\.[pd]ll$/i;
+            $file =~ s/\.pm$//i;
+            $TVI = $Window->Tree->InsertItem(
+                -parent => $parent,
+                -text   => $file,
+                -image  => $image,
+            );
+            # print "ITEMS($TVI) = $file\n";
+            $items{$TVI} = $file;
+        }
+    }
+    $Window->Status->Text(
+        "Found $files file"
+        .(($files==1)? "":"s")." and $dirs director"
+        .(($dirs==1)? "y":"ies")
+    );
+}
+
+#=================
+sub ViewPL_Click {
+#=================
+    $Menu->{ViewPL}->Checked(!$Menu->{ViewPL}->Checked());
+}
+
+#===========================
+sub ViewExtendedDump_Click {
+#===========================
+    $Menu->{ViewExtendedDump}->Checked(!$Menu->{ViewExtendedDump}->Checked());
+}
+
+#======================
+sub ViewRefresh_Click {
+#======================
+    %InfoCache = ();
+    Dirs_Click();
+}
+
+#=======================
+sub SettingsSave_Click {
+#=======================
+    $Menu->{SettingsSave}->Checked(!$Menu->{SettingsSave}->Checked());
+    $PmxSaveSettings = $Menu->{SettingsSave}->Checked();
+    my $key;
+    $main::HKEY_LOCAL_MACHINE->Open("SOFTWARE\\dada", $key)
+    or $main::HKEY_LOCAL_MACHINE->Create("SOFTWARE\\dada", $key);
+    $key->Close() if $key;
+    undef $key;
+    $main::HKEY_LOCAL_MACHINE->Open("SOFTWARE\\dada\\PMX", $key)
+    or $main::HKEY_LOCAL_MACHINE->Create("SOFTWARE\\dada\\PMX", $key);
+    if($key) {
+        $key->SetValueEx("SaveSettings", 0, 1, $PmxSaveSettings);
+        $key->Close();
+    }
+    return 1;
+}
+
+#========================
+sub SettingsReset_Click {
+#========================
+    my $key;
+    $main::HKEY_LOCAL_MACHINE->Open("SOFTWARE\\dada", $key)
+    or $main::HKEY_LOCAL_MACHINE->Create("SOFTWARE\\dada", $key);
+    $key->Close();
+    undef $key;
+    $main::HKEY_LOCAL_MACHINE->Open("SOFTWARE\\dada\\PMX", $key)
+    or $main::HKEY_LOCAL_MACHINE->Create("SOFTWARE\\dada\\PMX", $key);
+    if($key) {
+        undef $PmxWindow_left;
+        undef $PmxWindow_top;
+        undef $PmxWindow_width;
+        undef $PmxWindow_height;
+        undef $PmxViewExDump;
+        undef $PmxViewScripts;
+        WriteConfig($key);
+        $key->Close();
+    }
+    $Window->Move($PmxWindow_left, $PmxWindow_top);
+    $Window->Resize($PmxWindow_width, $PmxWindow_height);
+    $Menu->{ViewPL}->Checked($PmxViewScripts);
+    $Menu->{ViewExtendedDump}->Checked($PmxViewExDump);
+}
+
+
+#===================
+sub FileExit_Click {
+#===================
+    Window_Terminate();
+}
+
+
+#==========================
+sub ViewPerlVersion_Click {
+#==========================
+    use Config;
+    Win32::GUI::MessageBox(0, "This is perl, version $]\r\nBuilt for $Config{archname}", "Perl Version", 64);
+}
+
+#====================
+sub CaseInsensitive { uc($b) cmp uc($a); }
+#====================
+
+#====================
+sub FileProps_Click {
+#====================
+    GetProps();
+    $ModuleWindow->ModuleTabs->Select(0);
+    ModuleTabs_Click();
+    $ModuleWindow->Show();
+    $ModuleWindow->SetForegroundWindow();
+    $Window->Disable();
+}
+sub PopProps1_Click { FileProps_Click(); }
+sub PopProps2_Click { FileProps_Click(); }
+sub PopProps3_Click { FileProps_Click(); }
+
+#===================
+sub FileDump_Click {
+#===================
+    GetProps();
+    # DoModuleDump();
+    $ModuleWindow->ModuleTabs->Select(1);
+    ModuleTabs_Click();
+    $ModuleWindow->Show();
+    $Window->Disable();
+}
+sub PopDump1_Click { FileDump_Click(); }
+sub PopDump2_Click { FileDump_Click(); }
+
+#=============
+sub GetProps {
+#=============
+    my $node = $Window->Tree->SelectedItem;
+    my $name = GetFullPath($node);
+    my %nodedata = $Window->Tree->GetItem($node);
+    my $pname = GetPerlPath($node);
+    if($nodedata{-image} == $IL_MODULE) {
+
+        $name .= ".pm" unless $name =~ /\.p[lm]$/i;
+        $ModuleWindow->Text($pname." Properties");
+        $ModuleWindow->ModuleTabs->ModuleName->Text($pname);
+        my $mversion;
+        if(-f $name) {
+            open(PM, "<$name");
+            while(<PM>) {
+                if(/\$version\s*=\s*['"]?([^'";]*)['"]?;/i) {
+                    #$mversion = eval($1);
+                    $mversion = $1;
+                    seek(PM, 0, 2);
+                }
+            }
+            close(PM);
+        }
+        if($mversion) {
+            $ModuleWindow->ModuleTabs->ModuleVersion->Text($mversion);
+        } else {
+            $ModuleWindow->ModuleTabs->ModuleVersion->Text("");
+        }
+        if($name =~ /\.pm$/i) {
+            $ModuleWindow->ModuleTabs->ModuleType->Text("Module");
+        } else {
+            $ModuleWindow->ModuleTabs->ModuleType->Text("Script");
+        }
+    } elsif($nodedata{-image} == $IL_DLL) {
+        $ModuleWindow->ModuleTabs->ModuleName->Text($nodedata{-text});
+        $ModuleWindow->ModuleTabs->ModuleVersion->Text("");
+        $ModuleWindow->ModuleTabs->ModuleType->Text("Loadable object");
+    }
+    $ModuleWindow->ModuleTabs->ModuleFile->Text($name);
+    my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
+        $atime,$mtime,$ctime,$blksize,$blocks)           = stat($name);
+    $ModuleWindow->ModuleTabs->ModuleSize->Text($size);
+    $ModuleWindow->ModuleTabs->ModuleCtime->Text(scalar(localtime($ctime)));
+    $ModuleWindow->ModuleTabs->ModuleMtime->Text(scalar(localtime($mtime)));
+}
+
+#========================
+sub ModuleViewPod_Click {
+#========================
+    print "In ModuleViewPod_Click!\n";
+    my $node = $Window->Tree->SelectedItem;
+    my $name = GetFullPath($node);
+    $name .= ".pm" unless $name =~ /\.p[lm]$/i;
+    if($ModuleWindow->IsVisible()) {
+        $ModuleWindow->Disable();
+    } else {
+        $Window->Disable();
+    }
+    system("$^X podview.pl $name");
+    # my $pid;
+    # Win32::Spawn("$^X", "podview.pl $name", $pid);
+    if($ModuleWindow->IsVisible()) {
+        $ModuleWindow->Enable();
+        $ModuleWindow->SetForegroundWindow();
+    } else {
+        $Window->Enable();
+        $Window->SetForegroundWindow();
+    }
+    return 1;
+}
+sub PopPod_Click { ModuleViewPod_Click(); }
+sub FilePod_Click { ModuleViewPod_Click(); }
+
+#============================
+sub ModuleWindowClose_Click {
+#============================
+    $Window->Enable();
+    $Window->SetForegroundWindow();
+    Window_Activate();
+    $ModuleWindow->Hide();
+    return 1;
+}
+sub ModuleWindow_Terminate { ModuleWindowClose_Click(); }
+
+#=====================
+sub ModuleTabs_Click {
+#=====================
+    my $control;
+    print "Got ModuleTabs_Click (", $ModuleWindow->ModuleTabs->SelectedItem, ")\n" if $DEBUG;
+    my @controls = (
+        $ModuleWindow->ModuleTabs->ModuleNameLbl,
+        $ModuleWindow->ModuleTabs->ModuleName,
+        $ModuleWindow->ModuleTabs->ModuleVersionLbl,
+        $ModuleWindow->ModuleTabs->ModuleVersion,
+        $ModuleWindow->ModuleTabs->ModuleTypeLbl,
+        $ModuleWindow->ModuleTabs->ModuleType,
+        $ModuleWindow->ModuleTabs->ModuleFileLbl,
+        $ModuleWindow->ModuleTabs->ModuleFile,
+        $ModuleWindow->ModuleTabs->ModuleCtimeLbl,
+        $ModuleWindow->ModuleTabs->ModuleCtimeLbl,
+        $ModuleWindow->ModuleTabs->ModuleMtimeLbl,
+        $ModuleWindow->ModuleTabs->ModuleMtimeLbl,
+        $ModuleWindow->ModuleTabs->ModuleViewPod,
+    );
+    if($ModuleWindow->ModuleTabs->SelectedItem == 0) {
+        foreach $control (@controls) {
+            $control->Show();
+        }
+        $ModuleWindow->ModuleTabs->ModuleDump->Hide();
+    } else {
+        foreach $control (@controls) {
+            $control->Hide();
+        }
+        DoModuleDump();
+        $ModuleWindow->ModuleTabs->ModuleDump->Show();
+    }
+}
+
+#====================
+sub HelpAbout_Click {
+#====================
+    # $AboutWindow->Show();
+    # $Window->Disable();
+    $AboutWindow->DoModal();
+}
+
+#==================
+sub AboutOK_Click {
+#==================
+    $Window->Enable();
+    $Window->SetForegroundWindow();
+    Window_Activate();
+    $AboutWindow->Hide();
+    return 1;
+}
+
+#==========================
+sub AboutWindow_Terminate {
+#==========================
+    AboutOK_Click();
+    return 0;
+}
+
+#=================
+sub DoModuleDump {
+#=================
+    no strict 'refs';
+    my $name = $ModuleWindow->ModuleTabs->ModuleName->Text();
+    print "useing $name..." if $DEBUG;
+    my $use = eval("use $name;");
+    print "used\n" if $DEBUG;
+    if(!$@) {
+        my $output = DumpNames(%{$name.'::'}, $name.'::', $name.'::');
+        #my $expr = "use $name; DumpNames(\%".$name."::, '".$name."::', '".$name."::');";
+        $ModuleWindow->ModuleTabs->ModuleDump->Text($output);
+    } else {
+        Win32::GUI::MessageBox(0, $@, "Error using $name", 16);
+        $ModuleWindow->ModuleTabs->ModuleDump->Text("");
+    }
+    return 1;
+}
+
+# this code was originally taken
+# from a PerlScript sample by ActiveState
+#====================
+sub DumpNames(\%$$) {
+#====================
+    no strict 'refs';
+    my ($package,$packname,$pname) =  @_;
+    my $symname = 0;
+    my $value = 0;
+    my $key = 0;
+    my $i = 0;
+    $pname =~ s/main::(.+)/$1/;
+    my @found = ();
+    my $sym;
+    my %sym;
+    my @sym;
+    my %flags;
+    my $spname;
+
+    print "DumpNames called for $packname ($pname) = $package\n" if $DEBUG;
+
+    my $ret = "";
+
+    @found = ();
+    foreach $symname (sort keys %$package) {
+        push(@found, $symname) if defined %{$pname.$symname} and $symname =~ /::$/;
+    }
+    if($#found > -1) {
+        $ret .= "$pname Packages\r\n";
+        foreach $symname (@found) {
+            next if $symname eq 'main::';
+            $ret .= "\t$symname\r\n";
+        }
+    }
+
+    if ($packname ne 'main::') {
+
+        @found = ();
+        foreach $symname (sort keys %$package) {
+            push(@found, $symname) if defined &{$pname.$symname};
+        }
+        if($#found > -1) {
+            $ret .= "$pname Functions\r\n";
+            foreach $symname (@found) {
+                $ret .= "\t$symname()\r\n";
+            }
+        }
+
+        @found = ();
+        foreach $symname (sort keys %$package) {
+            push(@found, $symname) if defined ${$pname.$symname};
+        }
+        if($#found > -1) {
+            $ret .= "$pname Scalars\r\n";
+            foreach $symname (@found) {
+                $ret .= "\t\$$symname = ".${$pname.$symname}."\r\n";
+
+            }
+        }
+
+        @found = ();
+        foreach $symname (sort keys %$package) {
+            push(@found, $symname) if defined @{$pname.$symname};
+        }
+        if($#found > -1) {
+            $ret .= "$pname Lists\r\n";
+            foreach $symname (@found) {
+                if($Menu->{ViewExtendedDump}->Checked) {
+                    $ret .= "\t\@$symname = (\r\n";
+                    foreach (sort @{$$package{$symname}}) {
+                        $ret .= "\t\t$_\r\n";
+                    }
+                    $ret .= "\t);\r\n";
+                } else {
+                    $ret .= "\t\@$symname\r\n";
+                }
+
+            }
+        }
+
+        @found = ();
+        foreach $symname (sort keys %$package) {
+            push(@found, $symname) if defined %{$pname.$symname} and $symname !~ /::$/;
+        }
+        if($#found > -1) {
+            $ret .= "$pname Hashes\r\n";
+            foreach $symname (@found) {
+                if($Menu->{ViewExtendedDump}->Checked) {
+                    $ret .= "\t\%$symname = (\r\n";
+                    foreach (sort keys %{$$package{$symname}}) {
+                        $ret .= "\t\t$_ => ${$$package{$symname}}{$_}\r\n";
+                    }
+                    $ret .= "\t);\r\n";
+                } else {
+                    $ret .= "\t\%$symname\r\n";
+                }
+            }
+        }
+    }
+    $ret .= "\r\n";
+
+    # if ($packname ne 'main::') {
+    #    return;
+    # }
+
+    foreach $symname (sort keys %$package) {
+        if (defined %{$pname.$symname} and $symname =~ /::$/ and $symname ne 'main::') {
+            $spname = $packname . $symname;
+            next if $spname =~ /PMX::/ and $flags{'self'} == 0;
+            print "Dumping $symname ($spname)...\n" if $DEBUG;
+            $ret .= DumpNames(%{$spname}, $spname, $spname);
+        }
+    }
+    return $ret;
+}
+
+#===============
+sub ReadConfig {
+#===============
+    my $key;
+    my $val;
+    my $name;
+    $main::HKEY_LOCAL_MACHINE->Open("SOFTWARE\\dada", $key)
+    or $main::HKEY_LOCAL_MACHINE->Create("SOFTWARE\\dada", $key);
+    $key->Close();
+    undef $key;
+    $main::HKEY_LOCAL_MACHINE->Open("SOFTWARE\\dada\\PMX", $key)
+    or $main::HKEY_LOCAL_MACHINE->Create("SOFTWARE\\dada\\PMX", $key);
+    if($key) {
+        $key->GetValues($val);
+
+        #foreach $name (keys %$val) {
+        #    print "\t$name = $val->{$name}[2]\n";
+        #}
+
+        $PmxWindow_left   = $val->{'left'}[2];
+        $PmxWindow_top    = $val->{'top'}[2];
+        $PmxWindow_width  = $val->{'width'}[2];
+        $PmxWindow_height = $val->{'height'}[2];
+
+        $PmxViewExDump    = $val->{'ViewExDump'}[2];
+        $PmxViewScripts   = $val->{'ViewScripts'}[2];
+
+        $PmxSaveSettings  = $val->{'SaveSettings'}[2];
+
+        WriteConfig($key);
+        $key->Close();
+    } else {
+        WriteConfig();
+    }
+}
+
+#================
+sub WriteConfig {
+#================
+    my($key) = @_;
+
+    # put default values where needed
+    $PmxWindow_left = 100 unless defined($PmxWindow_left);
+    $PmxWindow_top = 100 unless defined($PmxWindow_top);
+    $PmxWindow_width = 400 unless defined($PmxWindow_width);
+    $PmxWindow_height = 300 unless defined($PmxWindow_height);
+    $PmxViewExDump = 0 unless defined($PmxViewExDump);
+    $PmxViewScripts = 0 unless defined($PmxViewScripts);
+    $PmxSaveSettings = 1 unless defined($PmxSaveSettings);
+
+    # write in the registry (note: 1 is REG_SZ)
+    if($key) {
+        $key->SetValueEx("left", 0, 1, $PmxWindow_left);
+        $key->SetValueEx("top", 0, 1, $PmxWindow_top);
+        $key->SetValueEx("width", 0, 1, $PmxWindow_width);
+        $key->SetValueEx("height", 0, 1, $PmxWindow_height);
+        $key->SetValueEx("ViewExDump", 0, 1, $PmxViewExDump);
+        $key->SetValueEx("ViewScripts", 0, 1, $PmxViewScripts);
+        $key->SetValueEx("SaveSettings", 0, 1, $PmxSaveSettings);
+    }
+}
+
+sub InitBitmaps {
+
+$BMP_UNKFOLDER = new Win32::GUI::BitmapInline( q(
+Qk32AAAAAAAAAHYAAAAoAAAAEAAAABAAAAABAAQAAAAAAIAAAAAAAAAAAAAAABAAAAAQAAAAAAAA
+AACcnABjzs4A9/f3AJzO/wCc//8Azv//AP///wD///8A////AP///wD///8A////AP///wD///8A
+////AHd3d3d3d3d3d3d3d3d3d3dwAAAAAAAABxIiIiIiIiIHFkVFAEVEQgcWVVQAVFRCBxZVVVVF
+RUIHFlVVAFRUUgcWVVUAVUVCBxZVVVAEVFIHFlUAVQBVQgcWZgBmAGZSBxIiIAABERF3cTZlUQd3
+d3d3EREQd3d3d3d3d3d3d3d3
+) );
+$BMP_FOLDER = new Win32::GUI::BitmapInline( q(
+Qk32AAAAAAAAAHYAAAAoAAAAEAAAABAAAAABAAQAAAAAAIAAAAAAAAAAAAAAABAAAAAQAAAAAAAA
+AACcnABjzs4A9/f3AJzO/wCc//8Azv//AP///wD///8A////AP///wD///8A////AP///wD///8A
+////AHd3d3d3d3d3d3d3d3d3d3dwAAAAAAAABxIiIiIiIiIHFkVFRUVEQgcWVVRUVFRCBxZVVVVF
+RUIHFlVVVFRUUgcWVVVVVUVCBxZVVVVUVFIHFlVVVVVVQgcWZmZmZmZSBxIiIiIRERF3cTZlUQd3
+d3d3EREQd3d3d3d3d3d3d3d3
+) );
+$BMP_MODULE = new Win32::GUI::BitmapInline( q(
+Qk32AAAAAAAAAHYAAAAoAAAAEAAAABAAAAABAAQAAAAAAIAAAAAAAAAAAAAAABAAAAAQAAAAAAAA
+AAAAgAAAgAAAAICAAIAAAACAAIAAgIAAAICAgADAwMAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA
+////AP//////////////////////AAAAAAAP//8P/////w///w//D/D/D///D/8P8P8P//8P+AAA
+jw///w/wAAAPD///D/AAAP8P//8P8IgP/w///w8A////D///D4D/8AAP//8P///w8P///w////AP
+////AAAAAP//////////////
+) );
+$BMP_DLL = new Win32::GUI::BitmapInline( q(
+Qk32AAAAAAAAAHYAAAAoAAAAEAAAABAAAAABAAQAAAAAAIAAAAAAAAAAAAAAABAAAAAQAAAAAAAA
+AAAAgAAAgAAAAICAAIAAAACAAIAAgIAAAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA
+////APAAAAAAAAD/+Hd3d3d3cP/4//////9w//j//////3D/+P//8A//cP/4//8HcP9w//j/+PCI
+D3D/+P8HD4D/cP/487CID/9w//j/CzD//3D/+P8zD///cP/4//////9w//j/////AAD/+P////9/
+j//4/////3j///iIiIiIj///
+) );
+
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/podview.pl perl-libwin32-0.191/GUI/samples/podview.pl
--- libwin32-0.191/GUI/samples/podview.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/podview.pl	2004-01-12 16:46:42.343750000 -0800
@@ -0,0 +1,1002 @@
+
+use Win32::GUI;
+use Win32::Registry;
+# use Win32::API;
+use lib "p:\\dada\\win32-gui\\samples";
+use Pod::RTF;
+use FindBin;
+
+$VERSION = "1.30";
+$DEBUG = 0;
+
+$NORMAL = Win32::GUI::LoadCursorFromFile("arrow_1.cur");
+$HAND = Win32::GUI::LoadCursorFromFile("harrow.cur");
+
+Win32::GUI::SetCursor($NORMAL);
+
+# Minimize the Perl's DOS window
+($DOShwnd, $DOShinstance) = Win32::GUI::GetPerlWindow();
+#Win32::GUI::CloseWindow($DOShwnd);
+
+# you can eventually...
+Win32::GUI::Hide($DOShwnd);
+
+$MRUMAX = 9;
+
+ReadConfig();
+
+@MRUDEF = ();
+for $i (1..$MRUMAX) {
+    push(@MRUDEF, " > \&$i $MRU{$i}");
+    push(@MRUDEF, "MenuMRU$i");
+    $subname = "MenuMRU${i}_Click";
+    *$subname = eval(qq(
+        sub {
+            LoadPod(\$MRU{$i}) if \$MRU{$i};
+        } 
+    )); 
+}
+
+
+$Menu = new Win32::GUI::Menu(
+    "&File" => "File",
+    "   >   &Open" => "MenuOpen",
+    "   >   &Reload" => "MenuReload",
+    "   >   &Save RTF" => "MenuSave",
+    "   >   -" => 0,
+    @MRUDEF,
+    "   >   -" => 0,
+    "   >   E&xit" => "MenuExit",
+
+    "&View" => "View",
+    "   >   Pod s&tructure" => { 
+        -name => "ViewStructure", 
+        -checked => 1 
+    },
+    "   >   Structure &depth..." => "ViewDepth",
+    "   >   &Source" => "ViewSource",
+
+    "&Tools" => "Tools",
+    "   >   E&xplore Perl modules..." => "ToolPmx",
+
+    "&Options" => "Options",
+    "   >   Choose &normal font..." => "MenuNormalFont",
+    "   >   Choose &fixed font..." => "MenuFixedFont",
+    "   >   Choose &heads color..." => "MenuHeadColor",
+    "   >   Choose &links color..." => "MenuLinkColor",
+    "   >   -", => 0,
+    "   >   &Save options" => "MenuSaveConfig",
+);
+
+
+$Window = new Win32::GUI::Window(
+    -name => "Window",
+    -text => "Perl POD Viewer",
+    -width => 640, -height => 480, 
+    -left => 100,  -top => 100,
+    -menu => $Menu,
+);
+
+$Window->AddHeader(
+    -name => "Header",
+    -left => 0,
+    -top  => 0,
+    -width => $Window->ScaleWidth/3,
+    -height => $Window->ScaleHeight,
+);
+$Window->Header->InsertItem(
+    -index => 0,
+    -text => "Structure",
+    -width => $Window->ScaleWidth/3,
+);
+
+$REC = new Win32::GUI::Class(
+    -name => "PodView_RichEdit",
+    -extends => "RichEdit",
+    -widget => "RichEdit",
+);
+
+$POD = $Window->AddRichEdit(
+    -name => "POD",
+    # -class => $REC, # still testing this...
+    -text => "",
+    -left => 10, 
+    -top => 10,
+    -width => 280/3*2, 
+    -height => 180,
+    -exstyle => WS_EX_CLIENTEDGE,
+    -style => WS_CHILD | WS_VISIBLE | WS_VSCROLL 
+            | ES_LEFT | ES_MULTILINE | ES_AUTOVSCROLL,
+);
+
+$Window->AddTreeView(
+    -name => "TOC",
+    -text => "",
+    -left => 10, 
+    -top => 10,
+    -width => 280/3, 
+    -height => 180,
+    -exstyle => WS_EX_CLIENTEDGE,
+    -style => WS_CHILD | WS_VISIBLE | WS_VSCROLL 
+            | ES_LEFT | ES_MULTILINE | ES_AUTOVSCROLL,
+    -lines => 1,
+    -rootlines => 1,
+    -hottrack => 1,
+);
+
+$Window->AddStatusBar(
+    -name => "Status",
+    -text => "PodView $VERSION Ready"
+);
+
+new GUI::ProgressBar(
+    $Window->Status,
+    -name   => "Progress",
+    -width  => 150,
+    -height => $Window->Status->Height-3,
+    -left   => $Window->Status->Width-150,
+    -top    => 2,
+);
+
+$NoPOD = $Window->AddLabel( 
+    -text    => "No POD found in file.",
+    -name    => "NoPOD",
+    -visible => 0,
+);
+
+LoadPod($ARGV[0] or $0);
+
+$Window->Show();
+$Window->Show(); # twice to avoid being preset by a 'start minimized' shortcut
+
+Win32::GUI::Dialog();
+
+# Restore the DOS window 
+GUI::Show($DOShwnd);
+
+
+######################################################################
+# SUBROUTINES
+#
+
+sub rgb {
+    my($color) = @_;
+    $color = sprintf("%06X", $color);
+    $color =~ /(..)(..)(..)/;
+    return hex($3), hex($2), hex($1);
+}
+
+sub LoadPod {
+    my $ticks = Win32::GetTickCount();
+    my($file, $blind) = @_;
+    $POD->SetRedraw(0);
+    $file = $PODFILE unless $file;
+    $Window->Status->Text("Loading $file...");
+    $Window->Status->Update;
+    Pod::RTF::set_head_color(rgb($HEAD_COLOR));
+    Pod::RTF::set_link_color(rgb($L_COLOR));
+    if(-f $file) {
+        if(open(TMP, ">podview.rtf")) {
+            binmode(TMP);
+            @Pod::RTF::heads = ();
+            Pod::RTF::pod2rtf($file, *TMP);
+            close(TMP);
+            $POD->Load("podview.rtf");
+            unlink("podview.rtf");
+            if(length($POD->Text) > 1) {
+                $Window->POD->Show;
+                if($Menu->{ViewStructure}->Checked) {
+                    $Window->Header->Show;
+                    $Window->TOC->Show;
+                }
+                $Window->NoPOD->Hide;
+                my $elapsed = Win32::GetTickCount();
+                $elapsed -= $ticks;
+                $Window->Status->Text("$file loaded in " . ($elapsed/1000) . " seconds.");
+                # $SHAddToRecentDocs->Call(2, $file);
+                
+                my($lvl, $pos); 
+                my %lastnode = ();
+                my %itemdata = ();
+                %TOCRef = ();
+                $TOC_CanExpand = 1;
+                $Window->TOC->Clear();
+                for (@Pod::RTF::heads) {
+                    %itemdata = ();
+                    ($lvl, $pos, $itemdata{-text}) = split(/;/);
+                    # printf "%3d. (%d) %-30s\n", $lvl, $pos, $itemdata{-text} if $lvl > $MAX_STRUCT_LEVEL;
+                    next if $lvl > $MAX_STRUCT_LEVEL;
+                    $itemdata{-text} =~ s/\{\S+ ([^}]*)\}/$1/g;
+                    if($lastnode{$lvl-1}) { 
+                        # print "node has a parent at level ", $lvl-1, ": $lastnode{$lvl-1}\n";
+                        $itemdata{-parent} = $lastnode{$lvl-1};
+                    }
+                    $itemdata{-item} = $lastnode{$lvl};
+                    $lastnode{$lvl} = $Window->TOC->InsertItem(
+                        %itemdata,
+                        # -text => $name,
+                        # -parent => $parent,
+                        # -item => $lastnode{$lvl},
+                    );
+                    $TOCRef{$lastnode{$lvl}} = $pos;
+                    $Window->TOC->Expand($itemdata{-parent}) if exists($itemdata{-parent});
+                    # print $_,"\n";
+                }
+                $TOC_CanExpand = 0;
+            } else {
+                $Window->Status->Text("PodView $VERSION Ready");
+                $Window->POD->Hide;
+                $Window->Header->Hide;
+                $Window->TOC->Hide;
+                $Window->NoPOD->Show;
+            }
+        } else {
+            Win32::GUI::MessageBox("Can't create temporary file!\n");
+            $Window->Status->Text("PodView $VERSION Ready");
+        }
+        $PODFILE = $file;
+        $POD->SetFocus();
+        if(not $blind) {
+            $POD->SetRedraw(1);
+            $POD->InvalidateRect(1);
+            #$POD->Update;
+        }
+        return length($Window->POD->Text);
+    } else {
+        Win32::GUI::MessageBox($dummy, "Can't open file '$file'\n");
+        $Window->Status->Text("PodView $VERSION Ready");
+        if(not $blind) {
+            $POD->SetRedraw(1);
+            $POD->InvalidateRect(1);
+            #$POD->Update;
+        }
+        return 0;
+    }
+}
+
+# not used, see Pod::RTF
+sub OldLoadPod {
+    my $ticks = Win32::GetTickCount();
+    my($file) = @_;
+    $file = $PODFILE unless $file;
+    $size = -s $file;
+
+    $NoPOD->Hide;
+    $Window->POD->Show;
+    $Window->Header->Show;
+    $Window->TOC->Show;
+    $POD->Update;
+
+    undef %normal;
+    $normal{-autocolor} = 1;
+    $normal{-height} = 240;
+    $normal{-name} = $NORMAL_FONT_NAME;
+    $normal{-bold} = 0;
+    $normal{-italic} = 0;
+    $normal{-underline} = 0;
+
+    if(open(FILE, $file)) {
+
+        # clear the text box and don't update it
+        $POD->Text("");
+        $POD->SetRedraw(0);
+
+        # starts with normal format
+        $POD->SendMessage(177, -1, 0);
+        $POD->SetCharFormat(%normal);
+
+        $Window->Status->Progress->SetPos(0);
+        $Window->Status->Progress->Show;
+        $Window->Status->Text("Loading $file...");
+        $Window->Status->Update;
+
+        $podfound = 0;
+        $pod = 0;
+        while(<FILE>) {
+            next unless($pod or /^=head(\d)/);
+            chomp;
+            if($pod == 0) {
+                # print "OUTSIDE POD\n";
+                if(/^=head(\d)\s+(.*)$/) {
+                    $n = $1;
+                    $name = $2;
+                    $pod = 1;
+                    $podfound = 1;
+                    undef %format;
+                    $format{-color} = $HEAD_COLOR;
+                    $format{-height} = 240+(7-$n)*20;
+                    $format{-bold} = 1 if $n == 1;
+                    PodAddText($name, %format);
+                    # $POD->SendMessage(177, -1, 0);            
+                    # $POD->SetCharFormat(%format);
+                    # $POD->ReplaceSel($name);
+                    # print ">!> $name\n";
+                    $POD->SendMessage(177, -1, 0);
+                    $POD->SetCharFormat(%normal);
+                }
+            } else {
+                if(/^$/) {
+                    if($over and not $item) {
+                        # undef $atext;
+                        # $atext = $POD->Text();
+                        # $parastart = rindex($atext, "\n", length($atext)-1)+1;
+                        # $POD->SendMessage(177, $parastart, length($atext)+2);
+                        # print "--- Indenting ($parastart, ", length($atext)+2, "):\n", join("\n", split(/[\r\n]+/, substr($atext, $parastart, length($atext)+2))), "\n";
+
+                        $POD->SendMessage(177, $para, length($POD->Text));
+
+                        undef %format;
+                        $format{-offset} = 0;
+                        $format{-startindent} = $over*100;
+                        $POD->SetParaFormat(%format);
+                    }
+                    $POD->SendMessage(177, -1, 0);                
+                    if(!$item) {
+                        $POD->ReplaceSel("\r\n\r\n");
+                    } else {
+                        $POD->ReplaceSel("\r\n");
+                    }
+                    $POD->SendMessage(177, -1, 0);                
+                    $item = 0;
+                } elsif(/^=cut/) {
+                    $pod = 0;
+                } elsif(/^=head(\d)\s+(.*)$/) {
+                    $n = $1;
+                    $name = $2;
+                    undef %format;
+                    $format{-color} = $HEAD_COLOR;
+                    $format{-height} = 240+(7-$n)*20;
+                    $format{-bold} = 1 if $n == 1;
+                    # $POD->SendMessage(177, -1, 0);
+                    # $POD->SetCharFormat(%format);
+                    # $POD->SendMessage(177, -1, 0);
+                    # $POD->ReplaceSel($name);
+                    PodAddText($name, %format);
+                    $POD->SendMessage(177, -1, 0);
+                    $POD->SetCharFormat(%normal);
+                    # print ">!> $name\n";
+                } elsif(/^=over\s*(\d*)/) {
+                    $over = ($1 or 4);
+                    #undef %format;
+                    #$format{-offset} = $over*100;
+                    #$format{-startindent} = $over*100;
+                    #$POD->SetParaFormat(%format);
+                    #print "Paraformatting ", $n*100, "\n";
+                    $item = 1;
+                    # print "got over=$over, item=$item\n";
+                    $para = length($POD->Text);
+                } elsif(/^=back/) {
+                    # print "got back\n";
+                    undef %format;
+                    $format{-offset} = 0;
+                    $format{-startindent} = 0;
+                    $POD->SetParaFormat(%format);
+                    $over = 0;
+                    $item = 0;
+                } elsif(/^=item\s*(.*)$/) {
+                    $item = $1;
+                    if($item) {
+                        undef %format;
+                        $format{-bold} = 1;
+                        $pitem = PodAddText($item, %format);
+                        $atext = $POD->Text();
+                        $POD->SendMessage(177, length($atext)-length($pitem), length($atext)+2);
+                        undef %format;
+                        $format{-offset} = 0;
+                        $format{-startindent} = 0;
+                        $POD->SetParaFormat(%format);
+                        $POD->SendMessage(177, -1, 0);
+                        # $POD->SendMessage(183, 0, 0);
+                        $POD->SetCharFormat(%normal);
+                    }
+                    $item = 1;
+                } elsif(/^\s+/) {
+                    undef %format;
+                    $format{-name} = $FIXED_FONT_NAME;
+                    $format{-height} = 200;
+                    $POD->SendMessage(177, -1, 0);
+                    $POD->SetCharFormat(%format);
+                    $POD->ReplaceSel($_."\r\n");
+                    $POD->SendMessage(177, -1, 0);
+                    $POD->SetCharFormat(%normal);
+                    $item = 0;
+                    # $para = length($POD->Text);
+                } else {
+                    $atext = $POD->Text();
+                    $POD->SendMessage(177, -1, 0);
+                    $POD->ReplaceSel(" ") unless $atext =~ /\s$/;
+                    PodAddText($_, %normal);
+                    $item = 0;
+                }
+            }
+            $Window->Status->Progress->SetPos(tell(FILE)*100/$size);
+            $Window->Status->Progress->Update;
+        }
+        close(FILE);
+
+        $Window->Status->Progress->Hide;
+
+        $POD->SetCharFormat(%normal);
+        $POD->SendMessage(177, 1, 2);
+        $POD->SendMessage(177, -1, 1);
+        
+        # repaint the text box
+        if(not $blind) {
+            $POD->SetRedraw(1);
+            $POD->InvalidateRect(1);
+            #$POD->Update;
+        }
+        
+        $Window->Caption("Perl POD Viewer - $file");
+        $PODFILE = $file;
+        
+        my $elapsed = Win32::GetTickCount();
+        $elapsed -= $ticks;
+        $Window->Status->Text("$file loaded in " . ($elapsed/1000) . " seconds.");
+    } else {
+        Win32::GUI::MessageBox("Cant open file '$file'\n");
+    }        
+    if(not $podfound) {
+        $Window->POD->Hide;
+        $Window->TOC->Hide;
+        $Window->Header->Hide;
+        $NoPOD->Show;
+    }
+}
+
+sub PodAddText {
+    my($text, %origformat) = @_;
+    my($before, $after, $podcmd, $inside);
+    my %format;
+    my $parsedtext = "";
+    while ($text =~ /^(.*?)([BICFL])<([^>]*)>(.*)$/) {
+        $before = $1;
+        $podcmd = $2;
+        $inside = $3;
+        $after  = $4;
+        # print "Adding:\n\t$before\n";
+        $POD->SendMessage(177, -1, 0);
+        $POD->SetCharFormat(%origformat);
+        $POD->ReplaceSel($before);
+        $parsedtext .= $before;
+        %format = %origformat;
+        $format{-bold} = 1 if $podcmd eq "B";
+        $format{-italic} = 1 if $podcmd eq "I";
+        if($podcmd eq "C" or $podcmd eq "F") {
+            $format{-name} = $FIXED_FONT_NAME;
+            # $format{-height} = 200 unless $format{-height};
+            #if($format{-height}) {
+            #    $format{-height} -= 40; # ???
+            #} else {
+            #    $format{-height} = 200;
+            #}
+        }
+        if($podcmd eq "L") {
+            $format{-color} = $L_COLOR;
+            $format{-autocolor} = 0;
+            $format{-underline} = 1;
+        }
+        $POD->SendMessage(177, -1, 0);
+        $POD->SetCharFormat(%format);
+        $POD->SendMessage(177, -1, 0);
+        $POD->ReplaceSel($inside);
+        #print "adding ($inside) with: \n";
+        #foreach $k (keys(%format)) {
+        #    print "\t$k=$format{$k}\n";
+        #}
+        
+        $parsedtext .= $inside;
+        # print "Adding($podcmd):\n\t$inside\n";
+        $POD->SendMessage(177, -1, 0);
+        $POD->SetCharFormat(%normal);
+        $text = $after;
+    }
+    $POD->SendMessage(177, -1, 0);
+    $POD->SetCharFormat(%origformat);
+    $POD->ReplaceSel($text);
+    $parsedtext .= $text;
+    return $parsedtext;
+}    
+
+sub ReadConfig {
+    my $key;
+    $HKEY_LOCAL_MACHINE->Open("SOFTWARE\\dada", $key)
+    or 
+    $HKEY_LOCAL_MACHINE->Create("SOFTWARE\\dada", $key);
+    $key->Close();
+    undef $key;
+    $HKEY_LOCAL_MACHINE->Open("SOFTWARE\\dada\\PodView", $key)
+    or 
+    $HKEY_LOCAL_MACHINE->Create("SOFTWARE\\dada\\PodView", $key);
+    if($key) {
+        my($val, $name);
+        $key->GetValues($val);
+        
+        #foreach $name (keys %$val) {
+        #    print "\t$name = $val->{$name}[2]\n";
+        #}
+        
+        $L_COLOR = $val->{'L_COLOR'}[2];
+        $HEAD_COLOR = $val->{'HEAD_COLOR'}[2];
+        $NORMAL_FONT_NAME = $val->{'NORMAL_FONT_NAME'}[2];
+        $FIXED_FONT_NAME = $val->{'FIXED_FONT_NAME'}[2];
+        $MAX_STRUCT_LEVEL = $val->{'MAX_STRUCT_LEVEL'}[2];
+
+        for $i (1..$MRUMAX) {
+            $MRU{$i} = $val->{'MRU'.$i}[2];
+            $MRU{$i} =~ s/\0//g;
+
+            # there are still some problems with SetMenuItemInfo()
+
+            # $MRU{$i} = "ciao mamma";
+            # print "Setting MenuMRU$i to \&$i $MRU{$i}\n";
+            # print "MenuMRU$i = ", $Menu->{'MenuMRU'.$i}, "\n";
+            # $Menu->{'MenuMRU'.$i}->SetMenuItemInfo(-text => "\&$i ".$MRU{$i});
+            # $Menu->{'MenuMRU'.$i}->SetMenuItemInfo(-text => $MRU{$i});
+        }
+
+        DefaultConfig($key);
+        $key->Close();
+    } else {
+        DefaultConfig();
+    }        
+
+    # $SHAddToRecentDocs = new Win32::API("shell32", "SHAddToRecentDocs", [N, P], N);
+
+}
+
+sub DefaultConfig {
+    my($key) = @_;
+    
+    if(!$L_COLOR) {
+        $L_COLOR = hex("FF0000");
+        $key->SetValueEx("L_COLOR", 0, REG_SZ, $L_COLOR) if $key;
+    }
+    if(!$HEAD_COLOR) {
+        $HEAD_COLOR = hex("008000");
+        $key->SetValueEx("HEAD_COLOR", 0, REG_SZ, $HEAD_COLOR) if $key;
+    }
+    if(!$NORMAL_FONT_NAME) {
+        $NORMAL_FONT_NAME = "Times New Roman";
+        $key->SetValueEx("NORMAL_FONT_NAME", 0, REG_SZ, $NORMAL_FONT_NAME) if $key;
+    }
+    if(!$FIXED_FONT_NAME) {
+        $FIXED_FONT_NAME = "Courier New";
+        $key->SetValueEx("FIXED_FONT_NAME", 0, REG_SZ, $FIXED_FONT_NAME) if $key;
+    }
+    if(!$MAX_STRUCT_LEVEL) {
+        $MAX_STRUCT_LEVEL = "2";
+        $key->SetValueEx("MAX_STRUCT_LEVEL", 0, REG_SZ, $MAX_STRUCT_LEVEL) if $key;
+    }
+}
+
+sub AddToMRU {
+    my($file) = @_;
+    my $key;
+
+    foreach $k (keys %MRU) {
+        return if $MRU{$k} eq $file;
+    }
+
+    for $i (reverse 2..$MRUMAX) {
+        $MRU{$i} = $MRU{$i-1};
+    }
+    $MRU{1} = $file;
+    WriteMRU();    
+}
+
+sub WriteMRU {
+    my $key;
+    my $U;
+    $HKEY_LOCAL_MACHINE->Open("SOFTWARE\\dada", $key)
+    or 
+    $HKEY_LOCAL_MACHINE->Create("SOFTWARE\\dada", $key);
+    $key->Close();
+    undef $key;
+    $HKEY_LOCAL_MACHINE->Open("SOFTWARE\\dada\\PodView", $key)
+    or 
+    $HKEY_LOCAL_MACHINE->Create("SOFTWARE\\dada\\PodView", $key);
+    if($key) {
+        foreach $U (1..$MRUMAX) {
+            $key->SetValueEx("MRU$U", 0, REG_SZ, $MRU{$U});
+            $Menu->{'MenuMRU'.$U}->Change(
+                -text => "&$U ".$MRU{$U}
+            );
+        }
+        $key->Close();
+    }        
+    return 1;
+}
+    
+
+sub SearchHead {
+    my($pos, $where, $headwanted) = @_;
+    my $opos = $pos;
+    my $found = 0;  
+    my %format = ();
+    my $stop = 0;
+    my $another = 0;
+    my $max_another = 3;
+    if($where > 0) { 
+        $stop = length($Window->POD->Text()); 
+    }
+    while(not $found) {
+        $pos += $where;
+        $found = 2 if $stop == 0 and $pos == 0;
+        $found = 2 if $stop > 0 and $pos == $stop;      
+        $Window->POD->Select($pos, $pos);
+        %format = $Window->POD->GetCharFormat(1);
+        #if($format{-color} == $HEAD_COLOR) {
+        if($format{-bold}) {
+            my $headtext = substr($Window->POD->Text, $pos, 1);
+            $tpos = $pos;
+            $char = "x";
+            #while($format{-color} == $HEAD_COLOR) {
+            while($format{-bold} and $char ne "\n") {
+                $tpos += 1;
+                $char = substr($Window->POD->Text, $tpos, 1);
+                $headtext .= $char;
+                $Window->POD->Select($tpos, $tpos);
+                %format = $Window->POD->GetCharFormat(1);
+                # print "${char}[$format{-bold}]";
+            }
+            # print "\n";
+            $tpos = $pos;
+            # $format{-color} = $HEAD_COLOR;
+            $format{-bold} = 1;
+            $char = "x";
+            # while($format{-color} == $HEAD_COLOR) {
+            while($format{-bold} and $char ne "\n") {
+                $tpos -= 1;
+                $char = substr($Window->POD->Text, $tpos, 1);
+                $headtext = $char . $headtext;
+                $Window->POD->Select($tpos, $tpos);
+                %format = $Window->POD->GetCharFormat(1);
+                # print "$char";
+            }
+            #print "\n";
+            # $headtext = strreverse($headtext) if $where < 0;
+            $headtext =~ s/[\r\n]//g;
+            #print "SearchHead: ($where,$pos) found '$headtext', wanted '$headwanted'\n";
+            if($headtext eq $headwanted) {
+                # $pos -= length($headtext) if $where > 0;
+                $pos = $tpos;
+                $found = 1;
+            } else {
+                $pos = ( ($where > 0) ? $pos+length($headtext)+1 : $tpos );
+                $another++; # banged on another head
+                $found = 2 if $another > $max_another; 
+            }
+        }
+    }
+    return wantarray ? ($opos, 0) : $opos if $found == 2;        
+    return wantarray ? ($pos,  1) : $pos;
+}
+
+sub strreverse {
+    my($string) = @_;
+    my $new = "";
+    for my $i (reverse 0..length($string)) {
+        $new .= substr($string, $i, 1);
+    }
+    return $new;
+}
+
+######################################################################
+# EVENTS :-)
+#
+
+sub Window_Resize {
+    if(defined $Window) {
+        ($width, $height) = ($Window->GetClientRect)[2..3];
+        $TOCwidth = ( $Window->Header->ItemRect(0) )[2];
+        $Window->Header->Resize($TOCwidth, 22);
+        if($Menu->{ViewStructure}->Checked) {
+            $Window->TOC->Move(0, 22);
+            $Window->TOC->Resize($TOCwidth, $height-22-$Window->Status->Height);
+            $Window->POD->Move($TOCwidth, 0);
+            $Window->POD->Resize($width-$TOCwidth, $height-$Window->Status->Height);
+        } else {
+            $Window->POD->Move(0, 0);
+            $Window->POD->Resize($width, $height-$Window->Status->Height);
+        }
+        $Window->Status->Resize($width, $height);
+        #if($Window->Status->Progress) {
+        #    $Window->Status->Progress->Move($Window->Status->Width-150, 2);
+        #}
+        $NoPOD->Move($width/2-$NoPOD->Width/2, $height/2-$NoPOD->Height/2);
+    }
+}
+
+sub Header_EndTrack {
+    my($item, $TOCwidth) = @_;
+    my($width, $height) = ($Window->GetClientRect)[2..3];
+    if($TOCwidth < 16) {
+        $Window->Header->ChangeItem(0, -width => 16);
+        $TOCwidth = 16;
+    }
+    $Window->Header->Resize($TOCwidth, 22);
+    $Window->TOC->Resize($TOCwidth, $height-22-$Window->Status->Height);
+    $Window->POD->Move($TOCwidth, 0);
+    $Window->POD->Resize($width-$TOCwidth, $height-$Window->Status->Height);
+    $Window->TOC->SetForegroundWindow();
+}
+
+sub Header_Track {
+    my($item, $width) = @_;
+    return 0 if $width < 16;
+    return 1;
+}
+
+sub Window_Terminate {
+    #WriteMRU();
+    return -1;
+}
+
+sub Window_Activate {
+    $POD->SetFocus;
+}
+
+sub TOC_Click {
+    my $EM_SCROLLCARET = 183;
+    my $EM_LINESCROLL = 182;
+    my $EM_SETSEL = 177;
+    my $EM_EXLINEFROMCHAR = 1078;
+    my($x, $y) = Win32::GUI::GetCursorPos();
+    $x -= $Window->TOC->Left;
+    $y -= $Window->TOC->Top;
+    my $node = $Window->TOC->HitTest($x, $y);
+    # print "LoadPod: DblClick on node($node)\n";
+    if($node) {
+        my %node = $Window->TOC->GetItem($node);
+        my $char;
+        my $found;
+        if($TOCRef{$node} < 0) {
+            $char = -$TOCRef{$node};
+        } else {
+            $Window->Status->Text("Searching '$node{-text}'...");
+            ($char, $found) = SearchHead($TOCRef{$node}, -1, $node{-text});
+            if($found == 0) {
+                ($char, $found) = SearchHead($TOCRef{$node}, 1, $node{-text});
+                if($found == 0) {
+                    $Window->Status->Text("WARNING: '$node{-text}' not found!");
+                } else {
+                    $Window->Status->Text("PodView $VERSION Ready");
+                }
+            } else {
+                $Window->Status->Text("PodView $VERSION Ready");
+                
+            }
+            $TOCRef{$node} = -$char if $found;
+        }
+        my $fvl = $Window->POD->FirstVisibleLine;
+        my $diff = ($Window->POD->LineFromChar($char)) - $fvl;
+        #print 
+        #    "Scrolling to line: ", 
+        #    $Window->POD->LineFromChar($char), 
+        #    " (char $char)\n";
+        $Window->POD->SendMessage($EM_LINESCROLL, 0, $diff);
+        my ($ci, $li) = $Window->POD->CharFromPos(1, 1);
+        $Window->POD->Select($ci, $ci);
+        $Window->POD->SendMessage($EM_SCROLLCARET, 0, 0);
+        #if($Window->TOC->GetChild($node)) {
+        #    $Window->TOC->Expand($node, 1);
+        #}
+    }
+    return 0;
+}
+
+sub TOC_Collapsing {
+    return ($TOC_CanExpand) ? 1 : 0;
+}
+sub TOC_Expanding {
+    return ($TOC_CanExpand) ? 1 : 0;
+}
+
+#sub TOC_Click {
+    # print "FVL=", $Window->POD->FirstVisibleLine, "\n";
+    # print "LINE=", 
+    #    $Window->POD->LineFromChar(($Window->POD->Selection)[0]), 
+    #    " (char=",
+    #    ($Window->POD->Selection)[0],
+    #    "\n";
+#}
+
+sub TOC_Collapse {
+#   $Window->TOC->Expand(shift);
+    return 0;
+}
+
+sub MenuExit_Click {
+    #WriteMRU();
+    return -1;
+}
+
+sub MenuSave_Click {
+    if($PODFILE) {
+        $POD->Save($PODFILE.".rtf");
+    }
+}
+
+sub MenuReload_Click {
+    my($place) = $Window->POD->CharFromPos(1, 1);
+    my $line   = $Window->POD->LineFromChar($place);
+    LoadPod(undef, 1);
+    my $EM_LINESCROLL = 182;    
+    my $EM_SCROLLCARET = 183;   
+    my $fvl = $Window->POD->FirstVisibleLine;
+    print "li=$line ci=$place\n";
+    $Window->POD->SendMessage($EM_LINESCROLL, 0, $line);    
+    $Window->POD->Select($place, $place);
+    $Window->POD->SendMessage($EM_SCROLLCARET, 0, 0);   
+    $Window->POD->SetRedraw(1);
+    $Window->POD->InvalidateRect(1);
+    
+}
+
+sub MenuOpen_Click {
+    my $file = GUI::GetOpenFileName();
+    if($DEBUG) {
+        print "GetOpenFileName returned $ret\n";
+        print "CommDlgExtendedError is ", GUI::CommDlgExtendedError(), "\n";
+        print "LastError is ", Win32::GetLastError(), "\n";
+    }
+    if($file) {
+        if(LoadPod($file)) {
+            AddToMRU($file);
+        }
+    }
+}
+
+sub MenuHeadColor_Click {
+    my $c = GUI::ChooseColor(-color => $HEAD_COLOR);
+    $HEAD_COLOR = $c if $c;
+}
+
+sub MenuLinkColor_Click {
+    my $c = GUI::ChooseColor(-color => $L_COLOR);
+    $L_COLOR = $c if $c;
+}
+
+sub MenuNormalFont_Click {
+    my @f = GUI::ChooseFont(-name => $NORMAL_FONT_NAME, -noscript => 1);
+    if($f[0]) {
+        my %f = @f;
+        $NORMAL_FONT_NAME = $f{-name};
+    }
+}
+
+sub MenuFixedFont_Click {
+    my @f = GUI::ChooseFont(-name => $FIXED_FONT_NAME, -noscript => 1, -fixedonly => 1);
+    if($f[0]) {
+        my %f = @f;
+        $FIXED_FONT_NAME = $f{-name};
+    }
+}
+
+sub MenuSaveConfig_Click {
+    my $key;
+    $HKEY_LOCAL_MACHINE->Open("SOFTWARE\\dada\\PodView", $key);
+    if($key) {
+        $key->SetValueEx("L_COLOR", 0, REG_SZ, $L_COLOR);
+        $key->SetValueEx("HEAD_COLOR", 0, REG_SZ, $HEAD_COLOR);
+        $key->SetValueEx("NORMAL_FONT_NAME", 0, REG_SZ, $NORMAL_FONT_NAME);
+        $key->SetValueEx("FIXED_FONT_NAME", 0, REG_SZ, $FIXED_FONT_NAME);
+        $key->Close();
+    } else {
+        Win32::GUI::MessageBox("ERROR: Unable to save config...");
+    }
+}
+
+sub ViewStructure_Click {
+    $Menu->{ViewStructure}->Checked(
+        not $Menu->{ViewStructure}->Checked
+    );
+    if($Menu->{ViewStructure}->Checked) {
+        $Window->Header->Show();
+        $Window->TOC->Show();
+    } else {
+        $Window->Header->Hide();
+        $Window->TOC->Hide();
+    }
+    Window_Resize();
+}
+
+sub ViewSource_Click {
+    system("start notepad $PODFILE");
+}
+
+sub ToolPmx_Click {
+    my $path = $FindBin::Bin;
+    $path =~ s(/)(\\)g;
+    $Window->Hide();
+    system("perl $path\\pmx.pl");
+    $Window->Show();
+}
+
+#===============================================================================
+# still testing this...
+
+$IBEAM = 32513;
+$ARROW = 32512;
+
+sub POD_MouseMove {
+    # print "Got POD_MouseMove\n";
+    my($shifts, $x, $y) = @_;
+    my $Cursor;
+    ($ci, $li) = $POD->CharFromPos($x, $y);
+    if($ci) {
+        # 11 == WM_SETREDRAW
+        $POD->SendMessage(11, 0, 0);
+        $POD->Disable();
+        my($ss, $se) = $POD->Selection();
+        $POD->Select($ci, $ci);
+        my %format = $POD->GetCharFormat();
+        $Cursor = ($se <= $ci and $ci >= $ss) ? $ARROW : $IBEAM;
+        $POD->Select($ss, $se);
+        $POD->SendMessage(11, 1, 0);
+        $POD->Enable();
+        $POD->InvalidateRect(0);
+        if($format{-color} == $L_COLOR) {
+            GUI::SetCursor($HAND); # if GUI::GetCursor() != $HAND;
+        } else {
+            GUI::SetCursor($Cursor);
+        }
+    #} else {
+    #    GUI::SetCursor(32513);
+    }
+    while ($POD->PeekMessage(512, 512)) {
+        $POD->GetMessage();
+    }
+    return 1;
+
+}
+
+
+sub POD_LButtonDown {
+    my($shifts, $x, $y) = @_;
+    my $ci;
+    my $li;
+    ($ci, $li) = $POD->CharFromPos($x, $y);
+    if($ci) {
+        $POD->Select($ci, $ci) if $ci;
+        my %format = $POD->GetCharFormat();
+        if($format{-color} == $L_COLOR) {
+            $Window->Status->Text("that's a link");
+        } elsif($format{-color} == $HEAD_COLOR) {
+            $Window->Status->Text("YUPPI! it's a head!");
+        } else {
+            $Window->Status->Text("nopi, it's text.");
+        }
+    } else {
+        $Window->Status->Text("nothing selected.");
+    }
+    return 1;
+
+}
+#===============================================================================
+
+
+######################################################################
+# POD - also "About PodView..." :-)
+#
+
+=head1 NAME
+
+PodView - Plain Old Documentation Viewer
+
+=head1 SYNOPSIS
+
+    perl podview.pl [filename]
+
+=head1 DESCRIPTION
+
+This was done to test the Win32::GUI module.
+
+=head1 AUTHOR
+
+Aldo Calpini ( I<dada@perl.it> )
+
+=cut
+
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/ppmrepa.bmp perl-libwin32-0.191/GUI/samples/ppmrepa.bmp
--- libwin32-0.191/GUI/samples/ppmrepa.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/ppmrepa.bmp	2004-01-12 16:46:42.359375000 -0800
@@ -0,0 +1 @@
+BM6      6   (                                                                             `````````````    OO`    'w  '?`     '? 'S  t'?`       3/L_;T XO`     c/[/kss  LGO`     O P +P Sk P {O`     Cw? P /k`     wc`     ```````            `            `    ```````                   
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/ppmrepc.bmp perl-libwin32-0.191/GUI/samples/ppmrepc.bmp
--- libwin32-0.191/GUI/samples/ppmrepc.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/ppmrepc.bmp	2004-01-12 16:46:42.375000000 -0800
@@ -0,0 +1 @@
+BM6      6   (                                   O ?     OOp         O ?          p  p           ? 0  p  p  p     ?     POpOp    p  p  p         POp  OpOp  p  p P OpOO     ?oOp      OpOp  P P P   ?oOp             0Op  p POpOp 0                 ? P  POp                     ? OOp                   0 OOp              p POO P         O O   ?OO
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/ppmrepf.bmp perl-libwin32-0.191/GUI/samples/ppmrepf.bmp
--- libwin32-0.191/GUI/samples/ppmrepf.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/ppmrepf.bmp	2004-01-12 16:46:42.390625000 -0800
@@ -0,0 +1 @@
+BM6      6   (                                                                             `````````````    OO`    'w  '?`    '? 'S  t'?`      3/L_;T XO`    c/[/kss  LGO`    O P +P Sk P {O`    Cw? P /k`    wc`    ```````                   
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/ppmrepi.bmp perl-libwin32-0.191/GUI/samples/ppmrepi.bmp
--- libwin32-0.191/GUI/samples/ppmrepi.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/ppmrepi.bmp	2004-01-12 16:46:42.406250000 -0800
@@ -0,0 +1 @@
+BM6      6   (                                   O ?     OOp         O ?          p  p           ? 0  p  p  p     ?     POpOp    p  p  p         POp   OpOp  p  p P OpOO     ?oOp     PPOpOp  P P P   ?oOp          0OpPPPOpOp 0 P P hpphpphpphppPPPOp P P P P PP[__[__[__[__WWWOp P P P P PfqqOp P P Pxx`x888 P P P  Ppp{$0000  p ?pp000kpp
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/ppmrepl.bmp perl-libwin32-0.191/GUI/samples/ppmrepl.bmp
--- libwin32-0.191/GUI/samples/ppmrepl.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/ppmrepl.bmp	2004-01-12 16:46:42.406250000 -0800
@@ -0,0 +1 @@
+BM6      6   (                                                                             ccccccccccccc    PPPc    hpphpphpphppPPPc    [__[__[__[__WWWc    fqqc    xx`x888c    pp{$0000c    pp000c    kppc    ccccccc                   
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/ppmrepn.bmp perl-libwin32-0.191/GUI/samples/ppmrepn.bmp
--- libwin32-0.191/GUI/samples/ppmrepn.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/ppmrepn.bmp	2004-01-12 16:46:42.421875000 -0800
@@ -0,0 +1 @@
+BM6      6   (                                                 ?w  ??   ?? 'S  t??     3/L_;T X   /[/kss  LG   g P +P Sk P {   [w? P /                                                    
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/ppmrepo.bmp perl-libwin32-0.191/GUI/samples/ppmrepo.bmp
--- libwin32-0.191/GUI/samples/ppmrepo.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/ppmrepo.bmp	2004-01-12 16:46:42.437500000 -0800
@@ -0,0 +1 @@
+BM6      6   (                                   O ?     OOp         O ?          p  p           ? 0  p  p  p     ?     POpOp    p  p  p         POp   OpOp  p  p P OpOO     ?oOp     PPOpOp  P P P   ?oOp          0Op  p POpOp 0 P P    P  P ? P  POp P P P P PP  PP P  P  P ? OOp P P P P P P  P  P  P 0 OOp P P P P  P  p POO P P P  P P O O  p ?OO
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/ppmrepr.bmp perl-libwin32-0.191/GUI/samples/ppmrepr.bmp
--- libwin32-0.191/GUI/samples/ppmrepr.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/ppmrepr.bmp	2004-01-12 16:46:42.453125000 -0800
@@ -0,0 +1 @@
+BM6      6   (                                                                                                        ??        ;T X          LG         P {        P /                     
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/pride.pl perl-libwin32-0.191/GUI/samples/pride.pl
--- libwin32-0.191/GUI/samples/pride.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/pride.pl	2004-01-12 16:46:42.468750000 -0800
@@ -0,0 +1,634 @@
+#!perl -w
+
+use strict;
+
+use Win32::GUI;
+use Cwd;
+
+my $VERSION = "0.14.00";
+my %objects = ();
+my %varobjects = ();
+
+my %TreeStruct;
+
+my $EM_SCROLLCARET = 183;
+my $EM_LINESCROLL = 182;
+my $EM_SETSEL = 177;
+my $EM_EXLINEFROMCHAR = 1078;
+
+my ($DOS) = Win32::GUI::GetPerlWindow();
+#Win32::GUI::Hide($DOS);
+
+my $Menu = new Win32::GUI::Menu(
+    "&File" => "File",
+    "   >   &New" => "FileNew",
+    "   >   &Open" => "FileOpen",
+    "   >   &Save" => "FileSave",
+    "   >   Save &As" => "FileSaveAs",
+    "   >   &Close" => "FileClose",
+    "   >   -" => 0,
+    "   >   &Repride" => "FileRepride",
+    "   >   -" => 0,
+    "   >   E&xit" => "FileExit",
+
+    "&Edit" => "Edit",
+    "   >   &Undo" => "EditUndo",
+    "    >    -" => 0,
+    "   >   Cu&t" => "EditCut",
+    "   >   &Copy" => "EditCopy",
+    "   >   &Paste" => "EditPaste",
+
+    "&Program" => "Program",
+    "   >   &View Structure" => { -name => "ProgramViewStructure", -checked => 1 },
+    "   >   &Rebuild Structure" => "ProgramRebuildStructure",
+
+    "&Run" => "Run",
+    "   >   &Execute" => "RunExecute",
+    "   >   &Debug" => "RunDebug",
+
+);
+
+my $EditorFont = new Win32::GUI::Font(
+    -name => "Courier New", 
+    -height => 16,
+);
+
+my $EditorClass = new Win32::GUI::Class(
+    -name => "PRIDE_${VERSION}_Editor",
+    -extends => "RichEdit",
+    -widget => "RichEdit",
+);
+
+my $Window = new Win32::GUI::Window(
+    -name   => "Window",
+    -left   => 100,
+    -top    => 100,
+    -width  => 800,
+    -height => 500,
+    -title  => "PRIDE version ".$VERSION,
+    -menu   => $Menu,
+);
+
+$Window->AddStatusBar(
+    -name => "Status",
+    -text => "PRIDE version $VERSION - Ready",
+);
+
+$Window->AddRichEdit(
+    -class     => $EditorClass,
+    -name      => "Editor",
+    -multiline => 1,
+    -left      => 150,
+    -top       => 28,
+    -width     => $Window->ScaleWidth,
+    -height    => $Window->ScaleHeight-28-$Window->Status->Height,
+    -font      => $EditorFont,
+    -exstyle   => WS_EX_CLIENTEDGE,
+    -style     => WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_HSCROLL
+        | ES_LEFT | ES_MULTILINE | ES_AUTOHSCROLL | ES_AUTOVSCROLL,
+);
+
+$Window->Editor->SendMessage(1093, 0, 1);
+
+$Window->AddTreeView(   
+    -name   => "ProgStruct",
+    -pos    => [0, 0],
+    -size   => [ 150, $Window->ScaleHeight-28-$Window->Status->Height ],
+    -lines  => 1,
+    -buttons => 1,
+    -rootlines => 1,
+);
+
+#
+#$Window->AddCombobox(
+#    -name      => "SelectObj",
+#    -left      => 0,
+#    -top       => 5,
+#    -width     => $Window->ScaleWidth/2,
+#    -height    => 300,
+#    -style     => Win32::GUI::constant("WS_VISIBLE", 0) | 3 | Win32::GUI::constant("WS_NOTIFY", 0),
+#);
+#
+#$Window->AddCombobox(
+#    -name      => "SelectSub",
+#    -left      => $Window->ScaleWidth/2,
+#    -top       => 5,
+#    -width     => $Window->ScaleWidth/2,
+#    -height    => 300,
+#    -style     => Win32::GUI::constant("WS_VISIBLE", 0) | 3 | Win32::GUI::constant("WS_NOTIFY", 0),
+#);
+#
+
+my $GotoWindow = new Win32::GUI::DialogBox(
+    -name => "GotoWindow",
+    -text => "Goto line...",
+    -left => 150,
+    -top  => 150,
+    -width => 200,
+    -height => 100,
+);
+
+$GotoWindow->AddLabel(
+    -name => "GotoLabel",
+    -text => "Line:",
+    -left => 5,
+    -top => 10,
+);
+
+$GotoWindow->AddTextfield(
+    -name => "GotoLine",
+    -left => 5,
+    -top => 25,
+    -width => 190,
+    -height => 22, 
+    -tabstop => 1,
+);
+
+$GotoWindow->AddButton(
+    -name => "GotoOK",
+    -text => "OK", 
+    -left => 5,
+    -top => 50,
+    -height => 22,
+    -width => 90,
+    -tabstop => 1,
+    -ok => 1,
+    -default => 1,
+);
+
+$GotoWindow->AddButton(
+    -name => "GotoCancel",
+    -text => "Cancel", 
+    -left => 100,
+    -top => 50,
+    -height => 22,
+    -width => 90,
+    -tabstop => 1,
+    -cancel => 1,
+);
+
+$Window->Show();
+
+my $FILE = ($ARGV[0] or $0);
+LoadFile($FILE);
+
+$Window->{-dialogui} = 1;
+
+print "DIALOGUI: $Window->{-dialogui}\n";<STDIN>;
+
+Win32::GUI::Dialog();
+
+Win32::GUI::Show($DOS);
+print "Bye bye from PRIDE version $VERSION...\n";
+
+sub Window_Terminate {
+    if(OkToClose()) {
+    return -1;
+    } else {
+    return 1;
+    }
+}
+
+sub Window_Resize {
+    my $Width = $Window->ScaleWidth;
+    my $Height = $Window->ScaleHeight;
+    $Window->Editor->Resize($Width, $Height-28-$Window->Status->Height);
+    $Window->Status->Resize($Width, $Window->Status->Height);
+#    $Window->SelectObj->Resize($Width/2, $Window->SelectObj->Height);
+#    $Window->SelectSub->Resize($Width/2, $Window->SelectSub->Height);
+#    $Window->SelectSub->Move($Width/2, 5);
+    $Window->Status->Move(0, $Window->ScaleHeight-$Window->Status->Height);
+}
+
+sub Window_Activate {
+    $Window->Editor->SetFocus();
+}
+
+sub LoadFile {
+    ($FILE) = @_;
+    my $DEBUG = 1;
+    print "FILE: $FILE\n" if $DEBUG;
+    open(FILE, $FILE) or return 0;
+    my $file = "";
+    my $object;
+    my $parent;
+    my $sub;
+    my $defo;
+    my $var;  
+    my $what;
+    my $name;
+    my $c = 1;
+
+    %objects = ("<perl>" => []);
+    %varobjects = ();
+#    $Window->SelectObj->Clear();
+#    $Window->SelectSub->Clear();
+#    $Window->SelectObj->AddString("<perl>");
+
+    $Window->ProgStruct->Clear();
+
+    $TreeStruct{"<perl>"} = $Window->ProgStruct->InsertItem(-text => "<perl>");
+
+    while(<FILE>) {
+    chomp;
+    # converts tabs in 4 spaces
+    s/\t/    /g;
+
+        if(/^\s*#/) {
+            $file .= $_."\r\n";
+        } else {
+
+            if(/\$(.+)\s*=\s*new (Win32::)?GUI::/) {
+                $var = $1;
+                $var =~ s/^\s*//;
+                $var =~ s/\s*$//;
+                print "Found variable: [$var]\n" if $DEBUG;
+                $object = "[TBD]";
+                $what = "X";
+                $defo = length($file);
+            }
+
+            #    $Window->SelectObj->AddString($object);
+            #    $Window->SelectObj->Text($object);
+            #    if(exists($objects{$object})) {
+            #        push(@{$objects{$object}}, "<definition>;".length($file));
+            #    } else {
+            #        $objects{$object} = [ "<definition>;".length($file) ];
+            #    }
+            #}
+
+            if(/\s*\$(\S+)->Add/) {
+                $parent = $1;
+                $parent =~ s/^\s*//;
+                $parent =~ s/\s*$//;
+                print "Found child of [$parent]\n" if $DEBUG;
+                print "varobjects(parent): $varobjects{$parent}\n" if $DEBUG;
+                if(exists($varobjects{$parent})) {
+                    $object = "[TBD]";
+                    $what = "";
+                    $defo = length($file);
+                } else {
+                    print "Skipping because [$parent] doesn't exists...\n" if $DEBUG;
+                }
+            }
+            if(/-name\s*=>\s*["']?([^,"']+)["']?,?/ and $object eq "[TBD]") {
+                $object = $1;
+                $object =~ s/^\s*//;
+                $object =~ s/\s*$//;
+                print "Found name: [$object]\n" if $DEBUG;
+                if(exists($objects{$object})) {
+                    push(@{$objects{$object}}, "<definition>;".$defo);
+                } else {
+                    $objects{$object} = [ "<definition>;".$defo ];
+                }
+                if($var) {
+                    #$Window->SelectObj->AddString($object." (\$".$var.")");
+                    #$Window->SelectObj->Text($object." (\$".$var.")");
+
+                    $TreeStruct{$object} = $Window->ProgStruct->InsertItem(
+                        -text => "$object (\$$var)",
+                    );
+                    $varobjects{$var} = $object;
+                } else {
+                    $TreeStruct{$object} = $Window->ProgStruct->InsertItem(
+                        -text => "$object",
+                    );
+                    #$Window->SelectObj->AddString($object);
+                    #$Window->SelectObj->Text($object);
+                }            
+                $object = "";
+                $var = "";
+                $what = "";
+            }
+            if(/\$(.+)\s*=\s*\$(.+)->Add/) {
+                $object = $1;
+                $parent = $2;
+                $object =~ s/^\s*//;
+                $object =~ s/\s*$//;
+                $parent =~ s/^\s*//;
+                $parent =~ s/\s*$//;
+                print "Found object: [$object] (parent: [$parent])\n" if $DEBUG;
+                print "objects(parent): $objects{$parent}\n" if $DEBUG;
+                #if(exists($objects{$parent})) {
+                #    $Window->SelectObj->AddString($object);
+                #    $Window->SelectObj->Text($object);
+                #    push(@{$objects{$object}}, "<definition>;".length($file));
+                #}
+                if(exists($varobjects{$parent})) {
+                    $object = "[TBD]";
+                    $what = "";
+                    $defo = length($file);
+                } else {
+                    print "Skipping because [$parent] doesn't exists...\n" if $DEBUG;
+                }
+
+            }
+            if(/^\s*sub ([^\s{]+)_([^\s{]+)/) {
+                $parent = $1;
+                $sub    = $2;
+                if(exists($objects{$parent})) {
+                    push(@{$objects{$parent}}, $sub.";".length($file));
+                } else {
+                    $parent = "<perl>";
+                    $sub    = $1."_".$2;
+                    if(exists($objects{$parent})) {
+                        push(@{$objects{$parent}}, $sub.";".length($file));
+                    }               
+                }               
+            } else {
+                if(/^\s*sub ([^\s{]+)/) {
+                    $parent = "<perl>";
+                    $sub    = $1;
+                    if(exists($objects{$parent})) {
+                        push(@{$objects{$parent}}, $sub.";".length($file));
+                    }               
+                }
+            }
+            # $file .= $c++." ".$_."\r\n";
+            $file .= $_."\r\n";
+        }               
+    }
+    close(FILE);
+
+    foreach $object (keys %objects) {
+        foreach $sub (@{$objects{$object}}) {
+            ($name, undef) = split(/;/, $sub, 2);
+            $TreeStruct{$object."-".$name} = $Window->ProgStruct->InsertItem(
+                -text => $name, 
+                -parent => $TreeStruct{$object},
+            );
+        }
+    }
+
+
+    $Window->Editor->Text($file);
+    $Window->Caption("PRIDE Version $VERSION - $FILE");
+    $Window->Editor->SetFocus();
+    return 1;
+}
+
+sub SelectObj_Change {
+    my $object = $Window->SelectObj->GetString($Window->SelectObj->SelectedItem);
+    $object =~ s/ \(\$.*\)$//;
+    print "Selected object: $object\n";
+    $Window->SelectSub->Clear();
+    my $sub;
+    my $name;
+    foreach $sub (@{$objects{$object}}) {
+    ($name, undef) = split(/;/, $sub, 2);
+    $Window->SelectSub->AddString($name);
+    }
+    $Window->SelectSub->Select(0);
+    SelectSub_Change();
+}
+
+sub SelectSub_Change {
+    my $object;
+    my $ssub;
+    my $issub = $Window->SelectSub->SelectedItem;
+    my $isobject = $Window->SelectObj->SelectedItem;
+    if($isobject >= 0) {
+    $object = $Window->SelectObj->GetString($Window->SelectObj->SelectedItem);
+    $object =~ s/ \(\$.*\)$//;
+    } else {
+    return 1;
+    }
+    if($issub >= 0) {
+    $ssub = $Window->SelectSub->GetString($Window->SelectSub->SelectedItem);
+    } else {
+    return 1;
+    }
+    my $sub;
+    my $name;
+    my $pos;
+    foreach $sub (@{$objects{$object}}) {
+    ($name, $pos) = split(/;/, $sub, 2);
+    if($name eq $ssub) {
+
+        GotoLine($Window->Editor->LineFromChar($pos));
+
+        #print "Object: $object / Sub: $ssub / Pos: $pos\n";
+        ## $Window->Editor->Select($pos-1, $pos+1);
+        #$Window->Editor->SendMessage($EM_SETSEL, $pos, $pos);
+        #$Window->Editor->SendMessage($EM_SCROLLCARET, 0, 0);
+        
+        $Window->Editor->Update();
+        $Window->Editor->SetFocus();
+    }
+    }
+}
+
+sub FileRepride_Click {
+    # system("perl $0");
+    if(OkToClose()) {
+
+    system("start /min perl $0");
+
+    #my $pid = 0;
+    #my $file;
+    #if($FILE !~ /^[a-z]:\\/i) {
+    #    $file = Win32::GetCwd."\\".$FILE;
+    #} else {
+    #    $file = $FILE;
+    #}
+    #print "Executing p:\\perl5\\bin\\perl.exe $file ...\n";
+    #my $r = Win32::Spawn("perl", "$file", $pid);
+    #my $err = Win32::GetLastError();
+    #print "Repride r=$r err=$err pid=$pid\n";
+    return -1;
+    } else {
+    return 1;
+    }
+}
+
+
+sub FileExit_Click {
+    if(OkToClose()) {
+    return -1;
+    } else {
+    return 1;
+    }
+}
+
+sub FileSave_Click {
+    # make a backup copy
+    open(BAKFILE, ">$FILE.bak");
+    open(OLDFILE, "<$FILE");
+    while(<OLDFILE>) { print <BAKFILE>; }
+    close(BAKFILE);
+    close(OLDFILE);
+
+    open(FILE, ">$FILE");
+    my $text = $Window->Editor->Text();
+    $text =~ s/\r\n/\n/g;
+    print FILE $text;
+    close(FILE);
+    $text = $Window->Text();
+    if($text =~ s/ \*$//) {
+    $Window->Text($text);
+    }
+}
+
+
+sub FileClose_Click {
+    if(OkToClose()) {
+    $Window->Editor->Text("");
+    $FILE = "untitled.pl";
+    $Window->Text("PRIDE version $VERSION - untitled.pl");
+    }
+}
+
+sub FileNew_Click {
+    if(OkToClose()) {
+    $Window->Editor->Text("");
+    $FILE = "untitled.pl";
+    $Window->Text("PRIDE version $VERSION - untitled.pl");
+    }
+}
+
+sub FileOpen_Click {
+    my $file = GUI::GetOpenFileName(-directory => Win32::GetCwd());
+    if($file) {
+    LoadFile($file);
+    }
+}
+
+
+sub FileSaveAs_Click {
+    my $file = GUI::GetSaveFileName(-directory => Win32::GetCwd());
+    if($file) {
+        open(BAKFILE, ">$FILE.bak");
+        open(OLDFILE, "<$FILE");
+        while(<OLDFILE>) { print <BAKFILE>; }
+        close(BAKFILE);
+        close(OLDFILE);
+
+        open(FILE, ">$file");
+        my $text = $Window->Editor->Text();
+        $text =~ s/\r\n/\n/g;
+        print FILE $text;
+        close(FILE);
+        $text = $Window->Text();
+        if($text =~ s/ \*$//) {
+            $Window->Text($text);
+        }
+    }
+}
+
+
+sub Editor_KeyPress {
+    my($key) = @_;
+
+    if($key == 7) {
+    $GotoWindow->Move(
+        $Window->Left+($Window->ScaleWidth-$GotoWindow->Width)/2,
+        $Window->Top+($Window->ScaleHeight-$GotoWindow->Height)/2,
+    );
+    $GotoWindow->Show();
+    $GotoWindow->GotoLine->SetFocus();
+    $Window->Disable();
+    return 0;
+    } else {
+    print "Editor_KeyPress got $key\n";
+    my($pos, undef) = $Window->Editor->Selection();
+    my $line = 1 + $Window->Editor->LineFromChar($pos);
+    $Window->Status->Text("on line $line");
+    return 1;
+    }
+}
+
+sub GotoWindow_Terminate {
+    GotoCancel_Click();
+}
+
+sub GotoCancel_Click {
+    $GotoWindow->Hide();
+    $Window->Enable();
+    $Window->SetForegroundWindow();
+    return 1;
+}
+
+sub GotoOK_Click {
+    $GotoWindow->Hide();
+    $Window->Enable();
+    GotoLine($GotoWindow->GotoLine->Text);
+    return 1;
+}
+
+sub GotoLine {
+    my($line) = @_;
+    print "Line=$line\n";
+    my $fvl = $Window->Editor->FirstVisibleLine;
+    print "FVL=$fvl\n";
+    my $diff = ($line-1) - $fvl;
+    print "DIFF=$diff\n";
+    $Window->Editor->SendMessage($EM_LINESCROLL, 0, $diff);
+    my ($ci, $li) = $Window->Editor->CharFromPos(1, 1);
+    print "CI=$ci\n";
+    $Window->Editor->Select($ci, $ci);
+    $Window->Editor->SendMessage($EM_SCROLLCARET, 0, 0);
+    $Window->Editor->SetFocus();
+}
+
+sub Editor_Change {
+    my $text = $Window->Text;
+    if($text !~ /\*$/) {
+    $Window->Text($text." *");
+    }
+    return 1;
+}
+
+sub OkToClose {
+    # if($Window->Editor->Modified()) {
+    if($Window->Text =~ /\*$/) {
+    my $answer = $Window->MessageBox("Save changes to $FILE ?", "PRIDE", 3+48);
+    if($answer == 3) { # IDCANCEL
+        return 0;
+    } elsif($answer == 6) {
+        FileSave_Click();
+        return 1;
+    } elsif($answer == 7) {
+        return 1;
+    }
+    } else {
+    return 1;
+    }
+    return 0;
+}
+
+#=======================
+sub ProgStruct_KeyDown {
+#=======================
+    my($key) = @_;
+    if($key == 13) {
+        ProgStruct_DblClick();
+    }
+}
+#========================
+sub ProgStruct_DblClick {
+#========================
+    my $sub = $Window->ProgStruct->SelectedItem;
+    print "ProgStruct_DblClick: sub=$sub\n";
+    my %sub = $Window->ProgStruct->GetItem($sub);
+    my $obj = $Window->ProgStruct->GetParent($sub);
+    print "ProgStruct_DblClick: obj=$obj\n";
+    my %obj = $Window->ProgStruct->GetItem($obj);
+
+    $obj{-text} =~ s/\s\(.*\)$//;
+
+    if(exists $TreeStruct{$obj{-text}."-".$sub{-text}}) {
+        foreach my $o (@{$objects{$obj{-text}}}) {
+            my ($name, $pos) = split(/;/, $o, 2);
+            if($name eq $sub{-text}) {
+                GotoLine($Window->Editor->LineFromChar($pos));
+
+                $Window->Editor->Update();
+                $Window->Editor->SetFocus();
+            }
+        }
+    } else {
+        print "not a child: $obj{-text}-$sub{-text}\n";
+    }
+    return 0;
+}
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/progressbar.pl perl-libwin32-0.191/GUI/samples/progressbar.pl
--- libwin32-0.191/GUI/samples/progressbar.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/progressbar.pl	2004-01-12 16:46:42.484375000 -0800
@@ -0,0 +1,186 @@
+
+use Win32::GUI;
+use Win32::Sound;
+
+$W = new Win32::GUI::Window(
+    -title    => "Win32::GUI::ProgressBar test",
+    -left     => 100,
+    -top      => 100,
+    -width    => 400,
+    -height   => 150,
+    -font     => $F,
+    -name     => "Window",
+) or print_and_die("new Window");
+
+$tX = 5;
+$W->AddLabel(
+    -name => "MIN_L",
+    -text => "Min.:",
+    -left => $tX,
+    -top  => 5,
+);
+$tX += $W->MIN_L->Width + 10;
+$sX1 = $tX;
+$W->AddTextfield(
+    -name   => "MIN",
+    -left   => $tX,
+    -top    => 5,
+    -width  => 80,
+    -height => 20,
+    -text   => "0",
+);
+$tX += $W->MIN->Width + 10;
+$sX2 = $tX;
+$W->AddLabel(
+    -name => "MAX_L",
+    -text => "Max.:",
+    -left => $tX,
+    -top  => 5,
+);
+$tX += $W->MAX_L->Width + 10;
+$sX3 = $tX;
+$W->AddTextfield(
+    -name   => "MAX",
+    -left   => $tX,
+    -top    => 5,
+    -width  => 80,
+    -height => 20,
+    -text   => "100",
+);
+$tX += $W->MAX->Width + 10;
+$sX4 = $tX;
+$W->AddButton(
+    -name => "SET",
+    -text => "Set range",
+    -left => $tX,
+    -top  => 5,
+);
+$tY = 5 + $W->MAX->Height * 2;
+$tX = 5;
+$W->AddLabel(
+    -name => "ACT_L",
+    -text => "Actual:",
+    -left => $tX,
+    -top  => $tY,
+);
+$tX = $sX1;
+$W->AddTextfield(-name => "ACT",
+    -text   => "10",
+    -left   => $tX,
+    -top    => $tY,
+    -width  => 80,
+    -height => 20,
+);
+$tX = $sX2;
+$W->AddLabel(
+    -name => "INC_L",
+    -text => "Inc.:",
+    -left => $tX,
+    -top  => $tY,
+);
+$tX = $sX3;
+$W->AddTextfield(
+    -name   => "INC",
+    -text   => "10",
+    -left   => $tX,
+    -top    => $tY,
+    -width  => 80,
+    -height => 20,
+);
+$tX = $sX4;
+$W->AddButton(
+    -name => "POS",
+    -text => "Set position",
+    -left => $tX,
+    -top  => $tY,
+);
+$tX += $W->POS->Width + 10;
+$W->AddButton(
+    -name => "UP",
+    -text => "+",
+    -left => $tX,
+    -top  => $tY,
+);
+$tX += $W->UP->Width + 10;
+$W->AddButton(
+    -name => "DN",
+    -text => "-",
+    -left => $tX,
+    -top  => $tY,
+);
+
+$tX += $W->DN->Width + 10;
+
+$W->Resize($tX, $W->Height);
+
+$tY = 5 + $W->MAX->Height * 2 + $W->ACT->Height * 2;
+$tW = $W->Width / 2;
+
+$W->AddProgressBar(
+    -name   => "PB",
+    -left   => ($W->Width - $tW) / 2,
+    -top    => $tY,
+    -width  => $tW,
+    -height => 20,
+    -smooth => 1,
+);
+
+$W->PB->SetPos(10);
+
+$W->Show;
+
+$return = $W->Dialog();
+print "Dialog: $return\n";
+
+sub POS_Click {
+    $W->PB->SetStep($W->INC->Text);
+    $W->PB->SetPos($W->ACT->Text);
+}
+
+sub UP_Click {
+    if($W->ACT->Text == $W->MAX->Text) {
+        Win32::Sound::Play("SystemDefault", SND_ASYNC);
+        return 1;
+    } else {
+        my $pos = $W->PB->SetPos(0);
+        $W->PB->SetPos($pos);
+        my $new = $pos + $W->INC->Text;
+        $new = $W->MAX->Text if $new > $W->MAX->Text;
+        $W->PB->SetPos($new);
+		$W->ACT->{-text} = $new;
+    }
+}
+
+sub DN_Click {
+    if($W->ACT->Text == $W->MIN->Text) {
+        Win32::Sound::Play("SystemDefault", SND_ASYNC);
+        return 1;
+    } else {
+        my $pos = $W->PB->SetPos(0);
+        $W->PB->SetPos($pos);
+        my $new = $pos - $W->INC->Text;
+        $new = $W->MIN->Text if $new < $W->MIN->Text;
+        $W->PB->SetPos($new);
+        $W->ACT->{-text} = $new;
+    }
+}
+
+
+sub SET_Click {
+    $W->PB->SetRange($W->MIN->Text, $W->MAX->Text);
+}
+
+sub print_and_die {
+    my($text) = @_;
+    my $err = Win32::GetLastError();
+    die "$text: Error $err\n";
+}
+
+sub Window_Resize {
+    my $tW = $W->ScaleWidth / 2;
+    my $tY = ($W->MAX->Height * 2) + ($W->ACT->Height * 2) + 5;
+    if($W->PB) {
+        $W->PB->Move(($W->ScaleWidth-$tW)/2, $tY);
+        $W->PB->Resize($tW, $W->ScaleHeight-$tY-20);
+    }
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/res.txt perl-libwin32-0.191/GUI/samples/res.txt
--- libwin32-0.191/GUI/samples/res.txt	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/res.txt	2004-01-12 16:46:42.500000000 -0800
@@ -0,0 +1,6 @@
+
+Microsoft (R) Program Maintenance Utility   Version 1.50
+Copyright (c) Microsoft Corp 1988-94. All rights reserved.
+
+NMAKE : fatal error U1064: MAKEFILE not found and no target specified
+Stop.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/richedit.pl perl-libwin32-0.191/GUI/samples/richedit.pl
--- libwin32-0.191/GUI/samples/richedit.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/richedit.pl	2004-01-12 16:46:42.515625000 -0800
@@ -0,0 +1,74 @@
+# Win32::GUI::RichEdit test
+
+use Win32::GUI;
+
+$Font = new Win32::GUI::Font(
+    -name => "Courier New", 
+    -height => 16,
+);
+
+$Menu = Win32::GUI::MakeMenu(
+    "&File"    => "File",
+    ">  &Load" => "FileLoad",
+    ">  &Save" => "FileSave",
+);
+
+$Window = new Win32::GUI::Window(
+    -name   => "Window",
+    -text   => "Win32::GUI TEST - RichEdit",
+    -width  => 500,
+    -height => 400, 
+    -left   => 100, 
+    -top    => 100,
+    -font   => $Font,
+    -menu   => $Menu,
+    -addstyle => WS_CLIPCHILDREN,
+);
+
+
+$Textbox = $Window->AddRichEdit(
+    -name    => "Text",
+    -text    => $text,
+    -left    => 5, 
+    -top     => 5,
+    -width   => $Window->ScaleWidth-10, 
+    -height  => $Window->ScaleHeight-10,
+    -style   => WS_CHILD | WS_VISIBLE | WS_VSCROLL 
+              | ES_LEFT | ES_MULTILINE | ES_AUTOVSCROLL,
+    -exstyle => WS_EX_CLIENTEDGE,
+);
+
+$file = ($ARGV[0] or $0);
+open(FILE, $file) or die "No file found $file\n";
+
+while(<FILE>) {
+    chomp;
+    if(/^#/) {
+        $Textbox->SetCharFormat(-color => hex("006400"));
+    } else {
+        $Textbox->SetCharFormat(-color => hex("000000"));
+    }
+    $Textbox->ReplaceSel($_."\r\n");
+}
+close(FILE);
+
+$Window->Show();
+
+Win32::GUI::Dialog();
+
+sub Window_Resize {
+    ($width, $height) = ($Window->GetClientRect)[2..3];
+    $Textbox->Resize($width-10, $height-10);
+}
+
+sub FileSave_Click {
+    $Textbox->Save("richedit.rtf");
+}
+
+sub FileLoad_Click {
+    $Textbox->Load("richedit.rtf");
+}
+
+sub Window_Terminate {
+    return -1;
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/richedit.rtf perl-libwin32-0.191/GUI/samples/richedit.rtf
--- libwin32-0.191/GUI/samples/richedit.rtf	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/richedit.rtf	2004-01-12 16:46:42.531250000 -0800
@@ -0,0 +1,79 @@
+{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fmodern Courier New;}}
+{\colortbl\red0\green0\blue0;\red0\green100\blue0;}
+\deflang1036\pard\plain\f2\fs32\cf1 # Win32::GUI::RichEdit test
+\par \plain\f2\fs32\cf0 
+\par use Win32::GUI;
+\par 
+\par $Font = new Win32::GUI::Font(
+\par     -name => "Courier New", 
+\par     -height => 16,
+\par );
+\par 
+\par $Menu = Win32::GUI::MakeMenu(
+\par     "&File"    => "File",
+\par     ">  &Load" => "FileLoad",
+\par     ">  &Save" => "FileSave",
+\par );
+\par 
+\par $Window = new Win32::GUI::Window(
+\par     -name   => "Window",
+\par     -text   => "Win32::GUI TEST - RichEdit",
+\par     -width  => 500,
+\par     -height => 400, 
+\par     -left   => 100, 
+\par     -top    => 100,
+\par     -font   => $Font,
+\par     -menu   => $Menu,
+\par     -addstyle => WS_CLIPCHILDREN,
+\par );
+\par 
+\par 
+\par $Textbox = $Window->AddRichEdit(
+\par     -name    => "Text",
+\par     -text    => $text,
+\par     -left    => 5, 
+\par     -top     => 5,
+\par     -width   => $Window->ScaleWidth-10, 
+\par     -height  => $Window->ScaleHeight-10,
+\par     -style   => WS_CHILD | WS_VISIBLE | WS_VSCROLL 
+\par               | ES_LEFT | ES_MULTILINE | ES_AUTOVSCROLL,
+\par     -exstyle => WS_EX_CLIENTEDGE,
+\par );
+\par 
+\par $file = ($ARGV[0] or $0);
+\par open(FILE, $file) or die "No file found $file\\n";
+\par 
+\par while(<FILE>) \{
+\par     chomp;
+\par     if(/^#/) \{
+\par         $Textbox->SetCharFormat(-color => hex("006400"));
+\par     \} else \{
+\par         $Textbox->SetCharFormat(-color => hex("000000"));
+\par     \}
+\par     $Textbox->ReplaceSel($_."\\r\\n");
+\par \}
+\par close(FILE);
+\par 
+\par $Window->Show();
+\par 
+\par Win32::GUI::Dialog();
+\par 
+\par sub Window_Resize \{
+\par     ($width, $height) = ($Window->GetClientRect)[2..3];
+\par     $Textbox->Resize($width-10, $height-10);
+\par \}
+\par 
+\par sub FileSave_Click \{
+\par     $Textbox->Save("richedit.rtf");
+\par \}
+\par 
+\par sub FileLoad_Click \{
+\par     $Textbox->Load("richedit.rtf");
+\par \}
+\par 
+\par sub Window_Terminate \{
+\par     return -1;
+\par \}
+\par \plain\f2\fs32 
+\par }
+ 
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/sfn.pl perl-libwin32-0.191/GUI/samples/sfn.pl
--- libwin32-0.191/GUI/samples/sfn.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/sfn.pl	2004-01-12 16:46:42.546875000 -0800
@@ -0,0 +1,25 @@
+
+
+use Win32::GUI;
+
+$file = "\0" . " " x 256;
+
+$ret = GUI::GetSaveFileName(
+    -title  => "Win32::GUI::GetSaveFileName test",
+    -file   => "\0" . " " x 256,
+    -filter => [
+        "Text documents (*.txt)" => "*.txt", 
+        "Perl stuff (*.pl, *.pm)" => "*.pl;*.pm", 
+        "All files", "*.*",
+    ],
+);
+
+if($ret) {
+    print "GetSaveFileName returned: '$ret'\n";
+} else {
+    if(GUI::CommDlgExtendedError()) {
+        print "ERROR. CommDlgExtendedError is: ", GUI::CommDlgExtendedError(), "\n";    
+    } else {
+        print "You cancelled.\n";
+    }
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/slider.pl perl-libwin32-0.191/GUI/samples/slider.pl
--- libwin32-0.191/GUI/samples/slider.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/slider.pl	2004-01-12 16:46:42.562500000 -0800
@@ -0,0 +1,62 @@
+
+use Win32::GUI;
+
+@tics = (
+    "nothing",
+    "almost nothing",
+    "something more than nothing",
+    "very few",
+    "few",
+    "so and so",
+    "much",
+    "very much",
+    "more than much",
+    "almost everything",
+    "everything",
+);
+  
+
+$Window = new GUI::Window(
+    -title    => "Win32::GUI::Slider test",
+    -left     => 100, 
+    -top      => 100, 
+    -width    => 300, 
+    -height   => 100,
+    -name     => "Window",
+);
+
+$Window->AddSlider(
+    -left   => 10,
+    -top    => 10,
+    -height => 150,
+    -width  => 150,
+    -name   => "Slider",
+);
+                                 
+$Window->AddLabel(
+    -name  => "Label",
+    -left  => 10,
+    -top   => 50,
+    -width => 250,
+    -text  => "this is a placeholder",
+);
+
+$Window->Slider->Min(0);
+$Window->Slider->Max(10);
+$Window->Slider->Pos(0);
+
+Slider_Scroll();
+
+$Window->Show;
+
+Win32::GUI::Dialog();
+
+sub Window_Terminate {
+    return -1;
+}
+
+sub Slider_Scroll {
+    $Window->Label->Text(
+        $Window->Slider->Pos ."/". $Window->Slider->Max ." ".
+        $tics[$Window->Slider->Pos]);
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/splitter.pl perl-libwin32-0.191/GUI/samples/splitter.pl
--- libwin32-0.191/GUI/samples/splitter.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/splitter.pl	2004-01-12 16:46:42.578125000 -0800
@@ -0,0 +1,124 @@
+
+use Win32::GUI;
+
+$M = new Win32::GUI::Menu(
+    "&Orientation"   => "Orientation",
+    " > &Horizontal" => "Horizontal",
+    " > &Vertical"   => { -name => "Vertical", -checked => 1 },
+);
+
+$W = new Win32::GUI::Window(
+    -title    => "Win32::GUI::Splitter test",
+    -pos      => [ 100, 100 ],
+    -size     => [ 400, 150 ],
+    -name     => "Window",
+    -menu     => $M,
+);
+
+
+$W->AddSplitter(
+    -name   => "Splitter",
+    -pos    => [ $W->ScaleWidth/2-2, 0 ],
+    -size   => [ 4, $W->ScaleHeight ],
+    -horizontal => 0,
+    -min => 50,
+    -max => 350,
+);
+
+#$W->Splitter->{-max} = 350;
+
+print "Splitter.min = ", $W->Splitter->Min, "\n";
+$W->Splitter->{-min} = 100;
+print "Splitter{min}= ", $W->Splitter->{-min}, "\n";
+
+$W->AddLabel(
+    -name => "LabelLeft",
+    -pos  => [0, 0],
+    -size => [ $W->ScaleWidth/2-2, $W->ScaleHeight ],
+    -text => "LEFT",
+        -background => "#FF5201",
+);
+
+$W->AddLabel(
+    -name => "LabelRite",
+    -pos  => [ $W->ScaleWidth/2+2, 0 ],
+    -size => [ $W->ScaleWidth/2-2, $W->ScaleHeight ],
+    -text => "RIGHT",
+        -background => "#78FFFF",
+);
+
+$W->Show();
+
+Win32::GUI::Dialog();
+
+sub Window_Terminate {
+    return -1;
+}
+
+sub Header_BeginTrack {
+    print "got BeginTrack\n";
+}
+
+sub Header_EndTrack {
+    print "got EndTrack\n";
+}
+
+sub Splitter_Release {
+    print "Splitter released at: $_[0]\n";
+    if($W->Splitter->{-horizontal}) {
+        $W->LabelLeft->Resize($W->LabelLeft->Width, $_[0]);
+        $W->LabelRite->Move(0, $_[0]+4);
+        $W->LabelRite->Resize($W->LabelRite->Width, $W->ScaleHeight-$_[0]-2);
+    } else {
+        $W->LabelLeft->Resize($_[0], $W->LabelLeft->Height);
+        $W->LabelRite->Move($_[0]+4, 0);
+        $W->LabelRite->Resize($W->ScaleWidth-$_[0]-2, $W->LabelRite->Height);
+    }
+    $W->InvalidateRect(1);
+}
+
+
+sub Horizontal_Click {
+    $M->{Horizontal}->Checked(not $M->{Horizontal}->Checked);
+    $M->{Vertical}->Checked(not $M->{Vertical}->Checked);
+
+    Win32::GUI::DestroyWindow($W->Splitter);
+    undef $W->{Splitter};
+
+    $W->AddSplitter(
+        -name   => "Splitter",
+        -left   => 0,
+        -top    => $W->ScaleHeight/2-2,
+        -width  => $W->ScaleWidth,
+        -height => 4,
+        -horizontal => 1,
+    );
+    $W->LabelLeft->Text( "UP" );
+    $W->LabelRite->Text( "DOWN" );
+    $W->LabelLeft->Width( $W->ScaleWidth );
+    $W->LabelRite->Width( $W->ScaleWidth );
+    Splitter_Release($W->ScaleHeight/2-2);
+}
+
+sub Vertical_Click {
+    $M->{Horizontal}->Checked(not $M->{Horizontal}->Checked);
+    $M->{Vertical}->Checked(not $M->{Vertical}->Checked);
+
+    Win32::GUI::DestroyWindow($W->Splitter);
+    undef $W->{Splitter};
+
+    $W->AddSplitter(
+        -name   => "Splitter",
+        -text   => "Helluva!",
+        -left   => $W->ScaleWidth/2-2,
+        -top    => 0,
+        -width  => 4,
+        -height => $W->ScaleHeight,
+        -horizontal => 0,
+    );
+    $W->LabelLeft->Text( "LEFT" );
+    $W->LabelRite->Text( "RIGHT" );
+    $W->LabelLeft->Height( $W->ScaleHeight );
+    $W->LabelRite->Height( $W->ScaleHeight );
+    Splitter_Release($W->ScaleWidth/2-2);
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/tabstrip.pl perl-libwin32-0.191/GUI/samples/tabstrip.pl
--- libwin32-0.191/GUI/samples/tabstrip.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/tabstrip.pl	2004-01-12 16:46:42.593750000 -0800
@@ -0,0 +1,62 @@
+#!perl -w
+use Win32::GUI;
+use strict;
+
+my $W = new GUI::Window(
+    -title    => "Win32::GUI::TabStrip test",
+    -left     => 100, 
+    -top      => 100, 
+    -width    => 300, 
+    -height   => 200,
+    -name     => "Window",
+);
+
+my $IL = new GUI::ImageList(16, 16, 8, 3, 10);
+my $IMG_ONE   = $IL->Add("one.bmp");
+my $IMG_TWO   = $IL->Add("two.bmp");
+my $IMG_THREE = $IL->Add("three.bmp");
+
+$W->AddTabStrip(
+    -name   => "Tab",
+    -left   => 0,   
+    -top    => 0, 
+    -width  => $W->ScaleWidth, 
+    -height => $W->ScaleHeight,
+    -imagelist => $IL,
+);
+
+$W->Tab->InsertItem(
+    -text => "First", 
+    -image => $IMG_ONE,
+);
+$W->Tab->InsertItem(
+    -text => "Second", 
+    -image => $IMG_TWO,
+);
+$W->Tab->InsertItem(
+    -text => "Third",
+    -image => $IMG_THREE,
+);
+
+$W->AddLabel(
+    -name  => "Selection",
+    -text  => "Click a tab...",
+    -left  => 5,
+    -top   => 50,
+);
+
+$W->Show;
+
+$W->Dialog();
+
+# while ($W->DoEvents() != -1) {}
+
+sub Window_Resize {
+    $W->Tab->Resize($W->ScaleWidth, $W->ScaleHeight);
+}
+
+sub Tab_Click {
+    my @tabs = ("First page", "Second page", "Third page");
+    $W->Selection->Text($tabs[$W->Tab->SelectedItem()]);
+}
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/test.msk perl-libwin32-0.191/GUI/samples/test.msk
--- libwin32-0.191/GUI/samples/test.msk	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/test.msk	2004-01-12 16:46:42.609375000 -0800
@@ -0,0 +1,11 @@
+[BEGIN]
+
+ Name:      ____________________ 
+ Password:  ____________________ 
+ Domain:    ____________________ 
+
+      {   OK   } { Cancel }
+
+[END]
+Fields = Name, Password, Domain
+Buttons = OK, Cancel
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/test2.msk perl-libwin32-0.191/GUI/samples/test2.msk
--- libwin32-0.191/GUI/samples/test2.msk	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/test2.msk	2004-01-12 16:46:42.625000000 -0800
@@ -0,0 +1,13 @@
+[BEGIN]
+ Name:           ____________________ 
+ Type:           ____________________ 
+ Software house: ____________________ 
+ Year:           ____
+ { } Command:    ____________________ 
+ Vote:           __
+
+      {   OK   } { Cancel }
+
+[END]
+Fields = Name, Type, Softhouse, Year, Command, Vote
+Buttons = OK, Cancel
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/textfield.pl perl-libwin32-0.191/GUI/samples/textfield.pl
--- libwin32-0.191/GUI/samples/textfield.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/textfield.pl	2004-01-12 16:46:42.640625000 -0800
@@ -0,0 +1,181 @@
+use blib;
+use Win32::GUI;
+
+my $Window = new Win32::GUI::Window(
+    -title  => "Win32::GUI::Textfield test",
+    -left   => 100,
+    -top    => 100,
+    -width  => 300,
+    -height => 500,
+    -name   => "Window",
+#	-style  => WS_MINIMIZEBOX | WS_CAPTION | WS_SYSMENU,
+);
+
+$Window->Show();
+
+# $B = new Win32::GUI::Brush(-system => 12);
+
+$Textfield = $Window->AddTextfield(
+    -name     => "Textfield",
+    -left     => 10,
+    -top      => 10,
+    -text     => "sample text",
+    -width    => 180,
+    -height   => 22,
+    -foreground => "#000000",
+    -background => "#E3E2CC",
+);
+
+
+
+# print $Window->Textfield->SendMessage(213, 0, 0);
+
+print "Textfield=", $Textfield, "\n";
+print "Textfield.handle=$Textfield->{'-handle'}\n";
+print "Textfield.keys = ", join(" ", keys(%{$Textfield})), "\n";
+
+printf "Textfield.foreground = %06x\n", $Textfield->{-foreground};
+
+
+$Window->AddCheckbox(
+    -name   => "Password",
+    -text   => "Password",
+    -left   => 10,
+    -top    => 40,
+);
+
+# $Window->{Password}->{-background} = $B->{-handle};
+
+my $Readonly = $Window->AddCheckbox(
+    -name   => "Readonly",
+    -text   => "Read only",
+    -left   => 10,
+    -top    => 70,
+);
+
+$Window->AddButton(
+    -name   => "Reset",
+    -text   => "Reset",
+    -pos    => [  10, 100 ],
+);
+
+$Window->AddButton(
+    -name   => "ScrollUp",
+    -text   => "UP",
+    -pos    => [  80, 100 ],
+);
+
+$Window->AddButton(
+    -name   => "ScrollDown",
+    -text   => "DOWN",
+    -pos    => [  120, 100 ],
+);
+
+$Window->AddButton(
+    -name   => "ScrollBottom",
+    -text   => "BOTTOM",
+    -pos    => [  160, 100 ],
+);
+
+$Window->AddButton(
+    -name   => "ScrollTop",
+    -text   => "TOP",
+    -pos    => [  200, 100 ],
+);
+
+$Multitext = $Window->AddTextfield(
+    -name     => "Multitext",
+    -multiline => 1,
+    -autohscroll => 1,
+    -autovscroll => 1,
+	-vscroll   => 1,
+	-hscroll   => 1,
+    -pos       => [  10, 140 ],
+    -size      => [ 180, 180 ],
+);
+
+
+$Multitext->Text("sample text sample text sample text sample text sample text sample text sample text sample text sample text sample text sample text sample text sample text sample text sample text ");
+
+printf "Multitext.style = %x\n", $Multitext->GetWindowLong(-16);
+
+Win32::GUI::Dialog();
+
+sub Window_Terminate {
+    return -1;
+}
+
+sub Password_Click {
+    printf "Style before: %8X\n", $Window->Textfield->GetWindowLong(-16);
+    print "PasswordChar: ", $Window->Textfield->PasswordChar, "\n";
+    if($Window->Textfield->PasswordChar != 0) {
+        print "turning Password on...\n";
+        $Window->Textfield->Change(-password => 1);
+        $Window->Textfield->PasswordChar('*');
+    } else {
+        print "turning Password off...\n";
+        $Window->Textfield->Change(-password => 0);
+        $Window->Textfield->PasswordChar(0);
+
+    }
+    printf "Style after: %8X\n", $Window->Textfield->GetWindowLong(-16);     
+}
+
+sub Readonly_Click {
+    printf "Style before: %8X\n", $Window->Textfield->GetWindowLong(-16);
+    if($Window->Readonly->Checked()) {
+        print "turning Readonly on...\n";
+        $Window->Textfield->Change(-readonly => 1);
+    } else {
+        print "turning Readonly off...\n";
+        $Window->Textfield->Change(-readonly => 0);
+
+    }
+
+    $Window->Textfield->Change( -background => [255,0,0] );
+
+    $style = $Window->Textfield->GetWindowLong(-16);
+    $style ^= hex('0800');
+    $Window->Textfield->SetWindowLong(-16, $style);
+    printf "Style after: %8X\n", $Window->Textfield->GetWindowLong(-16);
+    $Window->Textfield->InvalidateRect(1);
+    $Window->Textfield->Update();
+
+    my($from, $to) = $Window->Textfield->Selection();
+    print "Selection: ", substr($Window->Textfield->Text, $from, $to-$from), "\n";
+
+}
+
+sub Reset_Click {
+    my $DC = new Win32::GUI::DC($Window->Textfield);
+    $rc = $Window->SendMessage(307, $DC, $Window->Textfield->{-handle});
+    # $rc = Win32::GUI::SendMessage($Window->{-handle}, hex('133'), 0, 0);
+    print "SendMessage.rc = $rc\n";
+#    $Window->Textfield->Text("");
+	my $C = new Win32::GUI::Cursor("harrow.cur");
+	$Window->ChangeCursor($C);
+	$Window->Reset->ChangeCursor($C);
+}
+
+sub Multitext_Change {
+	print "got Change!\n";
+	# $Window->Multitext->InvalidateRect(1);
+}
+
+sub Textfield_Change {
+	print "got Change!\n";
+	# $Window->Multitext->InvalidateRect(1);
+}
+
+sub ScrollUp_Click {
+	$Window->Multitext->Scroll("up");
+}
+sub ScrollDown_Click {
+	$Window->Multitext->Scroll("down");
+}
+sub ScrollBottom_Click {
+	$Window->Multitext->Scroll("bottom");
+}
+sub ScrollTop_Click {
+	$Window->Multitext->Scroll("top");
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/three.bmp perl-libwin32-0.191/GUI/samples/three.bmp
--- libwin32-0.191/GUI/samples/three.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/three.bmp	2004-01-12 16:46:42.656250000 -0800
@@ -0,0 +1 @@
+BM6      6   (                                  @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ 
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/timer.pl perl-libwin32-0.191/GUI/samples/timer.pl
--- libwin32-0.191/GUI/samples/timer.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/timer.pl	2004-01-12 16:46:42.671875000 -0800
@@ -0,0 +1,102 @@
+#!perl -w
+use strict;
+use Win32::GUI;
+
+my $Window = new Win32::GUI::Window(
+    -name   => "Window",
+    -left   => 100,
+    -top    => 100,
+    -width  => 250,
+    -height => 150,
+    -title  => "Win32::GUI::Timer test",
+);
+
+$Window->AddLabel(
+    -name   => "CurrentTime",
+    -text   => scalar(localtime),
+    -left   => 10,
+    -top    => 10,
+    -notify => 1,
+    -align  => 'left',
+);
+
+my $BigFont = new Win32::GUI::Font(
+    -name   => "Arial",
+    -height => 25,
+    -weight => 900,
+);
+
+$Window->AddLabel(
+    -name   => "Dot",
+    -text   => "-",
+    -left   => 0,
+    -top    => 50,
+    -font   => $BigFont,
+);
+
+$Window->AddButton(
+    -name   => "ToggleDot",
+    -text   => "HI",
+    -left   => 10,
+    -top    => 75,
+);
+$Window->AddButton(
+    -name   => "KillDot",
+    -text   => "Stop",
+    -left   => 80,
+    -top    => 75,
+);
+
+my $Timer1 = $Window->AddTimer("Timer1", 1000);
+my $Timer2 = $Window->AddTimer("Timer2", 10);
+
+my $incr = 5;
+my $x = 0;
+$Window->Show();
+Win32::GUI::Dialog();
+
+sub Window_Terminate {
+    return -1;
+}
+
+sub Timer1_Timer {
+    $Window->CurrentTime->Text(scalar(localtime));
+}
+
+sub Timer2_Timer {
+    $x += $incr;
+    if($x > $Window->ScaleWidth) { $x = 0; }
+    $Window->Dot->Move($x, 50);
+}
+
+sub ToggleDot_Click {
+    if($Timer2->Interval == 10) {
+    $Timer2->Interval(100);
+    $incr = 1;
+    $Window->ToggleDot->Text("LO");
+    } else {
+    $Timer2->Interval(10);
+    $incr = 5;
+    $Window->ToggleDot->Text("HI");
+    }
+}
+
+sub KillDot_Click {
+    if($Window->KillDot->Text eq "Stop") {
+    $Timer2->Kill();
+    $Window->ToggleDot->Disable();
+    $Window->KillDot->Text("Go");
+    } else {
+    if($incr == 5) {
+        $Timer2->Interval(10);
+    } else {
+        $Timer2->Interval(100);
+    }
+    $Window->ToggleDot->Enable();
+    $Window->KillDot->Text("Stop");
+    }
+}
+
+sub CurrentTime_Click {
+    print "got!\n";
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/toolbar.pl perl-libwin32-0.191/GUI/samples/toolbar.pl
--- libwin32-0.191/GUI/samples/toolbar.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/toolbar.pl	2004-01-12 16:46:42.687500000 -0800
@@ -0,0 +1,76 @@
+
+use Win32::GUI;
+
+$W = new Win32::GUI::Window(
+    -title    => "Win32::GUI::Toolbar test",
+    -left     => 100, 
+    -top      => 100, 
+    -width    => 300, 
+    -height   => 200,
+    -style    => WS_OVERLAPPEDWINDOW,
+    -name     => "Window",
+	-events   => {
+		Terminate => sub { -1 },
+		Resize => sub {
+			my($self) = @_;
+			$self->Toolbar->Resize($self->ScaleWidth-10, 100);
+		},
+	},
+	
+) or print_and_die("new Window");
+
+$TB = $W->AddToolbar(
+    -left   =>  0,   
+    -top    => 0, 
+    -width  => $W->ScaleWidth-10, 
+    -height => 100,
+    -name   => "Toolbar",
+	-events => {
+		ButtonClick => sub {
+			my($self, $button) = @_;
+		    print "Toolbar: clicked button $button\n";
+		},
+	},
+
+);
+
+$B = new Win32::GUI::Bitmap("tools.bmp");
+
+$TB->SetBitmapSize(16, 16);
+
+$TB->AddBitmap($B, 3);
+
+$TB->AddString("ONE");
+$TB->AddString("TWO");
+$TB->AddString("THREE");
+
+$TB->AddButtons(
+    3,
+    0, 1, 4, 0, 0,
+    1, 2, 4, 0, 1,
+    2, 3, 4, 0, 2,
+);
+
+$W->Show;
+
+Win32::GUI::Dialog();
+
+sub print_and_die {
+    my($text) = @_;
+    my $err = Win32::GetLastError();
+    die "$text: Error $err\n";
+}
+
+sub Window_Terminate {
+    return -1;
+}
+
+sub Window_Resize {
+    $TB->Resize($W->ScaleWidth-10, 100);
+}
+
+#sub Toolbar_ButtonClick {
+#    my($button) = @_;
+#    print "Toolbar: clicked button $button\n";
+#}
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/tools.bmp perl-libwin32-0.191/GUI/samples/tools.bmp
--- libwin32-0.191/GUI/samples/tools.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/tools.bmp	2004-01-12 16:46:42.703125000 -0800
@@ -0,0 +1,6 @@
+BM6      6  (   0                                                           B JJJ ZZZ ccc {{{                                                                                                                                                                                                                                                          !!!!!!!!!!!!!!!     !!!!!!!!!!!     !!!!!!!!!     !!!!!!!!!!!              !!!!!!!!           !!!!!!         !!!
+!
+!!!         !!!!!!!         !!!!!!
+!!!         !!!!
+
+!!!           !!!!!!!!!              !!!!!!!!!!          !!!!!!!!!!!            !!!!!!!!!!!              !!!!!!!!!!!!!!!                !!!!!!!!!!!!!!!                
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/treeview.pl perl-libwin32-0.191/GUI/samples/treeview.pl
--- libwin32-0.191/GUI/samples/treeview.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/treeview.pl	2004-01-12 16:46:42.718750000 -0800
@@ -0,0 +1,234 @@
+
+use Win32::GUI;
+
+$Menu = Win32::GUI::MakeMenu(
+    "&Options"   => "Options",
+    " > Set &indent..."  => "Indent",
+    " > Choose &font..."  => "Font",
+    " > &Lines"  => { -name => "HasLines", -checked => 1 },
+    " > &Root lines"  => { -name => "HasRootLines", -checked => 1 },
+    " > &Buttons"  => { -name => "HasButtons", -checked => 1 },
+    " > I&mage"  => { -name => "HasImages", -checked => 1 },
+    " > -"       => 0,
+    " > E&xit"   => "Exit",
+);
+
+$Window = new GUI::Window(
+    -name   => "Window",
+    -text   => "Win32::GUI TEST - TreeView",
+    -height => 200, 
+    -width  => 300,
+    -left   => 100, 
+    -top    => 100,
+    -menu   => $Menu,
+);
+
+$C = new Win32::GUI::Cursor("harrow.cur");
+
+Win32::GUI::SetCursor($C);
+
+$B1 = new Win32::GUI::Bitmap("node.bmp");
+$B2 = new Win32::GUI::Bitmap("node_sel.bmp");
+
+$IL = new Win32::GUI::ImageList(16, 16, 0, 2, 10);
+$IL->Add($B1, 0);
+$IL->Add($B2, 0);
+
+$TV = $Window->AddTreeView(
+    -name      => "Tree",
+    -text      => "hello world!",
+    -width     => $Window->ScaleWidth, 
+    -height    => $Window->ScaleHeight,
+    -left      => 0, 
+    -top       => 0,
+    -lines     => 1, 
+    -rootlines => 1,
+    -buttons   => 1,
+    -visible   => 1,
+    -imagelist => $IL,
+#    -checkboxes => 1,
+#    -hottrack  => 1,
+);
+
+$IndentWin = new GUI::Window(
+    -text   => "Treeview Indent",
+    -name   => "IndentWin",
+    -width  => 200,
+    -height => 100, 
+    -left   => 110, 
+    -top    => 110,
+);
+
+$IndentVal = $IndentWin->AddLabel(
+    -text => "Indent value = ".$TV->Indent(),
+    -name => "IndentVal",
+    -left => 10, 
+    -top  => 10,
+);
+
+$IndentNew = $IndentWin->AddTextfield(
+    -text   =>  $TV->Indent(),
+    -name   =>  "IndentNew",
+    -left   =>  10, 
+    -top    => 40,
+    -width  => 100, 
+    -height => 25,
+);
+
+$IndentSet = $IndentWin->AddButton(
+    -text => "Set", 
+    -name => "IndentSet",
+    -left => 130, 
+    -top  => 40
+);
+                            
+$TV1 = $TV->InsertItem(
+    -text          => "ROOT", 
+    -image         => 0, 
+    -selectedimage => 1,
+);
+
+$TV3 = $TV->InsertItem(
+    -parent        => $TV1, 
+    -text          => "SUB 1", 
+    -image         => 0, 
+    -selectedimage => 1
+	-selected      => 1,
+);
+
+$TV2 = $TV->InsertItem(
+    -parent        => $TV1, 
+    -text          => "SUB 2", 
+    -image         => 0, 
+    -selectedimage => 1
+	-bold          => 1,
+);
+
+$Window->Show();
+
+my $dblclick = 0;
+
+Win32::GUI::Dialog();
+
+sub Window_Terminate {
+    $Window->PostQuitMessage(0);
+}
+
+sub Window_Resize {
+    $TV->Resize($Window->ScaleWidth, $Window->ScaleHeight);
+}
+
+sub Tree_NodeClick {
+    my %node = $TV->GetItem($_[0]);
+    print "Click on node '$node{-text}' ".
+          "(checkbox is ", ($TV->ItemCheck($_[0]) ? "on" : "off"), ")\n";
+    return 1;
+}
+
+sub Tree_Expand {
+    my %node = $TV->GetItem($_[0]);
+    print "Expanded node '$node{-text}'\n";
+    $dblclick = 1;
+    return 1;
+}
+
+sub Tree_Collapse {
+    my %node = $TV->GetItem($_[0]);
+    print "Collapsed node '$node{-text}'\n";
+    $dblclick = 1;
+    return 1;
+}
+
+sub Tree_DblClick {
+    if(!$dblclick) {
+        my($x, $y) = Win32::GUI::GetCursorPos();
+        print "Double click at $x, $y\n";
+        my $node = $TV->SelectedItem();
+        if($node) {
+            $TV->ItemCheck($node, !$TV->ItemCheck($node));
+            my %t = $TV->getItem($node);
+            foreach my $k (keys %t) {
+                print "$k => $t{$k}\n";
+            }
+
+        }
+    } else {
+        "got Collapse/Expand, ignoring DblClick\n";
+        $dblclick = 0;
+    }
+    return 1;
+}
+
+sub Indent_Click {
+    $Window->Disable();    
+    $IndentVal->Text("Indent value = ".$TV->Indent());
+    $IndentNew->Text($TV->Indent());
+    $IndentWin->Show();
+    $IndentNew->SetFocus();
+    $IndentNew->Select(0, length($IndentNew->Text()));
+    return 1;
+}
+
+sub IndentSet_Click {
+    $TV->Indent($IndentNew->Text());
+    $IndentWin->Hide();
+    $Window->Enable();
+    $Window->SetForegroundWindow();
+}
+
+sub IndentWin_Terminate {
+    $IndentWin->Hide();
+    $Window->Enable();
+    $Window->SetForegroundWindow();
+}
+
+sub Font_Click {
+    $Window->Disable();
+    my @font = GUI::ChooseFont();
+    if($font[0] eq "-name") {
+        undef $TreeviewFont;
+        $TreeviewFont = new GUI::Font(@font);
+        $TV->SetFont($TreeviewFont);
+        # $TV->Change(-font => $TreeviewFont);
+    }
+    $Window->Enable();
+    $Window->SetForegroundWindow();
+}
+
+sub Exit_Click {
+    $Window->PostQuitMessage(0);
+}
+
+sub HasLines_Click {
+    my $checked = !$Menu->{HasLines}->Checked;
+    printf "TV.Style is: %08X\n", $TV->GetWindowLong(-16);
+    $TV->Change(-lines => $checked);
+    printf "TV.Style after -lines => %d is: %08X\n", $checked, $TV->GetWindowLong(-16);
+    $Menu->{HasLines}->Checked($checked);
+}
+
+sub HasRootLines_Click {
+    my $checked = !$Menu->{HasRootLines}->Checked;
+    printf "TV.Style is: %08X\n", $TV->GetWindowLong(-16);
+    $TV->Change(-rootlines => $checked);
+    printf "TV.Style after -rootlines => %d is: %08X\n", $checked, $TV->GetWindowLong(-16);
+    $Menu->{HasRootLines}->Checked($checked);
+}
+
+sub HasButtons_Click {
+    my $checked = !$Menu->{HasButtons}->Checked;
+    printf "TV.Style is: %08X\n", $TV->GetWindowLong(-16);
+    $TV->Change(-buttons => $checked);
+    printf "TV.Style after -buttons => %d is: %08X\n", $checked, $TV->GetWindowLong(-16);
+    $Menu->{HasButtons}->Checked($checked);
+}
+
+sub HasImages_Click {
+    if($Menu->{HasImages}->Checked) {
+        $Menu->{HasImages}->Checked(0);
+        $TV->SetImageList(0);
+    } else {
+        $Menu->{HasImages}->Checked(1);
+        $TV->SetImageList($IL);
+    }
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/tt.pl perl-libwin32-0.191/GUI/samples/tt.pl
--- libwin32-0.191/GUI/samples/tt.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/tt.pl	2004-01-12 16:46:42.734375000 -0800
@@ -0,0 +1,48 @@
+use Win32::GUI;
+
+my $acc = new Win32::GUI::AcceleratorTable(
+	"A" => "Window", 
+	"B" => "Simple1", 
+);
+
+$W = new Win32::GUI::Window(
+    -title  => "test",
+    -left   => 100, 
+    -top    => 100, 
+    -width  => 280,
+    -vscroll => 1,               #!!!!!!
+    -height => 280,
+    -name   => "Window",
+    -accel  => $acc,
+);
+
+$W->AddButton(
+    -name    => "Simple1",
+    -left    => 5,
+    -top     => 5,
+    -width  => 122,
+    -height => 400,
+    -text    => "Just button",
+);
+
+$W->Show;
+
+# Win32::GUI::Dialog();
+while (Win32::GUI::DoEvents() != -1) {
+}
+
+sub Window_Terminate {
+  return -1;
+}
+
+sub Click {
+  print "Click\n";
+}
+
+sub Window_Click {
+  print "Window_Click\n";
+}
+
+sub Simple1_Click {
+  print "Simple1_Click\n";
+}
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/two.bmp perl-libwin32-0.191/GUI/samples/two.bmp
--- libwin32-0.191/GUI/samples/two.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/two.bmp	2004-01-12 16:46:42.750000000 -0800
@@ -0,0 +1 @@
+BM6      6   (                                                                                                 @ @ @ @ @ @ @ @ @       @ @ @ @ @ @ @ @ @       @ @ @ @ @       @ @ @       @ @ @       @ @ @       @ @ @ @ @       @ @ @ @ @       @ @ @ @ @ @       @ @ @ @ @ @ @       @ @ @ @ @                                                          
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/unkfolder.bmp perl-libwin32-0.191/GUI/samples/unkfolder.bmp
--- libwin32-0.191/GUI/samples/unkfolder.bmp	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/unkfolder.bmp	2004-01-12 16:46:42.765625000 -0800
@@ -0,0 +1 @@
+BM       v   (                                      c              wwwwwwwwwwwwwwwwp      """"""EE EDBUT TTBUUUEEBUU TTRUU UEBUUPTRU U UBf f fR"  wq6eQwwwwwwwwwwwwwwww
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/vmeta.pl perl-libwin32-0.191/GUI/samples/vmeta.pl
--- libwin32-0.191/GUI/samples/vmeta.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/vmeta.pl	2004-01-12 16:46:42.781250000 -0800
@@ -0,0 +1,48 @@
+
+use Win32::GUI;
+
+$W = new GUI::Window(
+    -left => 100,
+    -top => 100,
+    -width => 400,
+    -height => 400,
+    -title => "EMF Viewer",
+    -name => "Window",
+);
+
+$W->Show();
+
+$W->BeginPaint();
+
+# $result = $W->PlayEnhMetaFile("p:\\perl5\\win32gui-alpha\\testing\\hilogo.WMF");
+# $result = $W->PlayEnhMetaFile("p:\\perl5\\win32gui-alpha\\testing\\hilogo.WMF\0");
+# $result = $W->PlayEnhMetaFile("hilogo.WMF");
+
+# $result = $W->PlayWinMetaFile(".\\GLOBO.WMF");
+
+$result = $W->PlayEnhMetaFile("prova.emf");
+print "PlayMetaFile returned $result (LastError = ", Win32::GetLastError(),")\n";
+
+$W->EndPaint();
+
+Win32::GUI::Dialog();
+
+sub Window_Terminate {
+    return -1;
+}
+
+sub Window_Resize {
+    $W->InvalidateRect(1);
+    Paint();
+}   
+
+sub Window_Activate {
+    $W->InvalidateRect(1);
+    Paint();
+}
+
+sub Paint {
+	my $DC = $W->GetDC();
+    $result = $W->PlayEnhMetaFile("prova.emf");
+    print "PlayMetaFile returned $result (LastError = ", Win32::GetLastError(),")\n";
+}
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/winlist.pl perl-libwin32-0.191/GUI/samples/winlist.pl
--- libwin32-0.191/GUI/samples/winlist.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/winlist.pl	2004-01-12 16:46:42.796875000 -0800
@@ -0,0 +1,36 @@
+
+use Win32::GUI;
+
+foreach $ARG (@ARGV) {
+    $all=1 if $ARG=~m|[-/]a|i;
+    $min=1 if $ARG=~m|[-/]m|i;
+
+    if($ARG =~ m|[-/]h|i) {
+        $desktop = GUI::GetDesktopWindow();
+        $window = GUI::GetWindow($desktop, GW_CHILD);
+        while($window) {
+            $title = GUI::Text($window);
+            if(!GUI::IsVisible($window)) {
+                printf("%16d: %s\n", $window, $title);
+                GUI::Show($window) if $title =~ /emula/i;
+            }
+            $window = GUI::GetWindow($window, GW_HWNDNEXT);
+        }  
+        exit(0);
+    }
+
+}
+
+$desktop = GUI::GetDesktopWindow();
+print "Desktop Window: $desktop\n" if $all;
+
+$window = GUI::GetWindow($desktop, GW_CHILD);
+while($window) {
+    $title = GUI::Text($window);
+    if($all or ($title)) { # and GUI::IsVisible($window))) {
+        printf("%16d: %s\n", $window, $title);
+        GUI::Show($window, 6) if $min and $title ne "Program Manager";
+    }
+    $window = GUI::GetWindow($window, GW_HWNDNEXT);
+    # print $window;
+}  
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/winppm.ini perl-libwin32-0.191/GUI/samples/winppm.ini
--- libwin32-0.191/GUI/samples/winppm.ini	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/winppm.ini	2004-01-12 16:46:42.796875000 -0800
@@ -0,0 +1,2 @@
+1
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/winppm.pl perl-libwin32-0.191/GUI/samples/winppm.pl
--- libwin32-0.191/GUI/samples/winppm.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/winppm.pl	2004-01-12 16:46:42.828125000 -0800
@@ -0,0 +1,1371 @@
+use blib;
+use strict;
+use Win32::GUI;
+use Win32::GUI::BitmapInline;
+use PPM;
+use XML::Parser;
+use XML::PPMConfig;
+
+my $B_PPMREPO;
+my $B_PPMREPC;
+my $B_PPMREPN;
+my $B_PPMREPF;
+my $B_PPMREPI;
+my $B_PPMREPL;
+my $B_PPMREPA;
+my $B_PPMREPR;
+DefineBitmaps();
+
+my $VERSION = "0.72";
+
+my %WinPPM;
+InitSettings();
+
+my $TT = "";
+
+my $M = new Win32::GUI::Menu(
+    "&File"							=> "File",
+        " > &Properties"			=> { -name => "Properties", -default => 1 },
+		" > &Install"				=> "Install",
+        " > &Verify"				=> "Verify",
+        " > &Remove"				=> "Remove",
+		" > -"						=> 0,
+		" > &Search"				=> "Search",
+		" > -"						=> 0,
+        " > E&xit"					=> "Exit",
+
+    "&View"							=> "View",
+        " > &Repositories"			=> "ViewRepos",
+        " > Insta&lled packages"	=> "ViewInstd",
+		" > -"						=> 0,
+		" > PPM &Info..."			=> "PPMInfo",
+
+    "&Settings"						=> "Settings",
+        " > PPM &Configuration..."	=> "PPMConfig",
+		" > -"						=> 0,
+        " > &Autosave config"		=> { -name => "Autosave", -checked => $WinPPM{SAVE} },
+
+    "&Help"							=> "Help",
+        " > &About WinPPM..."		=> "About",
+);
+
+my $POP = new Win32::GUI::Menu(
+
+    ""						=> "POP_onRepository",
+    " > &Open"				=> { -name => "POP_RepOpen", -default => 1 },
+    " > &Properties"		=> "POP_RepProp",
+
+    ""						=> "POP_onInstd",
+    " > &Properties"		=> { -name => "POP_InstdProp", -default => 1 },
+    " > &Verify"			=> "POP_InstdVerify",
+    " > &Remove"			=> "POP_InstdRemove",
+
+    ""						=> "POP_onRepoPack",
+    " > &Properties"		=> { -name => "POP_Prop", -default => 1 },
+    " > &Install"			=> "POP_Install",
+	" > &Verify"			=> "POP_Verify",
+
+    ""							=> "POP_onSearchResults",
+    " > &Clear Search results"	=> { -name => "POP_ClearSearch", -default => 1 },
+
+);
+
+my $IL = new Win32::GUI::ImageList(16, 16, 24, 10, 10);
+my $IL_PPMREPO = $IL->Add($B_PPMREPO);
+my $IL_PPMREPC = $IL->Add($B_PPMREPC);
+my $IL_PPMREPN = $IL->Add($B_PPMREPN);
+my $IL_PPMREPF = $IL->Add($B_PPMREPF);
+my $IL_PPMREPI = $IL->Add($B_PPMREPI);
+my $IL_PPMREPL = $IL->Add($B_PPMREPL);
+my $IL_PPMREPA = $IL->Add($B_PPMREPA);
+my $IL_PPMREPR = $IL->Add($B_PPMREPR);
+
+my $W = new Win32::GUI::Window(
+    -name   => "W",
+    -text   => "WinPPM $VERSION",
+    -left   => 100,
+    -top    => 100,
+    -width  => 400,
+    -height => 300,
+    -menu   => $M,
+);
+
+my $PW = new Win32::GUI::DialogBox(
+    -name   => "PW",
+    -text   => "Package Properties",
+    -left   => 110,
+    -top    => 110,
+    -width  => 300,
+    -height => 400,
+);
+
+$PW->AddTextfield(
+    -name     => "PPMName",
+    -readonly => 1,
+    -left     => 10,
+    -top      => 10,
+    -width    => 200,
+    -height   => 22,
+    -text     => "I'm a placeholder",
+    -prompt   => [ "PPM Name:", 75 ],
+);
+$PW->AddTextfield(
+    -name     => "PPMVersion",
+    -readonly => 1,
+    -left     => 10,
+    -top      => 40,
+    -width    => 200,
+    -height   => 22,
+    -text     => "I'm a placeholder",
+    -prompt   => [ "PPM Version:", 75 ],
+);
+$PW->AddTextfield(
+    -name     => "PPMAuthor",
+    -readonly => 1,
+    -left     => 10,
+    -top      => 70,
+    -width    => 200,
+    -height   => 22,
+    -text     => "I'm a placeholder",
+    -prompt   => [ "Author:", 75 ],
+);
+$PW->AddTextfield(
+    -name     => "PPMDate",
+    -readonly => 1,
+    -left     => 10,
+    -top      => 100,
+    -width    => 200,
+    -height   => 22,
+    -text     => "I'm a placeholder",
+    -prompt   => [ "Installed:", 75 ],
+);
+$PW->AddTextfield(
+    -name      => "PPMAbstract",
+#    -readonly  => 1,
+    -multiline => 1,
+    -left      => 10,
+    -top       => 130,
+    -width     => 200,
+    -height    => 80,
+    -text      => "I'm a placeholder",
+    -prompt    => [ "Abstract:", 75 ],
+);
+$PW->AddButton(
+    -name     => "Close",
+    -left     => 235,
+    -top      => 345,
+	-text     => "&Close",
+    -default  => 1,
+	-cancel   => 1,
+    -tabstop  => 1,
+);
+$PW->AddButton(
+    -name     => "Operate",
+    -left     => 185,
+    -top      => 345,
+	-text     => "&Install",
+    -ok       => 1,
+	-cancel   => 1,
+    -tabstop  => 1,
+);
+
+my $RW = new Win32::GUI::DialogBox(
+    -name   => "RW",
+    -text   => "Repository Properties",
+    -left   => 110,
+    -top    => 110,
+    -width  => 300,
+    -height => 130,
+);
+$RW->AddTextfield(
+    -name      => "Name",
+    -left      => 10,
+    -top       => 10,
+    -width     => 200,
+    -height    => 22,
+    -text      => "I'm a placeholder",
+    -prompt    => [ "Name:", 75 ],
+    -tabstop   => 1,
+);
+$RW->AddTextfield(
+    -name      => "Location",
+    -left      => 10,
+    -top       => 40,
+    -width     => 200,
+    -height    => 22,
+    -text      => "I'm a placeholder",
+    -prompt    => [ "Location:", 75 ],
+    -tabstop   => 1,
+);
+$RW->AddButton(
+    -name     => "RepOK",
+    -left     => 150,
+    -top      => 75,
+    -width    => 60,
+    -text     => "&OK",
+    -ok       => 1,
+    -default  => 1,
+    -tabstop  => 1,
+);
+$RW->AddButton(
+    -name     => "RepClose",
+    -left     => 220,
+    -top      => 75,
+    -width    => 60,
+    -text     => "&Cancel",
+    -cancel   => 1,
+	-tabstop  => 1,
+);
+$RW->AddLabel(
+    -name    => "Editing",
+    -visible => 0,
+);
+
+my $CW = new Win32::GUI::DialogBox(
+    -name   => "CW",
+    -text   => "PPM Configuration",
+    -left   => 110,
+    -top    => 110,
+    -width  => 300,
+    -height => 220,
+);
+$CW->AddTextfield(
+    -name      => "Root",
+    -left      => 10,
+    -top       => 10,
+    -width     => 200,
+    -height    => 22,
+    -text      => "I'm a placeholder",
+    -prompt    => [ "Install root:", 75 ],
+    -tabstop   => 1,
+);
+$CW->AddTextfield(
+    -name      => "Build",
+    -left      => 10,
+    -top       => 40,
+    -width     => 200,
+    -height    => 22,
+    -text      => "I'm a placeholder",
+    -prompt    => [ "Build dir:", 75 ],
+    -tabstop   => 1,
+);
+$CW->AddCheckbox(
+    -name      => "Case",
+    -left      => 10,
+    -top       => 70,
+    -width     => 200,
+    -height    => 22,
+    -text      => "Case sensitive search",
+    -tabstop   => 1,
+);
+$CW->AddCheckbox(
+    -name      => "Clean",
+    -left      => 10,
+    -top       => 100,
+    -width     => 200,
+    -height    => 22,
+    -text      => "Clean temporary after build",
+    -tabstop   => 1,
+);
+$CW->AddCheckbox(
+    -name      => "Force",
+    -left      => 10,
+    -top       => 130,
+    -width     => 200,
+    -height    => 22,
+    -text      => "Force install (ignore dependencies)",
+    -tabstop   => 1,
+);
+$CW->AddButton(
+    -name     => "ConfOK",
+    -left     => 150,
+    -top      => $CW->Height-55,
+    -width    => 60,
+    -text     => "&OK",
+    -ok       => 1,
+    -default  => 1,
+    -tabstop  => 1,
+);
+$CW->AddButton(
+    -name     => "ConfClose",
+    -left     => 220,
+    -top      => $CW->Height-55,
+    -width    => 60,
+    -text     => "&Cancel",
+    -cancel   => 1,
+    -tabstop  => 1,
+);
+
+my $SW = new Win32::GUI::DialogBox(
+    -name   => "PW",
+    -text   => "PPM Search",
+    -left   => 110,
+    -top    => 110,
+    -width  => 300,
+    -height => 400,
+);
+$SW->AddTextfield(
+	-name    => "What",
+	-left    => 10,
+	-top     => 10,
+	-width   => 200,
+    -height  => 22,
+	-prompt  => [ "Regexp:", 75 ],
+	-tabstop => 1,
+);
+$SW->AddLabel(
+	-name    => "WhereLabel",
+	-left    => 10,
+	-top     => 44,
+	-text    => "Search in:",
+);
+$SW->AddComboboxEx(
+	-name      => "Where",
+	-left      => 85,
+	-top       => 40,
+	-tabstop   => 1,
+	-width     => 200,
+	-height    => 200,
+	-tabstop   => 1,
+    -style     => WS_VISIBLE | 2,
+	-imagelist => $IL,
+);
+$SW->AddButton(
+    -name      => "GroupWhat",
+    -left      => 10,
+    -top       => 70,
+    -width     => 275,
+    -height    => 100,
+    -text      => "What to search",
+	-style     => BS_GROUPBOX,
+	-visible   => 1,
+);
+$SW->AddRadioButton(
+    -name      => "SearchName",
+    -left      => 20,
+    -top       => 90,
+    -width     => 170,
+    -height    => 22,
+    -text      => "Package name",
+    -tabstop   => 1,
+);
+$SW->AddRadioButton(
+    -name      => "SearchAuthor",
+    -left      => 20,
+    -top       => 115,
+    -width     => 170,
+    -height    => 22,
+    -text      => "Author",
+    -tabstop   => 1,
+);
+$SW->AddRadioButton(
+    -name      => "SearchAbstract",
+    -left      => 20,
+    -top       => 140,
+    -width     => 170,
+    -height    => 22,
+    -text      => "Abstract",
+    -tabstop   => 1,
+);
+$SW->AddCheckbox(
+    -name      => "SearchCase",
+    -left      => 10,
+    -top       => 180,
+    -width     => 200,
+    -height    => 22,
+    -text      => "Case sensitive search",
+    -tabstop   => 1,
+);
+$SW->AddButton(
+	-name    => "SearchOK",
+	-text    => "&OK",
+	-left    => $SW->Width-145,
+	-top     => $SW->Height-55,
+	-width   => 60,
+	-ok      => 1,
+	-tabstop => 1,
+);
+$SW->AddButton(
+	-name    => "SearchCancel",
+	-text    => "Cancel",
+	-left    => $SW->Width-75,
+	-top     => $SW->Height-55,
+	-width   => 60,
+	-cancel  => 1,
+	-tabstop => 1,
+);
+
+
+$W->AddTreeView(
+    -name      => "Tree",
+    -imagelist => $IL,
+    -tabstop   => 1,
+	-lines     => 1,
+	-rootlines => 1,
+	-buttons   => 1,
+);
+$W->AddStatusBar(
+    -name   => "Status",
+);
+
+$W->Tree->InsertItem(
+    -text  => "Installed packages",
+    -image => $IL_PPMREPL,
+);
+
+my %Instd = ();
+
+my %Repos = ();
+
+%Repos = PPM::ListOfRepositories();
+foreach my $r (keys %Repos) {
+    $W->Tree->InsertItem(
+		-text => $r,
+		-image => $IL_PPMREPF,
+		-index => $W->Tree->Count,
+	);
+}
+$W->Tree->InsertItem(
+	-text => "Add new repository...",
+	-image => $IL_PPMREPN,
+	-index => $W->Tree->Count,
+);
+
+$W->Show();
+
+my @wins = Win32::GUI::EnumMyWindows();
+print "I have ", scalar(@wins), " window(s):\n";
+foreach my $win (@wins) {
+	print "$win: ", Win32::GUI::Text($win), "(", Win32::GUI::GetClassName($win), ")\n";
+}
+
+my $exitcode = Win32::GUI::Dialog();
+WriteSettings();
+
+#================
+sub W_Terminate {
+#================
+    return -1;
+}
+
+#=============
+sub W_Resize {
+#=============
+    $W->Tree->Move(2, 2);
+    $W->Tree->Resize($W->ScaleWidth-4, $W->ScaleHeight-2-$W->Status->Height);
+    $W->Status->Move(0, $W->ScaleHeight-$W->Status->Height);
+    $W->Status->Resize($W->ScaleWidth, $W->Status->Height);
+    return 1;
+}
+
+#===================
+sub Tree_NodeClick {
+#===================
+    my($node) = @_;
+	my %i;
+	my $v;
+	my $p;
+	my $pp;
+    my %n = $W->Tree->GetItem($node);
+    if($n{-image} == $IL_PPMREPO) {
+		%i = %{$Instd{$n{-text}}};
+		$PW->Operate->Text("&Remove");
+		$M->{Install}->Enabled(0);
+		$M->{Remove}->Enabled(1);
+        $v = $i{VERSION};
+        $p = $i{NAME};
+        #$pp = $p;
+        #$pp =~ s@-@/@g;
+        #my $i;
+        #foreach $i (@INC) {
+        #    if(-f "$i/$pp.pm") {
+        #        my $vv = ExtUtils::MM_Unix::parse_version(0, "$i/$pp.pm");
+        #        $v .= " ($vv)" if $vv;
+        #        $p = $pp;
+        #        $p =~ s@/@::@g;
+        #    }
+        #}
+        $W->Status->Text("$p $v");
+	} elsif($n{-image} == $IL_PPMREPC) {
+		my $parent = $W->Tree->GetParent($node);
+		my %r = $W->Tree->GetItem($parent);
+		%i = PPM::RepositoryPackageProperties(
+			"package" => $n{-text},
+			"location" => $Repos{$r{-text}},
+		);
+		$M->{Install}->Enabled(1);
+		$M->{Remove}->Enabled(0);
+		$PW->Operate->Text("&Install");
+        my $v = $i{VERSION};
+        my $p = $i{NAME};
+        $W->Status->Text("$p $v");
+	} elsif($n{-image} == $IL_PPMREPF) {
+		$W->Status->Text($Repos{$n{-text}});
+	} elsif($n{-image} eq $IL_PPMREPN) {
+        $W->Status->Text("Creates a new repository");
+    }
+}
+
+#==================
+sub Tree_DblClick {
+#==================
+    my($X, $Y) = Win32::GUI::GetCursorPos();
+	my $c = 0;
+    my $node = $W->Tree->HitTest(
+        $X - ($W->Left + $W->Tree->Left) - 2,
+        $Y - ($W->Top  + $W->Tree->Top ) - 2,
+    );
+    $node = $W->Tree->SelectedItem();
+	if($node) {
+        $W->Tree->Select($node);
+        my %n = $W->Tree->GetItem($node);
+		if($n{-image} == $IL_PPMREPF) {
+			if($W->Tree->GetNextVisible($node) == $W->Tree->GetChild($node)) {
+				$W->Tree->Expand($node, 0);
+			} else {
+				if(not exists $WinPPM{R}{$n{-text}}) {
+					$W->Tree->Clear($node);
+					my %p = PPM::RepositoryPackages("location" => $Repos{$n{-text}});
+					my $p;
+					foreach $p (@{$p{$Repos{$n{-text}}}}) {
+						$W->Tree->InsertItem(
+							-text => $p,
+							-index => $W->Tree->Count(),
+							-image => $IL_PPMREPC,
+							-parent => $node,
+						);
+						$c++;
+					}
+					$WinPPM{R}{$n{-text}} = 1;
+				}
+				$W->Tree->Expand($node, 1);
+				$W->Status->Text("$c package" . ( ($c > 1) ? "s" : "") );
+			}
+			# $W->Tree->EnsureVisible($W->Tree->GetChild($node));
+			# $W->Tree->Select($W->Tree->GetChild($node));
+		} elsif($n{-image} == $IL_PPMREPO or $n{-image} == $IL_PPMREPC) {
+			ShowProperties();
+		} elsif($n{-image} == $IL_PPMREPL) {
+			if($W->Tree->GetNextVisible($node) == $W->Tree->GetChild($node)) {
+				$W->Tree->Expand($node, 0);
+			} else {
+				$W->Tree->Clear($node);
+				%Instd = PPM::InstalledPackageProperties();
+				foreach my $i (sort keys %Instd) {
+					$W->Tree->InsertItem(
+						-text => $i,
+						-index => $W->Tree->Count(),
+						-image => $IL_PPMREPO,
+						-parent => $node,
+					);
+					$c++;
+				}
+				$W->Tree->Expand($node, 1);
+				$W->Status->Text("$c package" . ( ($c > 1) ? "s" : "") );
+			}
+			# $W->Tree->EnsureVisible($W->Tree->GetChild($node));
+			# $W->Tree->Select($W->Tree->GetChild($node));
+		} elsif($n{-image} == $IL_PPMREPN) {
+			my $node = $W->Tree->SelectedItem();
+			my %n = $W->Tree->GetItem($node);
+			$W->Disable();
+			$RW->Editing->Text("");
+			$RW->Name->Text("");
+			$RW->Location->Text("");
+			$RW->Text("Add new repository...");
+			$RW->Name->SetFocus();
+			$RW->Move(
+				$W->Left + ($W->Width  - $RW->Width )/2,
+				$W->Top  + ($W->Height - $RW->Height)/2,
+			);
+			$RW->Show();
+		} else {
+			Win32::GUI::MessageBox(0, "unknown image!");
+		}
+	} else {
+		Win32::GUI::MessageBox(0, "nothing selected!");
+	}
+	return 0;
+}
+
+#====================
+sub Tree_RightClick {
+#====================
+    my($X, $Y) = Win32::GUI::GetCursorPos();
+    my $node = $W->Tree->HitTest(
+        $X-$W->Tree->Left-2,
+        $Y-$W->Tree->Top-2,
+    );
+    if($node) {
+        $W->Tree->Select($node);
+        my %n = $W->Tree->GetItem($node);
+        if($n{-image} == $IL_PPMREPF) {
+            $W->TrackPopupMenu($POP->{POP_onRepository}, $X, $Y);
+        } elsif($n{-image} == $IL_PPMREPC) {
+			$W->TrackPopupMenu($POP->{POP_onRepoPack}, $X, $Y);
+		} elsif($n{-image} == $IL_PPMREPO) {
+			$W->TrackPopupMenu($POP->{POP_onInstd}, $X, $Y);
+		} elsif($n{-image} == $IL_PPMREPR) {
+			$W->TrackPopupMenu($POP->{POP_onSearchResults}, $X, $Y);
+		}
+    }
+    return 1;
+}
+
+#======================
+sub POP_RepProp_Click {
+#======================
+    my $node = $W->Tree->SelectedItem();
+    my %n = $W->Tree->GetItem($node);
+    $W->Disable();
+    $RW->Editing->Text($n{-text});
+    $RW->Name->Text($n{-text});
+    $RW->Location->Text($Repos{$n{-text}});
+    $RW->Text("Repository Properties");
+    $RW->Name->SetFocus();
+    $RW->Move(
+        $W->Left + ($W->Width  - $RW->Width )/2,
+        $W->Top  + ($W->Height - $RW->Height)/2,
+    );
+    $RW->Show();
+}
+
+#========================
+sub POP_InstdProp_Click {
+#========================
+	ShowProperties();
+}
+
+#=================
+sub Remove_Click {
+#=================
+	my $node = $W->Tree->SelectedItem();
+    my %n = $W->Tree->GetItem($node);
+	RemovePackage($n{-text});
+
+}
+#==========================
+sub POP_InstdRemove_Click {
+#==========================
+	Remove_Click();
+}
+
+#===================
+sub POP_Prop_Click {
+#===================
+	ShowProperties();
+}
+
+#=====================
+sub Properties_Click {
+#=====================
+	ShowProperties();
+}
+
+#==========================
+sub POP_ClearSearch_Click {
+#==========================
+	my $node = $W->Tree->GetChild(0);
+	my %i = $W->Tree->GetItem($node);
+	my $done = 0;
+	while($node and not $done) {
+		if($i{-image} == $IL_PPMREPR) {
+			$W->Tree->Clear($node);
+			$W->Tree->DeleteItem($node);
+			$done = 1;
+		}
+		$node = $W->Tree->GetNextSibling($node);
+	}
+}
+#==================
+sub Install_Click {
+#==================
+    my $node = $W->Tree->SelectedItem();
+    my %n = $W->Tree->GetItem($node);
+	my $parent = $W->Tree->GetParent($node);
+	my %r = $W->Tree->GetItem($parent);
+	InstallPackage($n{-text}, $Repos{$r{-text}});
+}
+#======================
+sub POP_Install_Click {
+#======================
+	Install_Click();
+}
+
+#================
+sub Close_Click {
+#================
+    $PW->Hide();
+    $W->Enable();
+    $W->SetForegroundWindow();
+    $W->Tree->SetFocus();
+}
+
+#=================
+sub PW_Terminate {
+#=================
+    Close_Click();
+    return 0;
+}
+
+#================
+sub RepOK_Click {
+#================
+    my %r = (
+        "repository" => $RW->Name->Text(),
+        "location"   => $RW->Location->Text(),
+    );
+    $r{save} = 1 if $WinPPM{SAVE};
+    my $ok = 1;
+    if(not $r{repository}) {
+        $RW->MessageBox(
+			"Repository name not valid",
+			"ERROR",
+			MB_ICONERROR,
+		);
+        return 0;
+    } elsif(not $r{location}) {
+		$RW->MessageBox(
+			"Repository location not valid",
+			"ERROR",
+			MB_ICONERROR,
+		);
+        return 0;
+    }
+    if($RW->Editing->Text) {
+        my @s = ();
+        @s = ("save" => 1) if $WinPPM{SAVE};
+        PPM::RemoveRepository("repository" => $RW->Editing->Text, @s);
+    }
+    PPM::AddRepository(%r);
+	RepClose_Click();
+	return 1;
+}
+
+#===================
+sub RepClose_Click {
+#===================
+    $RW->Hide();
+    $W->Enable();
+    $W->SetForegroundWindow();
+    $W->Tree->SetFocus();
+	return 1;
+}
+
+#=================
+sub RW_Terminate {
+#=================
+    RepClose_Click();
+    return 0;
+}
+
+#====================
+sub PPMConfig_Click {
+#====================
+    # $W->Disable();
+    my %o = PPM::GetPPMOptions();
+    $CW->Root->Text($o{ROOT});
+    $CW->Build->Text($o{BUILDDIR});
+    $CW->Case->Checked(
+        ($o{IGNORECASE} =~ /yes/i) ? 1 : 0
+    );
+    $CW->Clean->Checked(
+        ($o{CLEAN} =~ /yes/i) ? 1 : 0
+    );
+    $CW->Force->Checked(
+        ($o{FORCE_INSTALL} =~ /yes/i) ? 1 : 0
+    );
+    $CW->Move(
+        $W->Left + ($W->Width  - $CW->Width )/2,
+        $W->Top  + ($W->Height - $CW->Height)/2,
+    );
+    
+    $CW->DoModal();
+    
+    # $CW->Show();
+    return 1;
+}
+
+#====================
+sub ConfClose_Click {
+#====================
+    # $CW->Hide();
+    # $W->Enable();
+    # $W->SetForegroundWindow();
+    # $W->Tree->SetFocus();
+    return -1;
+}
+
+#=================
+sub CW_Terminate {
+#=================
+    ConfClose_Click();
+    return -1;
+    return 0;
+    
+}
+
+#==================
+sub PPMInfo_Click {
+#==================
+    my $p = XML::Parser->new( Style => 'Objects', Pkg => 'XML::PPMConfig' );
+    my @parsed = @{ $p->parsefile($PPM::PPMdat) };
+    my %parsed = %{$parsed[0]};
+    my $elem;
+    my $PPM_ver;
+    my $CPU;
+    my $OS_VALUE;
+    my $OS_VERSION;
+    my $LANGUAGE;
+    foreach $elem (@{$parsed{Kids}}) {
+        my $subelem = ref $elem;
+        $subelem =~ s/.*:://;
+        # print "$elem => $subelem\n";
+        next if ($subelem eq 'Characters');
+        if ($subelem eq 'PPMVER') {
+            # Get the value out of our _only_ character data element.
+            $PPM_ver = $elem->{Kids}[0]{Text};
+        } elsif ($subelem eq 'PLATFORM') {
+            # Get values out of our attributes
+            $CPU        = $elem->{CPU};
+            $OS_VALUE   = $elem->{OSVALUE};
+            $OS_VERSION = $elem->{OSVERSION};
+            $LANGUAGE   = $elem->{LANGUAGE};
+        }
+    }
+
+    Win32::GUI::MessageBox(
+        0,
+        "This is PPM, version $PPM_ver.\r\n".
+        "Platform: $OS_VALUE-$CPU $OS_VERSION $LANGUAGE",
+        "PPM Info",
+        MB_ICONINFORMATION | MB_OK,
+    );
+}
+
+#===============
+sub Exit_Click {
+#===============
+    return -1;
+}
+
+#=================
+sub Verify_Click {
+#=================
+    my $node = $W->Tree->SelectedItem();
+    my %n = $W->Tree->GetItem($node);
+    my $parent = $W->Tree->GetParent($node);
+    my %r = $W->Tree->GetItem($parent);
+    $PPM::PPMERR = "";
+    my $v;
+	if($r{-image} == $IL_PPMREPF) {
+		$v = PPM::VerifyPackage(
+	        "package" => $n{-text},
+	        "location" => $Repos{$r{-text}},
+	    );
+	} else {
+		$v = PPM::VerifyPackage(
+	        "package" => $n{-text},
+		);
+	}
+    if(not defined $v) {
+        Win32::GUI::MessageBox(0, $PPM::PPMERR, "ERROR", MB_ICONERROR);
+    } else {
+        if($v == 0) {
+            $W->MessageBox(
+                "Package $n{-text} is up-to-date",
+                "Verify",
+                MB_ICONINFORMATION
+            );
+        } else {
+            my $now = $W->MessageBox(
+                "Upgrade available!\r\nDo you want to upgrade now?",
+                "Verify",
+                MB_ICONEXCLAMATION | MB_YESNO
+            );
+			if($now == 6) {
+				if($r{-image} == $IL_PPMREPF) {
+					$v = PPM::VerifyPackage(
+						"package" => $n{-text},
+						"location" => $Repos{$r{-text}},
+						"upgrade" => 1,
+					);
+				} else {
+					$v = PPM::VerifyPackage(
+						"package" => $n{-text},
+						"upgrade" => 1,
+					);
+				}
+			}
+		}
+    }
+}
+#=====================
+sub POP_Verify_Click {
+#=====================
+	Verify_Click();
+}
+#==========================
+sub POP_InstdVerify_Click {
+#==========================
+	Verify_Click();
+}
+
+#====================
+sub ViewRepos_Click {
+#====================
+	SelectTab(0);
+}
+
+#====================
+sub ViewInstd_Click {
+#====================
+	SelectTab(1);
+}
+
+#===================
+sub Autosave_Click {
+#===================
+	$M->{Autosave}->Checked(not $M->{Autosave}->Checked);
+	$WinPPM{SAVE} = $M->{Autosave}->Checked;
+}
+
+#=================
+sub Search_Click {
+#=================
+    $W->Disable();
+	if(not exists $WinPPM{SW_Init}) {
+		my %o = PPM::GetPPMOptions();
+		$SW->SearchCase->Checked(
+			($o{IGNORECASE} =~ /yes/i) ? 1 : 0
+		);
+	}
+	$SW->Where->Clear();
+	$SW->Where->InsertItem(
+		-text => "All repositories",
+		-image => $IL_PPMREPA,
+		-selectedimage => $IL_PPMREPA,
+	);
+	my $node = $W->Tree->GetChild(0);
+	my %i = $W->Tree->GetItem($node);
+	$SW->Where->InsertItem(
+		-text => $i{-text},
+		-image => $i{-image},
+		-selectedimage => $i{-image},
+	);
+	while($node = $W->Tree->GetNextSibling($node)) {
+		%i = $W->Tree->GetItem($node);
+		next if $i{-image} == $IL_PPMREPN;
+		$SW->Where->InsertItem(
+			-text => $i{-text},
+			-image => $i{-image},
+			-selectedimage => $i{-image},
+		);
+	}
+	if(not exists $WinPPM{SW_Init}) {
+		$SW->SearchName->Checked(1);
+		$SW->Where->Select(0);
+		$WinPPM{SW_Init} = 1;
+	}
+	$SW->Move(
+        $W->Left + ($W->Width  - $SW->Width )/2,
+        $W->Top  + ($W->Height - $SW->Height)/2,
+    );
+    $SW->Show();
+}
+#===================
+sub SearchOK_Click {
+#===================
+    $SW->Hide();
+    $W->Enable();
+    $W->SetForegroundWindow();
+    $W->Tree->SetFocus();
+
+	POP_ClearSearch_Click();
+
+	my %sp;
+	my %f;
+	if($SW->SearchCase->Checked) {
+		$sp{"ignorecase"} = "No";
+	} else {
+		$sp{"ignorecase"} = "Yes";
+	}
+	if($SW->SearchName->Checked) {
+		$sp{"searchtag"} = "title";
+	} elsif($SW->SearchAuthor->Checked) {
+		$sp{"searchtag"} = "author";
+	} elsif($SW->SearchAbstract->Checked) {
+		$sp{"searchtag"} = "abstract";
+	}
+	$sp{"searchRE"} = $SW->What->Text;
+	if($SW->Where->Text eq "Installed packages") {
+		%f = PPM::QueryInstalledPackages(%sp);
+		if(%f) {
+			my $r = $W->Tree->InsertItem(
+				-text => "Search results",
+				-image => $IL_PPMREPR,
+			);
+			my $f;
+			foreach $f (sort keys %f) {
+				$W->Tree->InsertItem(
+					-text => $f,
+					-image => $IL_PPMREPO,
+					-parent => $r,
+				);
+			}
+			$W->Tree->Expand($r);
+			$W->Status->Text(scalar(keys %f)." packages found");
+		} else {
+			$W->MessageBox(
+				"No packages found",
+				"PPM Search",
+				MB_ICONEXCLAMATION,
+			);
+			$W->Status->Text("0 packages found");
+		}
+	} else {
+		if($SW->Where->Text ne "All repositories") {
+			$sp{"location"} = $Repos{$SW->Where->Text};
+			$sp{"repository"} = $SW->Where->Text;
+			%f = SearchAtLocation(%sp);
+		} else {
+			my %sf;
+			my @f;
+			%Repos = PPM::ListOfRepositories();
+			foreach my $r (sort keys %Repos) {
+				$sp{"location"} = $Repos{$r};
+				$sp{"repository"} = $r;
+				%sf = SearchAtLocation(%sp);
+				push(@f, %sf);
+			}
+			%f = @f;
+		}
+		if(%f) {
+			POP_ClearSearch_Click();
+			my $r = $W->Tree->InsertItem(
+				-text => "Search results",
+				-image => $IL_PPMREPR,
+			);
+			my $f;
+			foreach $f (sort keys %f) {
+				$W->Tree->InsertItem(
+					-text => $f,
+					-image => $IL_PPMREPC,
+					-parent => $r,
+				);
+			}
+			$W->Tree->Expand($r);
+			$W->Status->Text(scalar(keys %f)." packages found");
+		} else {
+			$W->MessageBox(
+				"No packages found",
+				"PPM Search",
+				MB_ICONEXCLAMATION,
+			);
+			$W->Status->Text("0 packages found");
+		}
+
+	}
+	return 1;
+}
+
+#=====================
+sub SearchAtLocation {
+#=====================
+    my(%sp) = @_;
+	my %f = ();
+	my %p = PPM::RepositoryPackages("location" => $sp{"location"});
+	foreach (keys %sp) {
+		print "SP: $_ = $sp{$_}\n";
+	}
+	foreach my $p (@{$p{$sp{"location"}}}) {
+		print "checking $p...";
+		my $string = PPM::QueryPPD("package" => $p, %sp);
+		if($string) {
+			$f{$p." ($sp{repository})"} = $sp{"location"};
+			print "match!\n";
+		} elsif(not defined $string) {
+			print "ERROR: $PPM::PPMERR\n";
+		} elsif($string eq "") {
+			print "no good\n";
+		}
+	}
+	return %f;
+}
+
+#=======================
+sub SearchCancel_Click {
+#=======================
+    $SW->Hide();
+    $W->Enable();
+    $W->SetForegroundWindow();
+    $W->Tree->SetFocus();
+}
+
+#==================
+sub Operate_Click {
+#==================
+	if($PW->Operate->Text eq "&Remove") {
+		RemovePackage($PW->PPMName->Text);
+		PW_Terminate();
+	} else {
+		my $node = $W->Tree->SelectedItem();
+		my $parent = $W->Tree->GetParent($node);
+		my %r = $W->Tree->GetItem($parent);
+		InstallPackage($PW->PPMName->Text, $Repos{$r{-text}});
+		PW_Terminate();
+	}
+}
+
+#===================
+sub ShowProperties {
+#===================
+    my $node = $W->Tree->SelectedItem();
+    my %n = $W->Tree->GetItem($node);
+	my $parent = $W->Tree->GetParent($node);
+	my %r = $W->Tree->GetItem($parent);
+	my %i;
+	if($r{-image} eq $IL_PPMREPF) {
+		%i = PPM::RepositoryPackageProperties(
+			"package" => $n{-text},
+			"location" => $Repos{$r{-text}},
+		);
+		$PW->Operate->Text("&Install");
+	} elsif($r{-image} eq $IL_PPMREPR) {
+		if($n{-image} eq $IL_PPMREPC) {
+			my($package, $repository) = split(/\s*[()]/, $n{-text});
+			%i = PPM::RepositoryPackageProperties(
+				"package" => $package,
+				"location" => $Repos{$repository},
+			);
+		} else {
+			%i = %{$Instd{$n{-text}}};
+		}
+	} else {
+		%i = %{$Instd{$n{-text}}};
+		$PW->Operate->Text("&Remove");
+	}
+	$W->Disable();
+	$PW->PPMName->Text($i{NAME});
+	$PW->PPMVersion->Text($i{VERSION});
+	$PW->PPMAuthor->Text($i{AUTHOR});
+	$PW->PPMAbstract->Text($i{ABSTRACT});
+	$PW->PPMDate->Text($i{DATE});
+	$PW->Move(
+		$W->Left + ($W->Width  - $PW->Width )/2,
+		$W->Top  + ($W->Height - $PW->Height)/2,
+	);
+	$PW->Show();
+}
+
+#==================
+sub RemovePackage {
+#==================
+	my($package) = @_;
+    my $sure = $W->MessageBox(
+        "Are you sure you want to remove $package?",
+        "Remove",
+        MB_ICONEXCLAMATION | MB_YESNO
+    );
+    print "sure: $sure\n";
+    if($sure == 6) {
+        $PPM::PPMERR = "";
+        $W->Status->Text("Removing '$package'...");
+        my $v = PPM::RemovePackage(
+            "package" => $package,
+        );
+		if($v == 1) {
+			$W->Status->Text("Package '$package' successfully removed.");
+		} else {
+			Win32::GUI::MessageBox($W, $PPM::PPMERR, "ERROR", MB_ICONERROR);
+        }
+    }
+}
+
+#===================
+sub InstallPackage {
+#===================
+	my($package, $location) = @_;
+	$PPM::PPMERR = "";
+	$W->Status->Text("Installing '$package'...");
+	my $v = PPM::InstallPackage(
+		"package" => $package,
+		"location" => $location,
+	);
+	if($v == 1) {
+		Win32::GUI::MessageBox($W, "Package '$package' successfully installed.", "WinPPM", MB_ICONINFORMATION);
+	} else {
+		Win32::GUI::MessageBox($W, $PPM::PPMERR, "ERROR", MB_ICONERROR);
+	}
+}
+
+#==================
+sub DefineBitmaps {
+#==================
+$B_PPMREPO = new Win32::GUI::BitmapInline( q(
+Qk02AwAAAAAAADYAAAAoAAAAEAAAABAAAAABABgAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAzOLj
+zOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLj
+zOLjzOLjAE/fAD+/AAC/AACAzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjAE/fT3D/
+AAC/AAC/AACAAACAzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjAE/fAD+/AAC/AAC/AAC/AACA
+AABwAABwzOLjzOLjzOLjzOLjzOLjzOLjzOLjAADfAADfAAC/AAC/AAC/AD+/ADCQAABwAABwAABw
+zOLjzOLjzOLjzOLjzOLjAADfAADfAD+/AAC/AAC/IFD/T3D/T3D/AACAAABwAABwAABwzOLjzOLj
+zOLjsLD/AADfAADfAAC/AAC/IFD/T3D/AAAAT3D/T3D/AABwAABwAB9QAE9wzOLjzOLjT0//AAC/
+AAC/AD+/b4//T3D/AAAAAL+/AFBQT3D/T3D/AABQAB9QAB9QzOLjzOLjAAC/AD+/b4//T3D/Dw8P
+AAAAAL+/AP//AP//AAAAADCQT3D/ACBwAB9QzOLjzOLjT3D/T3D/ADCQAB9QAB9QDw8PAP//AP//
+AP//AB9QAABQAD+/IFD/AABQzOLjzOLjzOLjT3D/AB9QAB9QAB9QAB9QAFBQAL+/AFBQAB9QAABQ
+AABQAD+/AE/fzOLjzOLjzOLjzOLjT3D/AB9QAB9QAB9QAB9QAB9QAB9QAABQAABQAABQADCQAE/f
+zOLjzOLjzOLjzOLjzOLjT3D/AB9QDw8PAB9QAB9QAB9QAABQACBwIFD/T0//zOLjzOLjzOLjzOLj
+zOLjzOLjzOLjIFD/AB9QAB9QAABQAB9QAE/fAE/fzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLj
+zOLjzOLjACBwAD+/T0//zOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLj
+zOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLj
+) );
+
+$B_PPMREPN = new Win32::GUI::BitmapInline( q(
+Qk02AwAAAAAAADYAAAAoAAAAEAAAABAAAAABABgAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAzOLj
+zOLjzOLjgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAzOLjzOLjzOLjzOLjgICAwMDA
+gICAwMDAgICAwMDAgICAwMDAgICAwMDAgICAgICAAAAAzOLjzOLjgICAwMDAwMDAwMDAwMDAwMDA
+wMDAwMDAwMDAwMDAwMDAwMDAgICAAAAAzOLjzOLjgICA////////////////////////////////
+////////////wMDAAAAAzOLjzOLjzOLjgICA////////////////f6Pnf3/P////////////////
+wMDAAAAAzOLjzOLjzOLjgICA////////////P3ffExzPAACfPz+X////////////wMDAAAAAzOLj
+zOLjzOLjgICA////////Pz/nAA/HCBTPJ1PTAAB0Pz+T////////wMDAAAAAzOLjzOLjzOLjgICA
+////v7//AADPGzPPL0y/E1+DO1TbAA9Yf5uv////wMDAAAAAzOLjzOLjzOLjgICA////k5vvL1vT
+Fy9rA3NzAP//ABNMG0fLf4en////wMDAAAAAzOLjzOLjzOLjgICA////////Z3/TAB9QACtQAFNr
+AAdQABt7f6fv////wMDAAAAAzOLjzOLjzOLjgICA////////////W3fTAxs/ABdQAC+fm6f/////
+////wMDAAAAAzOLjzOLjzOLjgICA////////////////v8fbk6Pv////////////////wMDAAAAA
+zOLjzOLjzOLjgICA////////////////////////////////////////wMDAAAAAzOLjzOLjzOLj
+AICAAICAAICAAICAAICAAICAAICAAICAAICAAICAAICAwMDAAAAAzOLjzOLjzOLjAICAAP//AP//
+AP//AP//AP//AP//AP//AP//AP//AP//AICAAAAAzOLjzOLjzOLjzOLjAICAAICAAICAAICAAICA
+AICAAICAAICAAICAAICAAICAAAAAzOLj
+) );
+
+$B_PPMREPF = new Win32::GUI::BitmapInline( q(
+Qk02AwAAAAAAADYAAAAoAAAAEAAAABAAAAABABgAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAzOLj
+zOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLj
+zOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjAAAAAAAAAAAAAAAAAAAA
+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAzOLjAJ+fYM/PYM/PYM/PYM/PYM/PYM/PYM/PYM/P
+YM/PYM/PYM/PYM/PYM/PAAAAzOLjAJ+fz///n8//n///n8//n///T6PnT3/Pn8//n///n8//n8//
+n8//YM/PAAAAzOLjAJ+fz///n///n///n///J3ffExzPAACfJz+Xn8//n///n8//n8//YM/PAAAA
+zOLjAJ+fz///n///n///Jz/nAA/HCBTPJ1PTAAB0Jz+Tn8//n///n8//YM/PAAAAzOLjAJ+fz///
+n///j7//AADPGzPPL0y/E1+DO1TbAA9YT5uvn8//n///YM/PAAAAzOLjAJ+fz///n///Y5vvL1vT
+Fy9rA3NzAP//ABNMG0fLT4enn///n8//YM/PAAAAzOLjAJ+fz///n///n///T3/TAB9QACtQAFNr
+AAdQABt7T6fvn8//n///YM/PAAAAzOLjAJ+fz///n///n///n///Q3fTAxs/ABdQAC+fa6f/n///
+n///n8//YM/PAAAAzOLjAJ+fz///z///z///z///z///d8fbY6Pvz///z///z///z///n///YM/P
+AAAAzOLjAJ+fYM/PYM/PYM/PYM/PYM/PYM/PYM/PAJ+fAJ+fAJ+fAJ+fAJ+fAJ+fzOLjzOLjzOLj
+AJ+f8PDwz///z///n///n///AJ+fAAAAzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjAJ+fAJ+f
+AJ+fAJ+fAJ+fAAAAzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLj
+zOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLj
+) );
+
+$B_PPMREPI = new Win32::GUI::BitmapInline( q(
+Qk02AwAAAAAAADYAAAAoAAAAEAAAABAAAAABABgAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAzOLj
+zOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLj
+zOLjzOLjAE/fAD+/AAC/AACAzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjAE/fT3D/
+AAC/AAC/AACAAACAzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjAE/fAD+/AAC/AAC/AAC/AACA
+AABwAABwzOLjzOLjzOLjzOLjzOLjzOLjzOLjAADfAADfAAC/AAC/AAC/AD+/ADCQAABwAABwAABw
+zOLjzOLjzOLjzOLjzOLjAADfAADfAD+/AAC/AAC/IFD/T3D/T3D/AACAAABwAABwAABwzOLjzOLj
+zOLjsLD/AADfAADfAAC/AAC/IFD/T3D/AAAAT3D/T3D/AABwAABwAB9QAE9wzOLjzOLjT0//AAC/
+AAC/AD+/b4//T3D/AAAAAL+/AFBQT3D/T3D/AABQAB9QAB9QzOLjzOLjAAC/AD+/b4//T3D/Dw8P
+AAAAAL+/AP//AP//AAAAADCQT3D/k5iYUFBQmamqzOLjT3D/T3D/ADCQAB9QAB9QDw8PAP//g4eH
+aHBwaHBwaHBwaHBwk5eXv7+/UFBQzOLjzOLjT3D/AB9QAB9QAB9QAB9QAFBQwNHSW19fW19fW19f
+W19fV1dXj4+Pg4iIzOLjzOLjzOLjT3D/AB9QAB9QAB9QAB9QAB9QtsHBkJCQkJCQkJCQkJCQmJiY
+ZnFxzOLjzOLjzOLjzOLjT3D/AB9QDw8PAB9QAB9QprGxuKCgx3h4r2B4oKCgODg4ucnKzOLjzOLj
+zOLjzOLjzOLjIFD/AB9QAB9QAABQprGxqHBw85t7wyQwoKCgMDAwzOLjzOLjzOLjzOLjzOLjzOLj
+zOLjzOLjACBwAD+/prGxtLSomIhwmIhwoKCgMDAwzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLj
+zOLjzOLjo6iooKCgoKCgoKCga3BwzOLj
+) );
+
+$B_PPMREPL = new Win32::GUI::BitmapInline( q(
+Qk02AwAAAAAAADYAAAAoAAAAEAAAABAAAAABABgAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAzOLj
+zOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLj
+zOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjAAAAAAAAAAAAAAAAAAAA
+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAzOLjAJycY87OY87OY87OY87OY87OY87OY87OY87O
+Y87OY87OY87OY87OY87OAAAAzOLjAJyczv//nM7/nP//nM7/nP//nM7/nP//k5iYUFBQmamqnM7/
+nM7/Y87OAAAAzOLjAJyczv//nP//g4eHaHBwaHBwaHBwaHBwk5eXv7+/UFBQnM7/nM7/Y87OAAAA
+zOLjAJyczv//nP//wNHSW19fW19fW19fW19fV1dXj4+Pg4iInP//nM7/Y87OAAAAzOLjAJyczv//
+nP//nP//tsHBkJCQkJCQkJCQkJCQmJiYZnFxnM7/nP//Y87OAAAAzOLjAJyczv//nP//nP//prGx
+uKCgx3h4r2B4oKCgODg4ucnKnP//nM7/Y87OAAAAzOLjAJyczv//nP//nP//prGxqHBw85t7wyQw
+oKCgMDAwnP//nM7/nP//Y87OAAAAzOLjAJyczv//nP//nP//prGxtLSomIhwmIhwoKCgMDAwnP//
+nP//nM7/Y87OAAAAzOLjAJyczv//zv//zv//zv//o6iooKCgoKCgoKCga3Bwzv//zv//nP//Y87O
+AAAAzOLjAJycY87OY87OY87OY87OY87OY87OY87OAJycAJycAJycAJycAJycAJyczOLjzOLjzOLj
+AJyc9/f3zv//zv//nP//nP//AJycAAAAzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjAJycAJyc
+AJycAJycAJycAAAAzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLj
+zOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLj
+) );
+
+$B_PPMREPC = new Win32::GUI::BitmapInline( q(
+Qk02AwAAAAAAADYAAAAoAAAAEAAAABAAAAABABgAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAzOLj
+zOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLj
+zOLjzOLjAE/fAD+/AAC/AACAzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjAE/fT3D/
+AAC/AAC/AACAAACAzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjAE/fAD+/AAC/AAC/AAC/AACA
+AABwAABwzOLjzOLjzOLjzOLjzOLjzOLjzOLjAADfAADfAAC/AAC/AAC/AD+/ADCQAABwAABwAABw
+zOLjzOLjzOLjzOLjzOLjAADfAADfAD+/AAC/AAC/IFD/T3D/T3D/AACAAABwAABwAABwzOLjzOLj
+zOLjsLD/AADfAADfAAC/AAC/IFD/T3D/AAC/T3D/T3D/AABwAABwAB9QAE9wzOLjzOLjT0//AAC/
+AAC/AD+/b4//T3D/AAC/AAC/AAC/T3D/T3D/AABQAB9QAB9QzOLjzOLjAAC/AD+/b4//T3D/AAC/
+AAC/AAC/AAC/AAC/AAC/ADCQT3D/ACBwAB9QzOLjzOLjT3D/T3D/ADCQAAC/AAC/AAC/AAC/AAC/
+AAC/AAC/AAC/AD+/IFD/AABQzOLjzOLjzOLjT3D/AAC/AAC/AAC/AAC/AAC/AAC/AAC/AAC/AAC/
+AAC/AD+/AE/fzOLjzOLjzOLjzOLjT3D/AAC/AAC/AAC/AAC/AAC/AAC/AAC/AAC/AAC/ADCQAE/f
+zOLjzOLjzOLjzOLjzOLjT3D/AAC/AAC/AAC/AAC/AAC/AAC/ACBwIFD/T0//zOLjzOLjzOLjzOLj
+zOLjzOLjzOLjIFD/AAC/AAC/AAC/AAC/AE/fAE/fzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLj
+zOLjzOLjAAC/AD+/T0//zOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLj
+zOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLj
+) );
+
+$B_PPMREPA = new Win32::GUI::BitmapInline( q(
+Qk02AwAAAAAAADYAAAAoAAAAEAAAABAAAAABABgAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAzOLj
+zOLjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAzOLjAJ+fYM/PYM/P
+YM/PYM/PYM/PYM/PYM/PYM/PYM/PYM/PYM/PYM/PYM/PAAAAzOLjAJ+fz///n8//n///n8//n///
+T6PnT3/Pn8//n///n8//n8//n8//YM/PAAAAzOLjAJ+fz///n///n///n///J3ffExzPAACfJz+X
+n8//n///n8//n8//YM/PAAAAAJ+fAJ+fz///n///n///Jz/nAA/HCBTPJ1PTAAB0Jz+Tn8//n///
+n8//YM/PAAAAAJ+fAJ+fz///n///j7//AADPGzPPL0y/E1+DO1TbAA9YT5uvn8//n///YM/PAAAA
+AJ+fAJ+fz///n///Y5vvL1vTFy9rA3NzAP//ABNMG0fLT4enn///n8//YM/PAAAAAJ+fAJ+fz///
+n///n///T3/TAB9QACtQAFNrAAdQABt7T6fvn8//n///YM/PAAAAAJ+fAJ+fz///n///n///n///
+Q3fTAxs/ABdQAC+fa6f/n///n///n8//YM/PAAAAAJ+fAJ+fz///z///z///z///z///d8fbY6Pv
+z///z///z///z///n///YM/PAAAAAJ+fAJ+fYM/PYM/PYM/PYM/PYM/PYM/PYM/PAJ+fAJ+fAJ+f
+AJ+fAJ+fAJ+fzOLjAJ+fz///AJ+f8PDwz///z///n///n///AJ+fAAAAn///n///n8//YM/PAAAA
+zOLjAJ+fz///z///AJ+fAJ+fAJ+fAJ+fAJ+fAAAAz///z///z///n///YM/PAAAAzOLjAJ+fYM/P
+YM/PYM/PYM/PYM/PYM/PYM/PAJ+fAJ+fAJ+fAJ+fAJ+fAJ+fzOLjzOLjzOLjAJ+f8PDwz///z///
+n///n///AJ+fAAAAzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLjAJ+fAJ+fAJ+fAJ+fAJ+fAAAA
+zOLjzOLjzOLjzOLjzOLjzOLjzOLjzOLj
+) );
+
+$B_PPMREPR = new Win32::GUI::BitmapInline( q(
+Qk02AwAAAAAAADYAAAAoAAAAEAAAABAAAAABABgAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAzOLj
+zOLjzOLjgICAgICAgICAgICAgICAgICAgICAgICAAAAAAAAAAAAAzOLjzOLjzOLjzOLjgICAwMDA
+gICAwMDAgICAwMDAgICAwMDAgAAA//8A/wAAAAAAAAAAzOLjzOLjgICAwMDAwMDAwMDAwMDAwMDA
+wMDAwMDAgAAA//8A/wAA/wAAAAAAAAAAzOLjzOLjgICA////////////////////////gAAA//8A
+/wAA/wAAwMDAwMDAAAAAzOLjzOLjzOLjgICA////////////////gAAA//8A/wAA/wAAwMDA////
+wMDAAAAAzOLjzOLjzOLjgICAgICAAAAAAAAAgICAwMDA/wAA/wAAwMDA////////wMDAAAAAzOLj
+zOLjzOLjgICAwMDA//8AwMDAAAAAgICAgICAwMDAPz+T////////wMDAAAAAzOLjzOLjgICA////
+//8AwMDA//8AwMDAAAAAwMDAO1TbAA9Yf5uv////wMDAAAAAzOLjzOLjgICA//8A//////8AwMDA
+//8AAAAAwMDAABNMG0fLf4en////wMDAAAAAzOLjzOLjgICA//////8A//////8AwMDAAAAAwMDA
+AAdQABt7f6fv////wMDAAAAAzOLjzOLjzOLjgICA//////8A////AAAAwMDAABdQAC+fm6f/////
+////wMDAAAAAzOLjzOLjzOLjgICAgICAgICAAAAAwMDAv8fbk6Pv////////////////wMDAAAAA
+zOLjzOLjzOLjgICA////////////////////////////////AAAAAAAAAAAAAAAAzOLjzOLjzOLj
+gICA////////////////////////////////wMDA////gICAzOLjzOLjzOLjzOLjgICA////////
+////////////////////////wMDAgICAzOLjzOLjzOLjzOLjzOLjgICAgICAgICAgICAgICAgICA
+gICAgICAgICAgICAzOLjzOLjzOLjzOLj
+) );
+
+}
+
+#=================
+sub InitSettings {
+#=================
+	if(open(INI, "winppm.ini")) {
+		$WinPPM{SAVE} = <INI>;
+		close(INI);
+	} else {
+		$WinPPM{SAVE} = 0;
+	}
+}
+
+#==================
+sub WriteSettings {
+#==================
+	if(open(INI, ">winppm.ini")) {
+		print INI $WinPPM{SAVE}, "\n";
+		close(INI);
+	} else {
+		$WinPPM{SAVE} = 0;
+	}
+}
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/samples/winsize.pl perl-libwin32-0.191/GUI/samples/winsize.pl
--- libwin32-0.191/GUI/samples/winsize.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/samples/winsize.pl	2004-01-12 16:46:42.875000000 -0800
@@ -0,0 +1,178 @@
+use Win32::GUI;
+
+my $VERSION = "1.01";
+
+my %output;
+
+foreach ("handles", "titles", "classes", "sizes", "styles") {
+    $output{$_} = 1;
+}
+
+print STDERR "Type '$0 -h' for help.\n";
+print STDERR "Move the mouse over a window and press ENTER:";
+
+my $enter = <STDIN>;
+print "\n";
+
+my ($x, $y) = Win32::GUI::GetCursorPos();
+print "Window at ($x, $y):\n";
+my $HWND = Win32::GUI::WindowFromPoint($x, $y);
+
+Win32::GUI::Resize($HWND, $ARGV[0], $ARGV[1]);
+
+
+#=================
+sub GetClassName {
+#=================
+    my($hwnd) = @_;
+    my $name = " " x 1024;
+    my $nameLen = 1024;
+    my $result = $GetClassName->Call($hwnd, $name, $nameLen);
+    if($result) {
+        return substr($name, 0, $result);
+    } else {
+        return "";
+    }
+}
+
+#=================
+sub GetCursorPos {
+#=================
+    my $POINT = pack("LL", 0, 0);
+    $GetCursorPos->Call($POINT);
+    return wantarray ? unpack("LL", $POINT) : $POINT;
+}
+
+#====================
+sub WindowFromPoint {
+#====================
+    my($x, $y) = @_;
+    my $POINT = pack("LL", $x, $y);
+    return $WindowFromPoint->Call($x, $y);
+}
+
+#==================
+sub GetWindowText {
+#==================
+    my($hwnd) = @_;
+    my $title = " " x 1024;
+    my $titleLen = 1024;
+    my $result = $GetWindowText->Call($hwnd, $title, $titleLen);
+    if($result) {
+        return substr($title, 0, $result);
+    } else {
+        return "";
+    }
+}
+
+#==================
+sub GetWindowRect {
+#==================
+    my($hwnd) = @_;
+    my $RECT = pack("iiii", 0, 0);
+    $GetWindowRect->Call($hwnd, $RECT);
+    return wantarray ? unpack("iiii", $RECT) : $RECT;
+}
+
+#==================
+sub OutputWinInfo {
+#==================
+    my($HWND, $level) = @_;
+#    print "OutputWinInfo.level = $level\n";
+    print "\t" x $level;
+    if($output{"handles"}) {
+        if ($output{"hex"}) {
+            printf("(%x) ", $HWND);
+        } else {
+            print "($HWND) ";
+        }
+    }
+    if($output{"titles"}) {
+        my $title = GetWindowText($HWND);
+        print " \"$title\"" if $title;
+    }
+    print "\n";
+    if($output{"classes"}) {
+        my $class = GetClassName($HWND);
+        print "\t" x $level;
+        print "\tClass: $class\n" if $class;
+    }
+    if($output{"sizes"}) {
+        my ($left, $top, $right, $bottom) = GetWindowRect($HWND);
+        print "\t" x $level;
+        print "\tPosition: ($left, $top)\n";
+        my $width = $right-$left;
+        my $height = $bottom-$top;
+        print "\t" x $level;
+        print "\tSize: ($width x $height)\n";
+    }
+    if($output{"styles"}) {
+        my $style = $GetWindowLong->Call($HWND, -16);
+        print "\t" x $level;
+        printf("\tStyle: %X\n", $style);
+        my $exstyle = $GetWindowLong->Call($HWND, -20);
+        print "\t" x $level;
+        printf("\tExtended Style: %X\n", $exstyle);
+    }
+}
+
+#===============
+sub FindChilds {
+#===============
+    my($parent, $hwnd, $level) = @_;
+    my $Child;
+    my $NextChild;
+    my $left;
+    my $right;
+    my $top;
+    my $bottom;
+    my $height;
+    my $width;
+    my $class;
+    my $text;
+    my $style;
+    my $args;
+    my $child;
+    my $header;
+
+    $Child = $GetWindow->Call($hwnd, 5);
+    $level++;
+    $header = "\t" x $level."Child windows:\n";
+    while($Child != 0) {
+        if($header) {
+            print $header;
+            undef $header;
+        }
+        OutputWinInfo($Child, $level);
+        FindChilds(\$child, $Child, $level);
+        $NextChild = $GetWindow->Call($Child, 2);
+        $Child = $NextChild;
+    }
+}
+
+
+#=========
+sub help {
+#=========
+    print <<END_OF_HELP;
+
+WinInfo version $VERSION
+by Aldo Calpini <dada\@perl.it>
+
+Usage: perl $0 [options]
+
+Options:
+    -o:[flags]: output the following informations:
+        h: window handles
+        t: window titles
+        c: window classes
+        s: window sizes
+        y: window styles
+        Default is '-o:htcsy' (all of them)
+
+    -r: recurse child windows       
+
+    -x: show handles in hexadecimal format
+
+END_OF_HELP
+}
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/t/01_basic.t perl-libwin32-0.191/GUI/t/01_basic.t
--- libwin32-0.191/GUI/t/01_basic.t	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/t/01_basic.t	2004-01-12 16:46:42.921875000 -0800
@@ -0,0 +1,17 @@
+#!perl -w
+# Before `make install' is performed this script should be runnable with
+# `make test'. After `make install' it should work as `perl test.pl'
+
+use strict;
+use vars qw( $loaded $clip $actual );
+
+######################### We start with some black magic to print on failure.
+
+BEGIN { $| = 1; print "1..1\n"; }
+END {print "not ok 1\n" unless $loaded;}
+use Win32::GUI;
+$loaded = 1;
+print "ok 1\n";
+
+######################### End of black magic.
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/t/02_window.t perl-libwin32-0.191/GUI/t/02_window.t
--- libwin32-0.191/GUI/t/02_window.t	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/t/02_window.t	2004-01-12 16:46:42.968750000 -0800
@@ -0,0 +1,50 @@
+#!perl -w
+# Before `make install' is performed this script should be runnable with
+# `make test'. After `make install' it should work as `perl test.pl'
+
+use strict;
+use vars qw( $loaded $clip $actual );
+
+######################### We start with some black magic to print on failure.
+
+BEGIN { $| = 1; print "1..9\n"; }
+END {print "not ok 1\n" unless $loaded;}
+use Win32::GUI;
+$loaded = 1;
+print "ok 1\n";
+
+######################### End of black magic.
+
+my $W = new Win32::GUI::Window(
+    -name => "TestWindow",
+    -pos  => [  0,   0],
+    -size => [100, 100],
+    -text => "TestWindow",
+);
+print ((defined $W and ref($W) =~ /Win32::GUI::Window/) ? "" : "not ");
+print "ok 2\n";
+
+print (($W->Left == 0) ? "" : "not ");
+print "ok 3\n";
+
+print (($W->Top == 0) ? "" : "not ");
+print "ok 4\n";
+
+$W->Left(100);
+print (($W->Left == 100) ? "" : "not ");
+print "ok 5\n";
+
+$W->Top(100);
+print (($W->Top == 100) ? "" : "not ");
+print "ok 6\n";
+
+$W->Move(0, 0);
+print (($W->Left == 0 && $W->Top == 0) ? "" : "not ");
+print "ok 7\n";
+
+print (($W->Text eq "TestWindow") ? "" : "not ");
+print "ok 8\n";
+
+$W->Text("TestChanged");
+print (($W->Text eq "TestChanged") ? "" : "not ");
+print "ok 9\n";
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/t/03_button.t perl-libwin32-0.191/GUI/t/03_button.t
--- libwin32-0.191/GUI/t/03_button.t	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/t/03_button.t	2004-01-12 16:46:43.000000000 -0800
@@ -0,0 +1,59 @@
+#!perl -w
+# Before `make install' is performed this script should be runnable with
+# `make test'. After `make install' it should work as `perl test.pl'
+
+use strict;
+use vars qw( $loaded $clip $actual );
+
+######################### We start with some black magic to print on failure.
+
+BEGIN { $| = 1; print "1..10\n"; }
+END {print "not ok 1\n" unless $loaded;}
+use Win32::GUI;
+$loaded = 1;
+print "ok 1\n";
+
+######################### End of black magic.
+
+my $W = new Win32::GUI::Window(
+    -name => "TestWindow",
+    -pos  => [  0,   0],
+    -size => [100, 100],
+    -text => "TestWindow",
+);
+print ((defined $W) ? "" : "not ");
+print "ok 2\n";
+
+my $B = $W->AddButton(
+    -name => "TestButton",
+    -pos  => [  0,   0],
+    -text => "TestButton",
+);
+
+print ((defined $B and ref($B) =~ /Win32::GUI::Button/) ? "" : "not ");
+print "ok 3\n";
+
+print ((defined $W->{TestButton}) ? "" : "not ");
+print "ok 4\n";
+
+print ((defined $W->TestButton) ? "" : "not ");
+print "ok 5\n";
+
+print (($B->Left == 0) ? "" : "not ");
+print "ok 6\n";
+
+print (($B->Top == 0) ? "" : "not ");
+print "ok 7\n";
+
+$W->TestButton->Left(100);
+print (($W->TestButton->Left == 100) ? "" : "not ");
+print "ok 8\n";
+
+$W->Top(100);
+print (($W->Top == 100) ? "" : "not ");
+print "ok 9\n";
+
+$W->Move(0, 0);
+print (($W->Left == 0 && $W->Top == 0) ? "" : "not ");
+print "ok 10\n";
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/typemap perl-libwin32-0.191/GUI/typemap
--- libwin32-0.191/GUI/typemap	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/typemap	2004-01-12 16:46:43.015625000 -0800
@@ -0,0 +1,61 @@
++# $Id: typemap,v 1.4 2003/12/19 09:14:43 caelum Exp $
+TYPEMAP
+HWND         T_HANDLE
+HMENU        T_HANDLE
+HICON        T_HANDLE
+HCURSOR      T_HANDLE
+HBITMAP      T_HANDLE
+HFONT        T_HANDLE
+HGDIOBJ      T_HANDLE
+HIMAGELIST   T_HANDLE
+HDC          T_HANDLE
+HBRUSH       T_HANDLE
+HPEN         T_HANDLE
+HTREEITEM    T_HANDLE
+LONG         T_IV
+LPCTSTR      T_PV
+LPTSTR       T_PV
+DWORD        T_IV
+UINT         T_IV
+BOOL         T_IV
+WPARAM       T_IV
+LPARAM       T_LPARAM
+LRESULT      T_IV
+HINSTANCE    T_UV
+COLORREF     T_COLOR
+LPCSTR       T_PV
+HENHMETAFILE T_UV
+FLOAT        T_FLOAT
+LPVOID       T_PV
+HACCEL       T_UV
+
+################################################################################
+INPUT
+T_HANDLE
+    if(SvROK($arg)) {
+        if(hv_fetch((HV*)SvRV($arg), \"-handle\", 7, 0) != NULL)
+            $var = ($type)(DWORD)SvIV(*(hv_fetch((HV*)SvRV($arg), \"-handle\", 7, 0)));
+        else
+            $var = NULL;
+    } else
+        $var = ($type)(DWORD)SvIV($arg);
+T_COLOR
+    $var = ($type) SvCOLORREF(NOTXSCALL $arg);
+T_UV    
+    $var= ($type)(DWORD)SvUV($arg)
+T_LPARAM
+    if(SvPOK($arg))
+      $var = ($type)(DWORD) SvPV_nolen($arg);
+    else
+      $var = ($type)(DWORD) SvIV($arg);
+
+################################################################################
+OUTPUT
+T_HANDLE
+    sv_setiv($arg, (IV)(DWORD)$var);
+T_COLOR
+    sv_setiv($arg, (IV) $var);
+T_UV    
+    if(  ! SvREADONLY($arg)  )
+        sv_setuv( $arg, (UV)(DWORD)$var );
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/GUI/vsplit.cur perl-libwin32-0.191/GUI/vsplit.cur
--- libwin32-0.191/GUI/vsplit.cur	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/GUI/vsplit.cur	2004-01-12 16:46:43.031250000 -0800
@@ -0,0 +1 @@
+          0  &          V  (       @                                                                           @                    @                                  ??            ??(                                          @       p              p       @      ?                                      ?    
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/IPC/IPC.xs perl-libwin32-0.191/IPC/IPC.xs
--- libwin32-0.191/IPC/IPC.xs	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/IPC/IPC.xs	2004-01-12 16:46:43.046875000 -0800
@@ -1,5 +1,5 @@
 //--------------------------------------------------------------------
-// $Id$
+// $Id: IPC.xs,v 1.1.1.1 2003/01/28 18:59:31 caelum Exp $
 //--------------------------------------------------------------------
 //
 //   Win32::IPC
@@ -9,15 +9,9 @@
 //
 //--------------------------------------------------------------------
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
-
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-
+#include "../win32perl.h"
+#include <wininet.h>
+#include <winver.h>
 
 static IV
 WaitForMultiple(AV* hArray, BOOL fWaitAll, DWORD dwTimeOut)
@@ -59,12 +53,12 @@
       PUTBACK;
       result = perl_call_method("get_process_handle", G_SCALAR|G_EVAL);
       SPAGAIN;
-      if ((result == 1) && SvIOKp(TOPs)) handle = (HANDLE)POPi;
+      if ((result == 1) && SvIOKp(TOPs)) handle = (HANDLE)(DWORD)POPi;
       PUTBACK;
       FREETMPS;
       LEAVE;
     } else if (sv_derived_from(*svpp,"Win32::IPC")) {
-      handle = (HANDLE)(SvIV(SvRV(*svpp)));
+      handle = (HANDLE)(DWORD)(SvIV(SvRV(*svpp)));
     } else {
       croak("Don't know how to wait on $objects[%d]",i);
       return IV_MAX;
@@ -111,14 +105,12 @@
 IV
 wait_any(objects,timeout=INFINITE)
 	SV *  objects
-	BOOL  waitall
 	DWORD timeout
 ALIAS:
 	wait_all = 1
 PROTOTYPE: \@;$
 PREINIT:
 	AV *	av;
-	DWORD 	ret;
 CODE:
 	if (!(SvROK(objects)
 	      && (av = (AV*)SvRV(objects))
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/IPC/typemap perl-libwin32-0.191/IPC/typemap
--- libwin32-0.191/IPC/typemap	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/IPC/typemap	2004-01-12 16:46:43.046875000 -0800
@@ -7,7 +7,7 @@
 T_PTROBJ
 	if (sv_derived_from($arg, \"${Package}\")) {
 	    IV tmp = SvIV((SV*)SvRV($arg));
-	    $var = ($type) tmp;
+	    $var = ($type)(DWORD) tmp;
 	}
 	else
 	    croak(\"$var is not of type ${Package}\")
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Internet/Internet.pm perl-libwin32-0.191/Internet/Internet.pm
--- libwin32-0.191/Internet/Internet.pm	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/Internet/Internet.pm	2004-01-12 16:46:43.062500000 -0800
@@ -20,6 +20,7 @@
 require Exporter;       # to export the constants to the main:: space
 require DynaLoader;     # to dynuhlode the module.
 
+use Win32;
 # use Win32::WinError;    # for windows constants.
 
 @ISA= qw( Exporter DynaLoader );
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Internet/Internet.xs perl-libwin32-0.191/Internet/Internet.xs
--- libwin32-0.191/Internet/Internet.xs	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/Internet/Internet.xs	2004-01-12 16:46:43.078125000 -0800
@@ -9,46 +9,8 @@
  *
  */
 
-// Basic includes
-#define  WIN32_LEAN_AND_MEAN
-// #include <math.h>
-#include <windows.h>
-
-// Extension specific includes
+#include "../win32perl.h"
 #include <wininet.h>
-#include <winver.h>
-
-#define __TEMP_WORD  WORD	/* perl defines a WORD, yikes! */
-
-// Perl includes
-#if (defined(__cplusplus) && !defined(PERL_OBJECT))
-extern "C" {
-#endif
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-#if (defined(__cplusplus) && !defined(PERL_OBJECT))
-}
-#endif
-
-#undef WORD
-#define WORD __TEMP_WORD
-
-#ifndef PERL_VERSION
-#  include "patchlevel.h"
-#  define PERL_REVISION		5
-#  define PERL_VERSION		PATCHLEVEL
-#  define PERL_SUBVERSION	SUBVERSION
-#endif
-
-#if PERL_REVISION == 5 && (PERL_VERSION < 4 || \
-			   (PERL_VERSION == 4 && PERL_SUBVERSION <= 75))
-#  define PL_sv_undef		sv_undef
-#  define PL_sv_yes		sv_yes
-#  define PL_sv_no		sv_no
-#  define PL_na			na
-#  define PL_dowarn		dowarn
-#endif
 
 // Section for the constant definitions.
 #define CROAK croak
@@ -973,7 +935,6 @@
     HINTERNET handle
     DWORD option
 PPCODE:
-    DWORD mysize;
     char *mybuf;
     long mybufsz = 16000;
     DWORD mynum;
@@ -1036,7 +997,6 @@
     DWORD mysize;
     void *mybuf;
     long mybufsz = 16000;
-    BOOL myquerystatus;
     DWORD mynum;
     BOOL myretval;
     STRLEN len;
@@ -1096,7 +1056,7 @@
     // printf("ITFST %d:%d:%d %d/%d/%d %d %d\n",st.wHour,st.wMinute,st.wSecond,
     //		st.wDay, st.wMonth, st.wYear, st.wDayOfWeek,RFC;
 
-    if (InternetTimeFromSystemTime((CONST SYSTEMTIME *)&st,
+    if (InternetTimeFromSystemTime((SYSTEMTIME *)&st,
 				  RFC,
 				  (LPSTR)&mybuffer,
 				  (DWORD)sizeof(mybuffer)))
@@ -1145,7 +1105,7 @@
     myURL.dwSchemeLength=mysize;
     myURL.lpszHostName=(char *)safemalloc(mysize);
     myURL.dwHostNameLength=mysize;
-    myURL.nPort=mysize;
+    myURL.nPort=(INTERNET_PORT)mysize;
     myURL.lpszUserName=(char *)safemalloc(mysize);
     myURL.dwUserNameLength=mysize;
     myURL.lpszPassword=(char *)safemalloc(mysize);
@@ -1190,7 +1150,7 @@
     myURL.dwStructSize=sizeof(myURL);
     myURL.lpszScheme	= SvPV(scheme, len); myURL.dwSchemeLength = len;
     myURL.lpszHostName	= SvPV(hostname, len); myURL.dwHostNameLength = len;
-    myURL.nPort		= port;
+    myURL.nPort		= (INTERNET_PORT)port;
     myURL.lpszUserName	= SvPV(username, len); myURL.dwUserNameLength = len;
     myURL.lpszPassword	= SvPV(password, len); myURL.dwPasswordLength = len;
     myURL.lpszUrlPath	= SvPV(path, len); myURL.dwUrlPathLength = len;
@@ -1336,7 +1296,6 @@
     HINTERNET myhandle;
     WIN32_FIND_DATA myfile;
     SYSTEMTIME mytime;
-    unsigned long myCreationTime, myLastAccessTime, myLastWriteTime;
     unsigned long myFileSize;	
 
     if (myhandle = FtpFindFirstFile(handle, pattern,
@@ -1387,7 +1346,6 @@
 PPCODE:
     WIN32_FIND_DATA myfile;
     SYSTEMTIME mytime;
-    unsigned long myCreationTime, myLastAccessTime, myLastWriteTime;
     unsigned long myFileSize;	
 
     if (InternetFindNextFile(handle, &myfile)) {
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Internet/Makefile.PL perl-libwin32-0.191/Internet/Makefile.PL
--- libwin32-0.191/Internet/Makefile.PL	2002-07-08 17:15:51.000000000 -0700
+++ perl-libwin32-0.191/Internet/Makefile.PL	2004-01-12 16:46:43.093750000 -0800
@@ -1,13 +1,12 @@
 use ExtUtils::MakeMaker;
 use Config;
-my $inetlib = 'wininet';
-$inetlib = 'inet' if $Config{'cc'} =~ /^bcc32/i;
+
 WriteMakefile(
     'NAME'		=> 'Win32::Internet',
     'VERSION_FROM'	=> 'Internet.pm', # finds $VERSION
+    'PM'		=> { 'Internet.pm' => '$(INST_LIBDIR)/Internet.pm' },
     'dist'		=> {COMPRESS => 'gzip -9f', SUFFIX => 'gz'},
-    'LIBS'		=> [ ":nosearch ${inetlib}.lib" ],
-    'INC'	=> '-I.',
+    'INC'		=> '-I.',
     ($] < 5.005 ? () :
       (
 	'AUTHOR'	=> 'Aldo Calpini <dada@divinf.it>',
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Internet/mingw32.exc perl-libwin32-0.191/Internet/mingw32.exc
--- libwin32-0.191/Internet/mingw32.exc	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/Internet/mingw32.exc	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Internet/typemap perl-libwin32-0.191/Internet/typemap
--- libwin32-0.191/Internet/typemap	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/Internet/typemap	2004-01-12 16:46:43.109375000 -0800
@@ -5,3 +5,15 @@
 BOOL                    T_IV
 LPTSTR                  T_PV
 HINTERNET               T_IV
+
+#############################################################################
+INPUT
+
+T_IV
+	$var = ($type)(DWORD)SvIV($arg)
+
+#############################################################################
+OUTPUT
+
+T_IV
+	sv_setiv($arg, (IV)(DWORD)$var);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Job/Job.pm perl-libwin32-0.191/Job/Job.pm
--- libwin32-0.191/Job/Job.pm	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/Job/Job.pm	2004-01-12 16:46:43.125000000 -0800
@@ -3,6 +3,7 @@
 use strict;
 use base qw(DynaLoader);
 use vars qw($VERSION);
+use Win32;
 
 $VERSION = '0.01';
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Job/Job.xs perl-libwin32-0.191/Job/Job.xs
--- libwin32-0.191/Job/Job.xs	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/Job/Job.xs	2004-01-12 16:46:43.140625000 -0800
@@ -1,9 +1,7 @@
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x0500
-#include <windows.h>
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
+#include "../win32perl.h"
 
 #define NEWZ_CONST_INT 413
 #define KILL_EXITCODE  293
@@ -19,14 +17,6 @@
 #define JOB_OBJECT_LIMIT_BREAKAWAY_OK 0x00000800
 #endif
 
-/* For non-threaded Perl */
-#ifndef pTHX
-#define pTHX	/* empty */
-#define aTHX	/* empty */
-#define pTHX_	/* empty */
-#define aTHX_	/* empty */
-#endif
-
 /* This structure contains the HANDLE for the job object, plus an
  * array of pointers to PROCESS_INFORMATION structures (one for each
  * process spawn()ed). We remember these so we can call CloseHandle()
@@ -73,7 +63,7 @@
 new_handle(pTHX_ HANDLE file)
 {
 	SV* rv = newSViv(0); /* blank SV */
-	sv_setref_iv(rv, "Win32::Job::_handle", (IV)file);
+	sv_setref_iv(rv, "Win32::Job::_handle", (IV)(DWORD)file);
 	return rv;
 }
 
@@ -208,7 +198,7 @@
 	HANDLE h;
     CODE:
 	iv = SvIV(SvRV(self));
-	h  = (HANDLE)iv;
+	h  = (HANDLE)(DWORD)iv;
 	if (h) CloseHandle(h);
 
 MODULE = Win32::Job	PACKAGE = Win32::Job
@@ -222,7 +212,7 @@
 	JOB_T	job;
     CODE:
 	Newz(NEWZ_CONST_INT, job, 1, job_t);
-	job->hJob  = CreateJobObject(NULL, NULL); /* unnamed job */
+	job->hJob  = (HANDLE)CreateJobObject(NULL, NULL); /* unnamed job */
 	job->procs = newAV();
 	job->info  = newHV();
 	RETVAL = job;
@@ -303,7 +293,7 @@
 	    char *curr = path;
 	    char *endp = strchr(curr, ';');
 	    int len;
-	    struct stat sbuf;
+	    struct stat     sbuf;
 	    while (endp) {
 		len = (int)(endp - curr);
 		strncpy(pbuf, curr, len);
@@ -527,7 +517,7 @@
 	    which = 0;     /* wait for ANY process to complete */
 	if (!interval)
 	    XSRETURN_UNDEF; /* you suck, programmer! */
-	dwInterval = interval * 1000;
+	dwInterval = (DWORD)(interval * 1000);
 	for (i = 0; i < imax; i++) {
 	    STRLEN l;
 	    SV *tmp = *av_fetch(self->procs, i, 0);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Job/test.pl perl-libwin32-0.191/Job/test.pl
--- libwin32-0.191/Job/test.pl	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/Job/test.pl	2004-01-12 16:46:43.140625000 -0800
@@ -1,8 +1,14 @@
 use Config;
 use Data::Dumper;
+use Win32;
 use Win32::Job;
 
 my $job;
+my $perlpath = $Config{perlpath};
+if ($^O eq 'cygwin') {
+	chomp($perlpath = `cygpath -w $perlpath`);
+	$perlpath .= '.exe' if $perlpath !~ /\.exe$/;
+}
 
 # Processes you spawn in the job are initially suspended. You can activate
 # them by using one of the following functions. This allows you to run several 
@@ -12,12 +18,12 @@
 # is one way to implement your own timeout, for example. The watchdog is passed
 # the $job object.
 $job = Win32::Job->new;
-$job->spawn($Config{perlpath}, "perl child.t", {
+$job->spawn($perlpath, "perl child.t", {
 	stdin => 'NUL',
 	stdout => 'stdout.txt',
 	stderr => 'stdout.txt',
 });
-$job->spawn($Config{perlpath}, "perl -le \"print \$\$\"");
+$job->spawn($perlpath, "perl -le \"print \$\$\"");
 $job->spawn("cmd", q{cmd /C "echo %PATH%"});
 $i = 0;
 $job->watch(sub {
@@ -32,7 +38,7 @@
 # you're letting it run with no timeout at all (and you might as well use a 
 # simpler module).
 $job = Win32::Job->new;
-$job->spawn($Config{perlpath}, "perl child.t"); #, {new_console => 1});
+$job->spawn($perlpath, "perl child.t"); #, {new_console => 1});
 $job->run(10);
 print Dumper $job->status;
 print "$^E\n";
@@ -40,7 +46,7 @@
 # You can call kill() explicitly to kill the job and all of its subprocesses.
 # You could do this from a watchdog timer, for example.
 $job = Win32::Job->new;
-$job->spawn($Config{perlpath}, "perl child.t");
+$job->spawn($perlpath, "perl child.t");
 $job->run(1);
 print Dumper $job->status;
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Job/typemap perl-libwin32-0.191/Job/typemap
--- libwin32-0.191/Job/typemap	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/Job/typemap	2004-01-12 16:46:43.156250000 -0800
@@ -4,7 +4,7 @@
 T_JOB
         if (sv_derived_from($arg, \"Win32::Job\")) {
             IV tmp = SvIV((SV*)SvRV($arg));
-            $var = ($type) tmp;
+            $var = ($type)(DWORD) tmp;
         }
         else
             croak(\"$var is not of type Win32::Job\")
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/MANIFEST perl-libwin32-0.191/MANIFEST
--- libwin32-0.191/MANIFEST	2002-07-08 17:28:22.000000000 -0700
+++ perl-libwin32-0.191/MANIFEST	2004-01-12 16:46:43.171875000 -0800
@@ -13,8 +13,8 @@
 APIFile/ex/DiskGeom.plx
 APIFile/ex/FormatFloppy.plx
 APIFile/ex/ListDevs.plx
-APIFile/ppport.h
 APIFile/test.pl
+APIFile/t/tie.t
 APIFile/typemap
 APINet/Changes
 APINet/MANIFEST
@@ -22,7 +22,6 @@
 APINet/Net.html
 APINet/Net.pm
 APINet/Net.xs
-APINet/mingw32.exc
 APINet/t/test.t
 APIRegistry/Changes
 APIRegistry/ExtUtils/Myconst2perl.pm
@@ -35,7 +34,6 @@
 APIRegistry/cRegistry.h
 APIRegistry/cRegistry.pc
 APIRegistry/const2perl.h
-APIRegistry/ppport.h
 APIRegistry/test.pl
 APIRegistry/typemap
 ChangeNotify/ChangeNotify.pm
@@ -94,7 +92,6 @@
 FileSecurity/FileSecurity.xs
 FileSecurity/MANIFEST
 FileSecurity/Makefile.PL
-FileSecurity/mingw32.exc
 FileSecurity/test.pl
 IPC/Changes
 IPC/IPC.pm
@@ -115,7 +112,6 @@
 Internet/docs/license.html
 Internet/docs/reference.html
 Internet/docs/toc.html
-Internet/mingw32.exc
 Internet/test-async.pl
 Internet/test.pl
 Internet/typemap
@@ -140,14 +136,12 @@
 NetAdmin/Makefile.PL
 NetAdmin/NetAdmin.pm
 NetAdmin/NetAdmin.xs
-NetAdmin/mingw32.exc
 NetAdmin/t/netadmin.t
 NetResource/Changes
 NetResource/MANIFEST
 NetResource/Makefile.PL
 NetResource/NetResource.pm
 NetResource/NetResource.xs
-NetResource/mingw32.exc
 NetResource/t/netresource.t
 NetResource/typemap
 ODBC/CMom.cpp
@@ -157,7 +151,7 @@
 ODBC/Constant.cpp
 ODBC/Constant.h
 ODBC/HISTORY.TXT
-ODBC/Icon2.ico
+ODBC/ODBC.ico
 ODBC/MANIFEST
 ODBC/Makefile.PL
 ODBC/ODBC.h
@@ -171,7 +165,6 @@
 ODBC/Test.pl
 ODBC/docs/object.html
 ODBC/docs/odbc.html
-ODBC/mingw32.exc
 ODBC/resource.h
 OLE/Changes			Lowlevel changelog
 OLE/MANIFEST
@@ -180,7 +173,6 @@
 OLE/OLE.xs
 OLE/README
 OLE/ToDo
-OLE/hints/cygwin.pl
 OLE/lib/OLE.pm			Compatibility layer: old toplevel OLE.pm
 OLE/lib/Win32/OLE/Const.pm	Win32::OLE::Const module: TypeLib constants
 OLE/lib/Win32/OLE/Enum.pm	Win32::OLE::Enum module: Collection objects
@@ -226,7 +218,6 @@
 PerfLib/PerfLib.pm
 PerfLib/PerfLib.xs
 PerfLib/calc.html
-PerfLib/mingw32.exc
 PerfLib/test.pl
 PerfLib/typemap
 Pipe/Client.pl
@@ -239,7 +230,6 @@
 Pipe/Pipe.xs
 Pipe/README
 Pipe/Server.pl
-Pipe/mingw32.exc
 Pipe/test.bat
 Process/Changes
 Process/MANIFEST
@@ -247,7 +237,6 @@
 Process/Process.hpp
 Process/Process.pm
 Process/Process.xs
-Process/mingw32.exc
 Process/test.pl
 Process/typemap
 README
@@ -284,7 +273,6 @@
 Shortcut/docs/reference.html
 Shortcut/docs/toc.html
 Shortcut/ln32.bat
-Shortcut/mingw32.exc
 Shortcut/test.pl
 Shortcut/typemap
 Sound/MANIFEST
@@ -292,7 +280,6 @@
 Sound/README
 Sound/Sound.pm
 Sound/Sound.xs
-Sound/mingw32.exc
 Sound/test.pl
 Sound/samples/welcome.wav
 Sound/samples/devices.pl
@@ -314,4 +301,216 @@
 WinError/Makefile.PL
 WinError/WinError.pm
 WinError/WinError.xs
+WinError/t/winerror.t
 ppport.h
+win32perl.h
+hints/cygwin.pl
+hints/MSWin32.pl
+GUI/Animation.xs
+GUI/Bitmap.xs
+GUI/BUGS
+GUI/DC.xs
+GUI/Font.xs
+GUI/BitmapInline.pm
+GUI/GridLayout.pm
+GUI/GUI.h
+GUI/GUI.pm
+GUI/GUI.rc
+GUI/GUI.xs
+GUI/guiperl.ico
+GUI/GUI_Constants.cpp
+GUI/GUI_Events.cpp
+GUI/GUI_Helpers.cpp
+GUI/GUI_MessageLoops.cpp
+GUI/GUI_Options.cpp
+GUI/hsplit.cur
+GUI/ImageList.xs
+GUI/Label.xs
+GUI/Listbox.xs
+GUI/ListView.xs
+GUI/Makefile.PL
+GUI/MANIFEST
+GUI/NotifyIcon.xs
+GUI/README
+GUI/README.txt
+GUI/CHANGELOG
+GUI/Rebar.xs
+GUI/resource.h
+GUI/RichEdit.xs
+GUI/samples/alarm.bmp
+GUI/samples/bitmap.pl
+GUI/samples/buttons.pl
+GUI/samples/camel.ico
+GUI/samples/cf.pl
+GUI/samples/class.pl
+GUI/samples/close.bmp
+GUI/samples/cmeta.pl
+GUI/samples/combobox.pl
+GUI/samples/dc.pl
+GUI/samples/dll.bmp
+GUI/samples/draw.pl
+GUI/samples/folder.bmp
+GUI/samples/frm2pl.pl
+GUI/samples/harrow.cur
+GUI/samples/hello.pl
+GUI/samples/listbox.pl
+GUI/samples/listview.pl
+GUI/samples/module.bmp
+GUI/samples/mousemove.pl
+GUI/samples/msk.pl
+GUI/samples/nem_lv.pl
+GUI/samples/nem_tv.pl
+GUI/samples/node.bmp
+GUI/samples/node_sel.bmp
+GUI/samples/ofn.pl
+GUI/samples/one.bmp
+GUI/samples/pmx.html
+GUI/samples/pmx.pl
+GUI/samples/Pod/RTF.pm
+GUI/samples/podview.pl
+GUI/samples/ppmrepa.bmp
+GUI/samples/ppmrepc.bmp
+GUI/samples/ppmrepf.bmp
+GUI/samples/ppmrepi.bmp
+GUI/samples/ppmrepl.bmp
+GUI/samples/ppmrepn.bmp
+GUI/samples/ppmrepo.bmp
+GUI/samples/ppmrepr.bmp
+GUI/samples/pride.pl
+GUI/samples/progressbar.pl
+GUI/samples/richedit.pl
+GUI/samples/sfn.pl
+GUI/samples/slider.pl
+GUI/samples/splitter.pl
+GUI/samples/tabstrip.pl
+GUI/samples/test.msk
+GUI/samples/test2.msk
+GUI/samples/textfield.pl
+GUI/samples/three.bmp
+GUI/samples/timer.pl
+GUI/samples/toolbar.pl
+GUI/samples/tools.bmp
+GUI/samples/treeview.pl
+GUI/samples/two.bmp
+GUI/samples/unkfolder.bmp
+GUI/samples/vmeta.pl
+GUI/samples/winlist.pl
+GUI/samples/winppm.ini
+GUI/samples/winppm.pl
+GUI/samples/winsize.pl
+GUI/samples/Zapotec.bmp
+GUI/samples/DateTime.pl
+GUI/samples/nemtimer.pl
+GUI/samples/res.txt
+GUI/samples/richedit.rtf
+GUI/samples/tt.pl
+GUI/docs/archdraft.html
+GUI/docs/archdraft.pod
+GUI/docs/dodoc.pl
+GUI/docs/dodoc2.pl
+GUI/docs/dohtml.pl
+GUI/docs/events.pod
+GUI/docs/GUI.pod
+GUI/docs/guiconcepts.pod
+GUI/docs/guioptions.pod
+GUI/docs/html/AcceleratorTable.html
+GUI/docs/html/Animation.html
+GUI/docs/html/archdraft.html
+GUI/docs/html/Bitmap.html
+GUI/docs/html/BitmapInline.html
+GUI/docs/html/Brush.html
+GUI/docs/html/Button.html
+GUI/docs/html/Checkbox.html
+GUI/docs/html/Class.html
+GUI/docs/html/Combobox.html
+GUI/docs/html/ComboboxEx.html
+GUI/docs/html/Cursor.html
+GUI/docs/html/DateTime.html
+GUI/docs/html/DC.html
+GUI/docs/html/DialogBox.html
+GUI/docs/html/events.html
+GUI/docs/html/Font.html
+GUI/docs/html/Graphic.html
+GUI/docs/html/GridLayout.html
+GUI/docs/html/Groupbox.html
+GUI/docs/html/GUI.html
+GUI/docs/html/guiconcepts.html
+GUI/docs/html/guioptions.html
+GUI/docs/html/guipacks.html
+GUI/docs/html/Header.html
+GUI/docs/html/Icon.html
+GUI/docs/html/ImageList.html
+GUI/docs/html/Label.html
+GUI/docs/html/Listbox.html
+GUI/docs/html/Listbox_Item.html
+GUI/docs/html/ListView.html
+GUI/docs/html/ListView_Item.html
+GUI/docs/html/ListView_SubItem.html
+GUI/docs/html/MDI.html
+GUI/docs/html/Menu.html
+GUI/docs/html/MenuButton.html
+GUI/docs/html/MenuItem.html
+GUI/docs/html/methods.html
+GUI/docs/html/NotifyIcon.html
+GUI/docs/html/options.html
+GUI/docs/html/packages.html
+GUI/docs/html/Pen.html
+GUI/docs/html/ProgressBar.html
+GUI/docs/html/RadioButton.html
+GUI/docs/html/Rebar.html
+GUI/docs/html/RichEdit.html
+GUI/docs/html/Slider.html
+GUI/docs/html/Splitter.html
+GUI/docs/html/StatusBar.html
+GUI/docs/html/TabStrip.html
+GUI/docs/html/Textfield.html
+GUI/docs/html/Timer.html
+GUI/docs/html/Toolbar.html
+GUI/docs/html/Tooltip.html
+GUI/docs/html/TreeView.html
+GUI/docs/html/UpDown.html
+GUI/docs/html/Win32_GUI.html
+GUI/docs/html/Window.html
+GUI/docs/methods.pod
+GUI/docs/newbuild.pl
+GUI/docs/options.pod
+GUI/docs/packages.pod
+GUI/docs/style.css
+GUI/docs/tut/guitut1-1.gif
+GUI/docs/tut/guitut1-2.gif
+GUI/docs/tut/guitut1-3.gif
+GUI/docs/tut/guitut1.html
+GUI/docs/tut/guitut1.pod
+GUI/docs/tut/guitut2.html
+GUI/docs/tut/guitut2.pod
+GUI/docs/tut/guitut3.html
+GUI/docs/tut/guitut3.pod
+GUI/docs/tut/guitut4.html
+GUI/docs/tut/guitut4.pod
+GUI/docs/tut/guitut5-1.gif
+GUI/docs/tut/guitut5-2.gif
+GUI/docs/tut/guitut5.html
+GUI/docs/tut/guitut5.pod
+GUI/docs/tut/guitut9.html
+GUI/docs/tut/guitut9.pod
+GUI/docs/tut/morethanone.pl
+GUI/t/01_basic.t
+GUI/t/02_window.t
+GUI/t/03_button.t
+GUI/TabStrip.xs
+GUI/Textfield.xs
+GUI/TODO
+GUI/Toolbar.xs
+GUI/TreeView.xs
+GUI/Splitter.xs
+GUI/typemap
+GUI/vsplit.cur
+Win32CORE/Changes
+Win32CORE/Makefile.PL
+Win32CORE/MANIFEST
+Win32CORE/t/win32core.t
+Win32CORE/Win32CORE.c
+Win32CORE/Win32CORE.pm
+CYGWIN-PATCHES/perl-libwin32-0.191-1.sh
+CYGWIN-PATCHES/README
+CYGWIN-PATCHES/setup.hint
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Makefile.PL perl-libwin32-0.191/Makefile.PL
--- libwin32-0.191/Makefile.PL	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/Makefile.PL	2004-01-12 16:46:43.187500000 -0800
@@ -1,10 +1,83 @@
 use ExtUtils::MakeMaker;
+use ExtUtils::MM;
+
+my @extensions = qw(
+	Win32CORE APIFile APINet APIRegistry ChangeNotify Clipboard Console
+	Event EventLog File FileSecurity Internet IPC Job Mutex NetAdmin
+	NetResource ODBC OLE PerfLib Pipe Process Registry Semaphore Service
+	Shortcut Sound TieRegistry WinError GUI
+);
+
+LinkHints();
+
+# Man pages don't get generated, so I just built a list manually for now.
+my %MAN3PODS = (
+	'APIFile/File.pm'			=> 	'Win32API/File',
+	'APINet/Net.pm'				=>	'Win32API/Net',
+	'APIRegistry/Registry.pm'		=>	'Win32API/Registry',
+	'ChangeNotify/ChangeNotify.pm'		=>	'Win32/ChangeNotify',
+	'Clipboard/Clipboard.pm'		=>	'Win32/Clipboard',
+	'Console/Console.pm'			=>	'Win32/Console',
+	'Event/Event.pm'			=>	'Win32/Event',
+	'EventLog/EventLog.pm'			=>	'Win32/EventLog',
+	'File/File.pm'				=>	'Win32/File',
+	'FileSecurity/FileSecurity.pm'		=>	'Win32/FileSecurity',
+	'GUI/BitmapInline.pm'			=>	'Win32/GUI/BitmapInline',
+	'GUI/docs/archdraft.pod'		=>	'Win32/GUI/archdraft',
+	'GUI/docs/events.pod'			=>	'Win32/GUI/events',
+	'GUI/docs/GUI.pod'			=>	'Win32/GUI',
+	'GUI/docs/guiconcepts.pod'		=>	'Win32/GUI/guiconcepts',
+	'GUI/docs/guioptions.pod'		=>	'Win32/GUI/guioptions',
+	'GUI/docs/methods.pod'			=>	'Win32/GUI/methods',
+	'GUI/docs/options.pod'			=>	'Win32/GUI/options',
+	'GUI/docs/packages.pod'			=>	'Win32/GUI/packages',
+	'GUI/docs/tut/guitut1.pod'		=>	'Win32/GUI/guitut1',
+	'GUI/docs/tut/guitut2.pod'		=>	'Win32/GUI/guitut2',
+	'GUI/docs/tut/guitut3.pod'		=>	'Win32/GUI/guitut3',
+	'GUI/docs/tut/guitut4.pod'		=>	'Win32/GUI/guitut4',
+	'GUI/docs/tut/guitut5.pod'		=>	'Win32/GUI/guitut5',
+	'GUI/docs/tut/guitut9.pod'		=>	'Win32/GUI/guitut9',
+	'GUI/GridLayout.pm'			=>	'Win32/GUI/GridLayout',
+	'Internet/Internet.pm'			=>	'Win32/Internet',
+	'IPC/IPC.pm'				=>	'Win32/IPC',
+	'Job/Job.pm'				=>	'Win32/Job',
+	'Mutex/Mutex.pm'			=>	'Win32/Mutex',
+	'NetAdmin/NetAdmin.pm'			=>	'Win32/NetAdmin',
+	'NetResource/NetResource.pm'		=>	'Win32/NetResource',
+	'ODBC/ODBC.pm'				=>	'Win32/ODBC',
+	'OLE/lib/Win32/OLE/Const.pm'		=>	'Win32/OLE/Const',
+	'OLE/lib/Win32/OLE/Enum.pm'		=>	'Win32/OLE/Enum',
+	'OLE/lib/Win32/OLE/NEWS.pod'		=>	'Win32/OLE/NEWS',
+	'OLE/lib/Win32/OLE/NLS.pm'		=>	'Win32/OLE/NLS',
+	'OLE/lib/Win32/OLE/TPJ.pod'		=>	'Win32/OLE/TPJ',
+	'OLE/lib/Win32/OLE/Variant.pm'		=>	'Win32/OLE/Variant',
+	'OLE/lib/Win32/OLE.pm'			=>	'Win32/OLE',
+	'PerfLib/PerfLib.pm'			=>	'Win32/PerfLib',
+	'Pipe/Pipe.pm'				=>	'Win32/Pipe',
+	'Process/Process.pm'			=>	'Win32/Process',
+	'Registry/Registry.pm'			=>	'Win32/Registry',
+	'Semaphore/Semaphore.pm'		=>	'Win32/Semaphore',
+	'Service/Service.pm'			=>	'Win32/Service',
+	'Sound/Sound.pm'			=>	'Win32/Sound',
+	'TieRegistry/TieRegistry.pm'		=>	'Win32/TieRegistry',
+	'Win32CORE/Win32CORE.pm'		=>	'Win32CORE',
+);
+
+for (values %MAN3PODS) {
+	$_ = '$(INST_MAN3DIR)/'.MM->replace_manpage_separator($_).'.$(MAN3EXT)';
+}
 
 WriteMakefile(
     NAME		=> 'Win32',
     DISTNAME		=> 'libwin32',
     VERSION_FROM	=> 'Win32.pm',
+    XS			=> { 'Win32.xs' => 'Win32.cpp' },
+    DIR			=> [@extensions],
+    MAN3PODS		=> { %MAN3PODS },
     'dist'		=> {COMPRESS => 'gzip -9f', SUFFIX => 'gz'},
+    clean		=> {FILES =>
+    	join ' ', map { "$_/hints" } @extensions
+    },
     ($] < 5.005 ? () :
       (
 	ABSTRACT	=> 'A collection of extensions that aims to provide '
@@ -13,22 +86,27 @@
       )),
 );
 
+sub MY::xs_c {
+    '
+.xs.cpp:
+	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs >xstmp.c && $(MV) xstmp.c $*.cpp
+';
+}
 
-package MY;
-use Config;
-sub post_initialize {
-    my $self = shift;
-    my @keep;
-    my $mingw32 = ($^O eq 'MSWin32') && ($Config{'cc'} =~ /^gcc/i);
-    warn "Not all subdirs build with Mingw32\n" if $mingw32;
-    foreach my $dir (@{$self->{'DIR'}}) {
-	if ($mingw32 && -f "$dir/mingw32.exc") {
-	    warn "Skipping $dir on Mingw32\n";
-	}
-	else {
-	    push(@keep,$dir);
+sub LinkHints {
+	use IO::File;
+	use File::Basename;
+
+	print "Creating hints files...\n";
+
+	my @hints = map { basename $_ } <hints/*.pl>;
+
+	for my $dir (@extensions) {
+		mkdir "$dir/hints";
+		for my $hint (@hints) {
+			my $file = new IO::File "> $dir/hints/$hint";
+			print $file
+qq{local \$/; open H, "../hints/$hint"; eval <H>; close H;\n};
+		}
 	}
-    }
-    $self->{DIR} = \@keep;
-    return $self->SUPER::post_initialize;
 }
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Mutex/Mutex.xs perl-libwin32-0.191/Mutex/Mutex.xs
--- libwin32-0.191/Mutex/Mutex.xs	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/Mutex/Mutex.xs	2004-01-12 16:46:43.187500000 -0800
@@ -1,5 +1,5 @@
 //--------------------------------------------------------------------
-// $Id$
+// $Id: Mutex.xs,v 1.1.1.1 2003/01/28 18:59:32 caelum Exp $
 //--------------------------------------------------------------------
 //
 //   Win32::Mutex
@@ -9,15 +9,7 @@
 //
 //--------------------------------------------------------------------
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
-
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-
+#include "../win32perl.h"
 
 MODULE = Win32::Mutex		PACKAGE = Win32::Mutex
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Mutex/typemap perl-libwin32-0.191/Mutex/typemap
--- libwin32-0.191/Mutex/typemap	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/Mutex/typemap	2004-01-12 16:46:43.203125000 -0800
@@ -7,7 +7,7 @@
 T_PTROBJ
 	if (sv_derived_from($arg, \"${Package}\")) {
 	    IV tmp = SvIV((SV*)SvRV($arg));
-	    $var = ($type) tmp;
+	    $var = ($type)(DWORD) tmp;
 	}
 	else
 	    croak(\"$var is not of type ${Package}\")
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/NetAdmin/NetAdmin.pm perl-libwin32-0.191/NetAdmin/NetAdmin.pm
--- libwin32-0.191/NetAdmin/NetAdmin.pm	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/NetAdmin/NetAdmin.pm	2004-01-12 16:46:43.218750000 -0800
@@ -9,6 +9,7 @@
 
 require Exporter;
 require DynaLoader;
+use Win32;
 
 die "The Win32::NetAdmin module works only on Windows NT" if(!Win32::IsWinNT() );
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/NetAdmin/NetAdmin.xs perl-libwin32-0.191/NetAdmin/NetAdmin.xs
--- libwin32-0.191/NetAdmin/NetAdmin.xs	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/NetAdmin/NetAdmin.xs	2004-01-12 16:46:43.234375000 -0800
@@ -16,24 +16,21 @@
  *    98.02.13 david.gardiner@unisa.edu.au
  */
 
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
+#include "../win32perl.h"
+
+#define FORCE_UNICODE	/* Avoid spurious warnings due to broken headers */
+
 #include <lmcons.h>     /* LAN Manager common definitions */
 #include <lmerr.h>      /* LAN Manager network error definitions */
-#include <lmUseFlg.h>
-#include <lmAccess.h>
-#include <lmAPIBuf.h>
+#include <lmuseflg.h>
+#include <lmaccess.h>
+#include <lmapibuf.h>
 #undef LPTSTR
 #define LPTSTR LPWSTR
-#include <lmServer.h>
+#include <lmserver.h>
 #include <lmwksta.h>
 #undef LPTSTR
 #define LPTSTR LPSTR
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
 
 #define RETURNRESULT(x)		if ((x)){ XST_mYES(0); }\
                      		else { XST_mNO(0); }\
@@ -556,7 +553,7 @@
 	length = (strlen(name)+1) * sizeof(WCHAR);
 	lpPtr = (LPWSTR)malloc(length);
 	if (lpPtr != NULL)
-	    MultiByteToWideChar(CP_ACP, NULL, name, -1, lpPtr, length);
+	    MultiByteToWideChar(CP_ACP, 0, name, -1, lpPtr, length);
     }
     return lpPtr;
 }
@@ -570,14 +567,15 @@
 	free(lpPtr);
 }
 
+/*
+
 int
 WCTMB(LPWSTR lpwStr, LPSTR lpStr, int size)
 {
     *lpStr = '\0';
-    return WideCharToMultiByte(CP_ACP,NULL,lpwStr,-1,lpStr,size,NULL,NULL);
+    return WideCharToMultiByte(CP_ACP,0,lpwStr,-1,lpStr,size,NULL,NULL);
 }
 
-/*
 void AddStringToHV(HV *hv, char *key, char *value)
 {
     char buffer[256];
@@ -902,7 +900,6 @@
 XS(XS_NT__NetAdmin_UsersExist)
 {
     dXSARGS;
-    char buffer[UNLEN+1];
     LPWSTR lpwServer, lpwUser;
     PUSER_INFO_0 puiUser;
     BOOL bReturn = FALSE;
@@ -937,8 +934,7 @@
     PUSER_INFO_10 pwzUsers10;
     DWORD filter, entriesRead, totalEntries, resumeHandle = 0;
     int index;
-    SV *sv, *nSv;
-    SV *user;
+    SV *sv;
     DWORD lastError = 0;
 
     if (items != 3) {
@@ -961,7 +957,7 @@
 					&resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzUsers[index].usri0_name, buffer, sizeof(buffer));
 		    av_push((AV*)sv, newSVpv(buffer, 0));
 		}
@@ -979,7 +975,7 @@
 					&resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzUsers10[index].usri10_name, buffer, sizeof(buffer));
 		    W2AHELPER(pwzUsers10[index].usri10_full_name, buffer1,
 			  sizeof(buffer1));
@@ -1031,7 +1027,7 @@
 					  &totalEntries, &resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pws[index].wkti0_transport_name, buffer,
 			  sizeof(buffer));
 		    av_push((AV*)sv, newSVpv(buffer, 0));
@@ -1050,7 +1046,7 @@
 						  &totalEntries, &resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    hvTemp = newHV();
 		    hv_store(hvTemp,
 			     "quality_of_service",
@@ -1101,8 +1097,7 @@
     PWKSTA_USER_INFO_1 pwzUser1;
     DWORD entriesRead, totalEntries, resumeHandle = 0;
     int index;
-    SV *sv, *nSv;
-    SV *user;
+    SV *sv;
     DWORD lastError = 0;
 
     if (items != 2) {
@@ -1124,7 +1119,7 @@
 					&resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzUser0[index].wkui0_username, buffer, sizeof(buffer));
 		    av_push((AV*)sv, newSVpv(buffer, 0));
 		}
@@ -1142,7 +1137,7 @@
 					     &resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzUser1[index].wkui1_username, buffer, sizeof(buffer));
 		    W2AHELPER(pwzUser1[index].wkui1_logon_domain, logon_domain,
 			  sizeof(logon_domain));
@@ -1295,7 +1290,7 @@
 	    for (index = 0; index <= count; ++index) {
 		psv = av_fetch((AV*)sv, index, 0);
 		if (psv != NULL) {
-		    MultiByteToWideChar(CP_ACP, NULL, (char*)SvPV(*psv,n_a),
+		    MultiByteToWideChar(CP_ACP, 0, (char*)SvPV(*psv,n_a),
 					-1, wzUser, sizeof(wzUser));
 		    lastError = NetGroupAddUser(lpwServer, lpwGroup, wzUser);
 		    if (lastError != 0)
@@ -1304,7 +1299,7 @@
 	    }
 	    break;
 	default:
-	    MultiByteToWideChar(CP_ACP, NULL, (char*)SvPV(sv,n_a),
+	    MultiByteToWideChar(CP_ACP, 0, (char*)SvPV(sv,n_a),
 				-1, wzUser, sizeof(wzUser));
 	    lastError = NetGroupAddUser(lpwServer, lpwGroup, wzUser);
 	    break;
@@ -1342,7 +1337,7 @@
 	    for (index = 0; index <= count; ++index) {
 		psv = av_fetch((AV*)sv, index, 0);
 		if (psv != NULL) {
-		    MultiByteToWideChar(CP_ACP, NULL, (char*)SvPV(*psv,n_a),
+		    MultiByteToWideChar(CP_ACP, 0, (char*)SvPV(*psv,n_a),
 					-1, wzUser, sizeof(wzUser));
 		    lastError = NetGroupDelUser(lpwServer, lpwGroup, wzUser);
 		    if (lastError != 0)
@@ -1351,7 +1346,7 @@
 	    }
 	    break;
 	default:
-	    MultiByteToWideChar(CP_ACP, NULL, (char*)SvPV(sv,n_a),
+	    MultiByteToWideChar(CP_ACP, 0, (char*)SvPV(sv,n_a),
 				-1, wzUser, sizeof(wzUser));
 	    lastError = NetGroupDelUser(lpwServer, lpwGroup, wzUser);
 	    break;
@@ -1389,7 +1384,7 @@
 					 &totalEntries, &resumeHandle);
 	    if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		break;
-	    for (index = 0; index < entriesRead; ++index)
+	    for (index = 0; index < (int)entriesRead; ++index)
 		if (lstrcmpiW(lpwUser, pwzGroupUsers[index].grui0_name) == 0) {
 		    bReturn = TRUE;
 		    break;
@@ -1405,7 +1400,7 @@
 	    // should check that entriesRead == totalEntries and redo if not
 	    // but 'this should not happen' if PREFLEN is sufficiently large...
 	    PGROUP_USERS_INFO_0 lpGroupInfo = pwzGroupUsers;
-	    for (index = 0; index < entriesRead; index++, lpGroupInfo++) {
+	    for (index = 0; index < (int)entriesRead; index++, lpGroupInfo++) {
 		if (lstrcmpiW(lpwGroup, lpGroupInfo->grui0_name) == 0) {
 		    bReturn = TRUE;
 		    break;
@@ -1429,9 +1424,9 @@
     char buffer[UNLEN+1];
     PGROUP_USERS_INFO_0 pwzGroupUsers;
     DWORD entriesRead, totalEntries;
-    size_t resumeHandle = 0;
+    DWORD resumeHandle = 0;
     int index;
-    SV *sv, *nSv;
+    SV *sv;
     DWORD lastError = 0;
 
     if (items != 3) {
@@ -1454,7 +1449,7 @@
 					     &resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzGroupUsers[index].grui0_name,
 			  buffer, sizeof(buffer));
 		    av_push((AV*)sv, newSVpv(buffer, 0));
@@ -1598,7 +1593,7 @@
 	    for (index = 0; index <= count; ++index) {
 		psv = av_fetch((AV*)sv, index, 0);
 		if (psv != NULL) {
-		    MultiByteToWideChar(CP_ACP, NULL, (char*)SvPV(*psv,n_a),
+		    MultiByteToWideChar(CP_ACP, 0, (char*)SvPV(*psv,n_a),
 					-1, wzUser, sizeof(wzUser));
 		    lastError = NetLocalGroupAddMembers(lpwServer, lpwGroup, 3,
 							(LPBYTE)&lgmi3MembersInfo, 1);
@@ -1608,7 +1603,7 @@
 	    }
 	    break;
 	default:
-	    MultiByteToWideChar(CP_ACP, NULL, (char*)SvPV(sv,n_a), -1,
+	    MultiByteToWideChar(CP_ACP, 0, (char*)SvPV(sv,n_a), -1,
 				wzUser, sizeof(wzUser));
 	    lastError = NetLocalGroupAddMembers(lpwServer, lpwGroup, 3,
 						(LPBYTE)&lgmi3MembersInfo, 1);
@@ -1649,7 +1644,7 @@
 	    for (index = 0; index <= count; ++index) {
 		psv = av_fetch((AV*)sv, index, 0);
 		if (psv != NULL) {
-		    MultiByteToWideChar(CP_ACP, NULL, (char*)SvPV(*psv,n_a),
+		    MultiByteToWideChar(CP_ACP, 0, (char*)SvPV(*psv,n_a),
 					-1, wzUser, sizeof(wzUser));
 		    lastError = NetLocalGroupDelMembers(lpwServer, lpwGroup, 3,
 							(LPBYTE)&lgmi3MembersInfo, 1);
@@ -1659,7 +1654,7 @@
 	    }
 	    break;
 	default:
-	    MultiByteToWideChar(CP_ACP, NULL, (char*)SvPV(sv,n_a), -1,
+	    MultiByteToWideChar(CP_ACP, 0, (char*)SvPV(sv,n_a), -1,
 				wzUser, sizeof(wzUser));
 	    lastError = NetLocalGroupDelMembers(lpwServer, lpwGroup, 3,
 						(LPBYTE)&lgmi3MembersInfo, 1);
@@ -1675,9 +1670,9 @@
 XS(XS_NT__NetAdmin_LocalGroupIsMember)
 {
     dXSARGS;
-    LPWSTR lpwServer, lpwGroup, lpwUser;
+    LPWSTR lpwServer, lpwGroup;
     DWORD entriesRead, totalEntries;
-    size_t resumeHandle = 0;
+    DWORD resumeHandle = 0;
     int index;
     BOOL bReturn = FALSE;
     DWORD lastError = 0;
@@ -1715,7 +1710,7 @@
 						&totalEntries, &resumeHandle);
 	    if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		break;
-	    for (index = 0; index < entriesRead; ++index)
+	    for (index = 0; index < (int)entriesRead; ++index)
 		if (EqualSid(pSid, pwzMembersInfo[index].lgrmi0_sid) != 0){
 		    bReturn = TRUE;
 		    break;
@@ -1742,7 +1737,7 @@
 		// should check that entriesRead == totalEntries and redo if not
 		// but 'this should not happen' if PREFLEN is sufficiently large
 		lpGroupInfo = pwzGroupUsers;
-		for (index = 0; index < entriesRead; index++, lpGroupInfo++) {
+		for (index = 0; index < (int)entriesRead; index++, lpGroupInfo++) {
 		    if (lstrcmpiW(lpwGroup, lpGroupInfo->lgrui0_name) == 0) {
 			bReturn = TRUE;
 			break;
@@ -1767,9 +1762,9 @@
     char buffer[UNLEN+1];
     PLOCALGROUP_MEMBERS_INFO_1 pwzMembersInfo;
     DWORD entriesRead, totalEntries;
-    size_t resumeHandle = 0;
+    DWORD resumeHandle = 0;
     int index;
-    SV *sv, *nSv;
+    SV *sv;
     DWORD lastError = 0;
 
     if (items != 3) {
@@ -1793,7 +1788,7 @@
 						    &resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzMembersInfo[index].lgrmi1_name, buffer,
 			  sizeof(buffer));
 		    av_push((AV*)sv, newSVpv(buffer, 0));
@@ -1821,9 +1816,9 @@
     char buffer1[UNLEN+1];
     PLOCALGROUP_MEMBERS_INFO_2 pwzMembersInfo;
     DWORD entriesRead, totalEntries;
-    size_t resumeHandle = 0;
+    DWORD resumeHandle = 0;
     int index;
-    SV *sv, *nSv;
+    SV *sv;
     DWORD lastError = 0;
 
     if (items != 3) {
@@ -1847,7 +1842,7 @@
 						    &resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzMembersInfo[index].lgrmi2_domainandname, buffer,
 			  sizeof(buffer));
 		    av_push((AV*)sv, newSVpv(buffer, 0));
@@ -1869,7 +1864,7 @@
 						    &resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzMembersInfo[index].lgrmi2_domainandname, buffer,
 			  sizeof(buffer));
 		    sprintf(buffer1, "%d", pwzMembersInfo[index].lgrmi2_sidusage );
@@ -1900,7 +1895,7 @@
     PSERVER_INFO_101 pwzServerInfo101;
     DWORD entriesRead, totalEntries, resumeHandle = 0;
     int index;
-    SV *sv, *nSv;
+    SV *sv;
     DWORD lastError = 0;
 
     if (items != 4) {
@@ -1925,7 +1920,7 @@
 					  lpwDomain, &resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzServerInfo[index].sv100_name, buffer,
 			  sizeof(buffer));
 		    av_push((AV*)sv, newSVpv(buffer, 0));
@@ -1947,7 +1942,7 @@
 					  lpwDomain, &resumeHandle);
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(pwzServerInfo101[index].sv101_name, buffer,
 			  sizeof(buffer));
 		    W2AHELPER(pwzServerInfo101[index].sv101_comment, buffer1,
@@ -1978,7 +1973,7 @@
     LPWSTR p;
     DWORD entriesRead, totalEntries, resumeHandle = 0;
     int index;
-    SV *sv, *nSv;
+    SV *sv;
     DWORD lastError = 0;
 
     if (items != 2) {
@@ -2002,7 +1997,7 @@
 		if (lastError != 0 && lastError != ERROR_MORE_DATA)
 		    break;
 		p = disks;
-		for (index = 0; index < entriesRead; ++index) {
+		for (index = 0; index < (int)entriesRead; ++index) {
 		    W2AHELPER(p, buffer, sizeof(buffer));
 		    av_push((AV*)sv, newSVpv(buffer, strlen(buffer)));
 		    p += 3;
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/NetAdmin/mingw32.exc perl-libwin32-0.191/NetAdmin/mingw32.exc
--- libwin32-0.191/NetAdmin/mingw32.exc	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/NetAdmin/mingw32.exc	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/NetAdmin/t/netadmin.t perl-libwin32-0.191/NetAdmin/t/netadmin.t
--- libwin32-0.191/NetAdmin/t/netadmin.t	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/NetAdmin/t/netadmin.t	2004-01-12 16:46:43.250000000 -0800
@@ -1,6 +1,8 @@
 #test for Perl NetAdmin Module Extension.
 #Written by Douglas_Lankshear@ActiveWare.com
 
+use Win32;
+
 BEGIN{
 	if( Win32::IsWin95() ){
 		print"1..1\nok 1\n";
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/NetResource/NetResource.xs perl-libwin32-0.191/NetResource/NetResource.xs
--- libwin32-0.191/NetResource/NetResource.xs	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/NetResource/NetResource.xs	2004-01-12 16:46:43.265625000 -0800
@@ -5,13 +5,11 @@
  * Heavily cleaned up and bugfixed by Gurusamy Sarathy <gsar@activestate.com>
  */
 
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-#include <malloc.h>
-#include <string.h>
+#include "../win32perl.h"
 
 #define UNICODE
 #define _UNICODE
+#define FORCE_UNICODE
 
 #undef LPTSTR        /* This is a band-aid to allow the NetShare* functions to use */
 #define LPTSTR LPWSTR    /* UNICODE strings while allowing the other functions to use
@@ -26,11 +24,6 @@
 #undef UNICODE
 #undef _UNICODE
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-/*#include "NTXSUB.h"*/
-
 static DWORD dwLastError = NO_ERROR;
 
 /*
@@ -317,7 +310,6 @@
     DWORD cEntries = 0xFFFFFFFF; /* enumerate all possible entries    */
     LPNETRESOURCEA lpnrLocal;     /* pointer to enumerated structures  */
     DWORD i;
-    HV*     phvNet;
     SV*        svNetRes;
     AV*	av;
 
@@ -428,7 +420,7 @@
         length = (strlen(name)+1)*2;
         lpPtr = (LPWSTR)safemalloc(length);
         if(lpPtr != NULL)
-            MultiByteToWideChar(CP_ACP, NULL, name, -1, lpPtr, length);
+            MultiByteToWideChar(CP_ACP, 0, name, -1, lpPtr, length);
     }
     return lpPtr;
 }
@@ -445,7 +437,7 @@
 int
 WCTMB(LPWSTR lpwStr, LPSTR lpStr, int size)
 {
-    return WideCharToMultiByte(CP_ACP, NULL, lpwStr, -1, lpStr, size, NULL, NULL);
+    return WideCharToMultiByte(CP_ACP, 0, lpwStr, -1, lpStr, size, NULL, NULL);
 }    
 
 
@@ -609,8 +601,6 @@
     PTSHARE_INFO    tshare
     DWORD parm_err = NO_INIT
     LPSTR servername
-PREINIT:
-    DWORD    parm;
 CODE:
     {
         SHARE_INFO_502     Share_502;
@@ -664,7 +654,7 @@
 	if (*device >= 'a' && *device <= 'z' && device[1] == ':')
 	    lpwDevice[0] = (WCHAR)(*device - 'a' + 'A');
 	else if (!strchr(device, '\\') && !strchr(device, '/'))
-	    lpwDevice = _wcsupr(lpwDevice);
+	    lpwDevice = (LPWSTR)_wcsupr(lpwDevice);
 
         dwLastError = NetShareCheck(lpwServer,lpwDevice,&type);
         FreeWideName( lpwServer );
@@ -706,7 +696,6 @@
     TSHARE_INFO    tRet;    
 CODE:
     {
-        BOOL bRet;
         PSHARE_INFO_502    pShareInfo;
         LPWSTR    lpwServer,lpwNetname;
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/NetResource/mingw32.exc perl-libwin32-0.191/NetResource/mingw32.exc
--- libwin32-0.191/NetResource/mingw32.exc	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/NetResource/mingw32.exc	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/NetResource/t/netresource.t perl-libwin32-0.191/NetResource/t/netresource.t
--- libwin32-0.191/NetResource/t/netresource.t	2002-07-08 17:50:34.000000000 -0700
+++ perl-libwin32-0.191/NetResource/t/netresource.t	2004-01-12 16:46:43.281250000 -0800
@@ -11,7 +11,7 @@
 
 use Win32::NetResource;
 #use Data::Dumper;
-#use Win32;
+use Win32;
 $debug = 2;
 
 sub deb {
@@ -20,16 +20,21 @@
     }
 }
 
-sub err {
-    my $err;
-    Win32::NetResource::GetError($err);
-    deb("|$err| => ", Win32::FormatMessage($err));
+sub err_ {
+    my $err_;
+    Win32::NetResource::GetError($err_);
+    deb("|$err_| => ", Win32::FormatMessage($err_));
 }
 
 print "1..7\n";
 
+my $tmp_dir = "c:\\perl_tmp_$$";
+mkdir $tmp_dir;
+
+sub END { rmdir $tmp_dir; }
+
 $ShareInfo = {
-		'path' => 'c:\\',
+		'path' => $tmp_dir,
 		'netname' => "myshare",
 		'remark' => "This mine, leave it alone",
 		'passwd' => "soundgarden",
@@ -55,13 +60,13 @@
 }
 print "ok 1\n";
 
-err();
+err_();
 
 #
 # Make a share of the current directory.
 
 $ShareInfo = {
-		'path' => "c:\\",
+		'path' => $tmp_dir,
 		'netname' => "PerlTempShare",
 		'remark' => "This mine, leave it alone",
 		'passwd' => "",
@@ -71,20 +76,21 @@
 		'type'  => 0,
 	     };
 
-
+# Try deleting it first, just in case.
+Win32::NetResource::NetShareDel("PerlTempShare");
 
 deb("Testing NetShareAdd");
 $parm = "";
 Win32::NetResource::NetShareAdd( $ShareInfo,$parm ) or print "not ";
 print "ok 2\n";
 
-err();
+err_();
 
 deb("testing NetShareGetInfo");
 $NewShare = {};
 Win32::NetResource::NetShareGetInfo("PerlTempShare", $NewShare) or print "not ";
 print "ok 3\n";
-err();
+err_();
 
 foreach (keys %$NewShare) {
     deb("# $_ => $NewShare->{ $_ }");
@@ -110,7 +116,7 @@
 
 Win32::NetResource::GetSharedResources($Aref,0,$host) or print "not ";
 print "ok 4\n";
-err();
+err_();
 
 deb("-----");
 foreach $href (@$Aref){
@@ -136,20 +142,22 @@
     $myRef->{'LocalName'} = $drive;
     #print STDERR "mapping to |$drive|\n", Dumper($myRef), "\n";
     Win32::NetResource::AddConnection($myRef,$passwd,$user,0);
-    err();
+    err_();
 
     Win32::NetResource::GetUNCName( $UNCName, $drive ) or print "not ";
     print "ok 5\n";
-    err();
+    err_();
     deb("uncname is $UNCName");
 
     Win32::NetResource::CancelConnection($drive,0,1) or print "not ";
     print "ok 6\n";
-    err();
+    err_();
 }
 else {
     print "ok $_ # skipped: share not found\n" for 5..6;
 }
 Win32::NetResource::NetShareDel("PerlTempShare") or print "not ";
 print "ok 7\n";
-err();
+err_();
+
+rmdir $tmp_dir;
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/NetResource/typemap perl-libwin32-0.191/NetResource/typemap
--- libwin32-0.191/NetResource/typemap	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/NetResource/typemap	2004-01-12 16:46:43.296875000 -0800
@@ -1,4 +1,4 @@
-# $Header$ 
+# $Header: /cvsroot/libwin32-exp/libwin32-exp/NetResource/typemap,v 1.1.1.1 2003/01/28 18:59:35 caelum Exp $ 
 # basic C types
 WORD			T_IV
 LONG                    T_IV
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/ODBC/CMom.cpp perl-libwin32-0.191/ODBC/CMom.cpp
--- libwin32-0.191/ODBC/CMom.cpp	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/ODBC/CMom.cpp	2004-01-12 16:46:43.312500000 -0800
@@ -20,34 +20,17 @@
    Use under GNU General Public License or Larry Wall's "Artistic License"
 */
 
-
-#define WIN32_LEAN_AND_MEAN
-#include <stdlib.h>
-#include <math.h>
-#include <windows.h>
-
-#include <stdio.h>
-
-#include <SQL.H>
-#include <SQLEXT.H>
-#include <ODBCINST.H>
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-#include "EXTERN.h"
-#include "perl.h"
-
 #define NO_XSLOCKS
-#include "XSub.h"
-#if defined(__cplusplus)
-}
-#endif
+#include "../win32perl.h"
+
+#include <sql.h>
+#include <sqlext.h>
+#include <odbcinst.h>
 
 #define	_CMOM_
-#include "odbc.h"	
-#include "cmom.hpp"
 
+#include "ODBC.h"
+#include "CMom.hpp"
 
 int	CMom::iTotalHistory = 0;
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/ODBC/CResults.cpp perl-libwin32-0.191/ODBC/CResults.cpp
--- libwin32-0.191/ODBC/CResults.cpp	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/ODBC/CResults.cpp	2004-01-12 16:46:43.328125000 -0800
@@ -20,33 +20,16 @@
    Use under GNU General Public License or Larry Wall's "Artistic License"
 */
 
-
-#define WIN32_LEAN_AND_MEAN
-#include <stdlib.h>
-#include <math.h>
-#include <windows.h>
-
-#include <stdio.h>
-
-#include <SQL.H>
-#include <SQLEXT.H>
-#include <ODBCINST.H>
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-#include <EXTERN.h>
-#include "perl.h"
-
 #define NO_XSLOCKS
-#include "XSub.h"
-#if defined(__cplusplus)
-}
-#endif
+#include "../win32perl.h"
+
+#include <sql.h>
+#include <sqlext.h>
+#include <odbcinst.h>
 
 #include "ODBCbuild.h"
-#include "odbc.h"	
-#include "cresults.hpp"
+#include "ODBC.h"	
+#include "CResults.hpp"
 
 CResults::CResults(ODBC_TYPE *h){
 	char szBuff[100];
@@ -82,7 +65,8 @@
 			SWORD	dColType;
 
 			for(iTemp = 1; iTemp <= sNumOfCols; iTemp++){
-				if (SQLColAttributes(h->hstmt, iTemp, SQL_COLUMN_DISPLAY_SIZE, NULL, NULL, NULL, &dSize[iTemp]) == SQL_SUCCESS){
+				if (SQLColAttributes(h->hstmt, iTemp,
+				  SQL_COLUMN_DISPLAY_SIZE, NULL, 0, NULL, &dSize[iTemp]) == SQL_SUCCESS){
 						//	If we cant resolve the size define it as the MAX Buffer
 						//	size. Later we can change this if needed.
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/ODBC/CResults.hpp perl-libwin32-0.191/ODBC/CResults.hpp
--- libwin32-0.191/ODBC/CResults.hpp	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/ODBC/CResults.hpp	2004-01-12 16:46:43.328125000 -0800
@@ -1,7 +1,9 @@
 #define	NULL_VALUE	""
 
-#ifndef _WIN64
+#ifndef SQLLEN
 #  define	SQLLEN	SDWORD
+#endif
+#ifndef SQLULEN
 #  define	SQLULEN	UDWORD
 #endif
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/ODBC/Constant.cpp perl-libwin32-0.191/ODBC/Constant.cpp
--- libwin32-0.191/ODBC/Constant.cpp	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/ODBC/Constant.cpp	2004-01-12 16:46:43.343750000 -0800
@@ -20,30 +20,14 @@
    Use under GNU General Public License or Larry Wall's "Artistic License"
 */
 
-
-#define WIN32_LEAN_AND_MEAN
-#include <stdlib.h>
-#include <math.h>		// VC-5.0 brain melt
-#include <windows.h>
-
-#include <stdio.h>
-#include <SQL.H>
-#include <SQLEXT.H>
-#include <ODBCINST.H>
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-#include <EXTERN.h>
-#include "perl.h"
-
 #define NO_XSLOCKS
-#include "XSub.h"
-#if defined(__cplusplus)
-}
-#endif
+#include "../win32perl.h"
+
+#include <sql.h>
+#include <sqlext.h>
+#include <odbcinst.h>
 
-#include "constant.h"		   
+#include "Constant.h"		   
 
 // constant function for exporting NT definitions.
 long
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/ODBC/Icon2.ico perl-libwin32-0.191/ODBC/Icon2.ico
--- libwin32-0.191/ODBC/Icon2.ico	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/ODBC/Icon2.ico	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-                (       @                                                                                                                                                                                                                               ww         ww{         w{                                                ;????=C           ` H G +PNu?<,?Q
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/ODBC/MANIFEST perl-libwin32-0.191/ODBC/MANIFEST
--- libwin32-0.191/ODBC/MANIFEST	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/ODBC/MANIFEST	2004-01-12 16:46:43.390625000 -0800
@@ -5,7 +5,7 @@
 Constant.cpp
 Constant.h
 HISTORY.TXT
-Icon2.ico
+ODBC.ico
 MANIFEST
 Makefile.PL
 ODBC.h
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/ODBC/Makefile.PL perl-libwin32-0.191/ODBC/Makefile.PL
--- libwin32-0.191/ODBC/Makefile.PL	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/ODBC/Makefile.PL	2004-01-12 16:46:43.421875000 -0800
@@ -1,11 +1,9 @@
 use ExtUtils::MakeMaker;
-use Config;
-$BORLAND = 1 if $Config{'cc'} =~ /^bcc32/i;
-my $incpath = $Config{incpath};
+
 WriteMakefile(
-    'INC'		=> ($BORLAND ? "-I$incpath\\mfc" : '-GX'),
     'OBJECT'		=> 'CMom$(OBJ_EXT) Constant$(OBJ_EXT) CResults$(OBJ_EXT) ODBC$(OBJ_EXT)',
     'NAME'		=> 'Win32::ODBC',
+    'PM'		=> { 'ODBC.pm' => '$(INST_LIBDIR)/ODBC.pm' },
     'VERSION_FROM'	=> 'ODBC.pm',
     'XS'	=> { 'ODBC.xs' => 'ODBC.cpp' },
     'dist'	=> { COMPRESS => 'gzip -9f', SUFFIX => 'gz' },
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/ODBC/ODBC.h perl-libwin32-0.191/ODBC/ODBC.h
--- libwin32-0.191/ODBC/ODBC.h	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/ODBC/ODBC.h	2004-01-12 16:46:43.453125000 -0800
@@ -1,37 +1,27 @@
-
 #define	SYNTAX_ERROR	999
-#define CROAK(xxxx)													\
-				PUSHMARK(sp);										\
-				XPUSHs(sv_2mortal(newSVnv((double)SYNTAX_ERROR)));	\
-				XPUSHs(sv_2mortal(newSVpv(xxxx, strlen(xxxx))));	\
-				PUTBACK;											\
-				return;												\
-																				\
-																				\
-
-#define	DEBUG_DUMP(xxx);		\
-/*
-								{																	\
-								 char szBuff[512]; 													\
-								 sprintf(szBuff, "=== %s (Thread: %04i)\n", xxx, GetCurrentThreadId());	\
-								 DebugPrint(szBuff);												\
-								}
- */
 
-/*
+#define CROAK(xxxx) \
+	PUSHMARK(sp); \
+	XPUSHs(sv_2mortal(newSVnv((double)SYNTAX_ERROR))); \
+	XPUSHs(sv_2mortal(newSVpv(xxxx, strlen(xxxx)))); \
+	PUTBACK; \
+	return;
+
+#define	DEBUG_DUMP(xxx) \
+{ \
+	char szBuff[512]; \
+	sprintf(szBuff, "=== %s (Thread: %04i)\n", xxx, GetCurrentThreadId()); \
+	DebugPrint(szBuff); \
+}
+
+#define	DEFAULT_DEBUG_FILE		"c:\\temp\\perlodbc.out"
+
 #ifndef _DEBUG
-	//	Define the Debug Macros...
 	#define	DebugDumpError(h)	
 	#define	DebugConnection(szString, h)
 	#define	DebugDump(szString)
 	#define	DebugPrint(szString)
 #endif
-*/
-
-#define TMPBUFSZ 512
-
-#define SUCCESSRETURNED(x)	(x == ERROR_SUCCESS)
-#define REGRETURN(x) XSRETURN_IV(SUCCESSRETURNED(x))
 
 #define MAX_DATA_BUF_SIZE		0x7FFFFFFE	//	Largest value for a SDWORD ( -1 for a string terminating null)	
 #define	MAX_DATA_ASSUME_SIZE	0x20000000	//	Largest size a field can specify before we assume that it is not accurate
@@ -40,8 +30,8 @@
 
 
 #define	COMMAND_LENGTH			1024
-#define	DSN_LENGTH				1024
-#define	DS_DESCRIPTION_LENGTH	2048
+#define	DSN_LENGTH			1024
+#define	DS_DESCRIPTION_LENGTH		2048
 
 #define ODBC_BUFF_SIZE 			1024
 #define	SQL_STATE_SIZE			10
@@ -51,13 +41,11 @@
 
 #define	TABLE_COMMAND_STRING	"%s(\"%s\", \"%s\", \"%s\", \"%s\")"
 
-#define	DEFAULT_DEBUG_FILE		"c:\\temp\\perlodbc.out"
-#define	DEFAULT_STMT_CLOSE_TYPE	SQL_DROP
+#define	DEFAULT_STMT_CLOSE_TYPE		SQL_DROP
 
 	//	Define ODBCList as a Macro for backward compatiblility.
 #define	THREAD_MOM	( (CMom *) ::cMom->operator[](GetCurrentThreadId()))
 #define	ODBCLIST	( (ODBC_TYPE *) (THREAD_MOM)->operator[]((DWORD)0))
-						
 
 class CResults;
 
@@ -165,11 +153,7 @@
 char *MapCloseType(UWORD uCloseType);
 void CleanError(ODBC_ERROR *h);
 int	ColNameToNum(ODBC_TYPE *h, char *szName);
-#ifdef __BORLANDC__
-BOOL WINAPI DllEntryPoint(HINSTANCE  hinstDLL, DWORD fdwReason, LPVOID  lpvReserved);
-#else
 BOOL WINAPI DllMain(HINSTANCE  hinstDLL, DWORD fdwReason, LPVOID  lpvReserved);
-#endif
 // void ReturnError(ODBC_TYPE *h);
 void AddDebug(ODBC_TYPE *h);
 void RemoveDebug(ODBC_TYPE *h);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/ODBC/ODBC.ico perl-libwin32-0.191/ODBC/ODBC.ico
--- libwin32-0.191/ODBC/ODBC.ico	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/ODBC/ODBC.ico	2004-01-12 16:46:43.500000000 -0800
@@ -0,0 +1 @@
+                (       @                                                                                                                                                                                                                               ww         ww{         w{                                                ;????=C           ` H G +PNu?<,?Q
\ No newline at end of file
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/ODBC/ODBC.xs perl-libwin32-0.191/ODBC/ODBC.xs
--- libwin32-0.191/ODBC/ODBC.xs	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/ODBC/ODBC.xs	2004-01-12 16:46:43.500000000 -0800
@@ -23,38 +23,19 @@
 #define PERL_POLLUTE
 #define __WIN32_ODBC__
 
-#define WIN32_LEAN_AND_MEAN
-#include <stdlib.h>
-#include <math.h>   // VC-5.0 brainmelt
-#include <windows.h>
-#include <stdio.h>
+#include "../win32perl.h"
     
     //  ODBC Stuff
-#include <SQL.H>
-#include <SQLEXT.H>
-#include <ODBCINST.H>
-
-    //  Win32 Perl Stuff
-#if defined(__cplusplus)
-extern "C" {
-#endif
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSub.h"
-
-#include "../ppport.h"
-
-#if defined(__cplusplus)
-}   
-#endif
-
+#include <sql.h>
+#include <sqlext.h>
+#include <odbcinst.h>
 
     //  Win32::ODBC Stuff                       
-#include "ODBCBuild.h"
+#include "ODBCbuild.h"
 #include "CResults.hpp" 
 #include "CMom.hpp"
-#include "odbc.h"
-#include "constant.h"
+#include "ODBC.h"
+#include "Constant.h"
 
 #undef  __WIN32_ODBC__
 
@@ -91,7 +72,6 @@
     ODBC_TYPE *h = 0;
     int iResult = 0;
     CMom    *cmDaughter;
-    int iTemp;
 
 
 #ifdef _Debug
@@ -269,7 +249,7 @@
             AllocConsole();
             SetConsoleTitle("DEBUG: ODBC.PLL");
             ghDebug = GetStdHandle(STD_ERROR_HANDLE);
-#endif _DEBUG
+#endif /* _DEBUG */
         }
         h->iDebug = 1;
     }
@@ -608,7 +588,6 @@
 
     char      szDSN[DSN_LENGTH]; // string to hold datasource name
     ODBC_TYPE * h;
-    int         con_num; //connection #
     char        *szIn = 0;
     int         iTemp = 0;
 
@@ -669,7 +648,7 @@
                 char    szError[100];
 
                 while (iTemp > 1){
-                    uType= SvIV(ST(iTemp - 1));
+                    uType=(UWORD)SvIV(ST(iTemp - 1));
                     if (SvIOKp(ST(iTemp)) || SvNOKp(ST(iTemp))){
                         udValue = SvIV(ST(iTemp));
                     }else{
@@ -736,14 +715,11 @@
 {
     dXSARGS;
     ODBC_TYPE * h;
-    int        con_num; // Connection #
     RETCODE retcode;          //ODBC gunk
     UCHAR  buff2[ODBC_BUFF_SIZE];
     SDWORD bufflenout;
-    int lenn;
     UWORD  x;
     char * szSQL; 
-    int len;
     STRLEN n_a;
 
     if(items < 2){
@@ -803,7 +779,6 @@
 {
     dXSARGS;
     ODBC_TYPE * h;
-    int        con_num;
 
     RETCODE retcode;         // yet more ODBC garbage
     UWORD   uType = SQL_FETCH_NEXT;
@@ -811,8 +786,7 @@
     DWORD   dRowSetSize = 1;
 
     UWORD   *rgfRowStatus = 0;
-    SQLULEN  udCRow = 0;
-    int     iTemp;  
+    SQLULEN  udCRow = 0, iTemp;  
 
     if(items < 1 || items > 3){
         CROAK("usage: ($err,@col) = ODBC_Fetch($connection [, $Row [, $FetchType]])\n0die \"Oops: $col[0]\" if ($err);\n");
@@ -826,7 +800,7 @@
 //      uType = SQL_FETCH_RELATIVE;
     }
     if (items > 2){
-        uType = SvIV(ST(2));
+        uType = (UWORD)SvIV(ST(2));
     }
                      
     PUSHMARK(sp);
@@ -961,7 +935,7 @@
 RETCODE TableColList(pTHX_ int iType){
     dXSARGS;
     ODBC_TYPE * h;
-    int        con_num, iTemp;
+    int    iTemp;
     UCHAR  buff2[ODBC_BUFF_SIZE];
     SDWORD bufflenout;
     UWORD  x;
@@ -1383,7 +1357,6 @@
 {
     dXSARGS;
     ODBC_TYPE * h;
-    long    iSize;
     char    *szType;
 
     if(items != 1){
@@ -1420,7 +1393,7 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     CleanError(h->Error);
-    uType = SvIV(ST(1));
+    uType = (UWORD)SvIV(ST(1));
     PUSHMARK(sp);
 
     switch(uType){
@@ -1466,7 +1439,7 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     CleanError(h->Error);
-    uType= SvIV(ST(1));
+    uType=(UWORD)SvIV(ST(1));
     if (SvIOKp(ST(2)) || SvNOKp(ST(2))){
         udValue = SvIV(ST(2));
     }else{
@@ -1508,7 +1481,7 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     CleanError(h->Error);
-    uOption = SvIV(ST(1));
+    uOption = (UWORD)SvIV(ST(1));
     PUSHMARK(sp);
 
     if(!h->Error->ErrNum){
@@ -1557,7 +1530,6 @@
     DWORD   *dValue = (DWORD *)ucValue;
     UWORD   uOption;
     UDWORD  udValue;
-    UCHAR   uType;
     RETCODE rResult = 0;
     STRLEN  n_a;
 
@@ -1567,7 +1539,7 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     CleanError(h->Error);
-    uOption = SvIV(ST(1));
+    uOption = (UWORD)SvIV(ST(1));
     if (items > 2){
         if (SvIOKp(ST(2)) || SvNOKp(ST(2))){
             udValue = SvIV(ST(2));
@@ -1652,7 +1624,7 @@
         iTotal = 100;
         items = 1;
     }else{
-        uOption = SvIV(ST(1));
+        uOption = (UWORD)SvIV(ST(1));
     }
 
     while(items--){
@@ -1670,7 +1642,7 @@
         iTemp++;
         if (items){     //  If there are no more stack elements we will screw up
                         //  trying to access ST(1 + iTemp)
-            uOption = SvIV(ST(1 + iTemp));
+            uOption = (UWORD)SvIV(ST(1 + iTemp));
         }
     }
     if (!h->Error->ErrNum){
@@ -1704,7 +1676,7 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     CleanError(h->Error);
-    uType = SvIV(ST(1));
+    uType = (UWORD)SvIV(ST(1));
     PUSHMARK(sp);
 
     if(!h->Error->ErrNum){
@@ -1751,7 +1723,7 @@
     h = _NT_ODBC_Verify(SvIV(ST(iStack)));
     CleanError(h->Error);
     iStack++;
-    uType = SvIV(ST(iStack));
+    uType = (UWORD)SvIV(ST(iStack));
     iStack++;
     szDriver = SvPV(ST(iStack), n_a);
     if (strlen(szDriver) == 0){
@@ -1845,7 +1817,7 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     CleanError(h->Error);
-    uType = SvIV(ST(1));
+    uType = (UWORD)SvIV(ST(1));
     PUSHMARK(sp);
 
     if(!h->Error->ErrNum){
@@ -1869,8 +1841,9 @@
                 iSize = (int) swBytes + 1;
                 iFlag = 0;
                 CleanError(h->Error);
+		break;
             }
-        } while (iSize <= (int) swBytes);
+        }
     }
 
     if (!h->Error->ErrNum){
@@ -1926,7 +1899,6 @@
     ODBC_TYPE * h;
     UWORD   iCol = 0;
     UWORD   iType = 0;
-    int     iTemp;
     UCHAR   *szName = 0;
     UCHAR   szBuff[ODBC_BUFF_SIZE];
     SWORD   dBuffLen = 0;
@@ -1940,7 +1912,7 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     szName = (unsigned char *) SvPV(ST(1), n_a);
-    iType = SvIV(ST(2));
+    iType = (UWORD)SvIV(ST(2));
     
     PUSHMARK(sp);
    
@@ -1980,8 +1952,6 @@
     ODBC_TYPE * h;
     int iDebug = 0;
     char    *szFile = 0;
-    char    szBuff[286];
-    DWORD   dCount;
     STRLEN  n_a;
 
     if(items < 1 || items > 3){
@@ -2003,8 +1973,10 @@
             if (ghFile){
             
 #ifdef _Debug   
+		{ char szBuff[1000];
                 sprintf(szBuff, "Closing debug file \"%s\"", (gszFile)? gszFile:"none opened");
                 DebugConnection(szBuff, h);
+		}
 #endif
                 CloseHandle(ghFile);
                 ghFile = 0;
@@ -2028,6 +2000,7 @@
             
 #ifdef _Debug
             if(ghDebug){
+		char szBuff[1000];
                 sprintf(szBuff, "Debug mode set on by connection %i.\n", h->conn);
                 DebugConnection(szBuff, h);
             }
@@ -2036,10 +2009,11 @@
         }else{
         
 #ifdef _Debug
-            if (ghDebug){
+            if (ghDebug){{
+		char szBuff[1000];
                 sprintf(szBuff, "Debug mode set off by connection %i.\n", h->conn);
                 DebugConnection(szBuff, h);
-            }
+	    }}
 #endif
 
             RemoveDebug(h);
@@ -2075,12 +2049,12 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     CleanError(h->Error);
-    uRow    = SvIV(ST(1));
+    uRow    = (UWORD)SvIV(ST(1));
     if (items > 2){
-        uOption = SvIV(ST(2));
+        uOption = (UWORD)SvIV(ST(2));
     }
     if (items > 3){
-        uLock   = SvIV(ST(3));
+        uLock   = (UWORD)SvIV(ST(3));
     }
     PUSHMARK(sp);
 
@@ -2109,17 +2083,9 @@
 {
     dXSARGS;
     ODBC_TYPE * h;
-    RETCODE retcode;         // yet more ODBC garbage
-    UCHAR  buff2[ODBC_BUFF_SIZE];
     UCHAR   *szBuf = 0;
     SDWORD  iBuf = DEFAULTCOLSIZE;
-    SDWORD  bufflenout;
-    SWORD   sSQLType;
-    SWORD   sTemp;
-    int lenn, iTotalPushed, iTemp;
-    UWORD  x;
-    int len;
-    DWORD   dTemp;
+    int iTemp;
     
     if(items != 1){
         CROAK("usage: ($Err, $Type) = ODBC_GetData($Connection)\n");
@@ -2201,7 +2167,7 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     if (items > 1){
-        uCloseSpecified = SvIV(ST(1));  
+        uCloseSpecified = (UWORD)SvIV(ST(1));  
     }
     CleanError(h->Error);
     PUSHMARK(sp);
@@ -2462,7 +2428,7 @@
 
     h = _NT_ODBC_Verify(SvIV(ST(0)));
     CleanError(h->Error);
-    sType = SvIV(ST(1));
+    sType = (SWORD)SvIV(ST(1));
     PUSHMARK(sp);
 
     if(!h->Error->ErrNum){
@@ -2511,11 +2477,11 @@
 }
 
 void TerminateThread(){
-    char    szBuff[100];
     CMom    *cmDaughter;
 
     DEBUG_DUMP("TerminateThread(): Entering Critical Section gDCS")
 #ifdef _Debug
+    { char szBuff[1000];
     EnterCriticalSection(&gDCS);
     sprintf(szBuff, "Thread %05i (total threads: %03i) terminating.\n", GetCurrentThreadId(), giThread);
         //  Entered Debug CS so no other debug messages interrupt us...
@@ -2523,6 +2489,7 @@
     DebugPrint(szBuff);
         //  If this thread has a CMom then delete it!
     DebugPrint("\t--> Checking for a daughter on this thread...\n");
+    }
 #endif
 
     if (::cMom){
@@ -2564,6 +2531,12 @@
     ODBC_TYPE   *h = 0;
     int iRetCode = 1;
 
+#if defined(__CYGWIN__) || defined(__MINGW32__)
+//  Otherwise, this is done in DllMain
+    InitializeCriticalSection(&gDCS);
+    InitializeCriticalSection(&gCS);
+#endif
+
     if (! ::cMom){
         ::cMom = new CMom;
     }
@@ -2600,7 +2573,6 @@
 {
     dXSARGS;
     char* file = __FILE__;
-    int i;
     RETCODE iRetCode = 1;
 
 #ifdef _Debug
@@ -2666,15 +2638,11 @@
 
 }           
 
-#ifdef  WIN32
+#if !defined(__CYGWIN__) && !defined(__MINGW32__)
 
     /* ===============  DLL Specific  Functions  ===================  */
     BOOL WINAPI
-#  ifdef __BORLANDC__
-    DllEntryPoint
-#  else
     DllMain
-#  endif
     (HINSTANCE  hinstDLL, DWORD fdwReason, LPVOID  lpvReserved){
         BOOL    bResult = TRUE;
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/ODBC/ODBCbuild.h perl-libwin32-0.191/ODBC/ODBCbuild.h
--- libwin32-0.191/ODBC/ODBCbuild.h	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/ODBC/ODBCbuild.h	2004-01-12 16:46:43.515625000 -0800
@@ -27,6 +27,7 @@
 
 #define	VERNAME			"ODBC extension for Win32 Perl"
 #define VERSION_NUM		VERSION_HI
+#undef  VERSION
 #define	VERSION			VERSION_NUM " " VERSION_TYPE
 #define VERDATE			__DATE__
 #define VERTIME			__TIME__
@@ -35,7 +36,7 @@
 #define VERCOMMENT		"This version requires " PERLVER "."
 
 #define RC_COMMENTS		VERNAME "\r\n----\r\n" VERCOMMENT "\0"
-#define	RC_COMPANY		"Roth Consulting\r\nhttp://www.roth.net/\0"
+#define	RC_COMPANY		"Roth Consulting\r\nhttp:\057/www.roth.net/\0"
 #define	RC_FILEDESC		INTERNALNAME " (for " PERLVER ")\0"
 #define RC_FILEVER		VERSION "\0"
 #define	RC_INTNAME		INTERNALNAME " " DEBUGGING "\0"
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/ODBC/Odbc.rc perl-libwin32-0.191/ODBC/Odbc.rc
--- libwin32-0.191/ODBC/Odbc.rc	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/ODBC/Odbc.rc	2004-01-12 16:46:43.531250000 -0800
@@ -1,9 +1,9 @@
 #include <windows.h>
-#include "ODBCBuild.h"
+#include "ODBCbuild.h"
 
 
 // Icon
-Win32ODBC               ICON    DISCARDABLE     "ODBC.ICO"
+Win32ODBC               ICON    DISCARDABLE     "ODBC.ico"
 
 
 // Version
@@ -29,7 +29,7 @@
         BLOCK "040904b0"
         BEGIN
             VALUE "Comments", 			RC_COMMENTS
-            VALUE "CompanyName", 		RC_COMPANY
+            VALUE "CompanyName",		RC_COMPANY
             VALUE "FileDescription", 	RC_FILEDESC 
             VALUE "FileVersion", 		RC_FILEVER
             VALUE "InternalName", 		RC_INTNAME
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/ODBC/Test.pl perl-libwin32-0.191/ODBC/Test.pl
--- libwin32-0.191/ODBC/Test.pl	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/ODBC/Test.pl	2004-01-12 16:46:43.546875000 -0800
@@ -36,6 +36,7 @@
 #                           - If omitted then we use the default value.
 #####
 
+    use Win32;
     use Win32::ODBC;
 
 
@@ -49,8 +50,7 @@
 
     $DriverType = "Microsoft Access Driver (*.mdb)";
     $Desc = "Description=The Win32::ODBC Test DSN for Perl";
-    $Dir = `cd`;
-    chop $Dir;
+    $Dir = Win32::GetCwd();
     $DBase = "ODBCTest.mdb";
 
     $iWidth=60;
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/ODBC/mingw32.exc perl-libwin32-0.191/ODBC/mingw32.exc
--- libwin32-0.191/ODBC/mingw32.exc	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/ODBC/mingw32.exc	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/OLE/MANIFEST perl-libwin32-0.191/OLE/MANIFEST
--- libwin32-0.191/OLE/MANIFEST	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/OLE/MANIFEST	2004-01-12 16:46:43.562500000 -0800
@@ -5,7 +5,6 @@
 OLE.xs
 README
 ToDo
-hints/cygwin.pl
 lib/OLE.pm		Compatibility layer: old toplevel OLE.pm
 lib/Win32/OLE.pm
 lib/Win32/OLE/Const.pm	Win32::OLE::Const module: TypeLib constants
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/OLE/Makefile.PL perl-libwin32-0.191/OLE/Makefile.PL
--- libwin32-0.191/OLE/Makefile.PL	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/OLE/Makefile.PL	2004-01-12 16:46:43.578125000 -0800
@@ -1,6 +1,8 @@
 use Config;
 use ExtUtils::MakeMaker qw(&WriteMakefile &neatvalue);
 
+my $ACTIVE_PERL = defined eval { Win32::BuildNumber() } ? 1 : 0;
+
 my @MM =
 (
  'NAME'	        => 'Win32::OLE',
@@ -66,6 +68,8 @@
 
 # Install typelib browser for ActivePerl help
 sub MY::post_constants {
+    return unless $ACTIVE_PERL;
+
     my @files = qw(Browser.dhtml Browser.html Class.png Const.png Default.png
                    Enum.png Event.png Function.png Global.png Help.png
                    Library.png Module.png Property.png Type.png);
@@ -82,6 +86,8 @@
 }
 
 sub MY::postamble {
+    return unless $ACTIVE_PERL;
+
     return q{
 all :: browser_to_blib
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/OLE/OLE.xs perl-libwin32-0.191/OLE/OLE.xs
--- libwin32-0.191/OLE/OLE.xs	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/OLE/OLE.xs	2004-01-12 16:46:43.593750000 -0800
@@ -27,13 +27,15 @@
 
 // #define _DEBUG
 
-#define register /* be gone */
-
 #define MY_VERSION "Win32::OLE(" XS_VERSION ")"
 
-#include <math.h>	/* this hack gets around VC-5.0 brainmelt */
+#define register /* be gone */
 #define _WIN32_DCOM
-#include <windows.h>
+#define PERL_NO_GET_CONTEXT
+#define NO_XSLOCKS
+
+#include "../win32perl.h"
+
 #include <ocidl.h>
 
 #ifdef _DEBUG
@@ -45,29 +47,6 @@
 
 extern "C" {
 
-#ifdef __CYGWIN__
-#   undef WIN32			/* don't use with Cygwin & Perl */
-#   include <netdb.h>
-#   include <sys/socket.h>
-#   include <unistd.h>
-#   define strrev _strrev
-    char *_strrev(char*);	/* from string.h (msvcrt40) */
-#endif
-
-#define PERL_NO_GET_CONTEXT
-#define NO_XSLOCKS
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-#include "patchlevel.h"
-
-#undef WORD
-typedef unsigned short WORD;
-
-#ifndef _WIN64
-#  define DWORD_PTR	DWORD
-#endif
-
 #if PERL_VERSION < 6
 #   error Win32::OLE requires Perl 5.6.0 or later
 #endif
@@ -174,7 +153,7 @@
                                 sizeof(MY_VERSION)-1, FALSE);          \
         if (!pinterp || !*pinterp || !SvIOK(*pinterp))		       \
             warn(MY_VERSION ": Per-interpreter data not initialized"); \
-        PERINTERP *pInterp = (PERINTERP*)SvIV(*pinterp)
+        PERINTERP *pInterp = (PERINTERP*)(DWORD)SvIV(*pinterp)
 #    define INTERP pInterp
 #else
 static PERINTERP Interp;
@@ -985,7 +964,7 @@
         DBG(("hv_fetch(%08x) returned %08x", punk, svp));
         punk->Release();
         if (svp)
-            return sv_2mortal(sv_bless(newRV((SV*)SvIV(*svp)), stash));
+            return sv_2mortal(sv_bless(newRV((SV*)(DWORD)SvIV(*svp)), stash));
     }
 
     if (!pDispatch) {
@@ -1026,7 +1005,7 @@
         pDispatch->QueryInterface(IID_IUnknown, (void**)&punk);
         /* use XIV as a weak reference */
         SV **svp = hv_store(g_hv_unique, (char*)&punk, sizeof(punk),
-                            newSViv((IV)pObj->self), 0);
+                            newSViv((IV)(DWORD)pObj->self), 0);
         DBG(("hv_store(%08x) returned %08x", punk, svp));
         punk->Release();
         pObj->flags |= OBJFLAG_UNIQUE;
@@ -1037,7 +1016,7 @@
     DBG(("CreatePerlObject=|%lx| Class=%s Tie=%s pDispatch=0x%x\n", pObj,
 	 HvNAME(stash), szTie, pDispatch));
 
-    hv_store(hvinner, PERL_OLE_ID, PERL_OLE_IDLEN, newSViv((IV)pObj), 0);
+    hv_store(hvinner, PERL_OLE_ID, PERL_OLE_IDLEN, newSViv((IV)(DWORD)pObj), 0);
     inner = sv_bless(newRV_noinc((SV*)hvinner), gv_stashpv(szTie, TRUE));
     sv_magic((SV*)pObj->self, inner, 'P', Nullch, 0);
     SvREFCNT_dec(inner);
@@ -1157,7 +1136,7 @@
 	    mg_get(*psv);
 
 	if (psv && SvIOK(*psv)) {
-	    WINOLEOBJECT *pObj = (WINOLEOBJECT*)SvIV(*psv);
+	    WINOLEOBJECT *pObj = (WINOLEOBJECT*)(DWORD)SvIV(*psv);
 
 	    DBG(("GetOleObject = |%lx|\n", pObj));
 	    if (pObj && pObj->header.lMagic == WINOLE_MAGIC)
@@ -1174,7 +1153,7 @@
 GetOleEnumObject(pTHX_ SV *sv, BOOL bDESTROY=FALSE)
 {
     if (sv_isobject(sv) && sv_derived_from(sv, szWINOLEENUM)) {
-	WINOLEENUMOBJECT *pEnumObj = (WINOLEENUMOBJECT*)SvIV(SvRV(sv));
+	WINOLEENUMOBJECT *pEnumObj = (WINOLEENUMOBJECT*)(DWORD)SvIV(SvRV(sv));
 
 	if (pEnumObj && pEnumObj->header.lMagic == WINOLEENUM_MAGIC)
 	    if (pEnumObj->pEnum || bDESTROY)
@@ -1189,7 +1168,7 @@
 GetOleVariantObject(pTHX_ SV *sv, BOOL bWarn=TRUE)
 {
     if (sv_isobject(sv) && sv_derived_from(sv, szWINOLEVARIANT)) {
-	WINOLEVARIANTOBJECT *pVarObj = (WINOLEVARIANTOBJECT*)SvIV(SvRV(sv));
+	WINOLEVARIANTOBJECT *pVarObj = (WINOLEVARIANTOBJECT*)(DWORD)SvIV(SvRV(sv));
 
 	if (pVarObj && pVarObj->header.lMagic == WINOLEVARIANT_MAGIC)
 	    return pVarObj;
@@ -1213,7 +1192,7 @@
 
     AddToObjectChain(aTHX_ (OBJECTHEADER*)pObj, WINOLETYPELIB_MAGIC);
 
-    return sv_bless(newRV_noinc(newSViv((IV)pObj)),
+    return sv_bless(newRV_noinc(newSViv((IV)(DWORD)pObj)),
 		    gv_stashpv(szWINOLETYPELIB, TRUE));
 }
 
@@ -1221,7 +1200,7 @@
 GetOleTypeLibObject(pTHX_ SV *sv)
 {
     if (sv_isobject(sv) && sv_derived_from(sv, szWINOLETYPELIB)) {
-	WINOLETYPELIBOBJECT *pObj = (WINOLETYPELIBOBJECT*)SvIV(SvRV(sv));
+	WINOLETYPELIBOBJECT *pObj = (WINOLETYPELIBOBJECT*)(DWORD)SvIV(SvRV(sv));
 
 	if (pObj && pObj->header.lMagic == WINOLETYPELIB_MAGIC)
 	    return pObj;
@@ -1242,7 +1221,7 @@
 
     AddToObjectChain(aTHX_ (OBJECTHEADER*)pObj, WINOLETYPEINFO_MAGIC);
 
-    return sv_bless(newRV_noinc(newSViv((IV)pObj)),
+    return sv_bless(newRV_noinc(newSViv((IV)(DWORD)pObj)),
 		    gv_stashpv(szWINOLETYPEINFO, TRUE));
 }
 
@@ -1250,7 +1229,7 @@
 GetOleTypeInfoObject(pTHX_ SV *sv)
 {
     if (sv_isobject(sv) && sv_derived_from(sv, szWINOLETYPEINFO)) {
-	WINOLETYPEINFOOBJECT *pObj = (WINOLETYPEINFOOBJECT*)SvIV(SvRV(sv));
+	WINOLETYPEINFOOBJECT *pObj = (WINOLETYPEINFOOBJECT*)(DWORD)SvIV(SvRV(sv));
 
 	if (pObj && pObj->header.lMagic == WINOLETYPEINFO_MAGIC)
 	    return pObj;
@@ -1409,7 +1388,7 @@
     UINT cp = QueryPkgVar(aTHX_ stash, CP_NAME, CP_LEN, cpDefault);
     int newenum = QueryPkgVar(aTHX_ stash, _NEWENUM_NAME, _NEWENUM_LEN);
 
-    while (pObj->PropIndex < pObj->cFuncs+pObj->cVars) {
+    while ((UINT)pObj->PropIndex < (UINT)(pObj->cFuncs+pObj->cVars)) {
 	ULONG index = pObj->PropIndex++;
 	/* Try all the INVOKE_PROPERTYGET functions first */
 	if (index < pObj->cFuncs) {
@@ -1756,7 +1735,7 @@
 	if ((iFlags & IMPLTYPEFLAG_FDEFAULT) &&
 	    (iFlags & IMPLTYPEFLAG_FSOURCE))
 	{
-	    HREFTYPE hRefType = NULL;
+	    HREFTYPE hRefType = 0;
 
 	    hr = pTypeInfo->GetRefTypeOfImplType(i, &hRefType);
 	    DBG(("GetRefTypeOfImplType: hr=0x%08x\n", hr));
@@ -2059,7 +2038,7 @@
 	XPUSHs(sv_2mortal(self));
 	if (pushname)
 	    XPUSHs(event);
-	for (int i=0; i < pdispparams->cArgs; ++i) {
+	for (UINT i=0; i < pdispparams->cArgs; ++i) {
 	    VARIANT *pVariant = &pdispparams->rgvarg[pdispparams->cArgs-i-1];
 	    DBG(("   Arg %d vt=0x%04x\n", i, V_VT(pVariant)));
 	    SV *sv = sv_newmortal();
@@ -2182,7 +2161,7 @@
     ENTER;
     SAVETMPS;
     PUSHMARK(sp);
-    for (int i=0; i < pdispparams->cArgs; ++i) {
+    for (UINT i=0; i < pdispparams->cArgs; ++i) {
 	VARIANT *pVariant = &pdispparams->rgvarg[pdispparams->cArgs-i-1];
 	DBG(("   Arg %d vt=0x%04x\n", i, V_VT(pVariant)));
 	SV *sv = sv_newmortal();
@@ -2270,7 +2249,7 @@
 
 	if (psv) {
 	    if (SvROK(*psv) && SvTYPE(SvRV(*psv)) == SVt_PVAV) {
-		if (++index >= cDims) {
+		if (++index >= (int)cDims) {
 		    warn(MY_VERSION ": SetSafeArrayFromAV unexpected failure");
 		    hr = E_UNEXPECTED;
 		    break;
@@ -2399,7 +2378,7 @@
 		plen[index] = av_len(pav[index])+1;
 
 		if (index < dim) {
-		    if (plen[index] > psab[index].cElements)
+		    if ((UINT)(plen[index]) > (UINT)(psab[index].cElements))
 			psab[index].cElements = plen[index];
 		}
 		else {
@@ -2475,11 +2454,11 @@
     VARTYPE vt = V_VT(pVariant);
     /* sv must NOT be Nullsv unless vt is VT_EMPTY, VT_NULL or VT_DISPATCH */
 
-#   define ASSIGN(vartype,perltype)                           \
-        if (vt & VT_BYREF) {                                  \
-            *V_##vartype##REF(pVariant) = Sv##perltype##(sv); \
-        } else {                                              \
-            V_##vartype(pVariant) = Sv##perltype##(sv);       \
+#   define ASSIGN(vartype,perltype,ctype)                           \
+        if (vt & VT_BYREF) {                                        \
+            *V_##vartype##REF(pVariant) = (ctype)Sv##perltype (sv); \
+        } else {                                                    \
+            V_##vartype(pVariant) = (ctype)Sv##perltype (sv);       \
         }
 
     /* XXX requirement to call mg_get() may change in Perl > 5.005 */
@@ -2509,7 +2488,7 @@
 	    SafeArrayGetLBound(psa, 1, &lLower);
 	    SafeArrayGetUBound(psa, 1, &lUpper);
 
-	    long lLength = 1 + lUpper-lLower;
+	    STRLEN lLength = 1 + lUpper-lLower;
 	    len = (len < lLength ? len : lLength);
 	    memcpy(pDest, pSrc, len);
 	    if (lLength > len)
@@ -2526,19 +2505,19 @@
 	break;
 
     case VT_I2:
-	ASSIGN(I2, IV);
+	ASSIGN(I2, IV, SHORT);
 	break;
 
     case VT_I4:
-	ASSIGN(I4, IV);
+	ASSIGN(I4, IV, UINT);
 	break;
 
     case VT_R4:
-	ASSIGN(R4, NV);
+	ASSIGN(R4, NV, FLOAT);
 	break;
 
     case VT_R8:
-	ASSIGN(R8, NV);
+	ASSIGN(R8, NV, DOUBLE);
 	break;
 
     case VT_CY:
@@ -2622,7 +2601,7 @@
 	break;
 
     case VT_ERROR:
-	ASSIGN(ERROR, IV);
+	ASSIGN(ERROR, IV, DWORD);
 	break;
 
     case VT_BOOL:
@@ -2689,7 +2668,7 @@
 
     case VT_UI1:
 	if (SvIOK(sv)) {
-	    ASSIGN(UI1, IV);
+	    ASSIGN(UI1, IV, BYTE);
 	}
 	else {
 	    char *ptr = SvPV_nolen(sv);
@@ -2719,9 +2698,9 @@
 
 #   define SET(perltype,vartype)                                 \
         if (vt & VT_BYREF) {                                     \
-            sv_set##perltype##(sv, *V_##vartype##REF(pVariant)); \
+            sv_set##perltype(sv, *V_##vartype##REF(pVariant)); \
         } else {                                                 \
-            sv_set##perltype##(sv, V_##vartype##(pVariant));     \
+            sv_set##perltype(sv, V_##vartype(pVariant));     \
         }
 
     sv_setsv(sv, &PL_sv_undef);
@@ -3182,7 +3161,7 @@
     if (SvOK(sv))
 	warn(MY_VERSION ": Per-interpreter data already set");
 
-    sv_setiv(sv, (IV)pInterp);
+    sv_setiv(sv, (IV)(DWORD)pInterp);
 #endif
 
     g_pObj = NULL;
@@ -3489,10 +3468,9 @@
 PPCODE:
 {
     char *buffer = "";
-    char *ptr;
     size_t length;
     unsigned int argErr;
-    int index, arrayIndex;
+    unsigned int index;
     I32 len;
     WINOLEOBJECT *pObj;
     EXCEPINFO excepinfo;
@@ -3532,7 +3510,7 @@
     if (SvROK(method) && (sv = SvRV(method)) &&	SvTYPE(sv) == SVt_PVAV &&
 	!SvOBJECT(sv) && av_len((AV*)sv) == 1)
     {
-	wFlags = SvIV(*av_fetch((AV*)sv, 0, FALSE));
+	wFlags = (USHORT)SvIV(*av_fetch((AV*)sv, 0, FALSE));
 	method = *av_fetch((AV*)sv, 1, FALSE);
     }
 
@@ -3552,7 +3530,7 @@
                 PUTBACK;
                 items = perl_call_method("All", G_ARRAY);
                 SPAGAIN;
-                for (index=0; index<items; ++index)
+                for (index=0; index<(UINT)items; ++index)
                     av_push(av, newSVsv(ST(index)));
                 sv_setsv(retval, sv_2mortal(newRV_noinc((SV*)av)));
 		XSRETURN_YES;
@@ -4025,8 +4003,6 @@
 	XSRETURN_EMPTY;
 
     IID iid;
-    ITypeInfo *pTypeInfo;
-    ITypeLib *pTypeLib;
 
     // XXX support GUIDs in addition to names too
     char *pszItf = SvPV_nolen(itf);
@@ -4199,7 +4175,7 @@
 		    if ((iFlags & IMPLTYPEFLAG_FDEFAULT) &&
 			(iFlags & IMPLTYPEFLAG_FSOURCE))
 		    {
-			HREFTYPE hRefType = NULL;
+			HREFTYPE hRefType = 0;
 			hr = pObj->pTypeInfo->GetRefTypeOfImplType(i, &hRefType);
 			DBG(("GetRefTypeOfImplType: hr=0x%08x\n", hr));
 			if (FAILED(hr))
@@ -4427,7 +4403,7 @@
     unsigned int argErr;
     STRLEN length;
     char *buffer;
-    int index;
+    UINT index;
     HRESULT hr;
     EXCEPINFO excepinfo;
     DISPID dispID = DISPID_VALUE;
@@ -4566,7 +4542,6 @@
     LCID lcid = SvIOK(locale) ? SvIV(locale) : lcidDefault;
     UINT cp = SvIOK(codepage) ? SvIV(codepage) : cpDefault;
     HV *stash = gv_stashpv(szWINOLE, TRUE);
-    unsigned int count;
 
     Initialize(aTHX_ stash);
     SetLastOleError(aTHX_ stash);
@@ -4578,7 +4553,7 @@
     if (CheckOleError(aTHX_ stash, hr))
 	XSRETURN_EMPTY;
 
-    hr = LoadRegTypeLib(clsid, major, minor, lcid, &pTypeLib);
+    hr = LoadRegTypeLib(clsid, (WORD)major, (WORD)minor, lcid, &pTypeLib);
     if (FAILED(hr) && SvPOK(typelib)) {
 	/* typelib not registerd, try to read from file "typelib" */
 	pszBuffer = SvPV_nolen(typelib);
@@ -4629,7 +4604,7 @@
 
     /* loop through all objects in type lib */
     count = pObj->pTypeLib->GetTypeInfoCount();
-    for (int index=0; index < count; ++index) {
+    for (UINT index=0; index < count; ++index) {
 	ITypeInfo *pTypeInfo;
 	TYPEATTR  *pTypeAttr;
 
@@ -4944,7 +4919,7 @@
 
     AddToObjectChain(aTHX_ (OBJECTHEADER*)pEnumObj, WINOLEENUM_MAGIC);
 
-    SV *sv = newSViv((IV)pEnumObj);
+    SV *sv = newSViv((IV)(DWORD)pEnumObj);
     ST(0) = sv_2mortal(sv_bless(newRV_noinc(sv), GetStash(aTHX_ self)));
     XSRETURN(1);
 }
@@ -5068,7 +5043,7 @@
 {
     HRESULT hr;
     WINOLEVARIANTOBJECT *pVarObj;
-    VARTYPE vt = items < 2 ? VT_EMPTY : SvIV(ST(1));
+    VARTYPE vt = items < 2 ? VT_EMPTY : (VARTYPE)SvIV(ST(1));
     SV *data = items < 3 ? Nullsv : ST(2);
 
     // XXX Initialize should be superfluous here
@@ -5111,7 +5086,7 @@
 	}
 
 	Newz(0, rgsabound, cDims, SAFEARRAYBOUND);
-	for (int iDim=0; iDim < cDims; ++iDim) {
+	for (UINT iDim=0; iDim < cDims; ++iDim) {
 	    SV *sv = ST(2+iDim);
 
 	    if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVAV) {
@@ -5178,7 +5153,7 @@
     AddToObjectChain(aTHX_ (OBJECTHEADER*)pVarObj, WINOLEVARIANT_MAGIC);
 
     HV *stash = GetStash(aTHX_ self);
-    SV *sv = newSViv((IV)pVarObj);
+    SV *sv = newSViv((IV)(DWORD)pVarObj);
     ST(0) = sv_2mortal(sv_bless(newRV_noinc(sv), stash));
     XSRETURN(1);
 }
@@ -5217,7 +5192,7 @@
     ST(0) = &PL_sv_undef;
     SetLastOleError(aTHX_ olestash);
     VariantInit(&variant);
-    hr = VariantChangeTypeEx(&variant, &pVarObj->variant, lcid, 0, type);
+    hr = VariantChangeTypeEx(&variant, &pVarObj->variant, lcid, 0, (VARTYPE)type);
     if (SUCCEEDED(hr)) {
 	ST(0) = sv_newmortal();
 	hr = SetSVFromVariantEx(aTHX_ &variant, ST(0), olestash);
@@ -5251,7 +5226,7 @@
     SetLastOleError(aTHX_ olestash);
     /* XXX: Does it work with VT_BYREF? */
     hr = VariantChangeTypeEx(&pVarObj->variant, &pVarObj->variant,
-			     lcid, 0, type);
+			     lcid, 0, (VARTYPE)type);
     CheckOleError(aTHX_ olestash, hr);
     if (FAILED(hr))
 	ST(0) = &PL_sv_undef;
@@ -5304,7 +5279,7 @@
 
 	long *rgIndices;
 	New(0, rgIndices, cDims, long);
-	for (int iDim=0; iDim < cDims; ++iDim)
+	for (UINT iDim=0; iDim < cDims; ++iDim)
             rgIndices[iDim] = SvIV(ST(1+iDim));
 
 	VARTYPE vt_base = V_VT(pSource) & VT_TYPEMASK;
@@ -5342,7 +5317,7 @@
     AddToObjectChain(aTHX_ (OBJECTHEADER*)pNewVar, WINOLEVARIANT_MAGIC);
 
     HV *stash = GetStash(aTHX_ self);
-    SV *sv = newSViv((IV)pNewVar);
+    SV *sv = newSViv((IV)(DWORD)pNewVar);
     ST(0) = sv_2mortal(sv_bless(newRV_noinc(sv), stash));
     XSRETURN(1);
 }
@@ -5554,7 +5529,7 @@
 	sign = 1;
     }
     while (u64) {
-	amount[len++] = u64%10 + '0';
+	amount[len++] = (char)(u64%10 + '0');
 	u64 /= 10;
     }
     if (len == sign)
@@ -5778,7 +5753,7 @@
 
     HRESULT hr = S_OK;
     UINT cDims = SafeArrayGetDim(psa);
-    for (int iDim=0; iDim < cDims; ++iDim) {
+    for (UINT iDim=0; iDim < cDims; ++iDim) {
 	long lLBound, lUBound;
 	hr = SafeArrayGetLBound(psa, 1+iDim, &lLBound);
 	if (FAILED(hr))
@@ -5871,7 +5846,7 @@
 
     long *rgIndices;
     New(0, rgIndices, cDims, long);
-    for (int iDim=0; iDim < cDims; ++iDim)
+    for (UINT iDim=0; iDim < cDims; ++iDim)
         rgIndices[iDim] = SvIV(ST(1+iDim));
 
     VARIANT variant, byref;
@@ -6090,7 +6065,7 @@
 	else {
 	    sv = sv_newmortal();
 	    SvUPGRADE(sv, SVt_PV);
-	    SvGROW(sv, len+1);
+	    SvGROW(sv, (UINT)len+1);
 	    SvCUR_set(sv, LCMapStringA(lcid, flags, string, length,
 				       SvPVX(sv), SvLEN(sv)));
 	    if (SvCUR(sv))
@@ -6131,7 +6106,7 @@
 	int len = GetLocaleInfoA(lcid, lctype, NULL, 0);
 	if (len > 0) {
 	    SvUPGRADE(sv, SVt_PV);
-	    SvGROW(sv, len);
+	    SvGROW(sv, (UINT)len);
 	    len = GetLocaleInfoA(lcid, lctype, SvPVX(sv), SvLEN(sv));
 	    if (len) {
 		SvCUR_set(sv, len-1);
@@ -6156,8 +6131,8 @@
 
     New(0, pCharType, len, unsigned short);
     if (GetStringTypeA(lcid, type, string, len, pCharType)) {
-	EXTEND(SP, len);
-	for (int i=0; i < len; ++i)
+	EXTEND(SP, (int)len);
+	for (STRLEN i=0; i < len; ++i)
 	    PUSHs(sv_2mortal(newSViv(pCharType[i])));
     }
     Safefree(pCharType);
@@ -6213,7 +6188,7 @@
 {
     DWORD_PTR dwResult;
 
-    SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0, NULL,
+    SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0, 0,
 		       SMTO_NORMAL, 5000, &dwResult);
     XSRETURN_EMPTY;
 }
@@ -6690,7 +6665,7 @@
 
     AddToObjectChain(aTHX_ (OBJECTHEADER*)pObj, WINOLETYPEINFO_MAGIC);
 
-    SV *sv = newSViv((IV)pObj);
+    SV *sv = newSViv((IV)(DWORD)pObj);
     ST(0) = sv_2mortal(sv_bless(newRV_noinc(sv), GetStash(aTHX_ self)));
     XSRETURN(1);
 }
@@ -6715,7 +6690,7 @@
 	XSRETURN_EMPTY;
 
     AV *av = newAV();
-    for (int i = 0; i < cNames; ++i) {
+    for (unsigned int i = 0; i < cNames; ++i) {
 	char szName[32];
 	// XXX use correct codepage ???
 	char *pszName = GetMultiByte(aTHX_ rgbstr[i],
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/OLE/hints/cygwin.pl perl-libwin32-0.191/OLE/hints/cygwin.pl
--- libwin32-0.191/OLE/hints/cygwin.pl	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/OLE/hints/cygwin.pl	1969-12-31 16:00:00.000000000 -0800
@@ -1,8 +0,0 @@
-$self->{CC} = 'g++';
-$self->{LIBS} = ['-lole32 -loleaut32 -luuid -lmsvcrt40'];
-$self->{CCFLAGS} .= '-fvtable-thunks ' . $Config{ccflags};
-
-# NOTE: These two functions are used for a typelib browser
-#       that requires the ActiveState PerlScript wrapper.
-sub MY::post_constants {}
-sub MY::postamble {}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/OLE/t/3_ole.t perl-libwin32-0.191/OLE/t/3_ole.t
--- libwin32-0.191/OLE/t/3_ole.t	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/OLE/t/3_ole.t	2004-01-12 16:46:43.625000000 -0800
@@ -41,6 +41,7 @@
 use Cwd;
 use FileHandle;
 use Sys::Hostname;
+use Win32;
 
 use Win32::OLE qw(CP_ACP CP_OEMCP HRESULT in valof with);
 use Win32::OLE::NLS qw(:DEFAULT :LANG :SUBLANG);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/PerfLib/Makefile.PL perl-libwin32-0.191/PerfLib/Makefile.PL
--- libwin32-0.191/PerfLib/Makefile.PL	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/PerfLib/Makefile.PL	2004-01-12 16:46:43.625000000 -0800
@@ -5,9 +5,6 @@
     'NAME'		=> 'Win32::PerfLib',
     'VERSION_FROM'	=> 'PerfLib.pm', # finds $VERSION
     'dist'		=> {COMPRESS => 'gzip -9f', SUFFIX => 'gz'},
-    'LIBS'		=> [''],   # e.g., '-lm' 
-    'DEFINE'		=> '',     # e.g., '-DHAVE_SOMETHING' 
-    'INC'		=> '',     # e.g., '-I/usr/include/other'
     ($] < 5.005 ? () :
       (
 	'AUTHOR'	=> 'Jutta M. Klebe <jmk@bybyte.de>',
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/PerfLib/PerfLib.xs perl-libwin32-0.191/PerfLib/PerfLib.xs
--- libwin32-0.191/PerfLib/PerfLib.xs	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/PerfLib/PerfLib.xs	2004-01-12 16:46:43.640625000 -0800
@@ -1,14 +1,7 @@
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
+#include "../win32perl.h"
 #include <winreg.h>
 #include <winperf.h>
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
-
 #if !defined(PERL_OBJECT)
 #  ifndef CPERLarg_
 #    define CPERLarg_
@@ -536,7 +529,7 @@
 int WCTMB(LPWSTR lpwStr, LPSTR lpStr, int size)
 {
     *lpStr = '\0';
-    return WideCharToMultiByte(CP_ACP,NULL,lpwStr,-1,lpStr,size,NULL,NULL);
+    return WideCharToMultiByte(CP_ACP,0,lpwStr,-1,lpStr,size,NULL,NULL);
 }
 
 
@@ -587,8 +580,6 @@
 		PPERF_INSTANCE_DEFINITION PerfInst)
 {
     PPERF_COUNTER_DEFINITION PerfCntr, CurCntr;
-    PPERF_COUNTER_BLOCK PtrToCntr;
-    PPERF_COUNTER_BLOCK PerfCntrBlk;
     BYTE *lpCounterData;
     LARGE_INTEGER *lpLargeInt;
     DWORD *lpDWord;
@@ -824,10 +815,8 @@
 	char akey[256] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009";
 	WCHAR wkey[256] = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009";
 	BYTE *nameArray;
-	BYTE *p;
 	DWORD value_len;
 	DWORD type;
-	DWORD value;
 
 	if (USING_WIDE()) {
 	    WCHAR wmachine[MAX_PATH+1];
@@ -917,7 +906,7 @@
 	RETVAL
 	counter		if (RETVAL) { SETPVN(1, nameArray, value_len); } Safefree(nameArray);
 
-bool
+DWORD
 PerfLibGetHelp(machine,help)
 	char *machine
 	SV *help
@@ -927,10 +916,8 @@
 	char akey[256] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009";
 	WCHAR wkey[256] = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009";
 	BYTE *helpArray;
-	BYTE *p;
 	DWORD value_len;
 	DWORD type;
-	DWORD value;
 
 	if (USING_WIDE()) {
 	    WCHAR wmachine[MAX_PATH+1];
@@ -1037,21 +1024,14 @@
 	PPERF_OBJECT_TYPE PerfObj;
 	PPERF_INSTANCE_DEFINITION PerfInst;
 	PPERF_COUNTER_DEFINITION PerfCntr, CurCntr;
-	PPERF_COUNTER_BLOCK PtrToCntr;
-	PPERF_COUNTER_BLOCK PerfCntrBlk;
 	BYTE *lpCounterData;
-	LARGE_INTEGER *lpLargeInt;
-	DWORD *lpDWord;
-	DWORD i,k,j,size,type,subtype, display, calc_mod, time_base;
+	DWORD i,j,type;
 	char buffer[TEMPBUFSZ];
-	HV *hvCounter;
 	HV *hvInstance;
 	HV *hvObject;
 	HV *hvCounterNum;
 	HV *hvInstanceNum;
 	HV *hvObjectNum;
-	struct tm t;
-	time_t stime;
 	FILETIME ft;
 	LARGE_INTEGER lft;
 	DWORD PerfLib_debug = 0;
@@ -1099,16 +1079,14 @@
 	lft.u.LowPart = (DWORD)ft.dwLowDateTime;
 	lft.u.HighPart = (LONG)ft.dwHighDateTime;
 	sprintf(buffer, "%I64d", lft.QuadPart);
-#//	hv_store((HV*)data, "SystemTime", strlen("SystemTime"),
-#//		 newSVpv(buffer, strlen(buffer)), 0);
 	hv_store((HV*)data, "SystemTime", strlen("SystemTime"),
-		 newSVnv(lft.QuadPart), 0);
+		 newSVnv((NV)lft.QuadPart), 0);
 	hv_store((HV*)data, "PerfTime", strlen("PerfTime"),
-		 newSVnv(PerfData->PerfTime.QuadPart),0);
+		 newSVnv((NV)PerfData->PerfTime.QuadPart),0);
 	hv_store((HV*)data, "PerfFreq", strlen("PerfFreq"),
-		 newSVnv(PerfData->PerfFreq.QuadPart),0);
+		 newSVnv((NV)PerfData->PerfFreq.QuadPart),0);
 	hv_store((HV*)data, "PerfTime100nSec", strlen("PerfTime100nSec"),
-		 newSVnv(PerfData->PerfTime100nSec.QuadPart),0);
+		 newSVnv((NV)PerfData->PerfTime100nSec.QuadPart),0);
 	WCTMB((LPWSTR)((PBYTE)PerfData + PerfData->SystemNameOffset), buffer,
 	      PerfData->SystemNameLength);
 	hv_store((HV*)data, "SystemName", strlen("SystemName"),
@@ -1145,7 +1123,7 @@
 	    if (PerfObj->NumInstances > 0 )
 	    {
 		hvInstanceNum = newHV();
-		for (j=1;j<=PerfObj->NumInstances;j++)
+		for (j=1;j<=(DWORD)(PerfObj->NumInstances);j++)
 		{
 		    if (PerfLib_debug)
 			printf("Instance %S\n",
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/PerfLib/mingw32.exc perl-libwin32-0.191/PerfLib/mingw32.exc
--- libwin32-0.191/PerfLib/mingw32.exc	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/PerfLib/mingw32.exc	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/PerfLib/typemap perl-libwin32-0.191/PerfLib/typemap
--- libwin32-0.191/PerfLib/typemap	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/PerfLib/typemap	2004-01-12 16:46:43.656250000 -0800
@@ -7,3 +7,13 @@
 PPERF_INSTANCE_DEFINITION	T_PTROBJ
 PPERF_COUNTER_DEFINITION	T_PTROBJ
 PPERF_COUNTER_BLOCK		T_PTROBJ
+
+INPUT
+
+T_IV
+	$var = ($type)(DWORD)SvIV($arg)
+
+OUTPUT
+
+T_IV
+	sv_setiv($arg, (IV)(DWORD)$var);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Pipe/Cpipe.cpp perl-libwin32-0.191/Pipe/Cpipe.cpp
--- libwin32-0.191/Pipe/Cpipe.cpp	2002-07-08 17:15:52.000000000 -0700
+++ perl-libwin32-0.191/Pipe/Cpipe.cpp	2004-01-12 16:46:43.671875000 -0800
@@ -1,25 +1,6 @@
-
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-
-#if defined(__cplusplus)
-#include <stdlib.h>
-#include <math.h>
-extern "C" {
-#endif
-
-#include <EXTERN.h>
-#include "perl.h"
-#include "XSub.h"
-
-#if defined(__cplusplus)
-}
-#endif
-
-#include "../ppport.h"
-
-#include "CPipe.hpp"
-#include "pipe.h"
+#include "../win32perl.h"
+#include "Cpipe.hpp"
+#include "Pipe.h"
 
 CPipe::CPipe(char *szName, DWORD dWait){
 	int	iTemp;
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Pipe/Makefile.PL perl-libwin32-0.191/Pipe/Makefile.PL
--- libwin32-0.191/Pipe/Makefile.PL	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Pipe/Makefile.PL	2004-01-12 16:46:43.687500000 -0800
@@ -1,10 +1,10 @@
 use ExtUtils::MakeMaker;
 use Config;
-$BORLAND = 1 if $Config{'cc'} =~ /^bcc32/i;
+
 WriteMakefile(
-    'INC'		=> ($BORLAND ? '' : '-GX'),
     'OBJECT'		=> 'Cpipe$(OBJ_EXT) Pipe$(OBJ_EXT)',
     'NAME'		=> 'Win32::Pipe',
+    'PM'		=> { 'Pipe.pm' => '$(INST_LIBDIR)/Pipe.pm' },
     'VERSION_FROM'	=> 'Pipe.pm',
     'XS'		=> { 'Pipe.xs' => 'Pipe.cpp' },
     'dist'		=> { COMPRESS => 'gzip -9f', SUFFIX => 'gz' },
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Pipe/Pipe.xs perl-libwin32-0.191/Pipe/Pipe.xs
--- libwin32-0.191/Pipe/Pipe.xs	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Pipe/Pipe.xs	2004-01-12 16:46:43.703125000 -0800
@@ -20,30 +20,9 @@
    Use under GNU General Public License or Larry Wall's "Artistic License"
 */
 
-#define WIN32_LEAN_AND_MEAN
-#include <stdlib.h>
-#include <math.h>
-#include <windows.h>
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-
-#include <EXTERN.h>
-#include "perl.h"
-#include "XSub.h"
-#include "patchlevel.h"
-
-#if (PATCHLEVEL < 5) && !defined(PL_sv_undef)
-# define PL_sv_undef sv_undef
-#endif
-
-#if defined(__cplusplus)
-}
-#endif
-
-#include "cpipe.hpp"
-#include "pipe.h"
+#include "../win32perl.h"
+#include "Cpipe.hpp"
+#include "Pipe.h"
 
 char gszError[ERROR_TEXT_SIZE];
 int	giError = 0;
@@ -193,7 +172,7 @@
 	if(items != 1){
 		CROAK("usage: Close($PipeHandle);\n");
 	}
-	Pipe = (class CPipe *)SvIV(ST(0));
+	Pipe = (class CPipe *)(DWORD)SvIV(ST(0));
 
 	PUSHMARK(sp);
 	
@@ -216,7 +195,7 @@
 	if(items != 2){
 		CROAK("usage: Write($PipeHandle, $Data);\n");
 	}
-	Pipe = (class CPipe *)SvIV(ST(0));
+	Pipe = (class CPipe *)(DWORD)SvIV(ST(0));
 	vpData = (void *)SvPV(ST(1), dDataLen);
 
 	PUSHMARK(sp);
@@ -240,7 +219,7 @@
 	if(items != 1){
 		CROAK("usage: Read($PipeHandle);\n");
 	}
-	Pipe = (class CPipe *)SvIV(ST(0));
+	Pipe = (class CPipe *)(DWORD)SvIV(ST(0));
 
 	PUSHMARK(sp);
 	
@@ -275,7 +254,7 @@
 	if(items != 1){
 		CROAK("usage: Connect($PipeHandle);\n");
 	}
-	Pipe = (class CPipe *)SvIV(ST(0));
+	Pipe = (class CPipe *)(DWORD)SvIV(ST(0));
 
 	PUSHMARK(sp);
 	
@@ -297,7 +276,7 @@
 	if(items > 0 && items < 3){
 		CROAK("usage: Disconnect($PipeHandle [, $iPurge]);\n");
 	}
-	Pipe = (class CPipe *)SvIV(ST(0));
+	Pipe = (class CPipe *)(DWORD)SvIV(ST(0));
 	if (items == 2){
 		iPurge = (int) SvIV(ST(1));
 	}
@@ -322,7 +301,7 @@
 	if(items != 2){
 		CROAK("usage: ResizeBuffer($PipeHandle, $Size);\n");
 	}
-	Pipe = (class CPipe *)SvIV(ST(0));
+	Pipe = (class CPipe *)(DWORD)SvIV(ST(0));
 	dSize = (DWORD)SvIV(ST(1));
 
 	PUSHMARK(sp);
@@ -344,7 +323,7 @@
 	if(items != 1){
 		CROAK("usage: BufferSize($PipeHandle);\n");
 	}
-	Pipe = (class CPipe *)SvIV(ST(0));
+	Pipe = (class CPipe *)(DWORD)SvIV(ST(0));
 
 	PUSHMARK(sp);
 	
@@ -369,7 +348,7 @@
 		CROAK("usage: Error([$PipeHandle]);\n");
 	}
 	if (items == 1){
-		Pipe = (class CPipe *)SvIV(ST(0));
+		Pipe = (class CPipe *)(DWORD)SvIV(ST(0));
 	}
 
 	PUSHMARK(sp);
@@ -417,7 +396,6 @@
 {
 	dXSARGS;
 	char* file = __FILE__;
-	int i;
 
 	giError = 0;
 	memset((void *)gszError, 0, ERROR_TEXT_SIZE);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Pipe/mingw32.exc perl-libwin32-0.191/Pipe/mingw32.exc
--- libwin32-0.191/Pipe/mingw32.exc	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Pipe/mingw32.exc	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Process/Makefile.PL perl-libwin32-0.191/Process/Makefile.PL
--- libwin32-0.191/Process/Makefile.PL	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Process/Makefile.PL	2004-01-12 16:46:43.718750000 -0800
@@ -1,9 +1,10 @@
 use ExtUtils::MakeMaker;
 use Config;
-$BORLAND = 1 if $Config{'cc'} =~ /^bcc32/i;
+
+$WINNT = $^O ne 'cygwin' ? Win32::IsWinNT() : (`uname -a`)[0] =~ /CYGWIN_NT/i;
+
 WriteMakefile(
-    'INC'		=> ($BORLAND ? '' : '-GX'),
-    'DEFINE'		=> (Win32::IsWinNT() ? '' : '-DSTRICTLY_WINDOWS95'),
+    'DEFINE'		=> ($WINNT   ? '' : '-DSTRICTLY_WINDOWS95'),
     'NAME'		=> 'Win32::Process',
     'VERSION_FROM'	=> 'Process.pm',
     'XS'		=> { 'Process.xs' => 'Process.cpp' },
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Process/Process.hpp perl-libwin32-0.191/Process/Process.hpp
--- libwin32-0.191/Process/Process.hpp	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Process/Process.hpp	2004-01-12 16:46:43.734375000 -0800
@@ -1,13 +1,8 @@
 /*
     cProcess class definition for the Win32::Process module extension
 */
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
 
-#ifndef _WIN64
-#  define DWORD_PTR	DWORD
-#  define PDWORD_PTR	DWORD*
-#endif
+#include "../win32perl.h"
 
 typedef BOOL (*LPSetProcessAffinityMask)(HANDLE, DWORD);
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Process/Process.xs perl-libwin32-0.191/Process/Process.xs
--- libwin32-0.191/Process/Process.xs	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Process/Process.xs	2004-01-12 16:46:43.750000000 -0800
@@ -1,27 +1,17 @@
-#include <stdlib.h>		// avoid BCC-5.0 brainmelt
-#include <math.h>		// avoid VC-5.0 brainmelt
+#include "../win32perl.h"
 #include "Process.hpp"
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
 
 #if defined(__cplusplus)
-#include <stdlib.h>
 extern "C" {
 #endif
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.H"
-
-#include "../ppport.h"
-
 static BOOL
 Create(cProcess* &cP, char* szAppName, char* szCommLine, DWORD Inherit,
        DWORD CreateFlags, char* szCurrDir)
 {
     BOOL bRetVal;
     void *env = NULL;
-#if PERL_VERSION > 5
+#if PERL_VERSION > 5 && defined(get_childenv)
     env = PerlEnv_get_childenv();
 #endif
     cP = NULL;
@@ -33,7 +23,7 @@
     catch (...) {
         bRetVal = FALSE;
     }
-#if PERL_VERSION > 5
+#if PERL_VERSION > 5 && defined(get_childenv)
     PerlEnv_free_childenv(env);
 #endif
     return bRetVal;
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Process/mingw32.exc perl-libwin32-0.191/Process/mingw32.exc
--- libwin32-0.191/Process/mingw32.exc	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Process/mingw32.exc	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Process/typemap perl-libwin32-0.191/Process/typemap
--- libwin32-0.191/Process/typemap	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Process/typemap	2004-01-12 16:46:43.765625000 -0800
@@ -12,7 +12,7 @@
 T_PTROBJ
 	if (sv_derived_from($arg, \"${Package}\")) {
 	    IV tmp = SvIV((SV*)SvRV($arg));
-	    $var = ($type) tmp;
+	    $var = ($type)(DWORD) tmp;
 	}
 	else
 	    croak(\"$var is not of type ${Package}\")
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Registry/Registry.xs perl-libwin32-0.191/Registry/Registry.xs
--- libwin32-0.191/Registry/Registry.xs	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Registry/Registry.xs	2004-01-12 16:46:43.781250000 -0800
@@ -1,20 +1,7 @@
-/*
- * This file was generated automatically by xsubpp version 1.9 from the 
- * contents of registry.xs. This file has been edited. Don't attempt to rebuild this
- * file with the XS file.
- *
- *    			 
- *
- */
-
 /* XS interface to the Windows NT Registry
  * Written by Jesse Dougherty for Hip Communications 
  */
-#define  WIN32_LEAN_AND_MEAN
-#include <windows.h>
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
+#include "../win32perl.h"
 
 /* Section for the constant definitions. */
 #define MAX_LENGTH 2048
@@ -469,7 +456,7 @@
 RegCreateKeyEx(hkey,subkey,res,kclass,options,sam,security,ohandle,disposition)
 	HKEY hkey
 	char *subkey
-	SV *res = NO_INIT
+	SV *res
 	char *kclass
 	DWORD options
 	REGSAM sam
@@ -524,7 +511,7 @@
 RegEnumKey(hkey,idx,subkey)
 	HKEY hkey
 	DWORD idx
-	char *subkey = NO_INIT
+	char *subkey
     CODE:
 	char keybuffer[TMPBUFSZ];
 	LONG result = RegEnumKey(hkey, idx, keybuffer, sizeof(keybuffer));
@@ -539,9 +526,9 @@
 RegEnumKeyEx(hkey,idx,subkey,classname,lastwritetime)
 	HKEY hkey
 	DWORD idx
-	char *subkey = NO_INIT
-	char *classname = NO_INIT
-	FILETIME lastwritetime = NO_INIT
+	char *subkey
+	char *classname
+	IV lastwritetime
     CODE:
 	char keybuffer[TMPBUFSZ];
 	DWORD keybuffersz = TMPBUFSZ;
@@ -563,10 +550,10 @@
 RegEnumValue(hkey,idx,name,reserved,type,value)
 	HKEY hkey
 	DWORD idx
-	char *name = NO_INIT
-	DWORD reserved = NO_INIT
+	char *name
+	DWORD reserved
 	DWORD type = NO_INIT
-	char *value = NO_INIT
+	char *value
     CODE:
 	static HKEY last_hkey;
 	char  myvalbuf[MAX_LENGTH];
@@ -669,7 +656,7 @@
 RegGetKeySecurity(hkey,sec_info,sec_desc)
 	HKEY hkey
 	DWORD sec_info
-	char *sec_desc = NO_INIT
+	char *sec_desc
     CODE:
 	SECURITY_DESCRIPTOR sd;
 	DWORD sdsz;
@@ -733,7 +720,7 @@
 RegOpenKeyEx(hkey,subkey,res,sam,ohandle)
 	HKEY hkey
 	char *subkey
-	SV *res = NO_INIT
+	SV *res
 	REGSAM sam
 	HKEY ohandle = NO_INIT
     CODE:
@@ -748,9 +735,9 @@
 bool
 RegQueryInfoKey(hkey,kclass,classsz,reserved,numsubkeys,maxsubkeylen,maxclasslen,numvalues,maxvalnamelen,maxvaldatalen,secdesclen,lastwritetime)
 	HKEY hkey
-	char *kclass = NO_INIT
+	char *kclass
 	DWORD classsz = NO_INIT
-	DWORD reserved = NO_INIT
+	DWORD reserved
 	DWORD numsubkeys = NO_INIT
 	DWORD maxsubkeylen = NO_INIT
 	DWORD maxclasslen = NO_INIT
@@ -758,7 +745,7 @@
 	DWORD maxvalnamelen = NO_INIT
 	DWORD maxvaldatalen = NO_INIT
 	DWORD secdesclen = NO_INIT
-	FILETIME lastwritetime = NO_INIT
+	IV lastwritetime
     CODE:
 	char keyclass[TMPBUFSZ];
 	FILETIME ft;
@@ -808,7 +795,7 @@
 RegQueryValueEx(hkey,valuename,reserved,type,data)
 	HKEY hkey
 	char *valuename
-	SV *reserved = NO_INIT
+	SV *reserved
 	DWORD type = NO_INIT
 	SV *data
     CODE:
@@ -960,7 +947,7 @@
 RegSetValueEx(hkey,valname,reserved,type,data)
 	HKEY hkey
 	char *valname
-	DWORD reserved = NO_INIT
+	DWORD reserved
 	DWORD type
 	SV *data
     CODE:
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Registry/t/registry.t perl-libwin32-0.191/Registry/t/registry.t
--- libwin32-0.191/Registry/t/registry.t	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Registry/t/registry.t	2004-01-12 16:46:43.796875000 -0800
@@ -5,12 +5,13 @@
 # Tests for NT Extensions - Registry Manipulation Routines
 # changed to test new registry extension modules.
 
+use Win32;
 use Win32::Registry;
 
 $bug = 1;
 
 open( ME, $0 ) || die $!;
-$bugs = grep( /^\$bug\+\+;\n$/, <ME> );
+$bugs = grep( /^\$bug\+\+;/, <ME> );
 close( ME );
 
 print "1..$bugs\n";
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Registry/typemap perl-libwin32-0.191/Registry/typemap
--- libwin32-0.191/Registry/typemap	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Registry/typemap	2004-01-12 16:46:43.796875000 -0800
@@ -2,3 +2,13 @@
 REGSAM                  T_IV
 HKEY                    T_IV
 HANDLE                  T_IV
+
+INPUT
+
+T_IV
+	$var = ($type)(DWORD)SvIV($arg)
+
+OUTPUT
+
+T_IV
+	sv_setiv($arg, (IV)(DWORD)$var);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Semaphore/Semaphore.xs perl-libwin32-0.191/Semaphore/Semaphore.xs
--- libwin32-0.191/Semaphore/Semaphore.xs	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Semaphore/Semaphore.xs	2004-01-12 16:46:43.812500000 -0800
@@ -1,5 +1,5 @@
 //--------------------------------------------------------------------
-// $Id$
+// $Id: Semaphore.xs,v 1.1.1.1 2003/01/28 19:00:03 caelum Exp $
 //--------------------------------------------------------------------
 //
 //   Win32::Semaphore
@@ -9,15 +9,7 @@
 //
 //--------------------------------------------------------------------
 
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
-
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-
+#include "../win32perl.h"
 
 MODULE = Win32::Semaphore	PACKAGE = Win32::Semaphore
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Semaphore/typemap perl-libwin32-0.191/Semaphore/typemap
--- libwin32-0.191/Semaphore/typemap	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Semaphore/typemap	2004-01-12 16:46:43.828125000 -0800
@@ -8,7 +8,7 @@
 T_PTROBJ
 	if (sv_derived_from($arg, \"${Package}\")) {
 	    IV tmp = SvIV((SV*)SvRV($arg));
-	    $var = ($type) tmp;
+	    $var = ($type)(DWORD) tmp;
 	}
 	else
 	    croak(\"$var is not of type ${Package}\")
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Service/Service.pm perl-libwin32-0.191/Service/Service.pm
--- libwin32-0.191/Service/Service.pm	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Service/Service.pm	2004-01-12 16:46:43.828125000 -0800
@@ -11,6 +11,7 @@
 
 require Exporter;
 require DynaLoader;
+use Win32;
 
 die "The Win32::Service module works only on Windows NT" if(!Win32::IsWinNT());
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Service/Service.xs perl-libwin32-0.191/Service/Service.xs
--- libwin32-0.191/Service/Service.xs	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Service/Service.xs	2004-01-12 16:46:43.843750000 -0800
@@ -2,13 +2,7 @@
  * Service.xs
  */
 
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
+#include "../win32perl.h"
 
 #define RETURNRESULT(x)		if ((x)){ XST_mYES(0); }\
                      		else { XST_mNO(0); }\
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Shortcut/Shortcut.pm perl-libwin32-0.191/Shortcut/Shortcut.pm
--- libwin32-0.191/Shortcut/Shortcut.pm	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Shortcut/Shortcut.pm	2004-01-12 16:46:43.859375000 -0800
@@ -12,6 +12,7 @@
 
 require Exporter;       # to export the constants to the main:: space
 require DynaLoader;     # to dynuhlode the module.
+use Win32;
 
 @ISA= qw( Exporter DynaLoader );
 @EXPORT = qw(
@@ -148,8 +149,9 @@
     my($self, $file) = @_;
     return undef unless ref($self);
 
-    return undef if not $file and not $self->{'File'};
-    $file = $self->{'File'} if not $file;
+    $file = Win32::GetFullPathName($self->{'File'} || $file);
+    return undef if not $file;
+    $self->{'File'} = $file;
 
     _SetPath($self->{'ilink'}, $self->{'ifile'}, $self->{'Path'});
     _SetArguments($self->{'ilink'}, $self->{'ifile'}, $self->{'Arguments'});
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Shortcut/Shortcut.xs perl-libwin32-0.191/Shortcut/Shortcut.xs
--- libwin32-0.191/Shortcut/Shortcut.xs	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Shortcut/Shortcut.xs	2004-01-12 16:46:43.875000000 -0800
@@ -9,35 +9,16 @@
  *
  */
 
-#define  WIN32_LEAN_AND_MEAN
-#include <stdlib.h>
-#include <math.h>
-#include <windows.h>
-
+#include "../win32perl.h"
 #include <shlobj.h>
 #include <shlguid.h>
 #include <objbase.h>
 
-#if defined(__cplusplus)
-extern "C" {
-#endif
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-#if defined(__cplusplus)
-}
-#endif
-
-#ifndef _WIN64
-#  define DWORD_PTR	DWORD
-#endif
-
 // Section for the constant definitions.
 #define CROAK croak
 #define MAX_LENGTH 2048
 #define TMPBUFSZ 1024
 
-
 DWORD
 constant(char *name, int arg)
 {
@@ -238,7 +219,6 @@
     IShellLink * ilink
     IPersistFile * ifile
 PPCODE:
-    HRESULT hres;
     ifile->Release();
     ilink->Release();
     XSRETURN_YES;
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Shortcut/mingw32.exc perl-libwin32-0.191/Shortcut/mingw32.exc
--- libwin32-0.191/Shortcut/mingw32.exc	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Shortcut/mingw32.exc	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Shortcut/test.pl perl-libwin32-0.191/Shortcut/test.pl
--- libwin32-0.191/Shortcut/test.pl	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Shortcut/test.pl	2004-01-12 16:46:43.890625000 -0800
@@ -2,6 +2,7 @@
 # Version 0.03
 # by Aldo Calpini <dada@divinf.it>
 
+use Win32;
 use Win32::Shortcut;
 use Cwd;
 
@@ -18,8 +19,10 @@
     # print "   L.ilink=".$L->{'ilink'}."\n";
     # print "   L.ifile=".$L->{'ifile'}."\n";
 
-    $L->Path($ENV{'SYSTEMROOT'}."\\Notepad.exe");
-    $L->WorkingDirectory($ENV{'TEMP'});
+    my $windows = $ENV{'SYSTEMROOT'} || $ENV{'WINDIR'};
+    $L->Path($windows."\\Notepad.exe");
+    my $temp = $ENV{'TEMP'}; $temp =~ s!/!\\!g;
+    $L->WorkingDirectory($temp);
     $L->ShowCmd(3);
 
     printf("%20s = %s\n","Path",            $L->Path);
@@ -51,9 +54,9 @@
     
     print "\n   Changing shortcut data...\n";
 
-    $L->Set($ENV{'SYSTEMROOT'}."\\Write.exe",
+    $L->Set($windows."\\Write.exe",
             "",
-            $ENV{'SYSTEMROOT'},
+            $windows,
             "This is a description",
             1,
             hex('0x0337'),
@@ -94,8 +97,8 @@
     $L = new Win32::Shortcut();
     if($L) {
         print "OK\n";
-        $L->Path("dummy.txt");
-        $pathto = Cwd::getcwd();
+        $pathto = Win32::GetCwd();
+        $L->Path("$pathto\\dummy.txt");
         $L->WorkingDirectory($pathto);
         printf("%20s = %s\n", "WorkingDirectory", $L->WorkingDirectory);
         printf("%20s = %s\n", "Path", $L->Path);
@@ -103,9 +106,10 @@
         $result = $L->Save("test3.lnk");
         if($result) {
             print "OK\n";
-            print "\n   Renaming \"dummy.txt\" to \"dummy2.txt\"...";
-            if(rename("dummy.txt", "dummy2.txt")) {
-                print "OK\n";
+## FIXME: why does resolving renamed shortcuts not work properly?
+#            print "\n   Renaming \"dummy.txt\" to \"dummy2.txt\"...";
+#            if(rename("dummy.txt", "dummy2.txt")) {
+#                print "OK\n";
                 print "   Attempting resolve...";
                 $L->Resolve() or print "Resolve failed\n";
                 if(-f $L->{'Path'}) {
@@ -118,9 +122,9 @@
                 } else {
                     print "FAILED\n";
                 }
-            } else {
-                print "** ERROR **\n";
-            }
+#            } else {
+#                print "** ERROR **\n";
+#            }
         } else {
             print "** ERROR **\n";
         }
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Shortcut/typemap perl-libwin32-0.191/Shortcut/typemap
--- libwin32-0.191/Shortcut/typemap	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Shortcut/typemap	2004-01-12 16:46:43.906250000 -0800
@@ -4,3 +4,12 @@
 IShellLink *           T_IV
 IPersistFile *         T_IV
 
+INPUT
+
+T_IV
+	$var = ($type)(DWORD)SvIV($arg);
+
+OUTPUT
+
+T_IV
+	sv_setiv($arg, (IV)(DWORD)$var);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Sound/Sound.xs perl-libwin32-0.191/Sound/Sound.xs
--- libwin32-0.191/Sound/Sound.xs	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Sound/Sound.xs	2004-01-12 16:46:43.921875000 -0800
@@ -12,23 +12,13 @@
 #######################################################################
 */
 
-#define  WIN32_LEAN_AND_MEAN
-#include <windows.h>
+#include "../win32perl.h"
 #include <mmsystem.h>
 
-#define __TEMP_WORD  WORD   /* perl defines a WORD, yikes! */
-
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "../ppport.h"
-
 // Section for the constant definitions.
-#define CROAK croak
-
-#undef WORD
-#define WORD __TEMP_WORD
+#ifndef CROAK
+# define CROAK croak
+#endif
 
 #define DEV_WAVEOUT 1
 #define DEV_WAVEIN  2
@@ -315,7 +305,6 @@
 void
 Play(...)
 PPCODE:
-    HANDLE myhandle;
     BOOL bResult;
     UINT flag=0; 
     LPCSTR name = NULL;
@@ -719,13 +708,13 @@
     }    
     tmpsv = hv_fetch(hself, "bits", 4, 0);
     if(tmpsv != NULL) {
-        wavfmt.wBitsPerSample = (DWORD) SvIV(*tmpsv);
+        wavfmt.wBitsPerSample = (WORD)SvIV(*tmpsv);
     } else {
         if(PL_dowarn) warn("Win32::Sound::WaveOut::OpenDevice: invalid format (bits)\n");
     }    
     tmpsv = hv_fetch(hself, "blockalign", 10, 0);
     if(tmpsv != NULL) {
-        wavfmt.nBlockAlign = (DWORD) SvIV(*tmpsv);
+        wavfmt.nBlockAlign = (WORD)SvIV(*tmpsv);
     } else {
         wavfmt.nBlockAlign = wavfmt.nChannels * wavfmt.wBitsPerSample / 8;
     }
@@ -740,8 +729,8 @@
         &wo,
         (UINT) id,
         &wavfmt,
-        NULL,
-        NULL,
+        0,
+        0,
         CALLBACK_NULL
     );
     if(RETVAL == MMSYSERR_NOERROR) {
@@ -763,7 +752,7 @@
     hself = (HV*) SvRV(self);
     tmpsv = hv_fetch(hself, "handle", 6, 0);
     if(tmpsv != NULL) {
-        wo = (HWAVEOUT) SvIV(*tmpsv);
+        wo = (HWAVEOUT)(DWORD) SvIV(*tmpsv);
         RETVAL = waveOutClose(wo);
         WaveOutCheckError(RETVAL);
     } else {
@@ -790,7 +779,7 @@
     hself = (HV*) SvRV(self);
     tmpsv = hv_fetch(hself, "handle", 6, 0);
     if(tmpsv != NULL) {
-        wo = (HWAVEOUT) SvIV(*tmpsv);
+        wo = (HWAVEOUT)(DWORD) SvIV(*tmpsv);
         wavlength = SvLEN(data);
         hgdata = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, wavlength);
         hv_store(hself, "wavdata", 7, newSViv((long) hgdata), 0);
@@ -825,10 +814,10 @@
     hself = (HV*)SvRV(self);
     tmpsv = hv_fetch(hself, "handle", 6, 0);
     if(tmpsv != NULL) {
-        wo = (HWAVEOUT) SvIV(*tmpsv);
+        wo = (HWAVEOUT)(DWORD) SvIV(*tmpsv);
         tmpsv = hv_fetch(hself, "wavheadlock", 11, 0);
         if(tmpsv != NULL) {
-            wh = (LPWAVEHDR) SvIV(*tmpsv);
+            wh = (LPWAVEHDR)(DWORD) SvIV(*tmpsv);
             RETVAL = waveOutWrite(wo, wh, sizeof(WAVEHDR));
             WaveOutCheckError(RETVAL);          
         } else {
@@ -851,8 +840,6 @@
     HV* hself;
     SV** tmpsv;
     HMMIO mmio;
-    HWAVEOUT wo;
-    LPWAVEHDR wh;
     WAVEFORMATEX wavfmt;
     MMCKINFO mmchunk; 
     MMCKINFO mmsubchunk; 
@@ -873,19 +860,19 @@
     }
     tmpsv = hv_fetch(hself, "samplerate", 10, 0);
     if(tmpsv != NULL) {
-        wavfmt.nSamplesPerSec = (DWORD) SvIV(*tmpsv);
+        wavfmt.nSamplesPerSec = (WORD) SvIV(*tmpsv);
     } else {
         if(PL_dowarn) warn("WaveOut::Save: invalid format (samplerate)");
     }
     tmpsv = hv_fetch(hself, "bits", 4, 0);
     if(tmpsv != NULL) {
-        wavfmt.wBitsPerSample = (DWORD) SvIV(*tmpsv);
+        wavfmt.wBitsPerSample = (WORD) SvIV(*tmpsv);
     } else {
         if(PL_dowarn) warn("WaveOut::Save: invalid format (bits)");
     }
     tmpsv = hv_fetch(hself, "blockalign", 10, 0);
     if(tmpsv != NULL) {
-        wavfmt.nBlockAlign = (DWORD) SvIV(*tmpsv);
+        wavfmt.nBlockAlign = (WORD) SvIV(*tmpsv);
     } else {
         wavfmt.nBlockAlign = wavfmt.nChannels * wavfmt.wBitsPerSample / 8;
     }
@@ -906,7 +893,7 @@
     } else {
         tmpsv = hv_fetch(hself, "wavdatalock", 11, 0);
         if(tmpsv != NULL) {
-            buffer = (char _huge*) SvIV(*tmpsv);
+            buffer = (char _huge*)(DWORD) SvIV(*tmpsv);
             bufferlen = (LONG) GlobalSize((HGLOBAL) buffer);
             printf("XS(WaveOut::Save): loaded bufferlen=%ld\n", bufferlen);
         } else {
@@ -960,10 +947,10 @@
     hself = (HV*)SvRV(self);
     tmpsv = hv_fetch(hself, "handle", 6, 0);
     if(tmpsv != NULL) {
-        wo = (HWAVEOUT) SvIV(*tmpsv);
+        wo = (HWAVEOUT)(DWORD) SvIV(*tmpsv);
         tmpsv = hv_fetch(hself, "wavheadlock", 11, 0);
         if(tmpsv != NULL) {
-            wh = (LPWAVEHDR) SvIV(*tmpsv);
+            wh = (LPWAVEHDR)(DWORD) SvIV(*tmpsv);
             if(wh->dwFlags & WHDR_PREPARED) {
                 RETVAL = waveOutUnprepareHeader(wo, wh, sizeof(wh));
             }
@@ -972,19 +959,19 @@
         }
         tmpsv = hv_fetch(hself, "wavhead", 7, 0);
         if(tmpsv != NULL) {
-            hg = (HGLOBAL) SvIV(*tmpsv);
+            hg = (HGLOBAL)(DWORD) SvIV(*tmpsv);
             GlobalFree(hg);
             hv_delete(hself, "wavhead", 7, 0);
         }
         tmpsv = hv_fetch(hself, "wavdatalock", 11, 0);
         if(tmpsv != NULL) {
-            hg = (HGLOBAL) SvIV(*tmpsv);
+            hg = (HGLOBAL)(DWORD) SvIV(*tmpsv);
             GlobalUnlock(hg);
             hv_delete(hself, "wavdatalock", 11, 0);
         }
         tmpsv = hv_fetch(hself, "wavdata", 7, 0);
         if(tmpsv != NULL) {
-            hg = (HGLOBAL) SvIV(*tmpsv);
+            hg = (HGLOBAL)(DWORD) SvIV(*tmpsv);
             GlobalFree(hg);
             hv_delete(hself, "wavdata", 7, 0);
         }        
@@ -1013,12 +1000,12 @@
     hself = (HV*) SvRV(self);
     tmpsv = hv_fetch(hself, "mmio", 4, 0);
     if(tmpsv != NULL) {
-        mmio = (HMMIO) SvIV(*tmpsv);
+        mmio = (HMMIO)(DWORD) SvIV(*tmpsv);
         mmioClose(mmio, 0);
     }
     tmpsv = hv_fetch(hself, "handle", 6, 0);
     if(tmpsv != NULL) {
-        wo = (HWAVEOUT) SvIV(*tmpsv);
+        wo = (HWAVEOUT)(DWORD) SvIV(*tmpsv);
         waveOutClose(wo);
     }   
     mmio = mmioOpen((LPSTR) filename, NULL, MMIO_READ);
@@ -1043,8 +1030,8 @@
                     &wo, 
                     (UINT) id, 
                     &wavfmt, 
-                    NULL, 
-                    NULL, 
+                    0, 
+                    0, 
                     CALLBACK_NULL /* | WAVE_ALLOWSYNC | WAVE_FORMAT_DIRECT */
                 );
                 if(mmr == MMSYSERR_NOERROR) {
@@ -1084,7 +1071,7 @@
     hself = (HV*)SvRV(self);
     hmmio = hv_fetch(hself, "mmio", 4, 0);
     if(hmmio != NULL) {
-        mmio = (HMMIO) SvIV(*hmmio);
+        mmio = (HMMIO)(DWORD) SvIV(*hmmio);
         mmioSeek(mmio, 0, SEEK_SET);
         mmchunk.fccType = mmioFOURCC('W', 'A', 'V', 'E'); 
         if (mmioDescend(mmio, &mmchunk, NULL, MMIO_FINDRIFF)) {
@@ -1122,7 +1109,7 @@
                 wh->dwFlags = 0;
                 hwo = hv_fetch(hself, "handle", 6, 0);
                 if(hwo != NULL) {
-                    wo = (HWAVEOUT) SvIV(*hwo);
+                    wo = (HWAVEOUT)(DWORD) SvIV(*hwo);
                     mmr = waveOutPrepareHeader(wo, wh, sizeof(WAVEHDR));
                     if(mmr == MMSYSERR_NOERROR) {
                         mmr = waveOutWrite(wo, wh, sizeof(WAVEHDR));
@@ -1157,7 +1144,7 @@
     hself = (HV*)SvRV(self);
     wavhead = hv_fetch(hself, "wavheadlock", 11, 0);
     if(wavhead != NULL) {
-        wh = (LPWAVEHDR) SvIV(*wavhead);
+        wh = (LPWAVEHDR)(DWORD) SvIV(*wavhead);
         if(wh->dwFlags & WHDR_DONE) {
             XSRETURN_IV(1);
         } else {
@@ -1171,7 +1158,6 @@
 void
 Position(self)
     SV* self
-    int type
 PPCODE:
     HV* hself;
     SV** handle;
@@ -1183,7 +1169,7 @@
     hself = (HV*)SvRV(self);
     handle = hv_fetch(hself, "handle", 6, 0);
     if(handle != NULL) {
-        wo = (HWAVEOUT) SvIV(*handle);
+        wo = (HWAVEOUT)(DWORD) SvIV(*handle);
         mmt.wType = (UINT) ttype;
         mmr = waveOutGetPosition(wo, &mmt, sizeof(MMTIME));
         if(mmr == MMSYSERR_NOERROR) {
@@ -1216,7 +1202,7 @@
     hself = (HV*)SvRV(self);
     handle = hv_fetch(hself, "handle", 6, 0);
     if(handle != NULL) {
-        RETVAL = waveOutPause((HWAVEOUT)SvIV(*handle));
+        RETVAL = waveOutPause((HWAVEOUT)(DWORD)SvIV(*handle));
         WaveOutCheckError(RETVAL);
     } else {
         PerlSetError(-1, "Device is not opened");
@@ -1235,7 +1221,7 @@
     hself = (HV*)SvRV(self);
     handle = hv_fetch(hself, "handle", 6, 0);
     if(handle != NULL) {
-        RETVAL = waveOutRestart((HWAVEOUT)SvIV(*handle));
+        RETVAL = waveOutRestart((HWAVEOUT)(DWORD)SvIV(*handle));
         WaveOutCheckError(RETVAL);
     } else {
         PerlSetError(-1, "Device is not opened");
@@ -1254,7 +1240,7 @@
     hself = (HV*)SvRV(self);
     handle = hv_fetch(hself, "handle", 6, 0);
     if(handle != NULL) {
-        RETVAL = waveOutReset((HWAVEOUT)SvIV(*handle));
+        RETVAL = waveOutReset((HWAVEOUT)(DWORD)SvIV(*handle));
         WaveOutCheckError(RETVAL);
     } else {
         PerlSetError(-1, "Device is not opened");
@@ -1275,7 +1261,7 @@
     hself = (HV*)SvRV(self);
     handle = hv_fetch(hself, "handle", 6, 0);    
     if(handle != NULL) {
-        wo = (HWAVEOUT)SvIV(*handle);
+        wo = (HWAVEOUT)(DWORD)SvIV(*handle);
         switch(items) {
         case 0:
             mmr = waveOutGetVolume(wo, &volume);
@@ -1329,7 +1315,7 @@
     hself = (HV*)SvRV(self);
     tmpsv = hv_fetch(hself, "mmio", 4, 0);
     if(tmpsv != NULL) {
-        mmio = (HMMIO) SvIV(*tmpsv);
+        mmio = (HMMIO)(DWORD) SvIV(*tmpsv);
         RETVAL = mmioClose(mmio, 0);
         hv_delete(hself, "mmio", 4, 0);
     } else {
@@ -1353,7 +1339,7 @@
     hself = (HV*)SvRV(self);
     tmpsv = hv_fetch(hself, "handle", 6, 0);
     if(tmpsv != NULL) {
-        wo = (HWAVEOUT) SvIV(*tmpsv);
+        wo = (HWAVEOUT)(DWORD) SvIV(*tmpsv);
         if(items == 1) {
             mmr = waveOutGetPitch(wo, &dwPitch);
             WaveOutCheckError(mmr);
@@ -1383,7 +1369,7 @@
     hself = (HV*)SvRV(self);
     tmpsv = hv_fetch(hself, "handle", 6, 0);
     if(tmpsv != NULL) {
-        wo = (HWAVEOUT) SvIV(*tmpsv);
+        wo = (HWAVEOUT)(DWORD) SvIV(*tmpsv);
         if(items == 1) {
             mmr = waveOutGetPlaybackRate(wo, &dwRate);
             WaveOutCheckError(mmr);
@@ -1430,10 +1416,10 @@
     hself = (HV*)SvRV(self);
     tmpsv = hv_fetch(hself, "handle", 6, 0);
     if(tmpsv != NULL) {
-        wo = (HWAVEOUT) SvIV(*tmpsv);
+        wo = (HWAVEOUT)(DWORD) SvIV(*tmpsv);
         tmpsv = hv_fetch(hself, "wavheadlock", 11, 0);
         if(tmpsv != NULL) {
-            wh = (LPWAVEHDR) SvIV(*tmpsv);
+            wh = (LPWAVEHDR)(DWORD) SvIV(*tmpsv);
             if(wh->dwFlags & WHDR_PREPARED) {
                 mmr = waveOutUnprepareHeader(wo, wh, sizeof(wh));
             }
@@ -1441,22 +1427,22 @@
         }
         tmpsv = hv_fetch(hself, "wavhead", 7, 0);
         if(tmpsv != NULL) {
-            hg = (HGLOBAL) SvIV(*tmpsv);
+            hg = (HGLOBAL)(DWORD) SvIV(*tmpsv);
             GlobalFree(hg);
         }
         tmpsv = hv_fetch(hself, "wavdatalock", 11, 0);
         if(tmpsv != NULL) {
-            hg = (HGLOBAL) SvIV(*tmpsv);
+            hg = (HGLOBAL)(DWORD) SvIV(*tmpsv);
             GlobalUnlock(hg);
         }
         tmpsv = hv_fetch(hself, "wavdata", 7, 0);
         if(tmpsv != NULL) {
-            hg = (HGLOBAL) SvIV(*tmpsv);
+            hg = (HGLOBAL)(DWORD) SvIV(*tmpsv);
             GlobalFree(hg);
         }        
 	tmpsv = hv_fetch(hself, "mmio", 4, 0);
 	if(tmpsv != NULL) {
-	    mmio = (HMMIO) SvIV(*tmpsv);
+	    mmio = (HMMIO)(DWORD) SvIV(*tmpsv);
 	    mmioClose(mmio, 0);
 	}
         waveOutClose(wo);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Sound/mingw32.exc perl-libwin32-0.191/Sound/mingw32.exc
--- libwin32-0.191/Sound/mingw32.exc	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Sound/mingw32.exc	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-ECHO is on.
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/TieRegistry/TieRegistry.pm perl-libwin32-0.191/TieRegistry/TieRegistry.pm
--- libwin32-0.191/TieRegistry/TieRegistry.pm	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/TieRegistry/TieRegistry.pm	2004-01-12 16:46:43.937500000 -0800
@@ -1797,7 +1797,7 @@
 [C<'\0'>].  Each subkey is also a key and so can contain subkeys
 and values [and has a class, time stamp, and security information].
 
-Each value has a name:  a string which E<can> be blank and E<can>
+Each value has a name:  a string which I<can> be blank and I<can>
 contain the delimiter character [backslash: C<'\\'>] and any
 character except for null, C<'\0'>.  Each value also has data
 associated with it.  Each value's data is a contiguous chunk of
@@ -1845,7 +1845,7 @@
 =item REG_DWORD
 
 A long [4-byte] integer value.  These values are expected either
-packed into a 4-character string or as a hex string of E<more than>
+packed into a 4-character string or as a hex string of I<more than>
 4 characters [but I<not> as a numeric value, unfortunately, as there is
 no sure way to tell a numeric value from a packed 4-byte string that
 just happens to be a string containing a valid numeric value].
@@ -1899,7 +1899,7 @@
 Note that you will most likely use C<$Registry> instead of using
 a tied hash.  C<$Registry> is a reference to a hash that has
 been tied to the virtual root of your computer's Registry [as if,
-C<$Registry= \%RegHash>].  So you would use C<$Registry-E<gt>{Key}>
+C<$Registry= \%RegHash>].  So you would use C<$Registry-I<gt>{Key}>
 rather than C<$RegHash{Key}> and use C<keys %{$Registry}> rather
 than C<keys %RegHash>, for example.
 
@@ -1959,7 +1959,7 @@
 fail, usually with C<ERROR_INSUFFICIENT_BUFFER>.  For example, you
 can't enumerate key names without also enumerating values which
 require huge buffers but the exact buffer size required cannot be
-determined beforehand because C<RegQueryInfoKey()> E<always> fails
+determined beforehand because C<RegQueryInfoKey()> I<always> fails
 with C<ERROR_INSUFFICIENT_BUFFER> for C<HKEY_PERFORMANCE_DATA> no
 matter how it is called.  So it is currently not very useful to
 tie a hash to this key.  You can use it to create an object to use
@@ -2428,7 +2428,7 @@
 you may not have C<KEY_WRITE> access to it or some of its subkeys.
 
 If the C<"Access"> option value is a string that starts with
-C<"KEY_">, then it should match E<one> of the predefined access
+C<"KEY_">, then it should match I<one> of the predefined access
 levels [probably C<"KEY_READ">, C<"KEY_WRITE">, or
 C<"KEY_ALL_ACCESS">] exported by the I<Win32API::Registry> module.
 Otherwise, a numeric value is expected.  For maximum flexibility,
@@ -3151,8 +3151,8 @@
 If true, specifies that the new key should be volatile, that is,
 stored only in memory and not backed by a hive file [and not saved
 if the computer is rebooted].  This option is ignored under
-Windows 95.  Specifying C<Volatile=E<GT>1>  is the same as
-specifying C<Options=E<GT>REG_OPTION_VOLATILE>.
+Windows 95.  Specifying C<Volatile=E<gt>1>  is the same as
+specifying C<Options=E<gt>REG_OPTION_VOLATILE>.
 
 =item Backup
 
@@ -3165,8 +3165,8 @@
 opened with C<KEY_WRITE> access as the C<"LocalSystem"> user which
 should have access to all subkeys.
 
-This option is ignored under Windows 95.  Specifying C<Backup=E<GT>1>
-is the same as specifying C<Options=E<GT>REG_OPTION_BACKUP_RESTORE>.
+This option is ignored under Windows 95.  Specifying C<Backup=E<gt>1>
+is the same as specifying C<Options=E<gt>REG_OPTION_BACKUP_RESTORE>.
 
 =item Options
 
@@ -3227,7 +3227,7 @@
 occurrences of either the delimiter or the OS delimiter.
 
 If C<$newSubKey> is not specified, then it is as if C<$key>
-was C<$Registry-E<GT>{LMachine}> and C<$newSubKey> is
+was C<$Registry-E<gt>{LMachine}> and C<$newSubKey> is
 C<"PerlTie:999"> where C<"999"> is actually a sequence number
 incremented each time this process calls C<Load()>.
 
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Win32.pm perl-libwin32-0.191/Win32.pm
--- libwin32-0.191/Win32.pm	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Win32.pm	2004-01-12 16:46:43.953125000 -0800
@@ -11,6 +11,7 @@
 
     require Exporter;
     require DynaLoader;
+    eval { require Win32CORE; };
 
     @ISA = qw|Exporter DynaLoader|;
     $VERSION = '0.191';
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Win32.xs perl-libwin32-0.191/Win32.xs
--- libwin32-0.191/Win32.xs	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/Win32.xs	2004-01-12 16:46:43.968750000 -0800
@@ -1,10 +1,5 @@
-#include <windows.h>
-
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
-#include "ppport.h"
+#include "win32perl.h"
+#include <objbase.h>
 
 #define SE_SHUTDOWN_NAMEA   "SeShutdownPrivilege"
 #define SE_SHUTDOWN_NAMEW   L"SeShutdownPrivilege"
@@ -13,7 +8,7 @@
 {
     dXSARGS;
     char *lpSource;
-    BYTE buffer[4096];
+    char buffer[4096];
     DWORD dwDataLen;
     STRLEN n_a;
 
@@ -102,7 +97,6 @@
     char Domain[256];
     DWORD DomLen = sizeof(Domain);
     SID_NAME_USE snu;
-    long retval;
     STRLEN n_a;
     BOOL bResult;
 
@@ -112,7 +106,6 @@
     sid = SvPV(ST(1), n_a);
     if (IsValidSid(sid)) {
 	if (USING_WIDE()) {
-	    WCHAR wSID[sizeof(SID)];
 	    WCHAR wDomain[sizeof(Domain)];
 	    WCHAR wSystem[MAX_PATH+1];
 	    WCHAR wAccount[sizeof(Account)];
@@ -141,7 +134,7 @@
 	if (bResult) {
 	    sv_setpv(ST(2), Account);
 	    sv_setpv(ST(3), Domain);
-	    sv_setiv(ST(4), (double) snu);
+	    sv_setiv(ST(4), (IV) snu);
 	    XSRETURN_YES;
 	}
 	else {
@@ -334,7 +327,7 @@
     dXSARGS;
     if (items != 1)
 	croak("usage: Win32::FreeLibrary($handle)\n");
-    if (FreeLibrary((HINSTANCE) SvIV(ST(0)))) {
+    if (FreeLibrary((HINSTANCE)(DWORD)SvIV(ST(0)))) {
 	XSRETURN_YES;
     }
     XSRETURN_NO;
@@ -346,7 +339,7 @@
     STRLEN n_a;
     if (items != 2)
 	croak("usage: Win32::GetProcAddress($hinstance, $procname)\n");
-    XSRETURN_IV((long)GetProcAddress((HINSTANCE)SvIV(ST(0)), SvPV(ST(1), n_a)));
+    XSRETURN_IV((long)GetProcAddress((HINSTANCE)(DWORD)SvIV(ST(0)), SvPV(ST(1), n_a)));
 }
 
 XS(w32_RegisterServer)
@@ -354,7 +347,7 @@
     dXSARGS;
     BOOL result = FALSE;
     HINSTANCE hnd;
-    FARPROC func;
+    FARPROC(func);
     STRLEN n_a;
     char* lpName;
 
@@ -387,7 +380,7 @@
     dXSARGS;
     BOOL result = FALSE;
     HINSTANCE hnd;
-    FARPROC func;
+    FARPROC(func);
     STRLEN n_a;
     char* lpName;
 
@@ -437,14 +430,15 @@
 {
     dXSARGS;
     GUID guid;
-    char szGUID[50] = {'\0'};
-    HRESULT  hr     = CoCreateGuid(&guid);
+    char szGUID[100] = {'\0'};
+    HRESULT  hr      = CoCreateGuid(&guid);
 
     if (SUCCEEDED(hr)) {
-	LPOLESTR pStr = NULL;
-	StringFromCLSID(&guid, &pStr);
+	WCHAR pStr[100];
+	int retval = StringFromGUID2(guid, pStr, sizeof(pStr));
 	WideCharToMultiByte(CP_ACP, 0, pStr, wcslen(pStr), szGUID,
 			    sizeof(szGUID), NULL, NULL);
+	szGUID[retval - 1] = '\0';
 
 	XSRETURN_PV(szGUID);
     }
@@ -452,6 +446,9 @@
 	XSRETURN_UNDEF;
 }
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 XS(boot_Win32)
 {
     dXSARGS;
@@ -474,3 +471,6 @@
 
     XSRETURN_YES;
 }
+#ifdef __cplusplus
+}
+#endif
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Win32CORE/Changes perl-libwin32-0.191/Win32CORE/Changes
--- libwin32-0.191/Win32CORE/Changes	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/Win32CORE/Changes	2004-01-12 16:46:43.968750000 -0800
@@ -0,0 +1,6 @@
+Revision history for Perl extension Win32CORE.
+
+0.01  Wed Jan 15 00:35:19 2003
+	- original version; created by h2xs 1.21 with options
+		-A -n Win32CORE
+
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Win32CORE/MANIFEST perl-libwin32-0.191/Win32CORE/MANIFEST
--- libwin32-0.191/Win32CORE/MANIFEST	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/Win32CORE/MANIFEST	2004-01-12 16:46:43.984375000 -0800
@@ -0,0 +1,6 @@
+Changes
+Makefile.PL
+MANIFEST
+t/win32core.t
+Win32CORE.pm
+Win32CORE.c
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Win32CORE/Makefile.PL perl-libwin32-0.191/Win32CORE/Makefile.PL
--- libwin32-0.191/Win32CORE/Makefile.PL	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/Win32CORE/Makefile.PL	2004-01-12 16:46:44.000000000 -0800
@@ -0,0 +1,13 @@
+use ExtUtils::MakeMaker;
+
+my $BACKPORT            = 1 if not defined eval { Win32::GetOSVersion() };
+
+WriteMakefile(
+    'NAME'		=> 'Win32CORE',
+    'VERSION_FROM'	=> 'Win32CORE.pm',
+    'DEFINE'		=> '-DMODULE '.($BACKPORT ? '-DBACKPORT' : ''),
+    ($] >= 5.005 ? (
+        ABSTRACT_FROM => 'Win32CORE.pm',
+        AUTHOR        => 'Gurusamy Sarathy <gsar@activestate.com>',
+    ) : ()),
+);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Win32CORE/Win32CORE.c perl-libwin32-0.191/Win32CORE/Win32CORE.c
--- libwin32-0.191/Win32CORE/Win32CORE.c	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/Win32CORE/Win32CORE.c	2004-01-12 16:46:44.015625000 -0800
@@ -0,0 +1,798 @@
+/* WIN32CORE.xs
+ *
+ * (c) 1995 Microsoft Corporation. All rights reserved.
+ * 		Developed by hip communications inc., http://info.hip.com/info/
+ * Portions (c) 1993 Intergraph Corporation. All rights reserved.
+ *
+ *    You may distribute under the terms of either the GNU General Public
+ *    License or the Artistic License, as specified in the README file.
+ */
+#include <windows.h>
+
+#if defined(__CYGWIN__) && PERL_REVISION <= 5 && PERL_VERSION <= 6
+# undef WIN32
+#endif
+
+#define _TEMP_WORD WORD
+
+#include "EXTERN.h"
+#include "perl.h"
+#include "XSUB.h"
+
+#undef  WORD
+#define WORD _TEMP_WORD
+
+#ifdef MODULE
+#  include "../ppport.h"
+#endif
+
+#if defined(__CYGWIN__)
+#  undef  DllExport
+#  define DllExport
+#endif
+
+#define ONE_K_BUFSIZE		1024
+
+#ifndef get_childenv
+#  define get_childenv		win32_get_childenv
+#  define free_childenv		win32_free_childenv
+#  define get_childdir		win32_get_childdir
+#  define free_childdir		win32_free_childdir
+#endif
+
+#ifndef PerlDir_mapA
+#  define PerlDir_mapA(dir)	dir
+#endif
+
+#define isSLASH(c)		((c) == '/' || (c) == '\\')
+
+#define SKIP_SLASHES(s) \
+    STMT_START {				\
+	while (*(s) && isSLASH(*(s)))		\
+	    ++(s);				\
+    } STMT_END
+
+#define COPY_NONSLASHES(d,s) \
+    STMT_START {				\
+	while (*(s) && !isSLASH(*(s)))		\
+	    *(d)++ = *(s)++;			\
+    } STMT_END
+
+ 
+/* Add the CXT macros for Perls that don't have them. */
+
+#if !defined(START_MY_CXT) && defined(PERL_IMPLICIT_CONTEXT)
+
+/* Taken from perl.h in newer Perls */
+
+#define START_MY_CXT
+
+#define dMY_CXT_SV \
+	SV *my_cxt_sv = *hv_fetch(PL_modglobal, MY_CXT_KEY,		\
+				  sizeof(MY_CXT_KEY)-1, TRUE)
+
+#define dMY_CXT	\
+	dMY_CXT_SV;							\
+	my_cxt_t *my_cxtp = INT2PTR(my_cxt_t*, SvUV(my_cxt_sv))
+
+#define MY_CXT_INIT \
+	dMY_CXT_SV;							\
+	/* newSV() allocates one more than needed */			\
+	my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\
+	Zero(my_cxtp, 1, my_cxt_t);					\
+	sv_setuv(my_cxt_sv, PTR2UV(my_cxtp))
+
+#define MY_CXT		(*my_cxtp)
+
+#endif /* CXT macros */
+
+/* Only use CXT if building backport */
+
+#ifdef BACKPORT
+
+#define MY_CXT_KEY	"Win32CORE::_guts" XS_VERSION
+
+typedef struct {
+	char	Wgetlogin_buffer[128];
+	BOOL	Wuse_showwindow;
+	WORD	Wshowwindow;
+} my_cxt_t;
+ 
+START_MY_CXT
+
+#define w32_getlogin_buffer	MY_CXT.Wgetlogin_buffer
+#define w32_use_showwindow	MY_CXT.Wuse_showwindow
+#define w32_showwindow		MY_CXT.Wshowwindow
+
+static DWORD w32_platform = (DWORD)-1;
+
+#endif /* BACKPORT */
+
+/* Don't build anything when compiled as an extension on Perls that have the
+ * core linked in statically. Also don't build anything on non-windows
+ * platformls.
+ */
+
+#if !defined(MODULE) || defined(BACKPORT) && (\
+  defined(WIN32) || defined(_WIN32) || defined(__CYGWIN__) || \
+  defined(__CYGWIN32__) || defined(__WINDOWS__) || defined(_WINCE) \
+)
+
+/* Internal functions */
+
+DllExport unsigned long
+win32_os_id(void)
+{
+    static OSVERSIONINFO osver;
+
+    if (osver.dwPlatformId != w32_platform) {
+	memset(&osver, 0, sizeof(OSVERSIONINFO));
+	osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
+	GetVersionEx(&osver);
+	w32_platform = osver.dwPlatformId;
+    }
+    return (unsigned long)w32_platform;
+}
+
+DllExport int
+IsWinNT(void)
+{
+    return (win32_os_id() == VER_PLATFORM_WIN32_NT);
+}
+
+DllExport int
+IsWin95(void)
+{
+    return (win32_os_id() == VER_PLATFORM_WIN32_WINDOWS);
+}
+
+DllExport void*
+win32_get_childenv(void)
+{
+    return NULL;
+}
+
+DllExport void
+win32_free_childenv(void* d)
+{
+}
+
+DllExport char*
+win32_get_childdir(void)
+{
+    dTHX;
+    char* ptr;
+    char szfilename[(MAX_PATH+1)*2];
+    if (USING_WIDE()) {
+        WCHAR wfilename[MAX_PATH+1];
+        GetCurrentDirectoryW(MAX_PATH+1, wfilename);
+        W2AHELPER(wfilename, szfilename, sizeof(szfilename));
+    }
+    else {
+        GetCurrentDirectoryA(MAX_PATH+1, szfilename);
+    }
+
+    New(0, ptr, strlen(szfilename)+1, char);
+    strcpy(ptr, szfilename);
+    return ptr;
+}
+
+DllExport void
+win32_free_childdir(char* d)
+{
+    dTHX;
+    Safefree(d);
+}
+
+/* Find the longname of a given path.  path is destructively modified.
+ * It should have space for at least MAX_PATH characters. */
+DllExport char *
+win32_longpath(char *path)
+{
+    WIN32_FIND_DATA fdata;
+    HANDLE fhand;
+    char tmpbuf[MAX_PATH+1];
+    char *tmpstart = tmpbuf;
+    char *start = path;
+    char sep;
+    if (!path)
+	return Nullch;
+
+    /* drive prefix */
+    if (isALPHA(path[0]) && path[1] == ':') {
+	start = path + 2;
+	*tmpstart++ = path[0];
+	*tmpstart++ = ':';
+    }
+    /* UNC prefix */
+    else if (isSLASH(path[0]) && isSLASH(path[1])) {
+	start = path + 2;
+	*tmpstart++ = path[0];
+	*tmpstart++ = path[1];
+	SKIP_SLASHES(start);
+	COPY_NONSLASHES(tmpstart,start);	/* copy machine name */
+	if (*start) {
+	    *tmpstart++ = *start++;
+	    SKIP_SLASHES(start);
+	    COPY_NONSLASHES(tmpstart,start);	/* copy share name */
+	}
+    }
+    *tmpstart = '\0';
+    while (*start) {
+	/* copy initial slash, if any */
+	if (isSLASH(*start)) {
+	    *tmpstart++ = *start++;
+	    *tmpstart = '\0';
+	    SKIP_SLASHES(start);
+	}
+
+	/* FindFirstFile() expands "." and "..", so we need to pass
+	 * those through unmolested */
+	if (*start == '.'
+	    && (!start[1] || isSLASH(start[1])
+		|| (start[1] == '.' && (!start[2] || isSLASH(start[2])))))
+	{
+	    COPY_NONSLASHES(tmpstart,start);	/* copy "." or ".." */
+	    *tmpstart = '\0';
+	    continue;
+	}
+
+	/* if this is the end, bust outta here */
+	if (!*start)
+	    break;
+
+	/* now we're at a non-slash; walk up to next slash */
+	while (*start && !isSLASH(*start))
+	    ++start;
+
+	/* stop and find full name of component */
+	sep = *start;
+	*start = '\0';
+	fhand = FindFirstFile(path,&fdata);
+	*start = sep;
+	if (fhand != INVALID_HANDLE_VALUE) {
+	    STRLEN len = strlen(fdata.cFileName);
+	    if ((STRLEN)(tmpbuf + sizeof(tmpbuf) - tmpstart) > len) {
+		strcpy(tmpstart, fdata.cFileName);
+		tmpstart += len;
+		FindClose(fhand);
+	    }
+	    else {
+		FindClose(fhand);
+		errno = ERANGE;
+		return Nullch;
+	    }
+	}
+	else {
+	    /* failed a step, just return without side effects */
+	    /*PerlIO_printf(Perl_debug_log, "Failed to find %s\n", path);*/
+	    errno = EINVAL;
+	    return Nullch;
+	}
+    }
+    strcpy(path,tmpbuf);
+    return path;
+}
+
+/* End of internal functions. */
+
+/* XS Interface */
+
+XS(w32_SetLastError)
+{
+    dXSARGS;
+    if (items != 1)
+	Perl_croak(aTHX_ "usage: Win32::SetLastError($error)");
+    SetLastError(SvIV(ST(0)));
+    XSRETURN_EMPTY;
+}
+
+XS(w32_GetLastError)
+{
+    dXSARGS;
+    EXTEND(SP,1);
+    XSRETURN_IV(GetLastError());
+}
+
+XS(w32_LoginName)
+{
+    dXSARGS;
+#if defined(MODULE) && defined(BACKPORT) && !defined(PERL_IMPLICIT_SYS)
+    dMY_CXT;
+#endif
+    char *name = w32_getlogin_buffer;
+    DWORD size = sizeof(w32_getlogin_buffer);
+    EXTEND(SP,1);
+    if (GetUserName(name,&size)) {
+	/* size includes NULL */
+	ST(0) = sv_2mortal(newSVpvn(name,size-1));
+	XSRETURN(1);
+    }
+    XSRETURN_UNDEF;
+}
+
+XS(w32_NodeName)
+{
+    dXSARGS;
+    char name[MAX_COMPUTERNAME_LENGTH+1];
+    DWORD size = sizeof(name);
+    EXTEND(SP,1);
+    if (GetComputerName(name,&size)) {
+	/* size does NOT include NULL :-( */
+	ST(0) = sv_2mortal(newSVpvn(name,size));
+	XSRETURN(1);
+    }
+    XSRETURN_UNDEF;
+}
+
+XS(w32_DomainName)
+{
+    dXSARGS;
+    HINSTANCE hNetApi32 = LoadLibrary("netapi32.dll");
+    DWORD (__stdcall *pfnNetApiBufferFree)(LPVOID Buffer);
+    DWORD (__stdcall *pfnNetWkstaGetInfo)(LPWSTR servername, DWORD level,
+					  void *bufptr);
+
+    if (hNetApi32) {
+	pfnNetApiBufferFree = (DWORD (__stdcall *)(void *))
+	    GetProcAddress(hNetApi32, "NetApiBufferFree");
+	pfnNetWkstaGetInfo = (DWORD (__stdcall *)(LPWSTR, DWORD, void *))
+	    GetProcAddress(hNetApi32, "NetWkstaGetInfo");
+    }
+    EXTEND(SP,1);
+    if (hNetApi32 && pfnNetWkstaGetInfo && pfnNetApiBufferFree) {
+	/* this way is more reliable, in case user has a local account. */
+	char dname[256];
+	DWORD dnamelen = sizeof(dname);
+	struct {
+	    DWORD   wki100_platform_id;
+	    LPWSTR  wki100_computername;
+	    LPWSTR  wki100_langroup;
+	    DWORD   wki100_ver_major;
+	    DWORD   wki100_ver_minor;
+	} *pwi;
+	/* NERR_Success *is* 0*/
+	if (0 == pfnNetWkstaGetInfo(NULL, 100, &pwi)) {
+	    if (pwi->wki100_langroup && *(pwi->wki100_langroup)) {
+		WideCharToMultiByte(CP_ACP, 0, pwi->wki100_langroup,
+				    -1, (LPSTR)dname, dnamelen, NULL, NULL);
+	    }
+	    else {
+		WideCharToMultiByte(CP_ACP, 0, pwi->wki100_computername,
+				    -1, (LPSTR)dname, dnamelen, NULL, NULL);
+	    }
+	    pfnNetApiBufferFree(pwi);
+	    FreeLibrary(hNetApi32);
+	    XSRETURN_PV(dname);
+	}
+	FreeLibrary(hNetApi32);
+    }
+    else {
+	/* Win95 doesn't have NetWksta*(), so do it the old way */
+	char name[256];
+	DWORD size = sizeof(name);
+	if (hNetApi32)
+	    FreeLibrary(hNetApi32);
+	if (GetUserName(name,&size)) {
+	    char sid[ONE_K_BUFSIZE];
+	    DWORD sidlen = sizeof(sid);
+	    char dname[256];
+	    DWORD dnamelen = sizeof(dname);
+	    SID_NAME_USE snu;
+	    if (LookupAccountName(NULL, name, (PSID)&sid, &sidlen,
+				  dname, &dnamelen, &snu)) {
+		XSRETURN_PV(dname);		/* all that for this */
+	    }
+	}
+    }
+    XSRETURN_UNDEF;
+}
+
+XS(w32_FsType)
+{
+    dXSARGS;
+    char fsname[256];
+    DWORD flags, filecomplen;
+    if (GetVolumeInformation(NULL, NULL, 0, NULL, &filecomplen,
+			 &flags, fsname, sizeof(fsname))) {
+	if (GIMME_V == G_ARRAY) {
+	    XPUSHs(sv_2mortal(newSVpvn(fsname,strlen(fsname))));
+	    XPUSHs(sv_2mortal(newSViv(flags)));
+	    XPUSHs(sv_2mortal(newSViv(filecomplen)));
+	    PUTBACK;
+	    return;
+	}
+	EXTEND(SP,1);
+	XSRETURN_PV(fsname);
+    }
+    XSRETURN_EMPTY;
+}
+
+XS(w32_GetOSVersion)
+{
+    dXSARGS;
+    OSVERSIONINFOA osver;
+
+    if (USING_WIDE()) {
+	OSVERSIONINFOW osverw;
+	char szCSDVersion[sizeof(osverw.szCSDVersion)];
+	osverw.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
+	if (!GetVersionExW(&osverw)) {
+	    XSRETURN_EMPTY;
+	}
+	W2AHELPER(osverw.szCSDVersion, szCSDVersion, sizeof(szCSDVersion));
+	XPUSHs(newSVpvn(szCSDVersion, strlen(szCSDVersion)));
+	osver.dwMajorVersion = osverw.dwMajorVersion;
+	osver.dwMinorVersion = osverw.dwMinorVersion;
+	osver.dwBuildNumber = osverw.dwBuildNumber;
+	osver.dwPlatformId = osverw.dwPlatformId;
+    }
+    else {
+	osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
+	if (!GetVersionExA(&osver)) {
+	    XSRETURN_EMPTY;
+	}
+	XPUSHs(newSVpvn(osver.szCSDVersion, strlen(osver.szCSDVersion)));
+    }
+    XPUSHs(newSViv(osver.dwMajorVersion));
+    XPUSHs(newSViv(osver.dwMinorVersion));
+    XPUSHs(newSViv(osver.dwBuildNumber));
+    XPUSHs(newSViv(osver.dwPlatformId));
+    PUTBACK;
+}
+
+XS(w32_IsWinNT)
+{
+    dXSARGS;
+    EXTEND(SP,1);
+    XSRETURN_IV(IsWinNT());
+}
+
+XS(w32_IsWin95)
+{
+    dXSARGS;
+    EXTEND(SP,1);
+    XSRETURN_IV(IsWin95());
+}
+
+XS(w32_FormatMessage)
+{
+    dXSARGS;
+    DWORD source = 0;
+    char msgbuf[ONE_K_BUFSIZE];
+
+    if (items != 1)
+	Perl_croak(aTHX_ "usage: Win32::FormatMessage($errno)");
+
+    if (USING_WIDE()) {
+	WCHAR wmsgbuf[ONE_K_BUFSIZE];
+	if (FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
+			  &source, SvIV(ST(0)), 0,
+			  wmsgbuf, ONE_K_BUFSIZE-1, NULL))
+	{
+	    W2AHELPER(wmsgbuf, msgbuf, sizeof(msgbuf));
+	    XSRETURN_PV(msgbuf);
+	}
+    }
+    else {
+	if (FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
+			  &source, SvIV(ST(0)), 0,
+			  msgbuf, sizeof(msgbuf)-1, NULL))
+	    XSRETURN_PV(msgbuf);
+    }
+
+    XSRETURN_UNDEF;
+}
+
+XS(w32_Spawn)
+{
+    dXSARGS;
+    char *cmd, *args;
+    void *env;
+    char *dir;
+    PROCESS_INFORMATION stProcInfo;
+    STARTUPINFO stStartInfo;
+    BOOL bSuccess = FALSE;
+
+    if (items != 3)
+	Perl_croak(aTHX_ "usage: Win32::Spawn($cmdName, $args, $PID)");
+
+    cmd = SvPV_nolen(ST(0));
+    args = SvPV_nolen(ST(1));
+
+    env = PerlEnv_get_childenv();
+    dir = PerlEnv_get_childdir();
+
+    memset(&stStartInfo, 0, sizeof(stStartInfo));   /* Clear the block */
+    stStartInfo.cb = sizeof(stStartInfo);	    /* Set the structure size */
+    stStartInfo.dwFlags = STARTF_USESHOWWINDOW;	    /* Enable wShowWindow control */
+    stStartInfo.wShowWindow = SW_SHOWMINNOACTIVE;   /* Start min (normal) */
+
+    if (CreateProcess(
+		cmd,			/* Image path */
+		args,	 		/* Arguments for command line */
+		NULL,			/* Default process security */
+		NULL,			/* Default thread security */
+		FALSE,			/* Must be TRUE to use std handles */
+		NORMAL_PRIORITY_CLASS,	/* No special scheduling */
+		env,			/* Inherit our environment block */
+		dir,			/* Inherit our currrent directory */
+		&stStartInfo,		/* -> Startup info */
+		&stProcInfo))		/* <- Process info (if OK) */
+    {
+	int pid = (int)stProcInfo.dwProcessId;
+	if (IsWin95() && pid < 0)
+	    pid = -pid;
+	sv_setiv(ST(2), pid);
+	CloseHandle(stProcInfo.hThread);/* library source code does this. */
+	bSuccess = TRUE;
+    }
+    PerlEnv_free_childenv(env);
+    PerlEnv_free_childdir(dir);
+    XSRETURN_IV(bSuccess);
+}
+
+XS(w32_GetTickCount)
+{
+    dXSARGS;
+    DWORD msec = GetTickCount();
+    EXTEND(SP,1);
+    if ((IV)msec > 0)
+	XSRETURN_IV(msec);
+    XSRETURN_NV(msec);
+}
+
+XS(w32_SetCwd)
+{
+    dXSARGS;
+    if (items != 1)
+	Perl_croak(aTHX_ "usage: Win32::SetCurrentDirectory($cwd)");
+    if (!PerlDir_chdir(SvPV_nolen(ST(0))))
+	XSRETURN_YES;
+
+    XSRETURN_NO;
+}
+
+XS(w32_GetCwd)
+{
+    dXSARGS;
+    /* Make the host for current directory */
+    char* ptr = PerlEnv_get_childdir();
+    /*
+     * If ptr != Nullch
+     *   then it worked, set PV valid,
+     *   else return 'undef'
+     */
+    if (ptr) {
+	SV *sv = sv_newmortal();
+	sv_setpv(sv, ptr);
+	PerlEnv_free_childdir(ptr);
+
+#ifndef INCOMPLETE_TAINTS
+	SvTAINTED_on(sv);
+#endif
+
+	EXTEND(SP,1);
+	SvPOK_on(sv);
+	ST(0) = sv;
+	XSRETURN(1);
+    }
+    XSRETURN_UNDEF;
+}
+
+XS(w32_CopyFile)
+{
+    dXSARGS;
+    BOOL bResult;
+    if (items != 3)
+	Perl_croak(aTHX_ "usage: Win32::CopyFile($from, $to, $overwrite)");
+    if (USING_WIDE()) {
+	WCHAR wSourceFile[MAX_PATH+1];
+	WCHAR wDestFile[MAX_PATH+1];
+	A2WHELPER(SvPV_nolen(ST(0)), wSourceFile, sizeof(wSourceFile));
+	wcscpy(wSourceFile, PerlDir_mapW(wSourceFile));
+	A2WHELPER(SvPV_nolen(ST(1)), wDestFile, sizeof(wDestFile));
+	bResult = CopyFileW(wSourceFile, (WCHAR*)PerlDir_mapW(wDestFile), !SvTRUE(ST(2)));
+    }
+    else {
+	char szSourceFile[MAX_PATH+1];
+	strcpy(szSourceFile, PerlDir_mapA(SvPV_nolen(ST(0))));
+	bResult = CopyFileA(szSourceFile, PerlDir_mapA(SvPV_nolen(ST(1))), !SvTRUE(ST(2)));
+    }
+
+    if (bResult)
+	XSRETURN_YES;
+    XSRETURN_NO;
+}
+
+XS(w32_GetFullPathName)
+{
+    dXSARGS;
+    SV *filename;
+    SV *fullpath;
+    char *filepart;
+    DWORD len;
+
+    if (items != 1)
+	Perl_croak(aTHX_ "usage: Win32::GetFullPathName($filename)");
+
+    filename = ST(0);
+    fullpath = sv_mortalcopy(filename);
+    SvUPGRADE(fullpath, SVt_PV);
+    if (!SvPVX(fullpath) || !SvLEN(fullpath))
+        XSRETURN_UNDEF;
+
+    do {
+	len = GetFullPathName(SvPVX(filename),
+			      SvLEN(fullpath),
+			      SvPVX(fullpath),
+			      &filepart);
+    } while (len >= SvLEN(fullpath) && sv_grow(fullpath,len+1));
+    if (len) {
+	if (GIMME_V == G_ARRAY) {
+	    EXTEND(SP,1);
+	    if (filepart) {
+		XST_mPV(1,filepart);
+		len = filepart - SvPVX(fullpath);
+	    }
+	    else {
+		XST_mPVN(1,"",0);
+	    }
+	    items = 2;
+	}
+	SvCUR_set(fullpath,len);
+	ST(0) = fullpath;
+	XSRETURN(items);
+    }
+    XSRETURN_EMPTY;
+}
+
+XS(w32_GetShortPathName)
+{
+    dXSARGS;
+    SV *shortpath;
+    DWORD len;
+
+    if (items != 1)
+	Perl_croak(aTHX_ "usage: Win32::GetShortPathName($longPathName)");
+
+    shortpath = sv_mortalcopy(ST(0));
+    SvUPGRADE(shortpath, SVt_PV);
+    if (!SvPVX(shortpath) || !SvLEN(shortpath))
+        XSRETURN_UNDEF;
+
+    /* src == target is allowed */
+    do {
+	len = GetShortPathName(SvPVX(shortpath),
+			       SvPVX(shortpath),
+			       SvLEN(shortpath));
+    } while (len >= SvLEN(shortpath) && sv_grow(shortpath,len+1));
+    if (len) {
+	SvCUR_set(shortpath,len);
+	ST(0) = shortpath;
+	XSRETURN(1);
+    }
+    XSRETURN_UNDEF;
+}
+
+XS(w32_GetLongPathName)
+{
+    dXSARGS;
+    SV *path;
+    char tmpbuf[MAX_PATH+1];
+    char *pathstr;
+    STRLEN len;
+
+    if (items != 1)
+	Perl_croak(aTHX_ "usage: Win32::GetLongPathName($pathname)");
+
+    path = ST(0);
+    pathstr = SvPV(path,len);
+    strcpy(tmpbuf, pathstr);
+    pathstr = win32_longpath(tmpbuf);
+    if (pathstr) {
+	ST(0) = sv_2mortal(newSVpvn(pathstr, strlen(pathstr)));
+	XSRETURN(1);
+    }
+    XSRETURN_EMPTY;
+}
+
+XS(w32_GetNextAvailDrive)
+{
+    dXSARGS;
+    char ix = 'C';
+    char root[] = "_:\\";
+
+    EXTEND(SP,1);
+    while (ix <= 'Z') {
+	root[0] = ix++;
+	if (GetDriveType(root) == 1) {
+	    root[2] = '\0';
+	    XSRETURN_PV(root);
+	}
+    }
+    XSRETURN_UNDEF;
+}
+
+XS(w32_SetChildShowWindow)
+{
+    dXSARGS;
+#if defined(MODULE) && defined(BACKPORT) && !defined(PERL_IMPLICIT_SYS)
+    dMY_CXT;
+#endif
+    BOOL use_showwindow = w32_use_showwindow;
+    /* use "unsigned short" because Perl has redefined "WORD" */
+    unsigned short showwindow = w32_showwindow;
+
+    if (items > 1)
+	Perl_croak(aTHX_ "usage: Win32::SetChildShowWindow($showwindow)");
+
+    if (items == 0 || !SvOK(ST(0)))
+        w32_use_showwindow = FALSE;
+    else {
+        w32_use_showwindow = TRUE;
+        w32_showwindow = (unsigned short)SvIV(ST(0));
+    }
+
+    EXTEND(SP, 1);
+    if (use_showwindow)
+        ST(0) = sv_2mortal(newSViv(showwindow));
+    else
+        ST(0) = &PL_sv_undef;
+    XSRETURN(1);
+}
+
+XS(w32_Sleep)
+{
+    dXSARGS;
+    if (items != 1)
+	Perl_croak(aTHX_ "usage: Win32::Sleep($milliseconds)");
+    Sleep(SvIV(ST(0)));
+    XSRETURN_YES;
+}
+
+void init_Win32CORE(void)
+{
+    dTHX;
+    char *file = __FILE__;
+
+    newXS("Win32::GetLastError", w32_GetLastError, file);
+    newXS("Win32::SetLastError", w32_SetLastError, file);
+    newXS("Win32::LoginName", w32_LoginName, file);
+    newXS("Win32::NodeName", w32_NodeName, file);
+    newXS("Win32::DomainName", w32_DomainName, file);
+    newXS("Win32::FsType", w32_FsType, file);
+    newXS("Win32::GetCwd", w32_GetCwd, file);
+    newXS("Win32::SetCwd", w32_SetCwd, file);
+    newXS("Win32::GetOSVersion", w32_GetOSVersion, file);
+    newXS("Win32::FormatMessage", w32_FormatMessage, file);
+    newXS("Win32::Spawn", w32_Spawn, file);
+    newXS("Win32::GetTickCount", w32_GetTickCount, file);
+    newXS("Win32::IsWinNT", w32_IsWinNT, file);
+    newXS("Win32::IsWin95", w32_IsWin95, file);
+    newXS("Win32::CopyFile", w32_CopyFile, file);
+    newXS("Win32::GetFullPathName", w32_GetFullPathName, file);
+    newXS("Win32::GetLongPathName", w32_GetLongPathName, file);
+    newXS("Win32::GetNextAvailDrive", w32_GetNextAvailDrive, file);
+    newXS("Win32::GetShortPathName", w32_GetShortPathName, file);
+    newXS("Win32::SetChildShowWindow", w32_SetChildShowWindow, file);
+    newXS("Win32::Sleep", w32_Sleep, file);
+}
+
+XS(boot_Win32CORE)
+{
+    dXSARGS;
+#if defined(MODULE) && defined(BACKPORT) && !defined(PERL_IMPLICIT_SYS)
+    MY_CXT_INIT;
+#endif
+    init_Win32CORE();
+    XSRETURN_YES;
+}
+
+#else /* Do nothing in dynamic CORE extension and on non-Windows platforms */
+
+XS(boot_Win32CORE)
+{
+}
+
+#endif
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Win32CORE/Win32CORE.pm perl-libwin32-0.191/Win32CORE/Win32CORE.pm
--- libwin32-0.191/Win32CORE/Win32CORE.pm	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/Win32CORE/Win32CORE.pm	2004-01-12 16:46:44.031250000 -0800
@@ -0,0 +1,23 @@
+package Win32CORE;
+
+$VERSION = '0.01';
+
+use strict;
+use warnings;
+use vars qw($VERSION @ISA);
+use base qw(Exporter DynaLoader);
+
+bootstrap Win32CORE $VERSION;
+
+1;
+__END__
+=head1 NAME
+
+Win32CORE - Win32 CORE functions
+
+=head1 DESCRIPTION
+
+This library provides the functions marked as [CORE] in L<Win32>. See that
+document for usage information.
+
+=cut
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/Win32CORE/t/win32core.t perl-libwin32-0.191/Win32CORE/t/win32core.t
--- libwin32-0.191/Win32CORE/t/win32core.t	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/Win32CORE/t/win32core.t	2004-01-12 16:46:44.046875000 -0800
@@ -0,0 +1,6 @@
+#!perl
+
+use Test;
+BEGIN { plan tests => 1 };
+use Win32CORE;
+ok(1);
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/WinError/WinError.xs perl-libwin32-0.191/WinError/WinError.xs
--- libwin32-0.191/WinError/WinError.xs	2002-07-08 17:15:53.000000000 -0700
+++ perl-libwin32-0.191/WinError/WinError.xs	2004-01-12 16:46:44.062500000 -0800
@@ -1,12 +1,5 @@
-#if !defined(__MINGW32__) && !(defined(__BORLANDC__) && __BORLANDC__ >= 0x0550)
-#include <wtypes.h>
-#endif
-#include <WinError.h>
-
-#include "EXTERN.h"
-#include "perl.h"
-#include "XSUB.h"
-
+#include "../win32perl.h"
+#include <winerror.h>
 
 static double
 constant(char *name, int arg)
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/WinError/t/winerror.t perl-libwin32-0.191/WinError/t/winerror.t
--- libwin32-0.191/WinError/t/winerror.t	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/WinError/t/winerror.t	2004-01-12 16:46:44.078125000 -0800
@@ -0,0 +1,12 @@
+#!perl
+# vim:syntax=perl:
+use strict;
+use Test;
+
+BEGIN { plan tests => 2 }
+
+use Win32::WinError;
+
+ok(1);
+
+ok(defined eval { ERROR_BUSY });
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/hints/MSWin32.pl perl-libwin32-0.191/hints/MSWin32.pl
--- libwin32-0.191/hints/MSWin32.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/hints/MSWin32.pl	2004-01-12 16:46:44.093750000 -0800
@@ -0,0 +1,105 @@
+use Config;
+
+my $mingw   = 1 if $Config{'cc'} =~ /^gcc/i;
+my $borland = 1 if $Config{'cc'} =~ /^bcc32/i;
+my $msvc    = 1 if $Config{'cc'} =~ /^cl/i;
+
+my $incpath = $Config{'incpath'};
+
+my @res_files = map { s/\.rc$/.res/i;$_ } <*.[Rr][Cc]>;
+
+if ($borland) {
+# Find the library path
+	my ($libpath) = ( grep { /borland .* lib \/* \W/ix }
+				split (/\s+/ms, $Config{'ldflags'})
+			);
+# Strip off the -L"..." around the path
+	$libpath =~ s/^-L["']?//; $libpath =~ s/["']?$//;
+
+	$self->{INC} .= qq{ -I"$incpath" -I"$incpath\\mfc" };
+	$self->{CCFLAGS} .= $Config{ccflags} . qq{ -L"$libpath" -L"$libpath\\PSDK" };
+
+# include the Microsoft Platform SDK libs
+	$self->{dynamic_lib}{OTHERLDFLAGS} .= qq{ c0d32.obj -L"$libpath\\PSDK" };
+
+	$self->{LDLOADLIBS} .= " import32.lib cw32mti.lib odbc32.lib comctl32.lib wininet.lib ";
+} elsif ($mingw) {
+	$self->{CCFLAGS} .= $Config{ccflags} . " -pipe ";
+
+	if (((`gcc --version`)[0] !~ /\s[3-9]\.\d+/) &&
+	    ($self->{CCFLAGS} !~ /-fvtable-thunks/)) {
+		$self->{CCFLAGS} .= ' -fvtable-thunks ';
+	} else {
+		$self->{CCFLAGS} =~ s/-fvtable-thunks//g;
+	}
+
+	$self->{LDLOADLIBS} = q{ -lnetapi32 -lwininet -lversion -lmpr -lodbc32 -lodbccp32 -lwinmm -lstdc++ -lole32 -loleaut32 -luuid  -lcomctl32 -lgdi32 -lcomdlg32 -lntdll -lws2_32 }; 
+} elsif ($msvc) {
+	$self->{INC}	.= ' -GX ';
+	$self->{LIBS}	.= ' :nosearch wininet.lib comctl32.lib ';
+	$self->{LDFROM}	.=  "\$(OBJECT) @res_files ";
+}
+
+$self->{clean}{FILES} .= ' *.res *.o *.obj vc*.pdb dll.base dll.exp *.stackdump';
+# Any way to include 'TMP*.$$$' in the above without having nmake go apeshit?
+
+$self->{dynamic_lib}{INST_DYNAMIC_DEP} .= " @res_files ";
+
+package MY;
+
+sub special_targets {
+    my $section = shift->SUPER::special_targets(@_);
+    $section =~ s/\.SUFFIXES([^\n]+)\n/\.SUFFIXES$1 .rc .res\n/;
+    return $section;
+}
+
+sub c_o {
+	my $section = shift->SUPER::c_o(@_);
+
+# Borland C doesn't preserve case in object files, this throws off dmake.
+	if ($borland) {
+		$section =~ s/^(\s+\$\(CCCMD.+?)\s+(\$\*\.\w+)/$1 $2 && ren \$*\$(OBJ_EXT) \$*\$(OBJ_EXT)\n/msg
+	}
+
+# Add target for compiling resource files.
+	if ($mingw) {
+            $section .= <<'EOF';
+
+# Added by hints/MSWin32.pl
+.rc.res:
+	windres -O coff -o $*.res $*.rc
+EOF
+	} else {
+	    my $rc = $borland ? qq{brcc32.exe -x -I"$incpath"} : "rc.exe";
+
+	    $section .= <<"EOF";
+
+# Added by hints/MSWin32.pl
+.rc.res:
+	$rc /l 0x409 /fo\$*.res \$*.rc
+EOF
+	}
+
+	return $section;
+}
+
+sub dynamic_lib {
+	my $section = shift->SUPER::dynamic_lib(@_);
+	if ($borland) {
+		return <<"EOF" . $section;
+
+# Added by hints/MSWin32.pl to dynamic_lib
+RESFILES = @res_files
+
+EOF
+	} elsif ($mingw) {
+		return <<"EOF" . $section;
+
+# Added by hints/MSWin32.pl to dynamic_lib
+OBJECT += @res_files
+
+EOF
+	} else {
+		return $section;
+	}
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/hints/cygwin.pl perl-libwin32-0.191/hints/cygwin.pl
--- libwin32-0.191/hints/cygwin.pl	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/hints/cygwin.pl	2004-01-12 16:46:44.109375000 -0800
@@ -0,0 +1,67 @@
+use Config;
+
+for (qw(INCLUDE LIB)) {
+	warn
+"WARNING: Having environment variable $_ set will most likely cause your build to fail!\n"
+		if exists $ENV{$_} && $ENV{$_} ne '';
+}
+
+my @res_files = map { s/\.rc$/.res/i;$_ } <*.[Rr][Cc]>;
+
+$self->{LIBS} = [q{ -L/lib/w32api -lnetapi32 -lwininet -lversion -lmpr -lodbc32 -lodbccp32 -lwinmm -lstdc++ -lole32 -loleaut32 -luuid  -lcomctl32 -lgdi32 -lcomdlg32 -lntdll }]; 
+
+if ($Config{cc} =~ /\Wgcc/) {
+# Check for GCC >= 3.x
+	if (((`gcc --version`)[0] !~ /\s[3-9]\.\d+/) &&
+	    ($self->{CCFLAGS} !~ /-fvtable-thunks/)) {
+		$self->{CCFLAGS} .= ' -fvtable-thunks ';
+	} else {
+		$self->{CCFLAGS} =~ s/-fvtable-thunks//g;
+	}
+}
+
+$self->{CCFLAGS} .= $Config{ccflags} . " -pipe ";
+$self->{CCFLAGS} =~ s|-I/usr/local/include/?||g;
+
+$self->{clean}{FILES} .= ' *.res *.o *.obj vc*.pdb TMP*.$$$ dll.base dll.exp *.stackdump ';
+
+$self->{dynamic_lib}{INST_DYNAMIC_DEP} .= " @res_files ";
+
+package MY;
+
+# Add targets for compiling resource files.
+
+sub special_targets {
+    my $section = shift->SUPER::special_targets(@_);
+    $section =~ s/\.SUFFIXES([^\n]+)\n/\.SUFFIXES$1 .rc .res\n/;
+    return $section;
+}
+
+sub c_o {
+	my $section = shift->SUPER::c_o(@_);
+        $section .= <<'EOF';
+
+# Added by hints/cygwin.pl
+.rc.res:
+	windres -O coff -o $*.res $*.rc
+
+EOF
+	return $section;
+}
+
+sub dynamic_lib {
+   my $section = shift->SUPER::dynamic_lib(@_);
+   if (defined $section && $section) {
+	$section = <<"EOF" . $section;
+
+# Added by hints/cygwin.pl to dynamic_lib
+OBJECT += @res_files
+
+EOF
+## This doesn't seem to help much.
+#	$section .= <<'EOF' if -e '/bin/rebase';
+#	rebase -v -d -b 0x70000000 -o 0x10000 $@
+#EOF
+   }
+   $section;
+}
diff --strip-trailing-cr -aruN -x .build -x .inst -x .sinst -x CVS -x '*.sw?' -x .cvsignore -I ' $Id: ' libwin32-0.191/win32perl.h perl-libwin32-0.191/win32perl.h
--- libwin32-0.191/win32perl.h	1969-12-31 16:00:00.000000000 -0800
+++ perl-libwin32-0.191/win32perl.h	2004-01-12 16:46:44.109375000 -0800
@@ -0,0 +1,396 @@
+/*
+ * This file provides some common includes and workarounds for libwin32
+ * extensions. Use as a replacement for all necessary Perl headers and
+ * <windows.h>. As well as some ANSI headers and the ppport.h compatibility
+ * header. Include any other headers you need after this one.
+ *
+ * Headers generally don't get included more than once, so don't worry about
+ * duplicating an #include by accident.
+ *
+ * If you want to pass macros to perl headers, such as #define NO_XSLOCKS,
+ * define them before including this header.
+ *
+ * Rafael Kitover - 12/2003
+ */
+
+#ifndef WIN32_PERL_H
+#define WIN32_PERL_H
+
+/* ANSI C stuff */
+
+#include <stdlib.h>
+#include <math.h>
+#include <stdio.h>
+#undef isnan
+#ifndef __BORLANDC__
+#include <malloc.h>
+#endif
+
+/* Win32 stuff */
+
+#include <windows.h>
+
+#if (!defined(__MINGW32__) && !(defined(__BORLANDC__)) || __BORLANDC__ >= 0x0550)
+#include <wtypes.h>
+#endif
+
+#if defined(__CYGWIN__) && PERL_REVISION <= 5 && PERL_VERSION <= 6
+/* No win32.h in cygwin perl 5.6 */
+# undef WIN32
+#endif
+
+/* This header conflicts with Perl's macros, so include it early. */
+#include <shlobj.h>
+
+/* Perl stuff */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "EXTERN.h"
+#include "perl.h"
+#include "XSUB.h"
+#include "patchlevel.h"
+
+#ifdef __cplusplus
+}
+#endif
+
+#include "ppport.h"
+
+#undef 	Top			/* some devel version pollutes */
+
+/* Type Fixups */
+
+#undef  WORD
+
+#if !defined(_WIN64) && !defined(DWORD_PTR)
+#  define DWORD_PTR	DWORD
+#endif
+
+#if !defined(_WIN64) && !defined(PDWORD_PTR)
+#  define PDWORD_PTR	DWORD*
+#endif
+
+#ifdef __cplusplus
+	#define lw32_perl_LIBCAST HINSTANCE__*
+#else
+	#define lw32_perl_LIBCAST HANDLE
+#endif
+
+#if !defined(__CYGWIN__) && !defined(__BORLANDC__)
+	#undef  stat
+	#define stat _stati64
+#endif
+
+#ifdef __BORLANDC__
+	#define FARPROC(fptr) int __stdcall (*fptr)(void)
+#else
+	#define FARPROC(fptr) FARPROC fptr
+#endif
+
+/* Constant Fixups */
+
+#ifndef _MAX_PATH
+#	define _MAX_PATH MAX_PATH
+#endif
+
+/* Function Fixups */
+
+/* Perl 5.005 added win32_get_osfhandle/win32_open_osfhandle */
+/* This block was taken from Tye's APIFile.xs and modified */
+#if (PERL_REVISION <= 5 && PERL_VERSION < 5) || defined(__CYGWIN__)
+# define win32_get_osfhandle _get_osfhandle
+# ifdef __CYGWIN__
+#  define win32_open_osfhandle(handle,mode) \
+	(Perl_croak(aTHX_ "_open_osfhandle not implemented on Cygwin!"), -1)
+# else
+#  define win32_open_osfhandle _open_osfhandle
+# endif
+# ifdef _get_osfhandle
+#  undef _get_osfhandle	/* stolen_get_osfhandle() isn't available here */
+# endif
+# ifdef _open_osfhandle
+#  undef _open_osfhandle /* stolen_open_osfhandle() isn't available here */
+# endif
+#endif
+
+#ifdef __BORLANDC__ /* Borland C Fixups */
+
+#define DllMain DllEntryPoint
+
+/* Disable "not expanded inline" warnings. */
+#pragma warn -inl
+
+/* Some Borland C compilers don't have odbccp32.lib, notably the free 5.5
+ * version, so we "delayload" a couple functions we need ourselves.
+ */
+
+#ifdef __cplusplus
+	#define static_inline static inline
+#else
+	#define static_inline static
+#endif
+
+#include <odbcinst.h>	/* To avoid prototype redefinition problems. */
+
+#undef  SQLConfigDataSource
+#define SQLConfigDataSource		lw32_perl_SQLConfigDataSource
+#undef  SQLGetPrivateProfileString
+#define SQLGetPrivateProfileString	lw32_perl_SQLGetPrivateProfileString
+
+static HANDLE odbccp32_dll = NULL;
+
+static BOOL __stdcall (*odbccp32_SQLConfigDataSource)(HWND, WORD, LPCSTR,
+			LPCSTR);
+
+static int __stdcall (*odbccp32_SQLGetPrivateProfileString)(LPCSTR, LPCSTR,
+			LPCSTR, LPCSTR, INT, LPCSTR);
+
+static_inline void odbccp32_init(void)
+{
+	odbccp32_dll = LoadLibrary("odbccp32.dll");
+	if (odbccp32_dll == NULL) {
+		croak("Could not LoadLibrary odbccp32.dll");
+	}
+
+	odbccp32_SQLConfigDataSource =
+	  (BOOL __stdcall (*)(HWND, WORD, LPCSTR, LPCSTR))
+          GetProcAddress((lw32_perl_LIBCAST)odbccp32_dll,
+	  	"SQLConfigDataSource");
+
+	if (odbccp32_SQLConfigDataSource == NULL) {
+	  croak("could not find function SQLConfigDataSource in odbccp32.dll");
+	}
+
+	odbccp32_SQLGetPrivateProfileString =
+	  (int __stdcall (*)(LPCSTR, LPCSTR, LPCSTR, LPCSTR, INT, LPCSTR))
+	  GetProcAddress((lw32_perl_LIBCAST)odbccp32_dll,
+	  	"SQLGetPrivateProfileString");
+
+	if (odbccp32_SQLGetPrivateProfileString == NULL) {
+		croak(
+"could not find function SQLGetPrivateProfileString in odbccp32.dll");
+	}
+}
+
+static_inline BOOL
+lw32_perl_SQLConfigDataSource(HWND hwndParent, WORD fRequest,
+	LPCSTR lpszDriver, LPCSTR lpszAttributes)
+{
+
+	if (odbccp32_dll == NULL) { odbccp32_init(); }
+	return (BOOL)(*odbccp32_SQLConfigDataSource)(
+		hwndParent, fRequest, lpszDriver, lpszAttributes);
+}
+
+static_inline int
+lw32_perl_SQLGetPrivateProfileString(LPCSTR lpszSection, LPCSTR lpszEntry,
+	LPCSTR lpszDefault, LPCSTR RetBuffer, INT cbRetBuffer,
+	LPCSTR lpszFilename)
+{
+	if (odbccp32_dll == NULL) { odbccp32_init(); }
+	return (int)(*odbccp32_SQLGetPrivateProfileString)(
+		lpszSection, lpszEntry, lpszDefault, RetBuffer, cbRetBuffer,
+		lpszFilename);
+}
+
+#endif /* Borland C Fixups */
+
+#if defined(__CYGWIN__) || defined(__MINGW32__) /* Cygwin and MinGW Fixups */
+
+#include <commctrl.h>
+
+/* Older w32api commctrl.h missing some defs */
+#ifndef LVIF_INDENT
+	#define LVIF_INDENT 16
+	#define TCM_SETMINTABWIDTH   	(TCM_FIRST + 49)
+	#define TB_GETPADDING		(WM_USER+86)
+	#define TB_SETPADDING		(WM_USER+87)
+	#define TB_SETINDENT		(WM_USER+47)
+	#define TB_GETMAXSIZE		(WM_USER+83)
+	#if (_WIN32_IE >= 0x0400)
+		#define TVGN_LASTVISIBLE	10
+	#endif
+#endif
+
+/* commctrl.h macro DateTime_(Get|Set)Systemtime is capitalized incorrectly in
+ * the w32api headers.
+ */
+
+#define DateTime_GetSystemtime DateTime_GetSystemTime
+#define DateTime_SetSystemtime DateTime_SetSystemTime
+
+/* Missing TreeView_GetLastVisible and ListView_GetCheckState macros.
+ */
+#define TreeView_GetLastVisible(w) TreeView_GetNextItem(w,NULL,TVGN_LASTVISIBLE)
+
+/* Taken this from Laurent Rocher's (rocherl@club-internet.fr) Win32::GUI patch
+ * from: http://perso.club-internet.fr/rocherl/HowTo/howto-mingw.html
+ */
+#define ListView_GetCheckState(w,i) (int)(((SNDMSG((w), LVM_GETITEMSTATE, (WPARAM)i, LVIS_STATEIMAGEMASK)) >> 12) -1)
+
+/* Cygwin/Mingw libkernel32 does not have the Job functions, so we have to load
+ * them at run time from kernel32.dll
+ *
+ * These get optimized out when not referenced.
+ */
+
+#undef  CreateJobObject
+#define CreateJobObject			lw32_perl_CreateJobObject
+#undef  TerminateJobObject
+#define TerminateJobObject		lw32_perl_TerminateJobObject
+#undef  AssignProcessToJobObject
+#define AssignProcessToJobObject	lw32_perl_AssignProcessToJobObject
+
+static HANDLE kernel32_dll = NULL;
+
+static HANDLE __stdcall (*kernel32_CreateJobObjectA)(LPSECURITY_ATTRIBUTES, LPCSTR);
+
+static BOOL __stdcall (*kernel32_TerminateJobObject)(HANDLE, UINT);
+
+static BOOL __stdcall (*kernel32_AssignProcessToJobObject)(HANDLE, HANDLE);
+
+static inline void kernel32_init()
+{
+	kernel32_dll = LoadLibrary("kernel32.dll");
+	if (kernel32_dll == NULL) {
+		croak("Could not LoadLibrary kernel32.dll");
+	}
+
+	kernel32_CreateJobObjectA =
+	  (HANDLE __stdcall (*)(LPSECURITY_ATTRIBUTES, LPCSTR))
+	  GetProcAddress((lw32_perl_LIBCAST)kernel32_dll,"CreateJobObjectA");
+
+	if (kernel32_CreateJobObjectA == NULL) {
+	  croak("could not find function CreateJobObjectA in kernel32.dll");
+	}
+
+	kernel32_TerminateJobObject =
+	  (BOOL __stdcall (*)(HANDLE, UINT))
+	  GetProcAddress((lw32_perl_LIBCAST)kernel32_dll,"TerminateJobObject");
+
+	if (kernel32_TerminateJobObject  == NULL) {
+	  croak("could not find function TerminateJobObject in kernel32.dll");
+	}
+
+	kernel32_AssignProcessToJobObject =
+	  (BOOL __stdcall (*)(HANDLE, HANDLE))
+	  GetProcAddress((lw32_perl_LIBCAST)kernel32_dll,
+	  	"AssignProcessToJobObject");
+
+	if (kernel32_AssignProcessToJobObject == NULL) {
+	  croak(
+"could not find function AssignProcessToJobObject in kernel32.dll");
+	}
+}
+
+static inline HANDLE lw32_perl_CreateJobObject(
+	LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName)
+{
+	if (kernel32_dll == NULL) { kernel32_init(); }
+	return (HANDLE)(*kernel32_CreateJobObjectA)(lpJobAttributes, lpName);
+}
+
+static inline BOOL lw32_perl_TerminateJobObject(HANDLE hJob, UINT uExitCode)
+{
+	if (kernel32_dll == NULL) { kernel32_init(); }
+	return (BOOL)(*kernel32_TerminateJobObject)(hJob, uExitCode);
+}
+
+static inline BOOL lw32_perl_AssignProcessToJobObject(HANDLE hJob,
+	HANDLE hProcess)
+{
+	if (kernel32_dll == NULL) { kernel32_init(); }
+	return (BOOL)(*kernel32_AssignProcessToJobObject)(hJob, hProcess);
+}
+
+#endif /* Cygwin and MinGW Fixups */
+
+
+#ifdef __CYGWIN__ /* Cygwin specific Fixups */
+
+/* Headers */
+#include <netdb.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <wchar.h>
+
+/* Possibly missing prototypes */
+#define _wcscmpi _wcsicmp
+int  _wcsicmp(const wchar_t*, const wchar_t*);
+long _wtol (const wchar_t*);
+
+/* Make an itoa and ltoa macro using snprintf */
+
+#define itoa(num,str,len) snprintf(str, len, "%d",  num), str;
+#define ltoa(num,str,len) snprintf(str, len, "%ld", num), str;
+
+/* UNICODE stuff (from win32.h) */
+
+#undef USING_WIDE
+#undef A2WHELPER
+#undef A2WHELPER_LEN
+#undef W2AHELPER
+#undef W2AHELPER_LEN
+
+#define USING_WIDE() (0)
+
+#define A2WHELPER_LEN(lpa, alen, lpw, nBytes)\
+    (lpw[0] = 0, MultiByteToWideChar(CP_ACP, 0, \
+                                    lpa, alen, lpw, (nBytes/sizeof(WCHAR))))
+
+#define A2WHELPER(lpa, lpw, nBytes)     A2WHELPER_LEN(lpa, -1, lpw, nBytes)
+
+#define W2AHELPER_LEN(lpw, wlen, lpa, nChars)\
+    (lpa[0] = '\0', WideCharToMultiByte(CP_ACP, 0, \
+                                       lpw, wlen, (LPSTR)lpa, nChars,NULL,NULL))
+
+#define W2AHELPER(lpw, lpa, nChars)     W2AHELPER_LEN(lpw, -1, lpa, nChars)
+
+/*
+ * Implementation of missing functions.
+ *
+ * NOTE: These will not bloat the code, since on GCC at least a static inline
+ * function will only be compiled if there are calls to it.
+ */
+
+#ifndef strrev
+#define strrev lw32_perl_strrev
+
+static inline char *lw32_perl_strrev(char* str)
+{
+	int  start = 0;
+	int  end   = strlen(str) - 1;
+
+	while (start < end) {
+		char tmp   = str[start];
+		str[start] = str[end];
+		str[end]   = tmp;
+		start++; end--;
+	}
+}
+
+#endif /* strrev */
+
+/*
+ * Cygwin installations with postgres installed may have a conflicting
+ * /usr/include/sqltypes.h which will break trying to #include <sql.h>.
+ */
+# ifndef ODBCVER
+#  define ODBCVER 0x0351
+# endif
+
+# include <w32api/sqltypes.h>
+
+#endif /* Cygwin specific Fixups */
+
+/* Clear out unnecessary macros */
+
+#undef lw32_perl_LIBCAST
+
+#undef Stat
+#undef Move
+
+#endif /* WIN32_PERL_H */
