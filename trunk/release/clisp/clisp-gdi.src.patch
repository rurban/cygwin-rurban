diff -burN origsrc/clisp-2.48/modules/gdi/ChangeLog src/clisp-2.48/modules/gdi/ChangeLog
--- origsrc/clisp-2.48/modules/gdi/ChangeLog	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/ChangeLog	2009-07-29 08:57:25.000000000 +0000
@@ -0,0 +1,8 @@
+2009-07-29  Reini Urban  <rurban@x-ray.at>
+
+	* funcs-*.c: Remove all duplicate wrong processSTRUCT calls.
+	Remove first T return values on success.
+
+2009-07-28  Reini Urban  <rurban@x-ray.at>
+
+	Uploaded to http://code.google.com/p/clisp-gdi/
diff -burN origsrc/clisp-2.48/modules/gdi/Makefile src/clisp-2.48/modules/gdi/Makefile
--- origsrc/clisp-2.48/modules/gdi/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/Makefile	2009-07-13 10:36:05.000000000 +0000
@@ -0,0 +1,53 @@
+# Makefile for the CLISP module GDI
+
+# Programs used by "make":
+CC = gcc
+
+CFLAGS =  -W -Wswitch -Wcomment -Wpointer-arith -Wimplicit -Wreturn-type  -Wno-sign-compare -g -DSAFETY=1 -DUNICODE -DDYNAMIC_FFI -DNO_SIGSEGV -I. -I.. -falign-functions=4
+
+INCLUDES=-I. -I..
+CPP = gcc -O -E -w -DUNICODE -DDYNAMIC_FFI
+CLFLAGS = 
+
+MODPREP = ../modprep
+
+CLISP = clisp -q -norc -E 1:1
+
+LN = ln
+
+MAKE = make
+
+SHELL = /bin/sh
+
+DISTRIBFILES = *
+distribdir =
+
+all : gdi.o gdi.fas
+
+gdi.fas : gdi.lisp
+	$(CLISP) -c gdi.lisp
+
+gdi.c : gdi.m local.c funcs-ok.c funcs-rest.c funcs-prob.c funcs-count.c funcs-out.c
+	cat gdi.m local.c funcs-ok.c funcs-rest.c funcs-prob.c  funcs-count.c funcs-out.c >gdi.mm
+	$(CLISP) $(MODPREP) gdi.mm gdi.c
+
+#grep -v "\#line" gdi.mmm > gdi.c
+#rm gdi.mmm
+
+gdi.o : gdi.c
+	$(CC) $(CFLAGS) $(INCLUDES) -I.. -c gdi.c
+
+# Make a module
+clisp-module : all
+
+clean :
+	rm gdi.o gdi.c gdi.mm gdi.fas gdi.lib
+# Make a module distribution into $(distribdir)
+clisp-module-distrib : clisp-module force
+	$(LN) $(DISTRIBFILES) $(distribdir)
+
+tgz : clean
+	cd ..; tar -zcvf gdi.tar.gz gdi
+
+force :
+
diff -burN origsrc/clisp-2.48/modules/gdi/README src/clisp-2.48/modules/gdi/README
--- origsrc/clisp-2.48/modules/gdi/README	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/README	2009-07-29 10:09:43.000000000 +0000
@@ -0,0 +1,78 @@
+This module is a interface to gdi, the lowest level
+ms windows graphics api. It is a work in progress,
+and is copyright Dan Stanger 2002 and Reini Urban 2006-2009.
+It is licensed under the LGPL and all rights assigned
+to the Free Software Foundation.
+There are many places to learn about the gdi.  The wine
+web site has some links to web sites about it.
+
+This is the modern version of gdi, i.e. case-sensitive with proper caps.
+The repo is at http://code.google.com/p/clisp-gdi/
+
+WARNING: DONT regenerate any code without
+thinking very carefully.  All the c files were hand edited,
+and you dont want to redo that.
+END WARNING
+
+All the C files were hand edited to use with_string_0
+instead of TheAsciz.
+
+Todo:
+
+Fix warnings.
+Test existing code.
+Add more message handling code.
+Finish the process*, output* routines.
+Write more examples, and documentation.
+
+To install:
+Copy the gdi directory to clisp-x.y/modules/gdi and 
+configure with --with-modules=gdi, or
+copy gdi under the build dir and add gdi to the MODULES line in build/Makefile
+Compile gdi.lisp with:
+clisp -q -c gdi.lisp
+make the object gdi.o
+make
+cd ..
+echo rm -rf gdi+base;./clisp-link add gdi . gdi+base
+cd gdi+base
+cp * /usr/local/lib/clisp/base
+
+now clisp should execute with the gdi module, and *features* should
+have :GDI in it.
+
+Notes:
+Some functions which in c would return a struct return multiple values
+if it was more convenient to do so.  For example GetTextExtentPoint32
+would return a SIZE, but most of the time, the size will be used
+directly.  If this proves not to be the case, change it.
+
+Files:
+Makefile
+func.awk program to convert output of c preprocesser to clisp module code
+funcs-count.c functions <= 5 args
+funcs-count.h header file of functions <= 5 args
+funcs-ok.c functions that probably translated ok
+funcs-ok.h header file of functions that probably translated ok
+funcs-out.c functions that return data
+funcs-out.h header file of functions that return data
+funcs-prob.c functions that have been hand edited
+funcs-prob.h header file of functions that will require hand editing
+funcs-rest.c functions that have more than 5 parameters, has been hand edited
+funcs-rest.c-prev a previous version of the previous file
+funcs-rest.h header file of functions that have more than 5 parameters
+funcs-rest.sh script to create the funcs-rest.c
+gdi-preload.lisp used by module process
+gdi.lisp lisp code for module
+gdi.m c code that was written by hand
+input.awk code to help generate process* routines in local.c
+link.sh used by module process
+local.c mostly process and output routines.
+struct1.awk code to help generate process* routines in local.c
+struct2.awk code to help generate lisp structures
+struct3.awk code to help generate output* routines in local.c
+todo obsolete ??? todo list
+
+Maintainer note:
+Dan Stanger stopped writing at this code at end of 2003, and 
+Reini Urban took it over 2006.
diff -burN origsrc/clisp-2.48/modules/gdi/TODO src/clisp-2.48/modules/gdi/TODO
--- origsrc/clisp-2.48/modules/gdi/TODO	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/TODO	2009-07-13 13:39:26.000000000 +0000
@@ -0,0 +1,5 @@
+fix b, bool
+add object arg
+fix function args in header, no commas
+handle wide-strings: GetICMProfileW
+finish unimplemented outputSTRUCT
\ No newline at end of file
diff -burN origsrc/clisp-2.48/modules/gdi/cs-modprep.patch src/clisp-2.48/modules/gdi/cs-modprep.patch
--- origsrc/clisp-2.48/modules/gdi/cs-modprep.patch	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/cs-modprep.patch	2009-07-28 15:54:08.005125000 +0000
@@ -0,0 +1,61 @@
+difforig utils/modprep.lisp
+
+diff -u utils/modprep.lisp.orig utils/modprep.lisp
+--- utils/modprep.lisp.orig	2009-06-25 23:43:02.000000000 +0200
++++ utils/modprep.lisp	2009-07-12 21:23:01.156250000 +0200
+@@ -221,7 +221,7 @@
+ 
+ (defun endif-p (line) (eq :|endif| (decode-directive line)))
+ 
+-;; DEFMODULE(name,package)
++;; DEFMODULE(name,package,[package-properties])
+ (defvar *module-name*)
+ (defvar *module-line*)
+ (defvar *module-package*) 
+@@ -335,7 +335,8 @@
+   (find tag *objdefs* :test #'string= :key #'objdef-tag))
+ (defun write-string-c-style (string out)
+   (loop :for cc :across string :and ii :upfrom 0
+-    :do (cond ((alphanumericp cc) (write-char (char-downcase cc) out))
++    :do (cond ((alphanumericp cc) 
++               (write-char (if (case-sensitive-package-p) cc (char-downcase cc)) out))
+               ((char= cc #\:) (write-char (if (zerop ii) #\K #\_) out))
+               ((or (char= cc #\_) (char= cc #\-)) (write-char #\_ out))
+               (t (format out "_~2,'0x" (char-code cc))))))
+@@ -373,6 +374,9 @@
+ (defun case-sensitive-package-p ()
+   (let ((properties (gethash *module-package* *package-properties*)))
+     (or (getf properties :modern) (getf properties :case-sensitive))))
++(defun case-inverted-package-p ()
++  (let ((properties (gethash *module-package* *package-properties*)))
++    (or (getf properties :modern) (getf properties :case-inverted))))
+ 
+ (defun string-upcase-verbose (string)
+   (when (and (some #'lower-case-p string)    ; upcasing will modify
+@@ -597,8 +601,9 @@
+       (setq pack (string-upcase pack)))
+     (unless (every (lambda (c) (or (not (alpha-char-p c)) (upper-case-p c)))
+                    name)
+-      (warn "~S:~D: fixed function name case ~S" *input-file* *lineno* name)
+-      (setq name (string-upcase name)))
++      (when (not (case-sensitive-package-p))
++        (warn "~S:~D: fixed function name case ~S" *input-file* *lineno* name)
++        (setq name (string-upcase name))))
+     (pushnew pack *module-all-packages* :test #'string=)
+     (vector-push-extend fd *fundefs*)
+     fd))
+@@ -1171,9 +1176,13 @@
+             (format out "  subr_initdata_t _~A;" (fundef-tag fd))))
+     (formatln out "  int _dummy_to_avoid_trailing_comma_in_initializer;")
+     (formatln out "} ~A = {" subr-tab-initdata)
++    (if (case-inverted-package-p) 
++        (formatln out "/* case-inverted for modern, will be inverted again lisp-side */"))
+     (loop :for fd :across *fundefs*
+       :do (with-conditional (out (fundef-cond-stack fd))
+-            (format out "  { ~S, ~S }," (fundef-pack fd) (fundef-name fd))))
++            (format out "  { ~S, ~S }," (fundef-pack fd) 
++                    (if (case-inverted-package-p) (string-invertcase (fundef-name fd))
++                      (fundef-name fd)))))
+     (formatln out "  0")
+     (formatln out "};") (newline out)
+     ;; Emit the decl first, to avoid "gcc -missing-declarations" warnings.
diff -burN origsrc/clisp-2.48/modules/gdi/document.pl src/clisp-2.48/modules/gdi/document.pl
--- origsrc/clisp-2.48/modules/gdi/document.pl	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/document.pl	2009-07-15 08:43:30.000000000 +0000
@@ -0,0 +1,27 @@
+#!/usr/bin/perl -n
+
+# document.pl funcs-*.h  >> gdi.xml
+# Reini Urban
+
+#BEGIN { print "<section id=\"gdi-functions\"><title>Functions</title>\n"; }
+#END { print "</section>\n"; }
+
+($r,$n,$a) = /^(\w+)\s+(\w+)\((.+)\);/;
+$a =~ s/,/ /g;
+$a =~ s/void/ /g;
+print "<varlistentry id=\"$n\"><term><code>($n $a)</code></term>\n";
+print "  <para>See <link linkend=\"http://social.msdn.microsoft.com/search/en-us/?query=$n\">MSDN</link></para>\n";
+if ($r eq "BOOL") {
+    print "  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para>\n";
+} elsif ($r =~ /int|UINT|LPARAM|DWORD|WORD|LONG/) {
+    print "  <para>Returns <constant>&t;</constant> and a <type>&integer;</type>.</para>\n";
+} elsif ($r =~ /CHAR|char/) {
+    print "  <para>Returns <constant>&t;</constant> and a <type>$r</type>.</para>\n";
+} elsif ($r =~ /void/i) {
+    print "  <para>Returns nothing.</para>\n";
+} elsif ($r =~ /^H|ATOM/)
+    print "  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>$r</type> handle.</para>\n";
+} else { # ($r =~ /^H|ATOM/)
+    print "  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>$r</type> structure.</para>\n";
+}
+print "</varlistentry>\n";
diff -burN origsrc/clisp-2.48/modules/gdi/func.awk src/clisp-2.48/modules/gdi/func.awk
--- origsrc/clisp-2.48/modules/gdi/func.awk	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/func.awk	2009-07-13 12:04:24.000000000 +0000
@@ -0,0 +1,483 @@
+# awk.parser - recursive-descent translator for part of awk
+#   input:  awk program (very restricted subset)
+#   output: C code to implement the awk program
+
+BEGIN { program() }
+
+function advance() {      # lexical analyzer; returns next token
+    if (tok == "(eof)") return "(eof)"
+    while (length(line) == 0)
+        if (getline line == 0)
+            return tok = "(eof)"
+    sub(/^[ \t]+/, "", line)   # remove white space
+    if (match(line, /^[A-Za-z_][A-Za-z_0-9]*/) ||    # identifier
+        match(line, /^-?([0-9]+\.?[0-9]*|\.[0-9]+)/) ||  # number
+        match(line, /^(<|<=|==|!=|>=|>)/) ||         # relational
+        match(line, /^./)) {                    # everything else
+            tok = substr(line, 1, RLENGTH)
+            line = substr(line, RLENGTH+1)
+            return tok
+        }
+    error("line " NR " incomprehensible at " line)
+}
+function gen(s) {     # print s with 2*nt leading spaces
+    printf("%s%s\n", substr("                                          ", 1, 2*nt), s)
+}
+function eat(s) {     # read next token if s == tok
+    if (tok != s) error("line " NF ": saw " tok ", expected " s)
+    advance()
+}
+function nl() {       # absorb newlines and semicolons
+    while (tok == "\n" || tok == ";")
+        advance()
+}
+function error(s) { print "Error: " s | "cat 1>&2"; exit 1 }
+
+function program() {
+    advance()
+    gen("#line 1 \"funcs.c\"")
+    pastats()
+    if (tok != "(eof)") error("program continues after END")
+}
+function pastats() {
+    nt=0;
+    while (tok != "END" && tok != "(eof)") pastat()
+}
+function initCurrentNames(c,a,i,n) {
+    n = split("void int char float double long bool",a, " ")
+    for(i=1; i <=n; i++)c[a[i]]=1
+}
+# rettype funcname (args...);
+function pastat(retType, retName, funcName,args,argTypes, argNames,rest) {
+    delete currentNames
+    delete inits
+    initCurrentNames(currentNames)
+    retType = tok
+    advance()
+    funcName = tok
+    advance()
+    eat("(")
+    args=exprlist()
+    eat(")")
+    nl()
+    makeArgTypes(args,argTypes)
+    makeArgNames(args,argNames)
+    rest = 0
+    if(doHead(funcName,argNames) ~ /rest/)rest = 1
+    gen("{")
+    nt++
+    retName = makeUniqueName(tolower(retType))
+    doIdentDecl("object","arg")
+    doIdentDecl(retType,retName)
+    doIdentList(argTypes,argNames,inits)
+    doInits(inits)
+    if(rest)doRest();
+    doCall(retName, funcName, argNames)
+    doRet(retType,retName)
+    nt--; gen("}")
+}
+function doRest(){
+   # gen("skipSTACK(argcount);");
+}
+
+function makeUniqueName(n)
+{
+   if( n in currentNames)return makeUniqueNameAux(n,0)
+   else
+   {
+      currentNames[n] = 1
+      return n
+   }
+}
+function makeUniqueNameAux(n,i,v)
+{
+   v = n i
+   if( v in currentNames)return makeUniqueNameAux(n,i+1)
+   else
+   {
+      currentNames[v]=1
+      return v
+   }
+}
+function makeStringFromArray(a,n,i,s)
+{
+   n = a[0]
+   if( n >= 6)return "&rest r"
+   s = ""
+   for(i=1; i <= n; i++)s=s " " a[i]
+   return s
+}
+function doHead(f,a,s) {
+   s = makeStringFromArray(a)
+   gen("// untested - was never called")
+   gen("// uninspected - compiles but code was not checked")
+   #gen("DEFUN( GDI:" toupper(f) "," s ")")
+   gen("DEFUN( " toupper(f) ":" f "," s ")")
+   return s
+}
+function doCall(r,f,a,s,i,sep) {
+   s=""
+   sep=""
+   for(i=1; i <= a[0]; i++){
+      s = s sep a[i]
+      sep = ","
+   }
+   gen("begin_call();")
+   gen(r " = " f "(" s ");")
+   gen("end_call();")
+}
+function doRet(r,name) {
+    if(r ~/H.*/)doHandle(name)
+    else if("void" == r)doVoid()
+    else if("BOOL"==r)doBool(name)
+    else if("BYTE"==r)doByte(name)
+    else if("WORD"==r)doWord(name)
+    else if("ATOM"==r)doAtom(name)
+    else if("CHAR"==r || "char" == r)doChar(name)
+    else if("int"==r || "LONG" == r || "INT" == r || "LPARAM"==r)doInt(name,"s")
+    else if("DWORD"==r || "UINT" == r)doInt(name,"u")
+}
+function doInt(name,ty){
+  gen("if(0 <=" name "){")
+  nt++
+  gen("DWORD e;")
+  gen("begin_call();");
+  gen("e = GetLastError();")
+  gen("end_call();")
+  gen("value1 = NIL;")
+  gen("value2 = uint32_to_I(e);")
+  gen("mv_count=2;")
+  nt--
+  gen("}")
+  gen("else")
+  gen("{")
+  nt++
+  gen("value1 = T;")
+  gen("value2 = "ty"int32_to_I("name");")
+  gen("mv_count=2;")
+  nt--
+  gen("}")
+  gen("return;")
+}
+function doHandle(h) {
+  gen("if(NULL ==" h "){")
+  nt++
+  gen("DWORD e;")
+  gen("begin_call();");
+  gen("e = GetLastError();")
+  gen("end_call();")
+  gen("value1 = NIL;")
+  gen("value2 = uint32_to_I(e);")
+  gen("mv_count=2;")
+  nt--
+  gen("}")
+  gen("else")
+  gen("{")
+  nt++
+  gen("value1 = T;")
+  gen("value2 = allocate_fpointer((FOREIGN)"h");")
+  gen("mv_count=2;")
+  nt--
+  gen("}")
+  gen("return;")
+}
+function doVoid()
+{
+   gen("mv_count = 0;")
+   gen("return;")
+}
+function doByte(b)
+{
+   gen("mv_count = 1;")
+   gen("value1 = uint8_to_I(" b ");")
+   gen("return;")
+}
+function doWord(b)
+{
+   gen("mv_count = 1;")
+   gen("value1 = uint16_to_I(" b ");")
+   gen("return;")
+}
+function doAtom(h) {
+  gen("if(0 ==" h "){")
+  nt++
+  gen("DWORD e;")
+  gen("begin_call();");
+  gen("e = GetLastError();")
+  gen("end_call();")
+  gen("value1 = NIL;")
+  gen("value2 = uint32_to_I(e);")
+  gen("mv_count=2;")
+  nt--
+  gen("}")
+  gen("else")
+  gen("{")
+  nt++
+  gen("value1 = T;")
+  gen("value2 = allocate_fpointer((FOREIGN)"h");")
+  gen("mv_count=2;")
+  nt--
+  gen("}")
+  gen("return;")
+}
+function doBool(b) {
+  gen("if(!" b "){")
+  nt++
+  gen("DWORD e;")
+  gen("begin_call();");
+  gen("e = GetLastError();")
+  gen("end_call();")
+  gen("value1 = NIL;")
+  gen("value2 = uint32_to_I(e);")
+  gen("mv_count=2;")
+  nt--
+  gen("}")
+  gen("else")
+  gen("{")
+  nt++
+  gen("value1 = T;")
+  gen("mv_count=1;")
+  nt--
+  gen("}")
+  gen("return;")
+}
+
+function doChar(b)
+{
+   gen("mv_count = 1;")
+   gen("value1 = int_char(" b ");")
+   gen("return;")
+}
+function pattern() { return expr() }
+
+function statlist() {
+    eat("{"); nl(); while (tok != "}") stat(); eat("}"); nl()
+}
+
+function stat() {
+    if (tok == "print") { eat("print"); gen("print(" exprlist() ");") }
+    else if (tok == "if") ifstat()
+    else if (tok == "while") whilestat()
+    else if (tok == "{") statlist()
+    else gen(simplestat() ";")
+    nl()
+}
+
+function ifstat() {
+    eat("if"); eat("("); gen("if (" expr() ") {"); eat(")"); nl(); nt++
+    stat()
+    if (tok == "else") {      # optional else
+        eat("else")
+        nl(); nt--; gen("} else {"); nt++
+        stat()
+    }
+    nt--; gen("}")
+}
+
+function whilestat() {
+    eat("while"); eat("("); gen("while (" expr() ") {"); eat(")"); nl()
+    nt++; stat(); nt--; gen("}")
+}
+
+function simplestat(   lhs) { # ident = expr | name(exprlist)
+    lhs = ident()
+    if (tok == "=") {
+        eat("=")
+        return "assign(" lhs ", " expr() ")"
+    } else return lhs
+}
+function doIdent( type, name) {
+    if(type ~ /^H.*/) {
+       gen("arg = popSTACK();")
+       gen("if(!fpointerp(arg))invalid_argument(arg);");
+       gen(name " = TheFpointer(arg)->fp_pointer;")
+    }
+    else if( "DWORD" == type || "UINT" == type || "DWORD32" == type ||
+              "COLORREF" == type) {
+       gen("arg = popSTACK();")
+       gen("check_uint(arg);")
+       gen(name " = I_to_uint32(arg);")
+    }
+    else if( "int" == type || "INT" == type || "LONG" == type || "LPARAM"==type){
+       gen("arg = popSTACK();")
+       gen("check_sint(arg);")
+       gen(name " = I_to_sint32(arg);")
+    }
+    else if( "LPSTR" == type || "LPCSTR" == type) {
+       gen("arg = popSTACK();")
+       gen("if(!stringp(arg))invalid_argument(arg);");
+       gen(name " = TheAsciz(string_to_asciz(arg,encoding));")
+    }
+    else if( "LPWSTR" == type || "LPCWSTR" == type) {
+       gen("arg = popSTACK();")
+       gen("if(!stringp(arg))invalid_argument(arg);");
+       gen(name " = WIDECHAR(arg,encoding);")
+    }
+    else if( "float" == type || "FLOAT" == type) {
+       gen("arg = popSTACK();")
+       gen("check_ffloat(arg);");
+       gen(name " = ffloat_value(arg);")
+    }
+    else if("BYTE_P" == type) {
+       gen("arg = popSTACK();")
+       gen("if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);");
+       gen(name " = (BYTE*)&(TheSbvector(arg)->data);")
+    }
+    else if("INT_P" == type || "DWORD_P" == type || "LPINT" == type) {
+       gen("arg = popSTACK();")
+       gen("if(!simple_bit_vector_p(Atype_32Bit,arg))invalid_argument(arg);");
+       gen(name " = (INT*)&(TheSbvector(arg)->data);")
+    }
+    else if("PVOID" == type || "PCVOID" == type) {
+       gen("arg = popSTACK();")
+       gen("if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);");
+       gen(name " = (void*)&(TheSbvector(arg)->data);")
+    }
+    else if(type ~ /^LPC.*/) {
+       sub("^LPC","",type)
+       gen("arg0 = popSTACK();")
+       gen("process"type"("name",arg0);")
+    }
+    else if(type ~ /^LP.*/) {
+       sub("^LP","",type)
+       gen("arg0 = popSTACK();")
+       gen("process"type"("name",arg0);")
+    }
+    else
+    {
+       sub("_P$","",type)
+       gen("arg0 = popSTACK();")
+       gen("process"type"("name",arg0);")
+    }
+}
+function doIdentDecl( e,n,i,a) {
+   if("BYTE_P" == e || "INT_P" == e || "DWORD_P" == e) {
+       sub("_P$","",e)
+       gen(e "* " n ";")
+   }
+   else if("LPINT" == e){
+       gen("int* " n ";")
+   }
+   else if("PVOID" == e || "PCVOID" == e || "void_P" == e) {
+       gen("void* " n ";")
+   }
+   else if( e ~ /_P$/){
+      sub("_P$","",e)
+      gen(e "* " n " = alloca(sizeof("e"));")
+      gen("object arg0 = 0;")
+      a[i] = "process"e"("n",arg0);"
+   }
+   else if(e ~ /^LPC.*/ && e !~ /STR/) {
+      sub("^LPC","",e)
+      gen(e "* " n " = alloca(sizeof("e"));")
+      gen("object arg0 = 0;")
+      a[i] = "process"e"("n",arg0);"
+   }
+   else if(e ~ /^LP.*/ && e !~ /STR/) {
+      sub("^LP","",e)
+      gen(e "* " n " = alloca(sizeof("e"));")
+      gen("object arg0 = 0;")
+      a[i] = "process"e"("n",arg0);"
+   }
+   else
+   {
+      gen(e " " n ";")
+   }
+   return n
+}
+function makeArgTypes( e,a, n) {
+   n = split(e,a,",")
+   a[0] = n;
+}
+function makeArgNames( e,a, n, i) {
+   n = split(e,a,",")
+   for(i=1; i <= n; i++)a[i] = makeUniqueName(tolower(a[i]))
+   a[0]=n
+   return n
+}
+
+function doInits(inits,i) {
+   for(i = 1; i <= inits[0]; i++){
+     if(i in inits)gen(inits[i])
+   }
+}
+function doIdentList( types,names,inits,i,n) {
+   n = names[0];
+   inits[0] = n
+   for(i=1; i <= n; i++)doIdentDecl(types[i],names[i],i,inits)
+   for(i=n; 1 <= i; i--)doIdent(types[i],names[i])
+}
+function exprlist(    n, e, e0) { # expr , expr , ...
+    e = ident()        # has to be at least one
+    for (n = 1; tok == ","; n++) {
+        advance()
+        e = e "," ident()
+    }
+    return e
+}
+
+function expr(e) {            # rel | rel relop rel
+    e = rel()
+    while (tok ~ /<|<=|==|!=|>=|>/) {
+        op = tok
+        advance()
+        e = sprintf("eval(\"%s\", %s, %s)", op, e, rel())
+    }
+    return e
+}
+
+function rel(op, e) {         # term | term [+-] term
+    e = term()
+    while (tok == "+" || tok == "-") {
+        op = tok
+        advance()
+        e = sprintf("eval(\"%s\", %s, %s)", op, e, term())
+    }
+    return e
+}
+
+function term(op, e) {        # fact | fact [*/%] fact
+    e = fact()
+    while (tok == "*" || tok == "/" || tok == "%") {
+        op = tok
+        advance()
+        e = sprintf("eval(\"%s\", %s, %s)", op, e, fact())
+    }
+    return e
+}
+
+function fact(  e) {          # (expr) | $fact | ident | number
+    if (tok == "(") {
+        eat("("); e = expr(); eat(")")
+        return "(" e ")"
+    } else if (tok == "$") {
+        eat("$")
+        return "field(" fact() ")"
+    } else if (tok ~ /^[A-Za-z][A-Za-z0-9]*/) {
+        return ident()
+    } else if (tok ~ /^-?([0-9]+\.?[0-9]*|\.[0-9]+)/) {
+        e = tok
+        advance()
+        return "num((float)" e ")"
+    } else
+        error("unexpected " tok " at line " NR)
+}
+
+function ident(  id, e) {     # name | name[expr] | name(exprlist)
+    if (!match(tok, /^[A-Za-z_][A-Za-z_0-9]*/))
+        error("unexpected " tok " at line " NR)
+    id = tok
+    advance()
+    if (tok == "[") {         # array
+        eat("["); e = expr(); eat("]")
+        return "array(" id ", " e ")"
+    } else if (tok == "(") {  # function call
+        eat("(")
+        if (tok != ")") {
+            e = exprlist()
+            eat(")")
+        } else eat(")")
+        return id "(" e ")"   # calls are statements
+    } else
+        return id             # variable
+}
diff -burN origsrc/clisp-2.48/modules/gdi/funcs-count.c src/clisp-2.48/modules/gdi/funcs-count.c
--- origsrc/clisp-2.48/modules/gdi/funcs-count.c	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/funcs-count.c	2009-07-30 14:44:01.000000000 +0000
@@ -0,0 +1,1574 @@
+#line 2 "funcs-count.c"
+// -*- d -*-
+/* functions <= 5 args */
+
+// untested - was never called
+DEFUN( GDI:AnimatePalette, hpalette iStartIndex cEntries paletteentry_p)
+/* The AnimatePalette function only changes entries with the PC_RESERVED flag
+set in the corresponding palPalEntry member of the LOGPALETTE structure.
+
+paletteentry_p is a pointer to the first member of an array of PALETTEENTRY 
+structs used to replace the current entries */
+{
+  object arg;
+  BOOL bool0;
+  HPALETTE hpalette;
+  UINT iStartIndex;
+  UINT cEntries;
+  PALETTEENTRY* paletteentry_p;
+  arg = popSTACK();
+  processFPTYPE(PALETTEENTRY*,paletteentry_p,arg);
+  cEntries = I_to_uint32(check_uint(popSTACK()));
+  iStartIndex = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  processFPTYPE(HPALETTE,hpalette,arg)
+
+  begin_system_call();
+  bool0 = AnimatePalette(hpalette,iStartIndex,cEntries,paletteentry_p);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("AnimatePalette");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ChoosePixelFormat, hdc pixelformatdescriptor_p)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  PIXELFORMATDESCRIPTOR* pixelformatdescriptor_p = alloca(sizeof(PIXELFORMATDESCRIPTOR));
+  object arg0;
+  arg0 = popSTACK();
+  processPIXELFORMATDESCRIPTOR(pixelformatdescriptor_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  int0 = ChoosePixelFormat(hdc,pixelformatdescriptor_p);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("ChoosePixelFormat");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:CreateBitmap, nWidth nHeight cPlanes cBitsPerPel lpvBits)
+/* Create monochrom bitmaps. Use CreateCompatibleBitmap to create color bitmaps.
+ * lpvBits - bitvector of color data used to set the colors in a rectangle 
+ *   of pixels. Each scan line in the rectangle must be word aligned, scan lines 
+ *   that are not word aligned must be padded with zeros.
+ * Returns a handle to the bitmap.
+ */
+{
+  object arg;
+  HBITMAP hbitmap;
+  int nWidth, nHeight;
+  UINT cPlanes, cBitsPerPel;
+  void* lpvBits;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  lpvBits = &(TheSbvector(arg)->data);
+  cBitsPerPel = I_to_uint32(check_uint(popSTACK()));
+  cPlanes = I_to_uint32(check_uint(popSTACK()));
+  nHeight = I_to_sint32(check_sint(popSTACK()));
+  nWidth  = I_to_sint32(check_sint(popSTACK()));
+
+  begin_system_call();
+  hbitmap = CreateBitmap(nWidth,nHeight,cPlanes,cBitsPerPel,lpvBits);
+  end_system_call();
+  if(NULL ==hbitmap){
+    GDI_ERROR("CreateBitmap");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hbitmap));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateDIBPatternBrushPt, pcvoid uint)
+{
+  object arg;
+  HBRUSH hbrush;
+  void* pcvoid;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pcvoid = &(TheSbvector(arg)->data);
+  begin_system_call();
+  hbrush = CreateDIBPatternBrushPt(pcvoid,uint);
+  end_system_call();
+  if(NULL ==hbrush){
+    GDI_ERROR("CreateDIBPatternBrushPt");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hbrush));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreatePolyPolygonRgn, point_p int_p int0 int1)
+{
+  object arg;
+  HRGN hrgn;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  INT* int_p;
+  int int0;
+  int int1;
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))invalid_argument(arg);
+  int_p = (INT*)&(TheSbvector(arg)->data);
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+
+  begin_system_call();
+  hrgn = CreatePolyPolygonRgn(point_p,int_p,int0,int1);
+  end_system_call();
+  if(NULL ==hrgn){
+    GDI_ERROR("CreatePolyPolygonRgn");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hrgn));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreatePolygonRgn, point_p int0 int1)
+{
+  object arg;
+  HRGN hrgn;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  int int0;
+  int int1;
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+
+  begin_system_call();
+  hrgn = CreatePolygonRgn(point_p,int0,int1);
+  end_system_call();
+  if(NULL ==hrgn){
+    GDI_ERROR("CreatePolygonRgn");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hrgn));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateScalableFontResourceA, dword lpcstr lpcstr0 lpcstr1)
+{
+  object arg;
+  BOOL bool0;
+  DWORD dword;
+  LPCSTR lpcstr;
+  LPCSTR lpcstr0;
+  LPCSTR lpcstr1;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr1, {
+    arg = popSTACK();
+    if(!stringp(arg))invalid_argument(arg);
+    with_string_0(arg,encoding, lpcstr0, {
+      arg = popSTACK();
+      if(!stringp(arg))invalid_argument(arg);
+      with_string_0(arg,encoding, lpcstr, {
+        dword = I_to_uint32(check_uint(popSTACK()));
+        begin_system_call();
+        bool0 = CreateScalableFontResourceA(dword,lpcstr,lpcstr0,lpcstr1);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("CreateScalableFontResourceA");
+        }
+        else
+        {
+          VALUES1(T);
+        }
+      });
+    });
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateScalableFontResourceW, dword lpcwstr lpcwstr0 lpcwstr1)
+{
+  object arg;
+  BOOL bool0;
+  DWORD dword;
+  LPCWSTR lpcwstr;
+  LPCWSTR lpcwstr0;
+  LPCWSTR lpcwstr1;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr1 = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr0 = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  begin_system_call();
+  bool0 = CreateScalableFontResourceW(dword,lpcwstr,lpcwstr0,lpcwstr1);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("CreateScalableFontResourceW");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:DPtoLP, hdc lppoint int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = DPtoLP(hdc,lppoint,int0);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("DPtoLP");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:DescribePixelFormat, hdc int0 uint lppixelformatdescriptor)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  UINT uint;
+  PIXELFORMATDESCRIPTOR* lppixelformatdescriptor = alloca(sizeof(PIXELFORMATDESCRIPTOR));
+  object arg0;
+  arg0 = popSTACK();
+  processPIXELFORMATDESCRIPTOR(lppixelformatdescriptor,arg0);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  int1 = DescribePixelFormat(hdc,int0,uint,lppixelformatdescriptor);
+  end_system_call();
+  if(0 <=int1){
+    GDI_ERROR("DescribePixelFormat");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int1));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:DrawEscape, hdc int0 int1 lpcstr)
+{
+  object arg;
+  int int2;
+  HDC hdc;
+  int int0;
+  int int1;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    check_sint(arg);
+    int1 = I_to_sint32(arg);
+    arg = popSTACK();
+    check_sint(arg);
+    int0 = I_to_sint32(arg);
+    arg = popSTACK();
+    if(!fpointerp(arg))invalid_argument(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+    begin_system_call();
+    int2 = DrawEscape(hdc,int0,int1,lpcstr);
+  end_system_call();
+  if(0 <=int2){
+    GDI_ERROR("DrawEscape");
+    }
+    else
+    {
+    VALUES1(sint32_to_I(int2));
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ExtCreatePen, dword dword0 logbrush_p dword1 dword_p)
+{
+  object arg;
+  HPEN hpen;
+  DWORD dword;
+  DWORD dword0;
+  LOGBRUSH* logbrush_p = alloca(sizeof(LOGBRUSH));
+  object arg0;
+  DWORD dword1;
+  DWORD* dword_p;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))invalid_argument(arg);
+  dword_p = (DWORD*)&(TheSbvector(arg)->data);
+  dword1 = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processLOGBRUSH(logbrush_p,arg0);
+  dword0 = I_to_uint32(check_uint(popSTACK()));
+  dword = I_to_uint32(check_uint(popSTACK()));
+
+  begin_system_call();
+  hpen = ExtCreatePen(dword,dword0,logbrush_p,dword1,dword_p);
+  end_system_call();
+  if(NULL ==hpen){
+    GDI_ERROR("ExtCreatePen");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hpen));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:ExtCreateRegion, xform_p nCount rgndata_p)
+/*
+   xform_p - NIL or fp_zero is for the identity transform
+ */
+{
+  object arg;
+  HRGN hrgn;
+  XFORM* xform_p = alloca(sizeof(XFORM));
+  object arg0;
+  DWORD nCount;
+  RGNDATA* rgndata_p;
+
+  arg = popSTACK();
+  processFPTYPE(RGNDATA*,rgndata_p,arg);
+  nCount = I_to_uint32(check_uint(popSTACK()));
+  //rgndata_p = alloca(dword*sizeof(RGNDATA));
+  //processRGNDATA_C(&rgndata_p,arg,nCount);
+  arg0 = popSTACK();
+  processXFORM(xform_p,arg0);
+
+  begin_system_call();
+  hrgn = ExtCreateRegion(xform_p,nCount,rgndata_p);
+  end_system_call();
+  if(NULL ==hrgn){
+    GDI_ERROR("ExtCreateRegion");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hrgn));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FixBrushOrgEx, hdc int0 int1 lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = FixBrushOrgEx(hdc,int0,int1,lppoint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("FixBrushOrgEx");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GdiComment, hdc uint byte_p)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT uint;
+  BYTE* byte_p;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  byte_p = (BYTE*)&(TheSbvector(arg)->data);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = GdiComment(hdc,uint,byte_p);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GdiComment");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GdiFlush,)
+{
+  object arg;
+  BOOL bool0;
+  begin_system_call();
+  bool0 = GdiFlush();
+  end_system_call();
+  if(!bool0){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GdiGetBatchLimit,)
+{
+  object arg;
+  DWORD dword;
+  begin_system_call();
+  dword = GdiGetBatchLimit();
+  end_system_call();
+  if(!dword){
+    DWORD e;
+    begin_system_call();
+    e = GetLastError();
+    end_system_call();
+    value1 = NIL;
+    value2 = uint32_to_I(e);
+    mv_count=2;
+  }
+  else
+  {
+    VALUES1(uint32_to_I(dword));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:LPtoDP, hdc lppoint int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = LPtoDP(hdc,lppoint,int0);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("LPtoDP");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ModifyWorldTransform, hdc xform_p dword)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  XFORM* xform_p = alloca(sizeof(XFORM));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processXFORM(xform_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = ModifyWorldTransform(hdc,xform_p,dword);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("ModifyWorldTransform");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:MoveToEx, hdc int0 int1 lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = MoveToEx(hdc,int0,int1,lppoint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("MoveToEx");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:OffsetViewportOrgEx, hdc int0 int1 lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = OffsetViewportOrgEx(hdc,int0,int1,lppoint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("OffsetViewportOrgEx");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:OffsetWindowOrgEx, hdc int0 int1 lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = OffsetWindowOrgEx(hdc,int0,int1,lppoint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("OffsetWindowOrgEx");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+/**
+ * The lpHandletable and nHandles parameters must be identical to those 
+ * passed to the EnumMetaFileProc callback procedure by EnumMetaFile. 
+ */
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PlayEnhMetaFileRecord, hdc lphandletable enhmetarecord_p nHandles)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HANDLETABLE* lphandletable;
+  ENHMETARECORD* enhmetarecord_p = alloca(sizeof(ENHMETARECORD));
+  UINT nHandles;
+  nHandles = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  processFPTYPE(ENHMETARECORD*,enhmetarecord_p,arg);
+  arg = popSTACK();
+  //lphandletable = alloca(nHandles*sizeof(HANDLETABLE));
+  processFPTYPE(HANDLETABLE*,lphandletable,arg);//,nHandles); //unimplemented
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = PlayEnhMetaFileRecord(hdc,lphandletable,enhmetarecord_p,nHandles);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("PlayEnhMetaFileRecord");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+/**
+ * The lpHandletable and nHandles parameters must be identical to those 
+ * passed to the EnumMetaFileProc callback procedure by EnumMetaFile. 
+ */
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PlayMetaFileRecord, hdc lphandletable lpmetarecord nHandles)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HANDLETABLE* lphandletable;
+  METARECORD* lpmetarecord;
+  UINT nHandles;
+  nHandles = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  processFPTYPE(METARECORD*,lpmetarecord,arg);
+  arg = popSTACK();
+  //lphandletable = alloca(nHandles*sizeof(HANDLETABLE));
+  processFPTYPE(HANDLETABLE*,lphandletable,arg);//,nHandles);//unimplemented
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = PlayMetaFileRecord(hdc,lphandletable,lpmetarecord,nHandles);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("PlayMetaFileRecord");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PolyBezier, hdc point_p dword)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = PolyBezier(hdc,point_p,dword);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("PolyBezier");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PolyBezierTo, hdc point_p dword)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = PolyBezierTo(hdc,point_p,dword);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("PolyBezierTo");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PolyDraw, hdc point_p byte_p int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  BYTE* byte_p;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  byte_p = (BYTE*)&(TheSbvector(arg)->data);
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = PolyDraw(hdc,point_p,byte_p,int0);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("PolyDraw");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PolyPolygon, hdc point_p int_p int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  INT* int_p;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))invalid_argument(arg);
+  int_p = (INT*)&(TheSbvector(arg)->data);
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = PolyPolygon(hdc,point_p,int_p,int0);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("PolyPolygon");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PolyPolyline, hdc point_p dword_p dword)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  DWORD* dword_p;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))invalid_argument(arg);
+  dword_p = (DWORD*)&(TheSbvector(arg)->data);
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = PolyPolyline(hdc,point_p,dword_p,dword);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("PolyPolyline");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PolyTextOutA, hdc polytexta_p int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POLYTEXTA* polytexta_p = alloca(sizeof(POLYTEXTA));
+  object arg0;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg0 = popSTACK();
+  processPOLYTEXTA(polytexta_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = PolyTextOutA(hdc,polytexta_p,int0);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("PolyTextOutA");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PolyTextOutW, hdc polytextw_p int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POLYTEXTW* polytextw_p;
+  object arg0;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(POLYTEXTW*,polytextw_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = PolyTextOutW(hdc,polytextw_p,int0);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("PolyTextOutW");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:Polygon, hdc point_p int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = Polygon(hdc,point_p,int0);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("Polygon");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:Polyline, hdc point_p int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = Polyline(hdc,point_p,int0);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("Polyline");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PolylineTo, hdc point_p dword)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* point_p = alloca(sizeof(POINT));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processPOINT(point_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = PolylineTo(hdc,point_p,dword);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("PolylineTo");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetBitmapBits, hbitmap dword pcvoid)
+{
+  object arg;
+  LONG long0;
+  HBITMAP hbitmap;
+  DWORD dword;
+  void* pcvoid;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pcvoid = &(TheSbvector(arg)->data);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hbitmap = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  long0 = SetBitmapBits(hbitmap,dword,pcvoid);
+  end_system_call();
+  if(0 <=long0){
+    GDI_ERROR("SetBitmapBits");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(long0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetBitmapDimensionEx, hbitmap int0 int1)
+{
+  object arg;
+  BOOL bool0;
+  HBITMAP hbitmap;
+  int int0;
+  int int1;
+  SIZE lpsize;
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hbitmap = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = SetBitmapDimensionEx(hbitmap,int0,int1,&lpsize);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetBitmapDimensionEx");
+  }
+  else
+  {
+    pushSTACK( uint32_to_I(lpsize.cy));
+    value1 = uint32_to_I(lpsize.cx);
+    value2 = popSTACK();
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetBoundsRect, hdc lpcrect uint)
+{
+  object arg;
+  UINT uint0;
+  HDC hdc;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  uint0 = SetBoundsRect(hdc,lpcrect,uint);
+  end_system_call();
+  if(!uint0){
+    GDI_ERROR("SetBoundsRect");
+  }
+  else
+  {
+    VALUES1(uint32_to_I(uint0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetBrushOrgEx, hdc int0 int1 lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = SetBrushOrgEx(hdc,int0,int1,lppoint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetBrushOrgEx");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetDIBColorTable, hdc uint uint0 rgbquad_p)
+{
+  object arg;
+  UINT uint1;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  RGBQUAD* rgbquad_p;
+  object arg0;
+  arg0 = popSTACK();
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+  rgbquad_p = alloca(uint0*sizeof(RGBQUAD));
+  processRGBQUAD_C(rgbquad_p,arg0,uint0);
+
+  begin_system_call();
+  uint1 = SetDIBColorTable(hdc,uint,uint0,rgbquad_p);
+  end_system_call();
+  if(!uint1){
+    GDI_ERROR("SetDIBColorTable");
+  }
+  else
+  {
+    VALUES1(uint32_to_I(uint1));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetEnhMetaFileBits, uint byte_p)
+{
+  object arg;
+  HENHMETAFILE henhmetafile;
+  UINT uint;
+  BYTE* byte_p;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  byte_p = (BYTE*)&(TheSbvector(arg)->data);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  begin_system_call();
+  henhmetafile = SetEnhMetaFileBits(uint,byte_p);
+  end_system_call();
+  if(NULL ==henhmetafile){
+    GDI_ERROR("SetEnhMetaFileBits");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)henhmetafile));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetMetaFileBitsEx, uint byte_p)
+{
+  object arg;
+  HMETAFILE hmetafile;
+  UINT uint;
+  BYTE* byte_p;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  byte_p = (BYTE*)&(TheSbvector(arg)->data);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  begin_system_call();
+  hmetafile = SetMetaFileBitsEx(uint,byte_p);
+  end_system_call();
+  if(NULL ==hmetafile){
+    GDI_ERROR("SetMetaFileBitsEx");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hmetafile));
+  }
+  return;
+}
+// untested - was never called
+/**
+ * The return value is the number of entries that were set in the logical palette.
+ */
+DEFUN( GDI:SetPaletteEntries, hpalette iStart cEntries paletteentry_p)
+{
+  object arg;
+  UINT uint1;
+  HPALETTE hpalette;
+  UINT iStart;
+  UINT cEntries;
+  PALETTEENTRY* paletteentry_p;
+  object arg0;
+  arg0 = popSTACK();
+  if(!fpointerp(arg0))invalid_argument(arg0);
+  paletteentry_p = TheFpointer(arg0)->fp_pointer;
+  cEntries = I_to_uint32(check_uint(popSTACK()));
+  iStart = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hpalette = TheFpointer(arg)->fp_pointer;
+
+  begin_system_call();
+  uint1 = SetPaletteEntries(hpalette,iStart,cEntries,paletteentry_p);
+  end_system_call();
+  if(!uint1){
+    GDI_ERROR("SetPaletteEntries");
+  }
+  else
+  {
+    VALUES1(uint32_to_I(uint1));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetPixelFormat, hdc int0 pixelformatdescriptor_p)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  PIXELFORMATDESCRIPTOR* pixelformatdescriptor_p = alloca(sizeof(PIXELFORMATDESCRIPTOR));
+  object arg0;
+  arg0 = popSTACK();
+  processPIXELFORMATDESCRIPTOR(pixelformatdescriptor_p,arg0);
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = SetPixelFormat(hdc,int0,pixelformatdescriptor_p);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetPixelFormat");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetViewportExtEx, hdc int0 int1 lpsize)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  SIZE* lpsize;
+  object arg0;
+  arg0 = popSTACK();
+  processLPSIZE(lpsize,arg0);
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = SetViewportExtEx(hdc,int0,int1,lpsize);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetViewportExtEx");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetViewportOrgEx, hdc int0 int1 lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = SetViewportOrgEx(hdc,int0,int1,lppoint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetViewportOrgEx");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetWinMetaFileBits, uint byte_p hdc metafilepict_p)
+{
+  object arg;
+  HENHMETAFILE henhmetafile;
+  UINT uint;
+  BYTE* byte_p;
+  HDC hdc;
+  METAFILEPICT* metafilepict_p = alloca(sizeof(METAFILEPICT));
+  object arg0;
+  arg0 = popSTACK();
+  processMETAFILEPICT(metafilepict_p,arg0);
+  getHDC(hdc,arg);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  byte_p = (BYTE*)&(TheSbvector(arg)->data);
+  uint = I_to_uint32(check_uint(popSTACK()));
+
+  begin_system_call();
+  henhmetafile = SetWinMetaFileBits(uint,byte_p,hdc,metafilepict_p);
+  end_system_call();
+  if(NULL ==henhmetafile){
+    GDI_ERROR("SetWinMetaFileBits");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)henhmetafile));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetWindowExtEx, hdc int0 int1 lpsize)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  SIZE* lpsize;// = alloca(sizeof(SIZE));
+  object arg0;
+  arg0 = popSTACK();
+  processLPSIZE(lpsize,arg0);
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = SetWindowExtEx(hdc,int0,int1,lpsize);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetWindowExtEx");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetWindowOrgEx, hdc int0 int1 lppoint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = SetWindowOrgEx(hdc,int0,int1,lppoint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetWindowOrgEx");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:StartDocA, hdc docinfoa_p)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  DOCINFOA* docinfoa_p;// = alloca(sizeof(DOCINFOA));
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(DOCINFOA*,docinfoa_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  int0 = StartDocA(hdc,docinfoa_p);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("StartDocA");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:StartDocW, hdc docinfow_p)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  DOCINFOW* docinfow_p;// = alloca(sizeof(DOCINFOW));
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(DOCINFOW*,docinfow_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  int0 = StartDocW(hdc,docinfow_p);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("StartDocW");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:TextOutA, hdc int0 int1 lpcstr int2)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  LPCSTR lpcstr;
+  int int2;
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    check_sint(arg);
+    int1 = I_to_sint32(arg);
+    arg = popSTACK();
+    check_sint(arg);
+    int0 = I_to_sint32(arg);
+    arg = popSTACK();
+    if(!fpointerp(arg))invalid_argument(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+    begin_system_call();
+    bool0 = TextOutA(hdc,int0,int1,lpcstr,int2);
+    end_system_call();
+    if(!bool0){
+      GDI_ERROR("TextOutA");
+    }
+    else
+    {
+      VALUES1(T);
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:TextOutW, hdc int0 int1 lpcwstr int2)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  LPCWSTR lpcwstr;
+  int int2;
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = TextOutW(hdc,int0,int1,lpcwstr,int2);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("TextOutW");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:UpdateICMRegKeyA, dword dword0 lpstr uint)
+{
+  object arg;
+  BOOL bool0;
+  DWORD dword;
+  DWORD dword0;
+  LPSTR lpstr;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpstr, {
+    dword0 = I_to_uint32(check_uint(popSTACK()));
+    dword = I_to_uint32(check_uint(popSTACK()));
+    begin_system_call();
+    bool0 = UpdateICMRegKeyA(dword,dword0,lpstr,uint);
+    end_system_call();
+    if(!bool0){
+      GDI_ERROR("UpdateICMRegKeyA");
+    }
+    else
+    {
+      VALUES1(T);
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:UpdateICMRegKeyW, dword dword0 lpwstr uint)
+{
+  object arg;
+  BOOL bool0;
+  DWORD dword;
+  DWORD dword0;
+  LPWSTR lpwstr;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpwstr = WIDECHAR(arg,encoding);
+  dword0 = I_to_uint32(check_uint(popSTACK()));
+  dword = I_to_uint32(check_uint(popSTACK()));
+  begin_system_call();
+  bool0 = UpdateICMRegKeyW(dword,dword0,lpwstr,uint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("UpdateICMRegKeyW");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+
+// Local-Variables:
+//  c-basic-offset: 2
+// End
diff -burN origsrc/clisp-2.48/modules/gdi/funcs-count.h src/clisp-2.48/modules/gdi/funcs-count.h
--- origsrc/clisp-2.48/modules/gdi/funcs-count.h	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/funcs-count.h	2006-08-13 14:24:15.000000000 +0000
@@ -0,0 +1,56 @@
+int          AddFontResourceA(LPCSTR);
+int          AddFontResourceW(LPCWSTR);
+BOOL         AnimatePalette(HPALETTE,UINT,UINT, PALETTEENTRY_P);
+int          ChoosePixelFormat(HDC,  PIXELFORMATDESCRIPTOR_P);
+HBITMAP      CreateBitmap(int,int,UINT,UINT,PCVOID);
+HBRUSH       CreateDIBPatternBrushPt(PCVOID,UINT);
+HRGN         CreatePolyPolygonRgn( POINT_P, INT_P,int,int);
+HRGN         CreatePolygonRgn( POINT_P,int,int);
+BOOL         CreateScalableFontResourceA(DWORD,LPCSTR,LPCSTR,LPCSTR);
+BOOL         CreateScalableFontResourceW(DWORD,LPCWSTR,LPCWSTR,LPCWSTR);
+BOOL         DPtoLP(HDC,LPPOINT,int);
+int          DescribePixelFormat(HDC,int,UINT,LPPIXELFORMATDESCRIPTOR);
+int          DrawEscape(HDC,int,int,LPCSTR);
+HPEN         ExtCreatePen(DWORD,DWORD, LOGBRUSH_P,DWORD, DWORD_P);
+HRGN         ExtCreateRegion( XFORM_P,DWORD, RGNDATA_P);
+BOOL         FixBrushOrgEx(HDC,int,int,LPPOINT);
+BOOL         GdiComment(HDC,UINT, BYTE_P);
+BOOL         GdiFlush(void);
+DWORD        GdiGetBatchLimit(void);
+BOOL         LPtoDP(HDC,LPPOINT,int);
+BOOL         ModifyWorldTransform(HDC, XFORM_P,DWORD);
+BOOL         MoveToEx(HDC,int,int,LPPOINT);
+BOOL         OffsetViewportOrgEx(HDC,int,int,LPPOINT);
+BOOL         OffsetWindowOrgEx(HDC,int,int,LPPOINT);
+BOOL         PlayEnhMetaFileRecord(HDC,LPHANDLETABLE, ENHMETARECORD_P,UINT);
+BOOL         PlayMetaFileRecord(HDC,LPHANDLETABLE,LPMETARECORD,UINT);
+BOOL         PolyBezier(HDC, POINT_P,DWORD);
+BOOL         PolyBezierTo(HDC, POINT_P,DWORD);
+BOOL         PolyDraw(HDC, POINT_P, BYTE_P,int);
+BOOL         PolyPolygon(HDC, POINT_P, INT_P,int);
+BOOL         PolyPolyline(HDC, POINT_P, DWORD_P,DWORD);
+BOOL         PolyTextOutA(HDC, POLYTEXTA_P,int);
+BOOL         PolyTextOutW(HDC, POLYTEXTW_P,int);
+BOOL         Polygon(HDC, POINT_P,int);
+BOOL         Polyline(HDC, POINT_P,int);
+BOOL         PolylineTo(HDC, POINT_P,DWORD);
+LONG         SetBitmapBits(HBITMAP,DWORD,PCVOID);
+BOOL         SetBitmapDimensionEx(HBITMAP,int,int,LPSIZE);
+UINT         SetBoundsRect(HDC,LPCRECT,UINT);
+BOOL         SetBrushOrgEx(HDC,int,int,LPPOINT);
+UINT         SetDIBColorTable(HDC,UINT,UINT, RGBQUAD_P);
+HENHMETAFILE SetEnhMetaFileBits(UINT, BYTE_P);
+HMETAFILE    SetMetaFileBitsEx(UINT, BYTE_P);
+UINT         SetPaletteEntries(HPALETTE,UINT,UINT, PALETTEENTRY_P);
+BOOL         SetPixelFormat(HDC,int,PIXELFORMATDESCRIPTOR_P);
+BOOL         SetViewportExtEx(HDC,int,int,LPSIZE);
+BOOL         SetViewportOrgEx(HDC,int,int,LPPOINT);
+HENHMETAFILE SetWinMetaFileBits(UINT, BYTE_P,HDC, METAFILEPICT_P);
+BOOL         SetWindowExtEx(HDC,int,int,LPSIZE);
+BOOL         SetWindowOrgEx(HDC,int,int,LPPOINT);
+int          StartDocA(HDC, DOCINFOA_P);
+int          StartDocW(HDC, DOCINFOW_P);
+BOOL         TextOutA(HDC,int,int,LPCSTR,int);
+BOOL         TextOutW(HDC,int,int,LPCWSTR,int);
+BOOL         UpdateICMRegKeyA(DWORD,DWORD,LPSTR,UINT);
+BOOL         UpdateICMRegKeyW(DWORD,DWORD,LPWSTR,UINT);
diff -burN origsrc/clisp-2.48/modules/gdi/funcs-ok.c src/clisp-2.48/modules/gdi/funcs-ok.c
--- origsrc/clisp-2.48/modules/gdi/funcs-ok.c	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/funcs-ok.c	2009-07-30 12:28:31.000000000 +0000
@@ -0,0 +1,2617 @@
+#line 2 "funcs-ok.c"
+
+/* functions that probably translated ok */
+
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:AbortDoc, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = AbortDoc(hdc);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("AbortDoc");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:AbortPath, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = AbortPath(hdc);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("AbortPath");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// inspected - changed ATOM from fp to int
+DEFUN( GDI:AddAtomA, lpcstr)
+{
+  object arg;
+  ATOM atom;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    atom = AddAtomA(lpcstr);
+    end_system_call();
+    if(!atom){
+      GDI_ERROR("AddAtomA");
+    }
+    else
+    {
+      //value1 = allocate_fpointer((FOREIGN)atom);
+      VALUES1(uint32_to_I(atom));
+    }
+  });
+  return;
+}
+// untested - was never called
+// inspected - changed ATOM from fp to int
+DEFUN( GDI:AddAtomW, lpcwstr)
+{
+  object arg;
+  ATOM atom;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  atom = AddAtomW(lpcwstr);
+  end_system_call();
+  if(!atom){
+    GDI_ERROR("AddAtomW");
+  }
+  else
+  {
+    VALUES1(uint32_to_I(atom)); //value2 = allocate_fpointer((FOREIGN)&atom));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:BeginPath, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = BeginPath(hdc);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("BeginPath");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CancelDC, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = CancelDC(hdc);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("CancelDC");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CloseEnhMetaFile, hdc)
+{
+  object arg;
+  HENHMETAFILE henhmetafile;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  henhmetafile = CloseEnhMetaFile(hdc);
+  end_system_call();
+  if(NULL ==henhmetafile){
+    GDI_ERROR("CloseEnhMetaFile");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)henhmetafile));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CloseFigure, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = CloseFigure(hdc);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("CloseFigure");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CloseMetaFile, hdc)
+{
+  object arg;
+  HMETAFILE hmetafile;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  hmetafile = CloseMetaFile(hdc);
+  end_system_call();
+  if(NULL ==hmetafile){
+    GDI_ERROR("CloseMetaFile");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hmetafile));
+  }
+  return;
+}
+// untested - was never called
+// was disabled on older cygwin
+DEFUN( GDI:ColorMatchToTarget, hdc hdcTarget uiAction)
+/* uiAction - one of the CS_ values: CS_ENABLE, CS_DISABLE, CS_DELETE_TRANSFORM
+ */
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HDC hdcTarget;
+  DWORD uiAction;
+  uiAction = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdcTarget,arg);
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = ColorMatchToTarget(hdc,hdcTarget,uiAction);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("ColorMatchToTarget");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:CombineRgn, hrgnDest hrgnSrc1 hrgnSrc2 fnCombineMode)
+/* hrgnDest must exist before CombineRgn is called.
+   fnCombineMode - one of the RGN_ values */
+{
+  object arg;
+  int int1;
+  HRGN hrgnDest,hrgnSrc1,hrgnSrc2;
+  int fnCombineMode;
+  fnCombineMode = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  processFPTYPE(HRGN,hrgnSrc2,arg);
+  arg = popSTACK();
+  processFPTYPE(HRGN,hrgnSrc1,arg);
+  arg = popSTACK();
+  processFPTYPE(HRGN,hrgnDest,arg);
+
+  begin_system_call();
+  int1 = CombineRgn(hrgnDest,hrgnSrc1,hrgnSrc2,fnCombineMode);
+  end_system_call();
+  if(0 <=int1){
+    GDI_ERROR("CombineRgn");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int1));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:CreateCompatibleBitmap, hdc nWidth nHeight)
+{
+  object arg;
+  HBITMAP hbitmap;
+  HDC hdc;
+  int nWidth,nHeight;
+  nHeight = I_to_sint32(check_sint(popSTACK()));
+  nWidth = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  hbitmap = CreateCompatibleBitmap(hdc,nWidth,nHeight);
+  end_system_call();
+  if(NULL ==hbitmap){
+    GDI_ERROR("CreateCompatibleBitmap");
+  }
+  else
+  {
+    value1 = allocate_fpointer((FOREIGN)hbitmap);
+    /* TODO: Attach a DeleteObject finalizer to it */
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateCompatibleDC, hdc)
+{
+  object arg;
+  HDC hdc0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  hdc0 = CreateCompatibleDC(hdc);
+  end_system_call();
+  if(NULL ==hdc0){
+    GDI_ERROR("CreateCompatibleDC");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hdc0));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:CreateDIBPatternBrush, hglobal fuColorSpec)
+/* fuColorSpec - one of the DIB_ values */
+{
+  object arg;
+  HBRUSH hbrush;
+  HGLOBAL hglobal;
+  UINT fuColorSpec;
+  fuColorSpec = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  processFPTYPE(HGLOBAL,hglobal,arg);
+  begin_system_call();
+  hbrush = CreateDIBPatternBrush(hglobal,fuColorSpec);
+  end_system_call();
+  if(NULL ==hbrush){
+    GDI_ERROR("CreateDIBPatternBrush");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hbrush));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:CreateDiscardableBitmap, hdc nWidth nHeight)
+/* For Win32-based applications, use the CreateCompatibleBitmap function instead. */
+{
+  object arg;
+  HBITMAP hbitmap;
+  HDC hdc;
+  int nWidth, nHeight;
+  nHeight = I_to_sint32(check_sint(popSTACK()));
+  nWidth  = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  hbitmap = CreateDiscardableBitmap(hdc,nWidth,nHeight);
+  end_system_call();
+  if(NULL ==hbitmap){
+    GDI_ERROR("CreateDiscardableBitmap");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hbitmap));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:CreateEllipticRgn, nLeftRect nTopRect nRightRect nBottomRect)
+{
+  object arg;
+  HRGN hrgn;
+  int nLeftRect,nTopRect,nRightRect,nBottomRect;
+  nBottomRect = I_to_sint32(check_sint(popSTACK()));
+  nRightRect  = I_to_sint32(check_sint(popSTACK()));
+  nTopRect    = I_to_sint32(check_sint(popSTACK()));
+  nLeftRect   = I_to_sint32(check_sint(popSTACK()));
+  begin_system_call();
+  hrgn = CreateEllipticRgn(nLeftRect,nTopRect,nRightRect,nBottomRect);
+  end_system_call();
+  if(NULL ==hrgn){
+    GDI_ERROR("CreateEllipticRgn");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hrgn));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateHalftonePalette, hdc)
+{
+  object arg;
+  HPALETTE hpalette;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  hpalette = CreateHalftonePalette(hdc);
+  end_system_call();
+  if(NULL ==hpalette){
+    GDI_ERROR("CreateHalftonePalette");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hpalette));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:CreateHatchBrush, fnStyle colorref)
+/* fnStyle is one of HS_BDIAGONAL, HS_CROSS, HS_DIAGCROSS, HS_FDIAGONAL, HS_HORIZONTAL
+ *   HS_VERTICAL.
+ * Returns a handle to the logical brush.
+ */
+{
+  object arg;
+  HBRUSH hbrush;
+  int fnStyle;
+  COLORREF colorref;
+  colorref = processCOLORREF(popSTACK());
+  fnStyle = I_to_sint32(check_sint(popSTACK()));
+  begin_system_call();
+  hbrush = CreateHatchBrush(fnStyle,colorref);
+  end_system_call();
+  if(NULL ==hbrush){
+    GDI_ERROR("CreateHatchBrush");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hbrush));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreatePatternBrush, hbitmap)
+{
+  object arg;
+  HBRUSH hbrush;
+  HBITMAP hbitmap;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hbitmap = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hbrush = CreatePatternBrush(hbitmap);
+  end_system_call();
+  if(NULL ==hbrush){
+    GDI_ERROR("CreatePatternBrush");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hbrush));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:CreatePen, fnPenStyle nWidth colorref)
+{
+  object arg;
+  HPEN hpen;
+  int fnPenStyle, nWidth;
+  COLORREF colorref;
+  colorref = processCOLORREF(popSTACK());
+  nWidth = I_to_sint32(check_sint(popSTACK()));
+  fnPenStyle = I_to_sint32(check_sint(popSTACK()));
+  begin_system_call();
+  hpen = CreatePen(fnPenStyle, nWidth, colorref);
+  end_system_call();
+  if(NULL ==hpen){
+    GDI_ERROR("CreatePen");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hpen));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:CreateRectRgn, nLeftRect nTopRect nRightRect nBottomRect)
+{
+  object arg;
+  HRGN hrgn;
+  int nLeftRect,nTopRect,nRightRect,nBottomRect;
+  nBottomRect = I_to_sint32(check_sint(popSTACK()));
+  nRightRect  = I_to_sint32(check_sint(popSTACK()));
+  nTopRect    = I_to_sint32(check_sint(popSTACK()));
+  nLeftRect   = I_to_sint32(check_sint(popSTACK()));
+  begin_system_call();
+  hrgn = CreateRectRgn(nLeftRect,nTopRect,nRightRect,nBottomRect);
+  end_system_call();
+  if(NULL ==hrgn){
+    GDI_ERROR("CreateRectRgn");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hrgn));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateSolidBrush, colorref)
+{
+  object arg;
+  HBRUSH hbrush;
+  COLORREF colorref;
+  colorref = processCOLORREF(popSTACK());
+  begin_system_call();
+  hbrush = CreateSolidBrush(colorref);
+  end_system_call();
+  if(NULL ==hbrush){
+    GDI_ERROR("CreateSolidBrush");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hbrush));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:DeleteColorSpace, hcolorspace)
+{
+  object arg;
+  BOOL bool0;
+  HCOLORSPACE hcolorspace;
+  arg = popSTACK();
+  processFPTYPE(HCOLORSPACE,hcolorspace,arg)
+  begin_system_call();
+  bool0 = DeleteColorSpace(hcolorspace);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("DeleteColorSpace");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:DeleteDC, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = DeleteDC(hdc);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("DeleteDC");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:DeleteEnhMetaFile, henhmetafile)
+{
+  object arg;
+  BOOL bool0;
+  HENHMETAFILE henhmetafile;
+  arg = popSTACK();
+  processFPTYPE(HENHMETAFILE,henhmetafile,arg)
+  begin_system_call();
+  bool0 = DeleteEnhMetaFile(henhmetafile);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("DeleteEnhMetaFile");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:DeleteMetaFile, hmetafile)
+{
+  object arg;
+  BOOL bool0;
+  HMETAFILE hmetafile;
+  arg = popSTACK();
+  processFPTYPE(HMETAFILE,hmetafile,arg)
+  begin_system_call();
+  bool0 = DeleteMetaFile(hmetafile);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("DeleteMetaFile");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:DeleteObject, hgdiobj)
+{
+  object arg;
+  BOOL bool0;
+  HGDIOBJ hgdiobj;
+  arg = popSTACK();
+  processFPTYPE(HGDIOBJ,hgdiobj,arg)
+  begin_system_call();
+  bool0 = DeleteObject(hgdiobj);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("DeleteObject");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:Ellipse, hdc nLeftRect nTopRect nRightRect nBottomRect)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int nLeftRect,nTopRect,nRightRect,nBottomRect;
+  nBottomRect = I_to_sint32(check_sint(popSTACK()));
+  nRightRect  = I_to_sint32(check_sint(popSTACK()));
+  nTopRect    = I_to_sint32(check_sint(popSTACK()));
+  nLeftRect   = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = Ellipse(hdc,nLeftRect,nTopRect,nRightRect,nBottomRect);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("Ellipse");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:EndDoc, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = EndDoc(hdc);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("EndDoc");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:EndPage, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = EndPage(hdc);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("EndPage");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:EndPath, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = EndPath(hdc);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("EndPath");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:EqualRgn, hrgn hrgn0)
+{
+  object arg;
+  BOOL bool0;
+  HRGN hrgn;
+  HRGN hrgn0;
+  processFPTYPE_fn(HRGN,hrgn0,popSTACK());
+  processFPTYPE_fn(HRGN,hrgn,popSTACK());
+  begin_system_call();
+  bool0 = EqualRgn(hrgn,hrgn0);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("EqualRgn");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:EscapeCommFunction, handle dword)
+{
+  object arg;
+  BOOL bool0;
+  HANDLE handle;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  processFPTYPE(HANDLE,handle,arg)
+  begin_system_call();
+  bool0 = EscapeCommFunction(handle,dword);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("EscapeCommFunction");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:ExcludeClipRect, hdc nLeftRect nTopRect nRightRect nBottomRect)
+{
+  object arg;
+  int int4;
+  HDC hdc;
+  int nLeftRect,nTopRect,nRightRect,nBottomRect;
+  nBottomRect = I_to_sint32(check_sint(popSTACK()));
+  nRightRect  = I_to_sint32(check_sint(popSTACK()));
+  nTopRect    = I_to_sint32(check_sint(popSTACK()));
+  nLeftRect   = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  int4 = ExcludeClipRect(hdc,nLeftRect,nTopRect,nRightRect,nBottomRect);
+  end_system_call();
+  if(0 <=int4){
+    GDI_ERROR("ExcludeClipRect");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int4));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ExtFloodFill, hdc nXStart nYStart colorref fuFillType)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int nXStart,nYStart;
+  COLORREF colorref;
+  UINT fuFillType;
+  fuFillType = I_to_uint32(check_uint(popSTACK()));
+  colorref = processCOLORREF(popSTACK());
+  nXStart = I_to_sint32(check_sint(popSTACK()));
+  nYStart = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = ExtFloodFill(hdc,nXStart,nYStart,colorref,fuFillType);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("ExtFloodFill");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:ExtSelectClipRgn, hdc hrgn fnMode)
+/* Returns the symbols as described in the MSDN docs, not 0-3 */
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  HRGN hrgn;
+  int fnMode;
+  fnMode = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  processFPTYPE(HRGN,hrgn,arg);
+  getHDC(hdc,arg);
+  begin_system_call();
+  int1 = ExtSelectClipRgn(hdc,hrgn,fnMode);
+  end_system_call();
+  if(0 <=int1) {
+      //GDI_ERROR("ExtSelectClipRgn");
+      value1 = `GDI::ERROR`; /* value 0 */
+      mv_count=1;
+  }
+  else
+  {
+    // return the constants, not the int
+    // NULLREGION, SIMPLEREGION, COMPLEXREGION
+    if (int1 == 1)
+        value1 = `GDI::NULLREGION`;
+    else if (int1 == 2)
+        value1 = `GDI::SIMPLEREGION`;
+    else if (int1 == 3)
+        value1 = `GDI::COMPLEXREGION`;
+    else
+        VALUES1(sint32_to_I(int1));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FillPath, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = FillPath(hdc);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("FillPath");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FillRgn, hdc hrgn hbrush)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  HRGN hrgn;
+  HBRUSH hbrush;
+  arg = popSTACK();
+  processFPTYPE(HBRUSH,hbrush,arg);
+  arg = popSTACK();
+  processFPTYPE(HRGN,hrgn,arg);
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = FillRgn(hdc,hrgn,hbrush);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("FillRgn");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// inspected - changed ATOM from fp to int
+DEFUN( GDI:FindAtomA, lpcstr)
+{
+  object arg;
+  ATOM atom;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    atom = FindAtomA(lpcstr);
+    end_system_call();
+    if(0 ==atom){
+        GDI_ERROR("FindAtomA");
+    }
+    else
+    {
+      VALUES1(uint32_to_I(atom));
+    }
+  });
+  return;
+}
+// untested - was never called
+// inspected - changed ATOM from fp to int
+DEFUN( GDI:FindAtomW, lpcwstr)
+{
+  object arg;
+  ATOM atom;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  atom = FindAtomW(lpcwstr);
+  end_system_call();
+  if(0 ==atom){
+    GDI_ERROR("FindAtomW");
+  }
+  else
+  {
+    VALUES1(uint32_to_I(atom));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FlattenPath, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = FlattenPath(hdc);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("FlattenPath");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FloodFill, hdc nXStart nYStart colorref)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int nXStart,nYStart;
+  COLORREF colorref;
+  colorref = processCOLORREF(popSTACK());
+  nYStart = I_to_sint32(check_sint(popSTACK()));
+  nXStart = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = FloodFill(hdc,nXStart,nYStart,colorref);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("FloodFill");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:FrameRgn, hdc hrgn hbrush nWidth nHeight)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HRGN hrgn;
+  HBRUSH hbrush;
+  int nWidth,nHeight;
+  nHeight = I_to_sint32(check_sint(popSTACK()));
+  nWidth = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  processFPTYPE(HBRUSH,hbrush,arg);
+  arg = popSTACK();
+  processFPTYPE(HRGN,hrgn,arg);
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = FrameRgn(hdc,hrgn,hbrush,nWidth,nHeight);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("FrameRgn");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GdiSetBatchLimit, dwLimit)
+{
+  object arg;
+  DWORD dword0;
+  DWORD dwLimit;
+  dwLimit = I_to_uint32(check_uint(popSTACK()));
+  begin_system_call();
+  dword0 = GdiSetBatchLimit(dwLimit);
+  end_system_call();
+  if(!dword0){
+    GDI_ERROR("GdiSetBatchLimit");
+  }
+  else
+  {
+    VALUES1(uint32_to_I(dword0));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetArcDirection, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = GetArcDirection(hdc);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("GetArcDirection");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// fixed
+// TODO: return make-rgb, resp. outputCOLORREF
+DEFUN( GDI:GetBkColor, hdc)
+{
+  object arg;
+  COLORREF colorref;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  colorref = GetBkColor(hdc);
+  end_system_call();
+  if(0 <=(int)colorref){
+    GDI_ERROR("GetBkColor");
+  }
+  else
+  {
+    VALUES1(sint32_to_I((int)colorref));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetBkMode, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = GetBkMode(hdc);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("GetBkMode");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetClipRgn, hdc hrgn)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  HRGN hrgn;
+  arg = popSTACK();
+  processFPTYPE(HRGN,hrgn,arg);
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = GetClipRgn(hdc,hrgn);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("GetClipRgn");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetColorSpace, hdc)
+{
+  object arg;
+  HANDLE handle;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  handle = GetColorSpace(hdc);
+  end_system_call();
+  if(NULL ==handle){
+    GDI_ERROR("GetColorSpace");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)handle));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetCurrentObject, hdc uint)
+{
+  object arg;
+  HGDIOBJ hgdiobj;
+  HDC hdc;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  hgdiobj = GetCurrentObject(hdc,uint);
+  end_system_call();
+  if(NULL ==hgdiobj){
+    GDI_ERROR("GetCurrentObject");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hgdiobj));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetFontLanguageInfo, hdc)
+{
+  object arg;
+  DWORD dword;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  dword = GetFontLanguageInfo(hdc);
+  end_system_call();
+  if(!dword){
+    GDI_ERROR("GetFontLanguageInfo");
+  }
+  else
+  {
+    VALUES1(uint32_to_I(dword));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetGraphicsMode, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = GetGraphicsMode(hdc);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("GetGraphicsMode");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetMapMode, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = GetMapMode(hdc);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("GetMapMode");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetMetaRgn, hdc hrgn)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  HRGN hrgn;
+  arg = popSTACK();
+  processFPTYPE(HRGN,hrgn,arg);
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = GetMetaRgn(hdc,hrgn);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("GetMetaRgn");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetNearestColor, hdc colorref)
+{
+  object arg;
+  COLORREF colorref0;
+  HDC hdc;
+  COLORREF colorref;
+  colorref = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  colorref0 = GetNearestColor(hdc,colorref);
+  end_system_call();
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetNearestPaletteIndex, hpalette colorref)
+{
+  object arg;
+  UINT uint;
+  HPALETTE hpalette;
+  COLORREF colorref;
+  colorref = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  processFPTYPE(HPALETTE,hpalette,arg);
+  begin_system_call();
+  uint = GetNearestPaletteIndex(hpalette,colorref);
+  end_system_call();
+  if(!uint){
+    GDI_ERROR("GetNearestPaletteIndex");
+  }
+  else
+  {
+    VALUES1(uint32_to_I(uint));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetObjectType, hgdiobj)
+{
+  object arg;
+  DWORD dword;
+  HGDIOBJ hgdiobj;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hgdiobj = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  dword = GetObjectType(hgdiobj);
+  end_system_call();
+  if(!dword){
+    GDI_ERROR("GetObjectType");
+  }
+  else
+  {
+    VALUES1(uint32_to_I(dword));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetPixel, hdc int0 int1)
+{
+  object arg;
+  COLORREF colorref;
+  HDC hdc;
+  int int0;
+  int int1;
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  colorref = GetPixel(hdc,int0,int1);
+  end_system_call();
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetPixelFormat, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = GetPixelFormat(hdc);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("GetPixelFormat");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetPolyFillMode, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = GetPolyFillMode(hdc);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("GetPolyFillMode");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GETROP2, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = GetROP2(hdc);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("GetROP2");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetStockObject, int0)
+{
+  object arg;
+  HGDIOBJ hgdiobj;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  begin_system_call();
+  hgdiobj = GetStockObject(int0);
+  end_system_call();
+  if(NULL ==hgdiobj){
+    GDI_ERROR("GetStockObject");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hgdiobj));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetStretchBltMode, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = GetStretchBltMode(hdc);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("GetStretchBltMode");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetSystemPaletteUse, hdc)
+{
+  object arg;
+  UINT uint;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  uint = GetSystemPaletteUse(hdc);
+  end_system_call();
+  if(!uint){
+    GDI_ERROR("GetSystemPaletteUse");
+  }
+  else
+  {
+    VALUES1(uint32_to_I(uint));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetTextAlign, hdc)
+{
+  object arg;
+  UINT uint;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  uint = GetTextAlign(hdc);
+  end_system_call();
+  if(!uint){
+    GDI_ERROR("GetTextAlign");
+  }
+  else
+  {
+    VALUES1(uint32_to_I(uint));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetTextCharacterExtra, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = GetTextCharacterExtra(hdc);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("GetTextCharacterExtra");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetTextCharset, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = GetTextCharset(hdc);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("GetTextCharset");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetTextColor, hdc)
+{
+  object arg;
+  COLORREF colorref;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  colorref = GetTextColor(hdc);
+  end_system_call();
+}
+// untested - was never called
+// inspected - changed ATOM from fp to int
+DEFUN( GDI:GlobalAddAtomA, lpcstr)
+{
+  object arg;
+  ATOM atom;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    atom = GlobalAddAtomA(lpcstr);
+  end_system_call();
+  if(0 ==atom){
+    GDI_ERROR("GlobalAddAtomA");
+    }
+    else
+    {
+      // allocate_fpointer((FOREIGN)atom);
+      VALUES1(uint32_to_I(atom));
+    }
+  });
+  return;
+}
+// untested - was never called
+// inspected - changed ATOM from fp to int
+DEFUN( GDI:GlobalAddAtomW, lpcwstr)
+{
+  object arg;
+  ATOM atom;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  atom = GlobalAddAtomW(lpcwstr);
+  end_system_call();
+  if(0 ==atom){
+    GDI_ERROR("GlobalAddAtomW");
+  }
+  else
+  {
+    //allocate_fpointer((FOREIGN)atom);
+    VALUES1(uint32_to_I(atom));
+  }
+  return;
+}
+// untested - was never called
+// inspected - changed ATOM from fp to int
+DEFUN( GDI:GlobalFindAtomA, lpcstr)
+{
+  object arg;
+  ATOM atom;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    atom = GlobalFindAtomA(lpcstr);
+  end_system_call();
+  if(0 ==atom){
+    GDI_ERROR("GlobalFindAtomA");
+    }
+    else
+    {
+      //allocate_fpointer((FOREIGN)atom);
+      VALUES1(uint32_to_I(atom));
+    }
+  });
+  return;
+}
+// untested - was never called
+// inspected - changed ATOM from fp to int
+DEFUN( GDI:GlobalFindAtomW, lpcwstr)
+{
+  object arg;
+  ATOM atom;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  atom = GlobalFindAtomW(lpcwstr);
+  end_system_call();
+  if(0 ==atom){
+    GDI_ERROR("GlobalFindAtomW");
+  }
+  else
+  {
+    //allocate_fpointer((FOREIGN)atom);
+    VALUES1(uint32_to_I(atom));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:IntersectClipRect, hdc int0 int1 int2 int3)
+{
+  object arg;
+  int int4;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  int4 = IntersectClipRect(hdc,int0,int1,int2,int3);
+  end_system_call();
+  if(0 <=int4){
+    GDI_ERROR("IntersectClipRect");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int4));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:InvertRgn, hdc hrgn)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HRGN hrgn;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = InvertRgn(hdc,hrgn);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("InvertRgn");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:LineTo, hdc int0 int1)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = LineTo(hdc,int0,int1);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("LineTo");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:LoadCursorFromFileA, lpcstr)
+{
+  object arg;
+  HCURSOR hcursor;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    hcursor = LoadCursorFromFileA(lpcstr);
+  end_system_call();
+  if(NULL ==hcursor){
+    GDI_ERROR("LoadCursorFromFileA");
+    }
+    else
+    {
+    VALUES1(allocate_fpointer((FOREIGN)hcursor));
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:LoadCursorFromFileW, lpcwstr)
+{
+  object arg;
+  HCURSOR hcursor;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  hcursor = LoadCursorFromFileW(lpcwstr);
+  end_system_call();
+  if(NULL ==hcursor){
+    GDI_ERROR("LoadCursorFromFileW");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hcursor));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:OffsetClipRgn, hdc int0 int1)
+{
+  object arg;
+  int int2;
+  HDC hdc;
+  int int0;
+  int int1;
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  int2 = OffsetClipRgn(hdc,int0,int1);
+  end_system_call();
+  if(0 <=int2){
+    GDI_ERROR("OffsetClipRgn");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int2));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:OffsetRgn, hrgn int0 int1)
+{
+  object arg;
+  int int2;
+  HRGN hrgn;
+  int int0;
+  int int1;
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int2 = OffsetRgn(hrgn,int0,int1);
+  end_system_call();
+  if(0 <=int2){
+    GDI_ERROR("OffsetRgn");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int2));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PaintRgn, hdc hrgn)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HRGN hrgn;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = PaintRgn(hdc,hrgn);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("PaintRgn");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PathToRegion, hdc)
+{
+  object arg;
+  HRGN hrgn;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  hrgn = PathToRegion(hdc);
+  end_system_call();
+  if(NULL ==hrgn){
+    GDI_ERROR("PathToRegion");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hrgn));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PlayMetaFile, hdc hmetafile)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HMETAFILE hmetafile;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hmetafile = TheFpointer(arg)->fp_pointer;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = PlayMetaFile(hdc,hmetafile);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("PlayMetaFile");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PtInRegion, hrgn int0 int1)
+{
+  object arg;
+  BOOL bool0;
+  HRGN hrgn;
+  int int0;
+  int int1;
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = PtInRegion(hrgn,int0,int1);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("PtInRegion");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PtVisible, hdc int0 int1)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = PtVisible(hdc,int0,int1);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("PtVisible");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:RealizePalette, hdc)
+{
+  object arg;
+  UINT uint;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  uint = RealizePalette(hdc);
+  end_system_call();
+  if(!uint){
+    GDI_ERROR("RealizePalette");
+  }
+  else
+  {
+    VALUES1(uint32_to_I(uint));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:Rectangle, hdc int0 int1 int2 int3)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = Rectangle(hdc,int0,int1,int2,int3);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("Rectangle");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ResizePalette, hpalette uint)
+{
+  object arg;
+  BOOL bool0;
+  HPALETTE hpalette;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hpalette = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = ResizePalette(hpalette,uint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("ResizePalette");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:RestoreDC, hdc int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = RestoreDC(hdc,int0);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("RestoreDC");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SaveDC, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = SaveDC(hdc);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("SaveDC");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SelectClipPath, hdc int0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = SelectClipPath(hdc,int0);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SelectClipPath");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SelectClipRgn, hdc hrgn)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  HRGN hrgn;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = SelectClipRgn(hdc,hrgn);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("SelectClipRgn");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// tested
+DEFUN( GDI:SelectObject, hdc hgdiobj)
+{
+  object arg;
+  HGDIOBJ hgdiobj0;
+  HDC hdc;
+  HGDIOBJ hgdiobj;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hgdiobj = TheFpointer(arg)->fp_pointer;
+  getHDC(hdc,arg);
+  begin_system_call();
+  hgdiobj0 = SelectObject(hdc,hgdiobj);
+  end_system_call();
+  if(NULL ==hgdiobj0){
+    GDI_ERROR("SelectObject");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hgdiobj0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetArcDirection, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  int1 = SetArcDirection(hdc,int0);
+  end_system_call();
+  if(0 <=int1){
+    GDI_ERROR("SetArcDirection");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int1));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetBkColor, hdc colorref)
+{
+  object arg;
+  COLORREF colorref0;
+  HDC hdc;
+  COLORREF colorref;
+  colorref = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  colorref0 = SetBkColor(hdc,colorref);
+  end_system_call();
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetBkMode, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  int1 = SetBkMode(hdc,int0);
+  end_system_call();
+  if(0 <=int1){
+    GDI_ERROR("SetBkMode");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int1));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetColorSpace, hdc hcolorspace)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HCOLORSPACE hcolorspace;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hcolorspace = TheFpointer(arg)->fp_pointer;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = SetColorSpace(hdc,hcolorspace);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetColorSpace");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetGraphicsMode, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  int1 = SetGraphicsMode(hdc,int0);
+  end_system_call();
+  if(0 <=int1){
+    GDI_ERROR("SetGraphicsMode");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int1));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetICMMode, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  int1 = SetICMMode(hdc,int0);
+  end_system_call();
+  if(0 <=int1){
+    GDI_ERROR("SetICMMode");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int1));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetMapMode, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  int1 = SetMapMode(hdc,int0);
+  end_system_call();
+  if(0 <=int1){
+    GDI_ERROR("SetMapMode");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int1));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetMapperFlags, hdc dword)
+{
+  object arg;
+  DWORD dword0;
+  HDC hdc;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  dword0 = SetMapperFlags(hdc,dword);
+  end_system_call();
+  if(!dword0){
+    GDI_ERROR("SetMapperFlags");
+  }
+  else
+  {
+    VALUES1(uint32_to_I(dword0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetMetaRgn, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = SetMetaRgn(hdc);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("SetMetaRgn");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetPolyFillMode, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  int1 = SetPolyFillMode(hdc,int0);
+  end_system_call();
+  if(0 <=int1){
+    GDI_ERROR("SetPolyFillMode");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int1));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetROP2, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  int1 = SetROP2(hdc,int0);
+  end_system_call();
+  if(0 <=int1){
+    GDI_ERROR("SetROP2");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int1));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetRectRgn, hrgn int0 int1 int2 int3)
+{
+  object arg;
+  BOOL bool0;
+  HRGN hrgn;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = SetRectRgn(hrgn,int0,int1,int2,int3);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetRectRgn");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetStretchBltMode, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  int1 = SetStretchBltMode(hdc,int0);
+  end_system_call();
+  if(0 <=int1){
+    GDI_ERROR("SetStretchBltMode");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int1));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetSystemPaletteUse, hdc uint)
+{
+  object arg;
+  UINT uint0;
+  HDC hdc;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  uint0 = SetSystemPaletteUse(hdc,uint);
+  end_system_call();
+  if(!uint0){
+    GDI_ERROR("SetSystemPaletteUse");
+  }
+  else
+  {
+    VALUES1(uint32_to_I(uint0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetTextAlign, hdc uint)
+{
+  object arg;
+  UINT uint0;
+  HDC hdc;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  uint0 = SetTextAlign(hdc,uint);
+  end_system_call();
+  if(!uint0){
+    GDI_ERROR("SetTextAlign");
+  }
+  else
+  {
+    VALUES1(uint32_to_I(uint0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetTextCharacterExtra, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  int1 = SetTextCharacterExtra(hdc,int0);
+  end_system_call();
+  if(0 <=int1){
+    GDI_ERROR("SetTextCharacterExtra");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int1));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetTextJustification, hdc int0 int1)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = SetTextJustification(hdc,int0,int1);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetTextJustification");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ShowWindow, hwnd int0)
+{
+  object arg;
+  BOOL bool0;
+  HWND hwnd;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hwnd = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = ShowWindow(hwnd,int0);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("ShowWindow");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ShowWindowAsync, hwnd int0)
+{
+  object arg;
+  BOOL bool0;
+  HWND hwnd;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hwnd = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = ShowWindowAsync(hwnd,int0);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("ShowWindowAsync");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:StartPage, hdc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = StartPage(hdc);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("StartPage");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:StrokeAndFillPath, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = StrokeAndFillPath(hdc);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("StrokeAndFillPath");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:StrokePath, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = StrokePath(hdc);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("StrokePath");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SwapBuffers, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = SwapBuffers(hdc);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SwapBuffers");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:UnrealizeObject, hgdiobj)
+{
+  object arg;
+  BOOL bool0;
+  HGDIOBJ hgdiobj;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hgdiobj = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = UnrealizeObject(hgdiobj);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("UnrealizeObject");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:UpdateColors, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = UpdateColors(hdc);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("UpdateColors");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:UpdateWindow, hwnd)
+{
+  object arg;
+  BOOL bool0;
+  HWND hwnd;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hwnd = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = UpdateWindow(hwnd);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("UpdateWindow");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:WidenPath, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = WidenPath(hdc);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("WidenPath");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
diff -burN origsrc/clisp-2.48/modules/gdi/funcs-ok.h src/clisp-2.48/modules/gdi/funcs-ok.h
--- origsrc/clisp-2.48/modules/gdi/funcs-ok.h	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/funcs-ok.h	2006-08-13 14:24:15.000000000 +0000
@@ -0,0 +1,119 @@
+int          AbortDoc(HDC);
+BOOL         AbortPath(HDC);
+ATOM         AddAtomA(LPCSTR);
+ATOM         AddAtomW(LPCWSTR);
+BOOL         BeginPath(HDC);
+BOOL         CancelDC(HDC);
+HENHMETAFILE CloseEnhMetaFile(HDC);
+BOOL         CloseFigure(HDC);
+HMETAFILE    CloseMetaFile(HDC);
+BOOL         ColorMatchToTarget(HDC,HDC,DWORD);
+int          CombineRgn(HRGN,HRGN,HRGN,int);
+HBITMAP      CreateCompatibleBitmap(HDC,int,int);
+HDC          CreateCompatibleDC(HDC);
+HBRUSH       CreateDIBPatternBrush(HGLOBAL,UINT);
+HBITMAP      CreateDiscardableBitmap(HDC,int,int);
+HRGN         CreateEllipticRgn(int,int,int,int);
+HPALETTE     CreateHalftonePalette(HDC);
+HBRUSH       CreateHatchBrush(int,COLORREF);
+HBRUSH       CreatePatternBrush(HBITMAP);
+HPEN         CreatePen(int,int,COLORREF);
+HRGN         CreateRectRgn(int,int,int,int);
+HBRUSH       CreateSolidBrush(COLORREF);
+BOOL         DeleteColorSpace(HCOLORSPACE);
+BOOL         DeleteDC(HDC);
+BOOL         DeleteEnhMetaFile(HENHMETAFILE);
+BOOL         DeleteMetaFile(HMETAFILE);
+BOOL         DeleteObject(HGDIOBJ);
+BOOL         Ellipse(HDC,int,int,int,int);
+int          EndDoc(HDC);
+int          EndPage(HDC);
+BOOL         EndPath(HDC);
+BOOL         EqualRgn(HRGN,HRGN);
+BOOL         EscapeCommFunction(HANDLE,DWORD);
+int          ExcludeClipRect(HDC,int,int,int,int);
+BOOL         ExtFloodFill(HDC,int,int,COLORREF,UINT);
+int          ExtSelectClipRgn(HDC,HRGN,int);
+BOOL         FillPath(HDC);
+int          FillRgn(HDC,HRGN,HBRUSH);
+ATOM         FindAtomA(LPCSTR);
+ATOM         FindAtomW(LPCWSTR);
+BOOL         FlattenPath(HDC);
+BOOL         FloodFill(HDC,int,int,COLORREF);
+BOOL         FrameRgn(HDC,HRGN,HBRUSH,int,int);
+DWORD        GdiSetBatchLimit(DWORD);
+int          GetArcDirection(HDC);
+COLORREF     GetBkColor(HDC);
+int          GetBkMode(HDC);
+int          GetClipRgn(HDC,HRGN);
+HANDLE       GetColorSpace(HDC);
+HGDIOBJ      GetCurrentObject(HDC,UINT);
+DWORD        GetFontLanguageInfo(HDC);
+int          GetGraphicsMode(HDC);
+int          GetMapMode(HDC);
+int          GetMetaRgn(HDC,HRGN);
+COLORREF     GetNearestColor(HDC,COLORREF);
+UINT         GetNearestPaletteIndex(HPALETTE,COLORREF);
+DWORD        GetObjectType(HGDIOBJ);
+COLORREF     GetPixel(HDC,int,int);
+int          GetPixelFormat(HDC);
+int          GetPolyFillMode(HDC);
+int          GetROP2(HDC);
+HGDIOBJ      GetStockObject(int);
+int          GetStretchBltMode(HDC);
+UINT         GetSystemPaletteUse(HDC);
+UINT         GetTextAlign(HDC);
+int          GetTextCharacterExtra(HDC);
+int          GetTextCharset(HDC);
+COLORREF     GetTextColor(HDC);
+ATOM         GlobalAddAtomA(LPCSTR);
+ATOM         GlobalAddAtomW( LPCWSTR);
+ATOM         GlobalFindAtomA(LPCSTR);
+ATOM         GlobalFindAtomW(LPCWSTR);
+int          IntersectClipRect(HDC,int,int,int,int);
+BOOL         InvertRgn(HDC,HRGN);
+BOOL         LineTo(HDC,int,int);
+HCURSOR      LoadCursorFromFileA(LPCSTR);
+HCURSOR      LoadCursorFromFileW(LPCWSTR);
+int          OffsetClipRgn(HDC,int,int);
+int          OffsetRgn(HRGN,int,int);
+BOOL         PaintRgn(HDC,HRGN);
+HRGN         PathToRegion(HDC);
+BOOL         PlayMetaFile(HDC,HMETAFILE);
+BOOL         PtInRegion(HRGN,int,int);
+BOOL         PtVisible(HDC,int,int);
+UINT         RealizePalette(HDC);
+BOOL         Rectangle(HDC,int,int,int,int);
+BOOL         ResizePalette(HPALETTE,UINT);
+BOOL         RestoreDC(HDC,int);
+int          SaveDC(HDC);
+BOOL         SelectClipPath(HDC,int);
+int          SelectClipRgn(HDC,HRGN);
+HGDIOBJ      SelectObject(HDC,HGDIOBJ);
+int          SetArcDirection(HDC,int);
+COLORREF     SetBkColor(HDC,COLORREF);
+int          SetBkMode(HDC,int);
+BOOL         SetColorSpace(HDC,HCOLORSPACE);
+int          SetGraphicsMode(HDC,int);
+int          SetICMMode(HDC,int);
+int          SetMapMode(HDC,int);
+DWORD        SetMapperFlags(HDC,DWORD);
+int          SetMetaRgn(HDC);
+int          SetPolyFillMode(HDC,int);
+int          SetROP2(HDC,int);
+BOOL         SetRectRgn(HRGN,int,int,int,int);
+int          SetStretchBltMode(HDC,int);
+UINT         SetSystemPaletteUse(HDC,UINT);
+UINT         SetTextAlign(HDC,UINT);
+int          SetTextCharacterExtra(HDC,int);
+BOOL         SetTextJustification(HDC,int,int);
+BOOL         ShowWindow(HWND,int);
+BOOL         ShowWindowAsync(HWND,int);
+int          StartPage(HDC);
+BOOL         StrokeAndFillPath(HDC);
+BOOL         StrokePath(HDC);
+BOOL         SwapBuffers(HDC);
+BOOL         UnrealizeObject(HGDIOBJ);
+BOOL         UpdateColors(HDC);
+BOOL         UpdateWindow(HWND);
+BOOL         WidenPath(HDC);
diff -burN origsrc/clisp-2.48/modules/gdi/funcs-out.c src/clisp-2.48/modules/gdi/funcs-out.c
--- origsrc/clisp-2.48/modules/gdi/funcs-out.c	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/funcs-out.c	2009-07-30 14:58:40.000000000 +0000
@@ -0,0 +1,2430 @@
+#line 2 "funcs-out.c"
+
+/* Functions that return data, therefore not T/nil as first value, but as last. 
+ * Also try to return structs as structs, not just foreign pointers. This is still work in progress
+ */
+
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CheckColorsInGamut, hdc lpaRGBQuad lpResult nCount)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  void* lpaRGBQuad;
+  void* lpResult;
+  DWORD nCount;
+  nCount = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  lpResult = &(TheSbvector(arg)->data);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  lpaRGBQuad = &(TheSbvector(arg)->data);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = CheckColorsInGamut(hdc,lpaRGBQuad,lpResult,nCount);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("CheckColorsInGamut");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// removed 1st lpxformResult arg
+DEFUN( GDI:CombineTransform, xform1 xform2)
+{
+  object arg1,arg2;
+  BOOL bool0;
+  XFORM xform1;
+  XFORM xform2;
+  XFORM *lpxform = alloca(sizeof(XFORM));
+  arg2 = popSTACK();
+  processXFORM(&xform2,arg2);
+  arg1 = popSTACK();
+  processXFORM(&xform1,arg1);
+
+  begin_system_call();
+  bool0 = CombineTransform(lpxform,&xform1,&xform2);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("CombineTransform");
+  }
+  else
+  {
+    value1 = outputXFORM(lpxform); // TODO
+    mv_count=1;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateDIBSection, hdc bitmapinfo_p uint handle dword)
+{
+  object arg;
+  HBITMAP hbitmap;
+  HDC hdc;
+  BITMAPINFO* bitmapinfo_p;// = alloca(sizeof(BITMAPINFO));
+  UINT uint;
+  void *ppvBits;
+  HANDLE handle;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  handle = (nullp(arg))?0:(TheFpointer(arg)->fp_pointer);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  processFPTYPE(BITMAPINFO*,bitmapinfo_p,arg);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  hbitmap = CreateDIBSection(hdc,bitmapinfo_p,uint,&ppvBits,handle,dword);
+  end_system_call();
+  if(NULL ==hbitmap){
+    GDI_ERROR("CreateDIBSection");
+  }
+  else
+  {
+    VALUES2(allocate_fpointer((FOREIGN)hbitmap), 
+            allocate_fpointer((FOREIGN)ppvBits));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EnumEnhMetaFile, hdc henhmetafile enhmfenumproc pvoid lpcrect)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HENHMETAFILE henhmetafile;
+  ENHMFENUMPROC enhmfenumproc;
+  void* pvoid;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  arg0 = popSTACK();
+  processFPTYPE(ENHMFENUMPROC,enhmfenumproc,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  henhmetafile = TheFpointer(arg)->fp_pointer;
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = EnumEnhMetaFile(hdc,henhmetafile,enhmfenumproc,pvoid,lpcrect);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("EnumEnhMetaFile");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EnumFontFamiliesA, hdc lpcstr fontenumproca lparam)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  LPCSTR lpcstr;
+  FONTENUMPROCA fontenumproca;
+  LPARAM lparam;
+  object arg0;
+  arg = popSTACK();
+  check_sint(arg);
+  lparam = I_to_sint32(arg);
+  arg0 = popSTACK();
+  //processFONTENUMPROCA(&fontenumproca,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    if(!fpointerp(arg))invalid_argument(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+  
+    begin_system_call();
+    int0 = EnumFontFamiliesA(hdc,lpcstr,fontenumproca,lparam);
+    end_system_call();
+    if(0 <=int0){
+      GDI_ERROR("EnumFontFamiliesA");
+    }
+    else
+    {
+      VALUES1(sint32_to_I(int0));
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EnumFontFamiliesExA, hdc plogfonta fontenumproca lparam dword)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  PLOGFONTA plogfonta;
+  FONTENUMPROCA fontenumproca;
+  LPARAM lparam;
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  lparam = I_to_sint32(check_sint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(FONTENUMPROCA,fontenumproca,arg0);
+  //processFONTENUMPROCA(&fontenumproca,arg0);
+  arg0 = popSTACK();
+  processFPTYPE(PLOGFONTA,plogfonta,arg0);
+  //processPLOGFONTA(plogfonta,arg0);
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = EnumFontFamiliesExA(hdc,plogfonta,fontenumproca,lparam,dword);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("EnumFontFamiliesExA");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EnumFontFamiliesExW, hdc plogfontw fontenumprocw lparam dword)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  PLOGFONTW plogfontw;
+  FONTENUMPROCW fontenumprocw;
+  LPARAM lparam;
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  lparam = I_to_sint32(check_sint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(FONTENUMPROCW,fontenumprocw,arg0);
+  //processFONTENUMPROCW(fontenumprocw,arg0);
+  arg0 = popSTACK();
+  processFPTYPE(PLOGFONTW,plogfontw,arg0);
+  //processPLOGFONTW(plogfontw,arg0);
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = EnumFontFamiliesExW(hdc,plogfontw,fontenumprocw,lparam,dword);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("EnumFontFamiliesExW");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EnumFontFamiliesW, hdc lpcwstr fontenumprocw lparam)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  FONTENUMPROCW fontenumprocw;
+  LPARAM lparam;
+  object arg0;
+  lparam = I_to_sint32(check_sint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(FONTENUMPROCW,fontenumprocw,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = EnumFontFamiliesW(hdc,lpcwstr,fontenumprocw,lparam);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("EnumFontFamiliesW");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EnumFontsA, hdc lpcstr fontenumproca lparam)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  LPCSTR lpcstr;
+  FONTENUMPROCA fontenumproca;
+  LPARAM lparam;
+  object arg0;
+  lparam = I_to_sint32(check_sint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(FONTENUMPROCA,fontenumproca,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    if(!fpointerp(arg))invalid_argument(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+  
+    begin_system_call();
+    int0 = EnumFontsA(hdc,lpcstr,fontenumproca,lparam);
+    end_system_call();
+    if(0 <=int0){
+      GDI_ERROR("EnumFontsA");
+    }
+    else
+    {
+      VALUES1(sint32_to_I(int0));
+    }
+  });
+  return;
+}
+// untested - was never called
+DEFUN( GDI:EnumFontsW, hdc lpcwstr fontenumprocw lparam)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  FONTENUMPROCW fontenumprocw;
+  LPARAM lparam;
+  object arg0;
+  lparam = I_to_sint32(check_sint(popSTACK()));
+  processFPTYPE(FONTENUMPROCW,fontenumprocw,popSTACK());
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = EnumFontsW(hdc,lpcwstr,fontenumprocw,lparam);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("EnumFontsW");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EnumICMProfilesA, hdc icmenumproca lparam)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  ICMENUMPROCA icmenumproca;
+  LPARAM lparam;
+  object arg0;
+  lparam = I_to_sint32(check_sint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(ICMENUMPROCA,icmenumproca,arg0);
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = EnumICMProfilesA(hdc,icmenumproca,lparam);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("EnumICMProfilesA");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EnumICMProfilesW, hdc icmenumprocw lparam)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  ICMENUMPROCW icmenumprocw;
+  LPARAM lparam;
+  object arg0;
+  lparam = I_to_sint32(check_sint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(ICMENUMPROCW,icmenumprocw,arg0);
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = EnumICMProfilesW(hdc,icmenumprocw,lparam);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("EnumICMProfilesW");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EnumMetaFile, hdc hmetafile mfenumproc lparam)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HMETAFILE hmetafile;
+  MFENUMPROC mfenumproc;
+  LPARAM lparam;
+  object arg0;
+
+  lparam = I_to_sint32(check_sint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(MFENUMPROC,mfenumproc,arg0);
+  arg = popSTACK();
+  processFPTYPE(HMETAFILE,hmetafile,arg);
+  arg = popSTACK();
+  processFPTYPE(HDC,hdc,arg);
+
+  begin_system_call();
+  bool0 = EnumMetaFile(hdc,hmetafile,mfenumproc,lparam);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("EnumMetaFile");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:EnumObjects, hdc int0 gobjenumproc lparam)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  GOBJENUMPROC gobjenumproc;
+  LPARAM lparam;
+  object arg0;
+
+  lparam = I_to_sint32(check_sint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(GOBJENUMPROC,gobjenumproc,arg0);
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  int1 = EnumObjects(hdc,int0,gobjenumproc,lparam);
+  end_system_call();
+  if(0 <=int1){
+    GDI_ERROR("EnumObjects");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+
+// untested - was never called
+/** 
+ * Retrieve the setting for the current aspect-ratio filter.
+ * The aspect ratio is the ratio formed by the width and height 
+ * of a pixel on a specified device.
+ * Returns lpAspectRatio [out]
+ */
+DEFUN( GDI:GetAspectRatioFilterEx, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  object arg0;
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = GetAspectRatioFilterEx(hdc,lpsize);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetAspectRatioFilterEx");
+  }
+  else
+  {
+    VALUES1(outputLPSIZE(lpsize));
+  }
+  return;
+}
+
+// untested - was never called
+/** 
+ * Returns: Pointer to a buffer to receive the bitmap bits 
+   and the number of copied bits. The bits are stored as an 
+   array of byte values.
+ */
+DEFUN( GDI:GetBitmapBits, hbitmap long0 pvoid)
+{
+  object arg;
+  LONG long1;
+  HBITMAP hbitmap;
+  LONG long0;
+  void* pvoid;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  arg = popSTACK();
+  check_sint(arg);
+  long0 = I_to_sint32(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hbitmap = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  long1 = GetBitmapBits(hbitmap,long0,pvoid);
+  end_system_call();
+  if(0 <=long1){
+    GDI_ERROR("GetBitmapBits");
+  }
+  else
+  {
+    value1 = allocate_fpointer((FOREIGN)pvoid);
+    value2 = sint32_to_I(long1);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetBitmapDimensionEx, hbitmap)
+{
+  object arg;
+  BOOL bool0;
+  HBITMAP hbitmap;
+  SIZE lpsize;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hbitmap = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = GetBitmapDimensionEx(hbitmap,&lpsize);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetBitmapDimensionEx");
+  }
+  else
+  {
+    pushSTACK( uint32_to_I(lpsize.cy));
+    value2 = uint32_to_I(lpsize.cx);
+    value3 = popSTACK();
+    value1 = T;
+    mv_count=3;
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetBoundsRect, hdc flags)
+{
+  object arg;
+  UINT ret;
+  HDC hdc;
+  RECT* lprect = alloca(sizeof(RECT));
+  object arg0;
+  UINT flags;
+  flags = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_named_argument(arg, "hdc");
+  hdc = TheFpointer(arg)->fp_pointer;
+
+  begin_system_call();
+  ret = GetBoundsRect(hdc,lprect,flags);
+  end_system_call();
+  if(!ret){
+    GDI_ERROR("GetBoundsRect");
+  }
+  else
+  {
+    value1 = outputRECT(lprect);
+    value2 = uint32_to_I(ret);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// removed lppoint
+DEFUN( GDI:GetBrushOrgEx, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_named_argument(arg, "hdc");
+  hdc = TheFpointer(arg)->fp_pointer;
+
+  begin_system_call();
+  bool0 = GetBrushOrgEx(hdc,lppoint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetBrushOrgEx");
+  }
+  else
+  {
+    VALUES1(outputPOINT(lppoint));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetCharABCWidthsA, hdc iFirstChar iLastChar lpabc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT iFirstChar,iLastChar;
+  ABC* lpabc = alloca(sizeof(ABC));
+  object arg0;
+  arg0 = popSTACK();
+  if(!fpointerp(arg0))invalid_argument(arg0);
+  //processABC(lpabc,arg0);
+  iLastChar = I_to_uint32(check_uint(popSTACK()));
+  iFirstChar = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_named_argument(arg, "hdc");
+  hdc = TheFpointer(arg)->fp_pointer;
+
+  begin_system_call();
+  bool0 = GetCharABCWidthsA(hdc,iFirstChar,iLastChar,lpabc);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetCharABCWidthsA");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// 
+DEFUN( GDI:GetCharABCWidthsFloatA, hdc iFirstChar iLastChar lpabcfloat)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT iFirstChar, iLastChar;
+  ABCFLOAT* lpabcfloat;
+  object arg0;
+  arg0 = popSTACK();
+  if(!fpointerp(arg0))invalid_named_argument(arg0, "lpabcfloat");
+  //processABCFLOAT(lpabcfloat,arg0);
+  iLastChar = I_to_uint32(check_uint(popSTACK()));
+  iFirstChar = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg0))invalid_named_argument(arg0, "hdc");
+  hdc = TheFpointer(arg)->fp_pointer;
+
+  begin_system_call();
+  bool0 = GetCharABCWidthsFloatA(hdc,iFirstChar,iLastChar,lpabcfloat);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetCharABCWidthsFloatA");
+  }
+  else
+  {
+    //value1 = outputABCFLOAT(lpabcfloat);
+    VALUES1(allocate_fpointer((FOREIGN)lpabcfloat));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetCharABCWidthsFloatW, hdc iFirstChar iLastChar lpabcfloat)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT iFirstChar, iLastChar;
+  ABCFLOAT* lpabcfloat;
+  object arg0;
+
+  arg0 = popSTACK();
+  //processABCFLOAT(lpabcfloat,arg0);
+  iLastChar = I_to_uint32(check_uint(popSTACK()));
+  iFirstChar = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = GetCharABCWidthsFloatW(hdc,iFirstChar,iLastChar,lpabcfloat);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetCharABCWidthsFloatW");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)lpabcfloat));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetCharABCWidthsW, hdc iFirstChar iLastChar lpabc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT iFirstChar,iLastChar;
+  ABC* lpabc = alloca(sizeof(ABC));
+  object arg0;
+
+  arg0 = popSTACK();
+  //processABC(lpabc,arg0);
+  iLastChar = I_to_uint32(check_uint(popSTACK()));
+  iFirstChar = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = GetCharABCWidthsW(hdc,iFirstChar,iLastChar,lpabc);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetCharABCWidthsW");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)lpabc));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetCharWidth32A, hdc iFirstChar iLastChar lpint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT iFirstChar, iLastChar;
+  int* lpint;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))invalid_argument(arg);
+  lpint = (int*)&(TheSbvector(arg)->data);
+  iLastChar = I_to_uint32(check_uint(popSTACK()));
+  iFirstChar = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = GetCharWidth32A(hdc,iFirstChar,iLastChar,lpint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetCharWidth32A");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetCharWidth32W, hdc uint uint0 lpint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  int* lpint;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))invalid_argument(arg);
+  lpint = (int*)&(TheSbvector(arg)->data);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = GetCharWidth32W(hdc,uint,uint0,lpint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetCharWidth32W");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetCharWidthA, hdc uint uint0 lpint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  int* lpint;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))invalid_argument(arg);
+  lpint = (int*)&(TheSbvector(arg)->data);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = GetCharWidthA(hdc,uint,uint0,lpint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetCharWidthA");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetCharWidthW, hdc uint uint0 lpint)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  int* lpint;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))invalid_argument(arg);
+  lpint = (int*)&(TheSbvector(arg)->data);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = GetCharWidthW(hdc,uint,uint0,lpint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetCharWidthW");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+
+// untested - was never called
+// removed lprect
+DEFUN( GDI:GetClientRect, hwnd)
+{
+  object arg;
+  BOOL bool0;
+  HWND hwnd;
+  RECT* lprect;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hwnd = TheFpointer(arg)->fp_pointer;
+
+  begin_call();
+  bool0 = GetClientRect(hwnd,lprect);
+  end_call();
+  if(!bool0){
+    GDI_ERROR("GetClientRect");
+  }
+  else
+  {
+    VALUES1(outputRECT(lprect));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetClipBox, hdc lprect)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  RECT* lprect = alloca(sizeof(RECT));
+  object arg0;
+  arg0 = popSTACK();
+  processRECT(lprect,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  int0 = GetClipBox(hdc,lprect);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("GetClipBox");
+  }
+  else
+  {
+    value1 = outputRECT(lprect);
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// removed lpcoloradjustment
+DEFUN( GDI:GetColorAdjustment, hdc )
+{
+  BOOL bool0;
+  HDC hdc;
+  COLORADJUSTMENT coloradjustment;
+  object arg;
+
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = GetColorAdjustment(hdc,&coloradjustment);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetColorAdjustment");
+  }
+  else
+  {
+    VALUES1(outputCOLORADJUSTMENT(&coloradjustment));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetCurrentPositionEx, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* lppoint = alloca(sizeof(POINT));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = GetCurrentPositionEx(hdc,lppoint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetCurrentPositionEx");
+
+  }
+  else
+  {
+    VALUES1(outputPOINT(lppoint));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetDCOrgEx, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* lppoint = alloca(sizeof(POINT));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = GetDCOrgEx(hdc,lppoint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetDCOrgEx");
+
+  }
+  else
+  {
+    VALUES1(outputPOINT(lppoint));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetDIBColorTable, hdc uint uint0 rgbquad_p)
+{
+  object arg;
+  UINT uint1;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  RGBQUAD* rgbquad_p;
+  object arg0;
+  arg0 = popSTACK();
+  //processRGBQUAD_C(rgbquad_p,arg0,1);
+  processFPTYPE(RGBQUAD*,rgbquad_p,arg0);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  uint1 = GetDIBColorTable(hdc,uint,uint0,rgbquad_p);
+  end_system_call();
+  if(!uint1){
+    GDI_ERROR("GetDIBColorTable");
+
+  }
+  else
+  {
+    VALUES2(allocate_fpointer(rgbquad_p),
+            uint32_to_I(uint1));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetDeviceGammaRamp, hdc pvoid)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  void* pvoid;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = GetDeviceGammaRamp(hdc,pvoid);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetDeviceGammaRamp");
+
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetEnhMetaFileA, lpcstr)
+{
+  object arg;
+  HENHMETAFILE henhmetafile;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    henhmetafile = GetEnhMetaFileA(lpcstr);
+  end_system_call();
+  if(NULL ==henhmetafile){
+    GDI_ERROR("GetEnhMetaFileA");
+
+    }
+    else
+    {
+      VALUES1(allocate_fpointer((FOREIGN)henhmetafile));
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetEnhMetaFileDescriptionA, henhmetafile uint lpstr)
+{
+  object arg;
+  UINT uint0;
+  HENHMETAFILE henhmetafile;
+  UINT uint;
+  LPSTR lpstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpstr, {
+    uint = I_to_uint32(check_uint(popSTACK()));
+    arg = popSTACK();
+    if(!fpointerp(arg))invalid_argument(arg);
+    henhmetafile = TheFpointer(arg)->fp_pointer;
+    begin_system_call();
+    uint0 = GetEnhMetaFileDescriptionA(henhmetafile,uint,lpstr);
+  end_system_call();
+  if(!uint0){
+    GDI_ERROR("GetEnhMetaFileDescriptionA");
+
+    }
+    else
+    {
+      value1 = T;
+      value2 = uint32_to_I(uint0);
+      mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetEnhMetaFileDescriptionW, henhmetafile uint lpwstr)
+{
+  object arg;
+  UINT uint0;
+  HENHMETAFILE henhmetafile;
+  UINT uint;
+  LPWSTR lpwstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpwstr = WIDECHAR(arg,encoding);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  henhmetafile = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  uint0 = GetEnhMetaFileDescriptionW(henhmetafile,uint,lpwstr);
+  end_system_call();
+  if(!uint0){
+    GDI_ERROR("GetEnhMetaFileDescriptionW");
+
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetEnhMetaFileHeader, henhmetafile uint lpenhmetaheader)
+{
+  object arg;
+  UINT uint0;
+  HENHMETAFILE henhmetafile;
+  UINT uint;
+  ENHMETAHEADER* lpenhmetaheader;// = alloca(sizeof(ENHMETAHEADER));
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(ENHMETAHEADER*,lpenhmetaheader,arg0);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  processFPTYPE(HENHMETAFILE,henhmetafile,arg);
+
+  begin_system_call();
+  uint0 = GetEnhMetaFileHeader(henhmetafile,uint,lpenhmetaheader);
+  end_system_call();
+  if(!uint0){
+    GDI_ERROR("GetEnhMetaFileHeader");
+
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+/**
+ * Retrieve optional palette entries from the specified enhanced metafile.
+ * lppaletteentry must contain the buffer to receive cEntries PALETTEENTRY structs.
+ */
+// fixed
+DEFUN( GDI:GetEnhMetaFilePaletteEntries, henhmetafile cEntries lppaletteentry)
+{
+  object arg;
+  UINT uint0;
+  HENHMETAFILE henhmetafile;
+  UINT cEntries;
+  PALETTEENTRY* lppaletteentry;
+  object arg0;
+  arg0 = popSTACK();
+  if(!fpointerp(arg0))invalid_argument(arg0);
+  lppaletteentry = TheFpointer(arg)->fp_pointer;
+  cEntries = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  henhmetafile = TheFpointer(arg)->fp_pointer;
+
+  begin_system_call();
+  uint0 = GetEnhMetaFilePaletteEntries(henhmetafile,cEntries,lppaletteentry);
+  end_system_call();
+  if(!uint0){
+    GDI_ERROR("GetEnhMetaFilePaletteEntries");
+
+  }
+  else
+  {
+    VALUES1(uint32_to_I(uint0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetEnhMetaFilePixelFormat, henhmetafile dword pixelformatdescriptor_p)
+{
+  object arg;
+  UINT uint;
+  HENHMETAFILE henhmetafile;
+  DWORD dword;
+  PIXELFORMATDESCRIPTOR* pixelformatdescriptor_p = alloca(sizeof(PIXELFORMATDESCRIPTOR));
+  object arg0;
+  arg0 = popSTACK();
+  processPIXELFORMATDESCRIPTOR(pixelformatdescriptor_p,arg0);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  henhmetafile = TheFpointer(arg)->fp_pointer;
+
+  begin_system_call();
+  uint = GetEnhMetaFilePixelFormat(henhmetafile,dword,pixelformatdescriptor_p);
+  end_system_call();
+  if(!uint){
+    GDI_ERROR("GetEnhMetaFilePixelFormat");
+
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetEnhMetaFileW, lpcwstr)
+{
+  object arg;
+  HENHMETAFILE henhmetafile;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  henhmetafile = GetEnhMetaFileW(lpcwstr);
+  end_system_call();
+  if(NULL ==henhmetafile){
+    GDI_ERROR("GetEnhMetaFileW");
+
+  }
+  else
+  {
+    
+      VALUES1(allocate_fpointer((FOREIGN)henhmetafile));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetFontData, hdc dword dword0 pvoid dword1)
+{
+  object arg;
+  DWORD dword2;
+  HDC hdc;
+  DWORD dword;
+  DWORD dword0;
+  void* pvoid;
+  DWORD dword1;
+  dword1 = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  dword0 = I_to_uint32(check_uint(popSTACK()));
+  dword = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  dword2 = GetFontData(hdc,dword,dword0,pvoid,dword1);
+  end_system_call();
+  if(!dword2){
+    GDI_ERROR("GetFontData");
+
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(dword2);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// changed to return lpdword as integer also
+DEFUN( GDI:GetICMProfileA, hdc lpdword lpstr)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  LPDWORD lpdword;
+  LPSTR lpstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpstr, {
+    arg = popSTACK();
+    if(!fpointerp(arg))invalid_argument(arg);
+    lpdword = TheFpointer(arg)->fp_pointer;
+    arg = popSTACK();
+    if(!fpointerp(arg))invalid_argument(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+    begin_system_call();
+    bool0 = GetICMProfileA(hdc,lpdword,lpstr);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetICMProfileA");
+
+    }
+    else
+    {
+      value1 = T;
+      value2 = uint32_to_I(*lpdword);
+      value3 = asciz_to_string(lpstr,encoding);
+    }
+  });
+  return;
+}
+// untested - was never called
+// requires a S16string as lpwstr
+// changed to return lpdword as integer also
+extern object allocate_s16string (uintL len);
+DEFUN( GDI:GetICMProfileW, hdc lpdword lpwstr)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  LPDWORD lpdword;
+  LPWSTR lpwstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpwstr = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  lpdword = TheFpointer(arg)->fp_pointer;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = GetICMProfileW(hdc,lpdword,lpwstr);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetICMProfileW");
+
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(*lpdword);
+    /* FIXME */
+    //value3 = allocate_s16string(lstrlenW(lpwstr));
+    //TheS16string(value3)->data = (void*)lpwstr;
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetKerningPairsA, hdc dword lpkerningpair)
+{
+  object arg;
+  DWORD dword0;
+  HDC hdc;
+  DWORD dword;
+  KERNINGPAIR* lpkerningpair;// = alloca(sizeof(KERNINGPAIR));
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(KERNINGPAIR*,lpkerningpair,arg0);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  dword0 = GetKerningPairsA(hdc,dword,lpkerningpair);
+  end_system_call();
+  if(!dword0){
+    GDI_ERROR("GetKerningPairsA");
+
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(dword0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetKerningPairsW, hdc dword lpkerningpair)
+{
+  object arg;
+  DWORD dword0;
+  HDC hdc;
+  DWORD dword;
+  KERNINGPAIR* lpkerningpair;// = alloca(sizeof(KERNINGPAIR));
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(KERNINGPAIR*,lpkerningpair,arg0);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  dword0 = GetKerningPairsW(hdc,dword,lpkerningpair);
+  end_system_call();
+  if(!dword0){
+    GDI_ERROR("GetKerningPairsW");
+
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(dword0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetLogColorSpaceA, hcolorspace lplogcolorspacea dword)
+{
+  object arg;
+  BOOL bool0;
+  HCOLORSPACE hcolorspace;
+  LOGCOLORSPACEA* lplogcolorspacea;// = alloca(sizeof(LOGCOLORSPACEA));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(LOGCOLORSPACEA*,lplogcolorspacea,arg0);
+  arg = popSTACK();
+  processFPTYPE(HCOLORSPACE,hcolorspace,arg);
+
+  begin_system_call();
+  bool0 = GetLogColorSpaceA(hcolorspace,lplogcolorspacea,dword);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetLogColorSpaceA");
+
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetLogColorSpaceW, hcolorspace lplogcolorspacew dword)
+{
+  object arg;
+  BOOL bool0;
+  HCOLORSPACE hcolorspace;
+  LOGCOLORSPACEW* lplogcolorspacew;// = alloca(sizeof(LOGCOLORSPACEW));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(LOGCOLORSPACEW*,lplogcolorspacew,arg0);
+  arg = popSTACK();
+  processFPTYPE(HCOLORSPACE,hcolorspace,arg);
+
+  begin_system_call();
+  bool0 = GetLogColorSpaceW(hcolorspace,lplogcolorspacew,dword);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetLogColorSpaceW");
+
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetMetaFileA, lpcstr)
+{
+  object arg;
+  HMETAFILE hmetafile;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    hmetafile = GetMetaFileA(lpcstr);
+  end_system_call();
+  if(NULL ==hmetafile){
+    GDI_ERROR("GetMetaFileA");
+
+    }
+    else
+    {
+      VALUES1(allocate_fpointer((FOREIGN)hmetafile));
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetMetaFileBitsEx, hmetafile uint pvoid)
+{
+  object arg;
+  UINT uint0;
+  HMETAFILE hmetafile;
+  UINT uint;
+  void* pvoid;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hmetafile = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  uint0 = GetMetaFileBitsEx(hmetafile,uint,pvoid);
+  end_system_call();
+  if(!uint0){
+    GDI_ERROR("GetMetaFileBitsEx");
+
+  }
+  else
+  {
+    value1 = T;
+    value2 = uint32_to_I(uint0);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetMetaFileW, lpcwstr)
+{
+  object arg;
+  HMETAFILE hmetafile;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  hmetafile = GetMetaFileW(lpcwstr);
+  end_system_call();
+  if(NULL ==hmetafile){
+    GDI_ERROR("GetMetaFileW");
+
+  }
+  else
+  {
+      VALUES1(allocate_fpointer((FOREIGN)hmetafile));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetObjectA, hgdiobj int0 pvoid)
+{
+  object arg;
+  int int1;
+  HGDIOBJ hgdiobj;
+  int int0;
+  void* pvoid;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hgdiobj = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int1 = GetObjectA(hgdiobj,int0,pvoid);
+  end_system_call();
+  if(0 <=int1){
+    GDI_ERROR("GetObjectA");
+
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int1));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetObjectW, hgdiobj int0 pvoid)
+{
+  object arg;
+  int int1;
+  HGDIOBJ hgdiobj;
+  int int0;
+  void* pvoid;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hgdiobj = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  int1 = GetObjectW(hgdiobj,int0,pvoid);
+  end_system_call();
+  if(0 <=int1){
+    GDI_ERROR("GetObjectW");
+
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int1));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetOutlineTextMetricsA, hdc uint lpoutlinetextmetrica)
+{
+  object arg;
+  UINT uint0;
+  HDC hdc;
+  UINT uint;
+  OUTLINETEXTMETRICA* lpoutlinetextmetrica;// = alloca(sizeof(OUTLINETEXTMETRICA));
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(OUTLINETEXTMETRICA*,lpoutlinetextmetrica,arg0);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  uint0 = GetOutlineTextMetricsA(hdc,uint,lpoutlinetextmetrica);
+  end_system_call();
+  if(!uint0){
+    GDI_ERROR("GetOutlineTextMetricsA");
+
+  }
+  else
+  {
+    VALUES1(uint32_to_I(uint0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetOutlineTextMetricsW, hdc uint lpoutlinetextmetricw)
+{
+  object arg;
+  UINT uint0;
+  HDC hdc;
+  UINT uint;
+  OUTLINETEXTMETRICW* lpoutlinetextmetricw;// = alloca(sizeof(OUTLINETEXTMETRICW));
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(OUTLINETEXTMETRICW*,lpoutlinetextmetricw,arg0);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  uint0 = GetOutlineTextMetricsW(hdc,uint,lpoutlinetextmetricw);
+  end_system_call();
+  if(!uint0){
+    GDI_ERROR("GetOutlineTextMetricsW");
+
+  }
+  else
+  {
+    VALUES1(uint32_to_I(uint0));
+  }
+  return;
+}
+// untested - was never called
+/**
+ * Retrieve a specified range of palette entries from the given logical palette.
+ * lppaletteentry must contain the buffer to receive cEntries PALETTEENTRY structs.
+ */
+// fixed
+DEFUN( GDI:GetPaletteEntries, hpalette iStartIndex cEntries lppaletteentry)
+{
+  object arg;
+  UINT uint1;
+  HPALETTE hpalette;
+  UINT iStartIndex, cEntries;
+  PALETTEENTRY* lppaletteentry;
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(PALETTEENTRY*,lppaletteentry,arg0);
+  cEntries = I_to_uint32(check_uint(popSTACK()));
+  iStartIndex = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  processFPTYPE(HPALETTE,hpalette,arg0);
+
+  begin_system_call();
+  uint1 = GetPaletteEntries(hpalette,iStartIndex,cEntries,lppaletteentry);
+  end_system_call();
+  if(!uint1){
+    GDI_ERROR("GetPaletteEntries");
+
+  }
+  else
+  {
+    VALUES1(uint32_to_I(uint1));
+  }
+  return;
+}
+// untested - was never called
+// return vector of point records?
+// See GDI:FlattenPath
+DEFUN( GDI:GetPath, hdc lppoint pbyte int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  PBYTE pbyte;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg0 = popSTACK();
+  processPBYTE(pbyte,arg0);
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  int1 = GetPath(hdc,lppoint,pbyte,int0);
+  end_system_call();
+  if(0 <=int1){
+    GDI_ERROR("GetPath");
+
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int1));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetRasterizerCaps, lprasterizer_status uint)
+{
+  object arg;
+  BOOL bool0;
+  RASTERIZER_STATUS* lprasterizer_status;// = alloca(sizeof(RASTERIZER_STATUS));
+  object arg0;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(RASTERIZER_STATUS*,lprasterizer_status,arg0);
+
+  begin_system_call();
+  bool0 = GetRasterizerCaps(lprasterizer_status,uint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetRasterizerCaps");
+
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetRegionData, hrgn dword lprgndata)
+{
+  object arg;
+  DWORD dword0;
+  HRGN hrgn;
+  DWORD dword;
+  RGNDATA* lprgndata;// = alloca(sizeof(RGNDATA));
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(RGNDATA*,lprgndata,arg0);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  processFPTYPE(HRGN,hrgn,arg0);
+
+  begin_system_call();
+  dword0 = GetRegionData(hrgn,dword,lprgndata);
+  end_system_call();
+  if(!dword0){
+    GDI_ERROR("GetRegionData");
+
+  }
+  else
+  {
+    VALUES1(uint32_to_I(dword0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetRgnBox, hrgn lprect)
+{
+  object arg;
+  int int0;
+  HRGN hrgn;
+  RECT* lprect = alloca(sizeof(RECT));
+  object arg0;
+  arg0 = popSTACK();
+  processRECT(lprect,arg0);
+  arg = popSTACK();
+  processFPTYPE(HRGN,hrgn,arg0);
+
+  begin_system_call();
+  int0 = GetRgnBox(hrgn,lprect);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("GetRgnBox");
+
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+/**
+ * Retrieves a range of palette entries from the system palette that is associated 
+ * with the specified device context.
+ *
+ * lppaletteentry must contain the buffer to receive cEntries PALETTEENTRY structs.
+ * If this parameter is C-PTR-NULL, the function returns the total number of entries 
+ * in the palette.
+ */
+DEFUN( GDI:GetSystemPaletteEntries, hdc iStartIndex cEntries lppaletteentry)
+{
+  object arg;
+  UINT uint1;
+  HDC hdc;
+  UINT iStartIndex, cEntries;
+  PALETTEENTRY* lppaletteentry;
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(PALETTEENTRY*,lppaletteentry,arg0);
+  cEntries = I_to_uint32(check_uint(popSTACK()));
+  iStartIndex = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  uint1 = GetSystemPaletteEntries(hdc,iStartIndex,cEntries,lppaletteentry);
+  end_system_call();
+  if(!uint1){
+    GDI_ERROR("GetSystemPaletteEntries");
+
+  }
+  else
+  {
+    VALUES1(uint32_to_I(uint1));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetTextCharsetInfo, hdc lpfontsignature dword)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  FONTSIGNATURE* lpfontsignature;// = alloca(sizeof(FONTSIGNATURE));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(FONTSIGNATURE*,lpfontsignature,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  int0 = GetTextCharsetInfo(hdc,lpfontsignature,dword);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("GetTextCharsetInfo");
+
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetTextExtentPoint32A, hdc lpcstr)
+{
+  object arg, arg0;
+  BOOL bool0;
+  HDC hdc;
+  LPCSTR lpcstr;
+  SIZE lpsize;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    getHDC(hdc,arg0);
+    begin_system_call();
+    bool0 = GetTextExtentPoint32A(hdc,lpcstr,Sstring_length(arg),&lpsize);
+    end_system_call();
+    if(!bool0){
+      GDI_ERROR("GetTextExtentPoint32A");
+    }
+    else
+    {
+      VALUES2(uint32_to_I(lpsize.cx), uint32_to_I(lpsize.cy));
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetTextExtentPoint32W, hdc lpcwstr)
+{
+  object arg, arg0;
+  BOOL bool0;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  SIZE lpsize;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  getHDC(hdc,arg0);
+
+  begin_system_call();
+  bool0 = GetTextExtentPoint32W(hdc,lpcwstr,Sstring_length(arg),&lpsize);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetTextExtentPoint32W");
+  }
+  else
+  {
+    VALUES2(uint32_to_I(lpsize.cx), uint32_to_I(lpsize.cy));
+  }
+  return;
+}
+/*
+// untested - was never called
+// deprecated
+DEFUN( GDI:GetTextExtentPointA, hdc lpcstr int0 lpsize)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  LPCSTR lpcstr;
+  int int0;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  object arg0;
+  arg0 = popSTACK();
+  processSIZE(lpsize,arg0);
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = GetTextExtentPointA(hdc,lpcstr,int0,lpsize);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetTextExtentPointA");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  });
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetTextExtentPointW, hdc lpcwstr int0 lpsize)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  int int0;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  object arg0;
+  arg0 = popSTACK();
+  processSIZE(lpsize,arg0);
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = GetTextExtentPointW(hdc,lpcwstr,int0,lpsize);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetTextExtentPointW");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+*/
+// untested - was never called
+DEFUN( GDI:GetTextFaceA, hdc)
+{
+  object arg;
+  int nCount;
+  HDC hdc;
+  int int0;
+  LPSTR lpstr;
+  getHDC(hdc,arg);
+  begin_system_call();
+  nCount = GetTextFaceA(hdc,0,NULL);
+  end_system_call();
+  if(0 <=nCount){
+    GDI_ERROR("GetTextFaceA");
+  }
+  else
+  {
+    lpstr = (LPSTR)alloca(nCount);
+    int0 = GetTextFaceA(hdc,nCount,lpstr);
+    end_system_call();
+    if(0 <=int0){
+      GDI_ERROR("GetTextFaceA");
+    }
+    else {
+      VALUES1(asciz_to_string(lpstr,encoding));
+    }
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetTextFaceW, hdc)
+{
+  object arg;
+  int nCount;
+  HDC hdc;
+  int int0;
+  LPWSTR lpwstr;
+  getHDC(hdc,arg);
+  begin_system_call();
+  nCount = GetTextFaceW(hdc,0,NULL);
+  end_system_call();
+  if(0 <=nCount){
+    GDI_ERROR("GetTextFaceW");
+  }
+  else
+  {
+    lpwstr = (LPWSTR)alloca(nCount);
+    int0 = GetTextFaceW(hdc,nCount,lpwstr);
+    end_system_call();
+    if(0 <=int0){
+      GDI_ERROR("GetTextFaceW");
+    }
+    else {
+      VALUES1(outputLPWSTR(lpwstr,nCount));
+    }
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetTextMetricsA, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  TEXTMETRICA textmetrica;
+  object arg0 = popSTACK();
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = GetTextMetricsA(hdc,&textmetrica);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetTextMetricsA");
+  }
+  else
+  {
+    VALUES1(outputTEXTMETRICA(&textmetrica));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetTextMetricsW, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  TEXTMETRICW textmetricw;// = alloca(sizeof(TEXTMETRICW));
+  //object arg0;
+  //arg0 = popSTACK();
+  //processTEXTMETRICW(lptextmetricw,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = GetTextMetricsW(hdc,&textmetricw);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetTextMetricsW");
+  }
+  else
+  {
+    VALUES1(outputTEXTMETRICW(&textmetricw));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetViewportExtEx, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  //object arg0;
+  //arg0 = popSTACK();
+  //processSIZE(lpsize,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = GetViewportExtEx(hdc,lpsize);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetViewportExtEx");
+
+  }
+  else
+  {
+    VALUES1(outputLPSIZE(lpsize));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetViewportOrgEx, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* lppoint = alloca(sizeof(POINT));
+  //object arg0;
+  //arg0 = popSTACK();
+  //processPOINT(lppoint,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = GetViewportOrgEx(hdc,lppoint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetViewportOrgEx");
+
+  }
+  else
+  {
+    VALUES1(outputPOINT(lppoint));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetWinMetaFileBits, henhmetafile uint lpbyte int0 hdc)
+{
+  object arg;
+  UINT uint0;
+  HENHMETAFILE henhmetafile;
+  UINT uint;
+  BYTE* lpbyte = alloca(sizeof(BYTE));
+  object arg0;
+  INT int0;
+  HDC hdc;
+  getHDC(hdc,arg);
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg0 = popSTACK();
+  processBYTE(lpbyte,arg0);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  henhmetafile = TheFpointer(arg)->fp_pointer;
+
+  begin_system_call();
+  uint0 = GetWinMetaFileBits(henhmetafile,uint,lpbyte,int0,hdc);
+  end_system_call();
+  if(!uint0){
+    GDI_ERROR("GetWinMetaFileBits");
+
+  }
+  else
+  {
+    VALUES1(uint32_to_I(uint0));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetWindowExtEx, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  //object arg0;
+  //arg0 = popSTACK();
+  //processSIZE(lpsize,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = GetWindowExtEx(hdc,lpsize);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetWindowExtEx");
+
+  }
+  else
+  {
+    VALUES1(outputLPSIZE(lpsize));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetWindowOrgEx, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  POINT* lppoint = alloca(sizeof(POINT));
+  object arg0;
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = GetWindowOrgEx(hdc,lppoint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetWindowOrgEx");
+  }
+  else
+  {
+    VALUES1(outputPOINT(lppoint));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetWorldTransform, hdc)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  XFORM* lpxform = alloca(sizeof(XFORM));
+  //object arg0;
+  //arg0 = popSTACK();
+  //processXFORM(lpxform,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = GetWorldTransform(hdc,lpxform);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetWorldTransform");
+  }
+  else
+  {
+    VALUES1(outputXFORM(lpxform));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:Escape, hdc int0 int1 lpcstr pvoid)
+{
+  object arg;
+  int int2;
+  HDC hdc;
+  int int0;
+  int int1;
+  LPCSTR lpcstr;
+  void* pvoid;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    check_sint(arg);
+    int1 = I_to_sint32(arg);
+    arg = popSTACK();
+    check_sint(arg);
+    int0 = I_to_sint32(arg);
+    arg = popSTACK();
+    if(!fpointerp(arg))invalid_argument(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+    begin_system_call();
+    int2 = Escape(hdc,int0,int1,lpcstr,pvoid);
+    end_system_call();
+    if(0 <=int2){
+      GDI_ERROR("Escape");
+    }
+    else
+    {
+      VALUES1(sint32_to_I(int2));
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+/*
+DEFUN( GDI:SetAbortProc, hdc abortproc)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  ABORTPROC abortproc;
+  arg0 = popSTACK();
+  processABORTPROC(abortproc,arg0);
+  getHDC(hdc,arg);
+  begin_system_call();
+  int0 = SetAbortProc(hdc,abortproc);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("SetAbortProc");
+
+  }
+  else
+  {
+    value1 = T;
+    value2 = sint32_to_I(int0);
+    mv_count=2;
+  }
+  return;
+}
+*/
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetCharWidthFloatA, hdc uint uint0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  UINT length;
+  FLOAT* pfloat;
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+  length = uint0 - uint + 1;
+  pfloat = alloca(sizeof(FLOAT)*length);
+  begin_system_call();
+  bool0 = GetCharWidthFloatA(hdc,uint,uint0,pfloat);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetCharWidthFloatA");
+  }
+  else
+  {
+    VALUES1(outputFLOATS(pfloat,length));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetCharWidthFloatW, hdc uint uint0 pfloat)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  FLOAT* pfloat;
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+  pfloat = alloca(sizeof(FLOAT)*(uint0 - uint + 1));
+  begin_system_call();
+  bool0 = GetCharWidthFloatW(hdc,uint,uint0,pfloat);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetCharWidthFloatW");
+  }
+  else
+  {
+    VALUES1(outputFLOATS(pfloat,0));
+  }
+  return;
+}
+
+//extern object allocate_ffloat (ffloat value);
+
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetMiterLimit, hdc pfloat)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  FLOAT pfloat;
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = GetMiterLimit(hdc,&pfloat);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetMiterLimit");
+  }
+  else
+  {
+    VALUES1(allocate_ffloat(pfloat));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetMiterLimit, hdc float0)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  FLOAT float0;
+  FLOAT pfloat;
+  ffloatjanus jfloat0;
+  FF_to_c_float(check_ffloat(popSTACK()),&jfloat0);
+  float0 = (float)(jfloat0.eksplicit);
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = SetMiterLimit(hdc,float0,&pfloat);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetMiterLimit");
+  }
+  else
+  {
+    VALUES1(allocate_ffloat(pfloat));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:LineDDA, lppoint lppoint0 lineddaproc lparam)
+{
+  object arg;
+  BOOL bool0;
+  POINT point;
+  POINT point0;
+  LINEDDAPROC lineddaproc;
+  LPARAM lparam;
+  arg = popSTACK();
+  check_sint(arg);
+  lparam = (LPARAM)I_to_sint32(arg);
+  arg = popSTACK();
+  processFPTYPE(LINEDDAPROC,lineddaproc,arg);
+  arg = popSTACK();
+  processPOINT(&point0,arg);
+  arg = popSTACK();
+  processPOINT(&point,arg);
+  begin_system_call();
+  bool0 = LineDDA(point.x,point.y,point0.x,point0.y,lineddaproc,lparam);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("LineDDA");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// Not implemented in Windows NT
+/*
+DEFUN( GDI:TranslateCharsetInfo, dword_p lpcharsetinfo dword)
+{
+  object arg;
+  BOOL bool0;
+  DWORD* dword_p;
+  HARSETINFO* lpcharsetinfo = alloca(sizeof(CHARSETINFO));
+  object arg0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processCHARSETINFO(lpcharsetinfo,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))invalid_argument(arg);
+  dword_p = (DWORD*)&(TheSbvector(arg)->data);
+
+  begin_system_call();
+  bool0 = TranslateCharsetInfo(dword_p,lpcharsetinfo,dword);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("TranslateCharsetInfo");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+*/
diff -burN origsrc/clisp-2.48/modules/gdi/funcs-out.h src/clisp-2.48/modules/gdi/funcs-out.h
--- origsrc/clisp-2.48/modules/gdi/funcs-out.h	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/funcs-out.h	2006-08-13 14:24:15.000000000 +0000
@@ -0,0 +1,84 @@
+BOOL         CheckColorsInGamut(HDC,PVOID,PVOID,DWORD);
+BOOL         CombineTransform(LPXFORM, XFORM_P, XFORM_P);
+HBITMAP      CreateDIBSection(HDC, BITMAPINFO_P,UINT,HANDLE,DWORD);
+BOOL         EnumEnhMetaFile(HDC,HENHMETAFILE,ENHMFENUMPROC,PVOID,LPCRECT);
+int          EnumFontFamiliesA(HDC,LPCSTR,FONTENUMPROCA,LPARAM);
+int          EnumFontFamiliesExA(HDC,PLOGFONTA,FONTENUMPROCA,LPARAM,DWORD);
+int          EnumFontFamiliesExW(HDC,PLOGFONTW,FONTENUMPROCW,LPARAM,DWORD);
+int          EnumFontFamiliesW(HDC,LPCWSTR,FONTENUMPROCW,LPARAM);
+int          EnumFontsA(HDC,LPCSTR,FONTENUMPROCA,LPARAM);
+int          EnumFontsW(HDC,LPCWSTR,FONTENUMPROCA,LPARAM);
+int          EnumICMProfilesA(HDC,ICMENUMPROCA,LPARAM);
+int          EnumICMProfilesW(HDC,ICMENUMPROCW,LPARAM);
+BOOL         EnumMetaFile(HDC,HMETAFILE,MFENUMPROC,LPARAM);
+int          EnumObjects(HDC,int,GOBJENUMPROC,LPARAM);
+BOOL         GetAspectRatioFilterEx(HDC,LPSIZE);
+LONG         GetBitmapBits(HBITMAP,LONG,PVOID);
+BOOL         GetBitmapDimensionEx(HBITMAP,LPSIZE);
+UINT         GetBoundsRect(HDC,LPRECT,UINT);
+BOOL         GetBrushOrgEx(HDC,LPPOINT);
+BOOL         GetCharABCWidthsA(HDC,UINT,UINT,LPABC);
+BOOL         GetCharABCWidthsFloatA(HDC,UINT,UINT,LPABCFLOAT);
+BOOL         GetCharABCWidthsFloatW(HDC,UINT,UINT,LPABCFLOAT);
+BOOL         GetCharABCWidthsW(HDC,UINT,UINT,LPABC);
+BOOL         GetCharWidth32A(HDC,UINT,UINT,LPINT);
+BOOL         GetCharWidth32W(HDC,UINT,UINT,LPINT);
+BOOL         GetCharWidthA(HDC,UINT,UINT,LPINT);
+BOOL         GetCharWidthW(HDC,UINT,UINT,LPINT);
+BOOL         GetClientRect(HWND,LPRECT);
+int          GetClipBox(HDC,LPRECT);
+BOOL         GetColorAdjustment(HDC,LPCOLORADJUSTMENT);
+BOOL         GetCurrentPositionEx(HDC,LPPOINT);
+BOOL         GetDCOrgEx(HDC,LPPOINT);
+UINT         GetDIBColorTable(HDC,UINT,UINT,RGBQUAD_P);
+BOOL         GetDeviceGammaRamp(HDC,PVOID);
+HENHMETAFILE GetEnhMetaFileA(LPCSTR);
+UINT         GetEnhMetaFileDescriptionA(HENHMETAFILE,UINT,LPSTR);
+UINT         GetEnhMetaFileDescriptionW(HENHMETAFILE,UINT,LPWSTR);
+UINT         GetEnhMetaFileHeader(HENHMETAFILE,UINT,LPENHMETAHEADER);
+UINT         GetEnhMetaFilePaletteEntries(HENHMETAFILE,UINT,LPPALETTEENTRY);
+UINT         GetEnhMetaFilePixelFormat(HENHMETAFILE,DWORD,PIXELFORMATDESCRIPTOR_P);
+HENHMETAFILE GetEnhMetaFileW(LPCWSTR);
+DWORD        GetFontData(HDC,DWORD,DWORD,PVOID,DWORD);
+BOOL         GetICMProfileA(HDC,DWORD,LPSTR);
+BOOL         GetICMProfileW(HDC,DWORD,LPWSTR);
+DWORD        GetKerningPairsA(HDC,DWORD,LPKERNINGPAIR);
+DWORD        GetKerningPairsW(HDC,DWORD,LPKERNINGPAIR);
+BOOL         GetLogColorSpaceA(HCOLORSPACE,LPLOGCOLORSPACEA,DWORD);
+BOOL         GetLogColorSpaceW(HCOLORSPACE,LPLOGCOLORSPACEW,DWORD);
+HMETAFILE    GetMetaFileA(LPCSTR);
+UINT         GetMetaFileBitsEx(HMETAFILE,UINT,PVOID);
+HMETAFILE    GetMetaFileW(LPCWSTR);
+int          GetObjectA(HGDIOBJ,int,PVOID);
+int          GetObjectW(HGDIOBJ,int,PVOID);
+UINT         GetOutlineTextMetricsA(HDC,UINT,LPOUTLINETEXTMETRICA);
+UINT         GetOutlineTextMetricsW(HDC,UINT,LPOUTLINETEXTMETRICW);
+UINT         GetPaletteEntries(HPALETTE,UINT,UINT,LPPALETTEENTRY);
+int          GetPath(HDC,LPPOINT,PBYTE,int);
+BOOL         GetRasterizerCaps(LPRASTERIZER_STATUS,UINT);
+DWORD        GetRegionData(HRGN,DWORD,LPRGNDATA);
+int          GetRgnBox(HRGN,LPRECT);
+UINT         GetSystemPaletteEntries(HDC,UINT,UINT,LPPALETTEENTRY);
+int          GetTextCharsetInfo(HDC,LPFONTSIGNATURE,DWORD);
+BOOL         GetTextExtentPoint32A(HDC,LPCSTR,int,LPSIZE);
+BOOL         GetTextExtentPoint32W( HDC,LPCWSTR,int,LPSIZE);
+BOOL         GetTextExtentPointA(HDC,LPCSTR,int,LPSIZE);
+BOOL         GetTextExtentPointW(HDC,LPCWSTR,int,LPSIZE);
+int          GetTextFaceA(HDC,int,LPSTR);
+int          GetTextFaceW(HDC,int,LPWSTR);
+BOOL         GetTextMetricsA(HDC,LPTEXTMETRICA);
+BOOL         GetTextMetricsW(HDC,LPTEXTMETRICW);
+BOOL         GetViewportExtEx(HDC,LPSIZE);
+BOOL         GetViewportOrgEx(HDC,LPPOINT);
+UINT         GetWinMetaFileBits(HENHMETAFILE,UINT,LPBYTE,INT,HDC);
+BOOL         GetWindowExtEx(HDC,LPSIZE);
+BOOL         GetWindowOrgEx(HDC,LPPOINT);
+BOOL         GetWorldTransform(HDC,LPXFORM);
+int          Escape(HDC,int,int,LPCSTR,PVOID);
+int          SetAbortProc(HDC,ABORTPROC);
+BOOL         GetCharWidthFloatA(HDC,UINT,UINT,PFLOAT);
+BOOL         GetCharWidthFloatW(HDC,UINT,UINT,PFLOAT);
+BOOL         GetMiterLimit(HDC,PFLOAT);
+BOOL         SetMiterLimit(HDC,FLOAT,PFLOAT);
+BOOL         LineDDA(LPPOINT,LPPOINT,LINEDDAPROC,LPARAM);
+BOOL         TranslateCharsetInfo(DWORD_P,LPCHARSETINFO,DWORD);
diff -burN origsrc/clisp-2.48/modules/gdi/funcs-prob.c src/clisp-2.48/modules/gdi/funcs-prob.c
--- origsrc/clisp-2.48/modules/gdi/funcs-prob.c	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/funcs-prob.c	2009-07-30 14:39:12.000000000 +0000
@@ -0,0 +1,1604 @@
+#line 2 "funcs-prob.c"
+
+/* functions that have been hand edited */
+
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:AddFontResourceA, lpcstr)
+{
+  object arg;
+  int int0;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    int0 = AddFontResourceA(lpcstr);
+    end_system_call();
+    if(0 <=int0){
+      GDI_ERROR("AddFontResourceA");
+    }
+    else
+    {
+      VALUES1(sint32_to_I(int0));
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:AddFontResourceW, lpcwstr)
+{
+  object arg;
+  int int0;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  int0 = AddFontResourceW(lpcwstr);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("AddFontResourceW");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CopyEnhMetaFileA, henhmetafile lpcstr)
+{
+  object arg;
+  HENHMETAFILE henhmetafile0;
+  HENHMETAFILE henhmetafile;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    if(!fpointerp(arg))invalid_argument(arg);
+    henhmetafile = TheFpointer(arg)->fp_pointer;
+    begin_system_call();
+    henhmetafile0 = CopyEnhMetaFileA(henhmetafile,lpcstr);
+    end_system_call();
+    if(NULL ==henhmetafile0){
+      GDI_ERROR("CopyEnhMetaFileA");
+    }
+    else
+    {
+      VALUES1(allocate_fpointer((FOREIGN)henhmetafile0));
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CopyEnhMetaFileW, henhmetafile lpcwstr)
+{
+  object arg;
+  HENHMETAFILE henhmetafile0;
+  HENHMETAFILE henhmetafile;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = 0; //WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  henhmetafile = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  henhmetafile0 = CopyEnhMetaFileW(henhmetafile,lpcwstr);
+  end_system_call();
+  if(NULL ==henhmetafile0){
+    GDI_ERROR("CopyEnhMetaFileW");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)henhmetafile0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CopyMetaFileA, hmetafile lpcstr)
+{
+  object arg;
+  HMETAFILE hmetafile0;
+  HMETAFILE hmetafile;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    if(!fpointerp(arg))invalid_argument(arg);
+    hmetafile = TheFpointer(arg)->fp_pointer;
+    begin_system_call();
+    hmetafile0 = CopyMetaFileA(hmetafile,lpcstr);
+    end_system_call();
+    if(NULL ==hmetafile0){
+      GDI_ERROR("CopyMetaFileA");
+    }
+    else
+    {
+      VALUES1(allocate_fpointer((FOREIGN)hmetafile0));
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CopyMetaFileW, hmetafile lpcwstr)
+{
+  object arg;
+  HMETAFILE hmetafile0;
+  HMETAFILE hmetafile;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hmetafile = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hmetafile0 = CopyMetaFileW(hmetafile,lpcwstr);
+  end_system_call();
+  if(NULL ==hmetafile0){
+    GDI_ERROR("CopyMetaFileW");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hmetafile0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateBitmapIndirect, bitmap_p)
+{
+  object arg;
+  HBITMAP hbitmap;
+  BITMAP* bitmap_p = alloca(sizeof(BITMAP));
+  object arg0;
+  arg0 = popSTACK();
+  processBITMAP(bitmap_p,arg0);
+  begin_system_call();
+  hbitmap = CreateBitmapIndirect(bitmap_p);
+  end_system_call();
+  if(NULL ==hbitmap){
+    GDI_ERROR("CreateBitmapIndirect");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hbitmap));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateBrushIndirect, logbrush_p)
+{
+  object arg;
+  HBRUSH hbrush;
+  LOGBRUSH* logbrush_p = alloca(sizeof(LOGBRUSH));
+  object arg0;
+  arg0 = popSTACK();
+  processLOGBRUSH(logbrush_p,arg0);
+  begin_system_call();
+  hbrush = CreateBrushIndirect(logbrush_p);
+  end_system_call();
+  if(NULL ==hbrush){
+    GDI_ERROR("CreateBrushIndirect");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hbrush));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateColorSpaceA, lplogcolorspacea)
+{
+  object arg;
+  HCOLORSPACE hcolorspace;
+  LOGCOLORSPACEA* lplogcolorspacea;
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(LOGCOLORSPACEA*,lplogcolorspacea,arg0);
+  begin_system_call();
+  hcolorspace = CreateColorSpaceA(lplogcolorspacea);
+  end_system_call();
+  if(NULL ==hcolorspace){
+    GDI_ERROR("CreateColorSpaceA");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hcolorspace));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateColorSpaceW, lplogcolorspacew)
+{
+  object arg;
+  HCOLORSPACE hcolorspace;
+  LOGCOLORSPACEW* lplogcolorspacew;
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(LOGCOLORSPACEW*,lplogcolorspacew,arg0);
+  begin_system_call();
+  hcolorspace = CreateColorSpaceW(lplogcolorspacew);
+  end_system_call();
+  if(NULL ==hcolorspace){
+    GDI_ERROR("CreateColorSpaceW");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hcolorspace));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateDCA, lpcstr lpcstr0 lpcstr1 devmodea_p)
+{
+  object arg;
+  HDC hdc;
+  LPCSTR lpcstr;
+  LPCSTR lpcstr0;
+  LPCSTR lpcstr1;
+  DEVMODEA* devmodea_p;
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(DEVMODEA*,devmodea_p,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr1, {
+    arg = popSTACK();
+    if(!stringp(arg))invalid_argument(arg);
+    with_string_0(arg,encoding, lpcstr0, {
+      arg = popSTACK();
+      if(!stringp(arg))invalid_argument(arg);
+      with_string_0(arg,encoding, lpcstr, {
+        processFPTYPE(DEVMODEA*,devmodea_p,arg0);
+        begin_system_call();
+        hdc = CreateDCA(lpcstr,lpcstr0,lpcstr1,devmodea_p);
+        end_system_call();
+        if(NULL ==hdc){
+          GDI_ERROR("CreateDCA");
+        }
+        else
+        {
+          VALUES1(allocate_fpointer((FOREIGN)hdc));
+        }
+      });
+    });
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateDCW, lpcwstr lpcwstr0 lpcwstr1 devmodew_p)
+{
+  object arg;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  LPCWSTR lpcwstr0;
+  LPCWSTR lpcwstr1;
+  DEVMODEW* devmodew_p;
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(DEVMODEW*,devmodew_p,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr1 = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr0 = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+
+  begin_system_call();
+  hdc = CreateDCW(lpcwstr,lpcwstr0,lpcwstr1,devmodew_p);
+  end_system_call();
+  if(NULL ==hdc){
+    GDI_ERROR("CreateDCW");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hdc));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateEllipticRgnIndirect, lpcrect)
+{
+  object arg;
+  HRGN hrgn;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  begin_system_call();
+  hrgn = CreateEllipticRgnIndirect(lpcrect);
+  end_system_call();
+  if(NULL ==hrgn){
+    GDI_ERROR("CreateEllipticRgnIndirect");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hrgn));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateEnhMetaFileA, hdc lpcstr lpcrect lpcstr0)
+{
+  object arg;
+  HDC hdc0;
+  HDC hdc;
+  LPCSTR lpcstr;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  LPCSTR lpcstr0;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr0, {
+    arg0 = popSTACK();
+    processRECT(lpcrect,arg0);
+    arg = popSTACK();
+    if(!stringp(arg))invalid_argument(arg);
+    with_string_0(arg,encoding, lpcstr, {
+      arg = popSTACK();
+      if(!fpointerp(arg))invalid_argument(arg);
+      hdc = TheFpointer(arg)->fp_pointer;
+      processRECT(lpcrect,arg0);
+      begin_system_call();
+      hdc0 = CreateEnhMetaFileA(hdc,lpcstr,lpcrect,lpcstr0);
+      end_system_call();
+      if(NULL ==hdc0){
+        GDI_ERROR("CreateEnhMetaFileA");
+      }
+      else
+      {
+        VALUES1(allocate_fpointer((FOREIGN)hdc0));
+      }
+    });
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateEnhMetaFileW, hdc lpcwstr lpcrect lpcwstr0)
+{
+  object arg;
+  HDC hdc0;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  LPCWSTR lpcwstr0;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr0 = WIDECHAR(arg,encoding);
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  hdc0 = CreateEnhMetaFileW(hdc,lpcwstr,lpcrect,lpcwstr0);
+  end_system_call();
+  if(NULL ==hdc0){
+    GDI_ERROR("CreateEnhMetaFileW");
+  }
+  else
+  {
+    
+      VALUES1(allocate_fpointer((FOREIGN)hdc0));
+  }
+  return;
+}
+// tested in p1.lisp
+DEFUN( GDI:CreateFontIndirectA, logfonta_p)
+{
+  object arg;
+  HFONT hfont;
+  LOGFONTA* logfonta_p = alloca(sizeof(LOGFONTA));
+  object arg0;
+  arg0 = popSTACK();
+  processLOGFONTA(logfonta_p,arg0);
+  begin_system_call();
+  hfont = CreateFontIndirectA(logfonta_p);
+  end_system_call();
+  if(NULL ==hfont){
+    GDI_ERROR("CreateFontIndirectA");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hfont));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateFontIndirectW, logfontw_p)
+{
+  object arg;
+  HFONT hfont;
+  LOGFONTW* logfontw_p = alloca(sizeof(LOGFONTW));
+  object arg0;
+  arg0 = popSTACK();
+  processLOGFONTW(logfontw_p,arg0);
+  begin_system_call();
+  hfont = CreateFontIndirectW(logfontw_p);
+  end_system_call();
+  if(NULL ==hfont){
+    GDI_ERROR("CreateFontIndirectW");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hfont));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateICA, lpcstr lpcstr0 lpcstr1 devmodea_p)
+{
+  object arg;
+  HDC hdc;
+  LPCSTR lpcstr;
+  LPCSTR lpcstr0;
+  LPCSTR lpcstr1;
+  DEVMODEA* devmodea_p;
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(DEVMODEA*,devmodea_p,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr1, {
+    arg = popSTACK();
+    if(!stringp(arg))invalid_argument(arg);
+    with_string_0(arg,encoding, lpcstr0, {
+      arg = popSTACK();
+      if(!stringp(arg))invalid_argument(arg);
+      with_string_0(arg,encoding, lpcstr, {
+        processFPTYPE(DEVMODEA*,devmodea_p,arg0);
+        begin_system_call();
+        hdc = CreateICA(lpcstr,lpcstr0,lpcstr1,devmodea_p);
+        end_system_call();
+        if(NULL ==hdc){
+            GDI_ERROR("CreateICA");
+        }
+        else
+        {
+          VALUES1(allocate_fpointer((FOREIGN)hdc));
+        }
+      });
+    });
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateICW, lpcwstr lpcwstr0 lpcwstr1 devmodew_p)
+{
+  object arg;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  LPCWSTR lpcwstr0;
+  LPCWSTR lpcwstr1;
+  DEVMODEW* devmodew_p;
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(DEVMODEW*,devmodew_p,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr1 = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr0 = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+
+  begin_system_call();
+  hdc = CreateICW(lpcwstr,lpcwstr0,lpcwstr1,devmodew_p);
+  end_system_call();
+  if(NULL ==hdc){
+    GDI_ERROR("CreateICW");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hdc));
+  }
+  return;
+}
+// untested - was never called
+/**
+ * presbits - Buffer containing the icon or cursor resource bits. 
+ *          These bits are typically loaded by calls to the LookupIconIdFromDirectory 
+ *          (in Windows 95 you can also call LookupIconIdFromDirectoryEx) and 
+ *          LoadResource functions. 
+ * The return value is the foreign-pointer to the handle to the icon or cursor.
+ */
+DEFUN( GDI:CreateIconFromResource, presbits dwResSize fIcon dwVer)
+{
+  object arg;
+  object arg0;
+  HICON hicon;
+  PBYTE presbits;
+  DWORD dwResSize;
+  BOOL fIcon;
+  DWORD dwVer;
+  dwVer = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processBOOL(&fIcon,arg0);
+  dwResSize = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  processPBYTE(presbits,arg); // TODO
+
+  begin_system_call();
+  hicon = CreateIconFromResource(presbits,dwResSize,fIcon,dwVer);
+  end_system_call();
+  if(NULL ==hicon){
+    GDI_ERROR("CreateIconFromResource");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hicon));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateIconIndirect, piconinfo)
+{
+  object arg;
+  HICON hicon;
+  ICONINFO iconinfo;
+  arg = popSTACK();
+  processICONINFO(&iconinfo,arg);
+  begin_system_call();
+  hicon = CreateIconIndirect(&iconinfo);
+  end_system_call();
+  if(NULL ==hicon){
+    GDI_ERROR("CreateIconIndirect");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hicon));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateMetaFileA, lpcstr)
+{
+  object arg;
+  HDC hdc;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    hdc = CreateMetaFileA(lpcstr);
+    end_system_call();
+    if(NULL ==hdc){
+      GDI_ERROR("CreateMetaFileA");
+    }
+    else
+    {
+      VALUES1(allocate_fpointer((FOREIGN)hdc));
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateMetaFileW, lpcwstr)
+{
+  object arg;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  hdc = CreateMetaFileW(lpcwstr);
+  end_system_call();
+  if(NULL ==hdc){
+    GDI_ERROR("CreateMetaFileW");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hdc));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreatePalette, logpalette_p)
+{
+  object arg;
+  HPALETTE hpalette;
+  LOGPALETTE* logpalette_p;
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(LOGPALETTE*,logpalette_p,arg0);
+
+  begin_system_call();
+  hpalette = CreatePalette(logpalette_p);
+  end_system_call();
+  if(NULL ==hpalette){
+    GDI_ERROR("CreatePalette");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hpalette));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreatePenIndirect, logpen_p)
+{
+  object arg;
+  HPEN hpen;
+  LOGPEN* logpen_p;
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(LOGPEN*,logpen_p,arg0);
+
+  begin_system_call();
+  hpen = CreatePenIndirect(logpen_p);
+  end_system_call();
+  if(NULL ==hpen){
+    GDI_ERROR("CreatePenIndirect");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hpen));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateRectRgnIndirect, lpcrect)
+{
+  object arg;
+  HRGN hrgn;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+
+  begin_system_call();
+  hrgn = CreateRectRgnIndirect(lpcrect);
+  end_system_call();
+  if(NULL ==hrgn){
+    GDI_ERROR("CreateRectRgnIndirect");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hrgn));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateWindowIndirectA, cs)
+{
+  object arg;
+  HWND hwnd;
+  CREATESTRUCT* p = alloca(sizeof(CREATESTRUCT));
+  object arg0;
+//asm("int3");
+  arg0 = popSTACK();
+  processCREATESTRUCTA(p,arg0);
+  begin_system_call();
+  hwnd = CreateWindowEx(p->dwExStyle, p->lpszClass, p->lpszName, p->style,
+    p->x, p->y, p->cx, p->cy, p->hwndParent, p->hMenu, p->hInstance,
+    p->lpCreateParams);
+  end_system_call();
+  if(NULL ==hwnd){
+    GDI_ERROR("CreateWindowEx");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hwnd));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FillRect, hdc lpcrect hbrush)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  HBRUSH hbrush;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hbrush = TheFpointer(arg)->fp_pointer;
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = FillRect(hdc,lpcrect,hbrush);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("FillRect");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+DEFUN(GDI:GetDC, hwnd)
+{
+  object arg = popSTACK();
+  DWORD e = 0;
+  HWND h = (nullp(arg))?0:(TheFpointer(arg)->fp_pointer);
+  HDC h0;
+  begin_system_call();
+  h0 = GetDC(h);
+  end_system_call();
+  if(NULL == h0){
+    GDI_ERROR("GetDC");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)h0));
+  }
+  return;
+}
+// Nothing in the docs indicates that this function can return a error code.
+// tested ok
+DEFUN( GDI:GetDeviceCaps, hdc int0)
+{
+  object arg;
+  int int1;
+  HDC hdc;
+  int int0;
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  int1 = GetDeviceCaps(hdc,int0);
+  end_system_call();
+  if(int1 <= 0){
+    GDI_ERROR("GetDeviceCaps");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int1));
+  }
+  return;
+}
+// tested
+DEFUN( GDI:GetSystemMetrics, int0)
+{
+  object arg;
+  int int1;
+  int int0;
+  arg = popSTACK();
+  int0 = I_to_sint32(arg);
+  begin_system_call();
+  int1 = GetSystemMetrics(int0);
+  end_system_call();
+  VALUES1(sint32_to_I(int1));
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:LoadCursorA, hinstance lpcstr)
+{
+  object arg;
+  HCURSOR hcursor;
+  HINSTANCE hinstance;
+  void* lpcstr;
+  arg = popSTACK();
+
+  if(stringp(arg))
+  {
+     lpcstr = TheAsciz(string_to_asciz(arg,encoding));
+  }
+  else if(fpointerp(arg))
+  {
+     lpcstr = TheFpointer(arg)->fp_pointer;
+  }
+  else invalid_argument(arg);
+  arg = popSTACK();
+  if(nullp(arg))
+  {
+     hinstance = NULL;
+  }
+  else if(fpointerp(arg))
+  {
+     hinstance = TheFpointer(arg)->fp_pointer;
+  }
+  else invalid_argument(arg);
+  begin_system_call();
+  hcursor = LoadCursorA(hinstance,lpcstr);
+  end_system_call();
+  if(NULL ==hcursor){
+    GDI_ERROR("LoadCursorA");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hcursor));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:LoadCursorW, hinstance lpcwstr)
+{
+  object arg;
+  HCURSOR hcursor;
+  HINSTANCE hinstance;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hinstance = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hcursor = LoadCursorW(hinstance,lpcwstr);
+  end_system_call();
+  if(NULL ==hcursor){
+    GDI_ERROR("LoadCursorW");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hcursor));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PlayEnhMetaFile, hdc henhmetafile lpcrect)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  HENHMETAFILE henhmetafile;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  henhmetafile = TheFpointer(arg)->fp_pointer;
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = PlayEnhMetaFile(hdc,henhmetafile,lpcrect);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("PlayEnhMetaFile");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:RectInRegion, hrgn lpcrect)
+{
+  object arg;
+  BOOL bool0;
+  HRGN hrgn;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hrgn = TheFpointer(arg)->fp_pointer;
+
+  begin_system_call();
+  bool0 = RectInRegion(hrgn,lpcrect);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("RectInRegion");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:RectVisible, hdc lpcrect)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = RectVisible(hdc,lpcrect);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("RectVisible");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// inspected - changed ATOM from fp to int
+DEFUN( GDI:RegisterClassA, wndclassa_p)
+{
+  object arg;
+  ATOM atom;
+  WNDCLASSA* wndclassa_p = alloca(sizeof(WNDCLASSA));
+  object arg0;
+  arg0 = popSTACK();
+//asm("int3");
+  processWNDCLASSA(wndclassa_p,arg0);
+  begin_system_call();
+  atom = RegisterClassA(wndclassa_p);
+  end_system_call();
+  if(!atom){
+    GDI_ERROR("RegisterClassA");
+  }
+  else
+  {
+    //value1 = allocate_fpointer((FOREIGN)atom);
+    VALUES1(uint32_to_I(atom));
+  }
+  return;
+}
+// untested - was never called
+// inspected - changed ATOM from fp to int
+DEFUN( GDI:RegisterClassW, wndclassw_p)
+{
+  object arg;
+  ATOM atom;
+  WNDCLASSW* wndclassw_p = alloca(sizeof(WNDCLASSW));
+  object arg0;
+  arg0 = popSTACK();
+  processWNDCLASSW(wndclassw_p,arg0);
+  begin_system_call();
+  atom = RegisterClassW(wndclassw_p);
+  end_system_call();
+  if(!atom){
+    GDI_ERROR("RegisterClassW");
+  }
+  else
+  {
+    //value2 = allocate_fpointer((FOREIGN)atom);
+    VALUES1(uint32_to_I(atom));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:RemoveFontResourceA, lpcstr)
+{
+  object arg;
+  BOOL bool0;
+  LPCSTR lpcstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcstr = TheAsciz(string_to_asciz(arg,encoding));
+  begin_system_call();
+  bool0 = RemoveFontResourceA(lpcstr);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("RemoveFontResourceA");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:RemoveFontResourceW, lpcwstr)
+{
+  object arg;
+  BOOL bool0;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  bool0 = RemoveFontResourceW(lpcwstr);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("RemoveFontResourceW");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ResetDCA, hdc devmodea_p)
+{
+  object arg;
+  HDC hdc0;
+  HDC hdc;
+  DEVMODEA* devmodea_p;
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(DEVMODEA*,devmodea_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  hdc0 = ResetDCA(hdc,devmodea_p);
+  end_system_call();
+  if(NULL ==hdc0){
+    GDI_ERROR("ResetDCA");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hdc0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ResetDCW, hdc devmodew_p)
+{
+  object arg;
+  HDC hdc0;
+  HDC hdc;
+  DEVMODEW* devmodew_p;
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(DEVMODEW*,devmodew_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  hdc0 = ResetDCW(hdc,devmodew_p);
+  end_system_call();
+  if(NULL ==hdc0){
+    GDI_ERROR("ResetDCW");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hdc0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SelectPalette, hdc hpalette bool0)
+{
+  object arg;
+  HPALETTE hpalette0;
+  HDC hdc;
+  HPALETTE hpalette;
+  BOOL bool0;
+  arg = popSTACK();
+  bool0 = nullp(arg);
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hpalette = TheFpointer(arg)->fp_pointer;
+  getHDC(hdc,arg);
+  begin_system_call();
+  hpalette0 = SelectPalette(hdc,hpalette,bool0);
+  end_system_call();
+  if(NULL ==hpalette0){
+    GDI_ERROR("SelectPalette");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hpalette0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetColorAdjustment, hdc coloradjustment_p)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  COLORADJUSTMENT* coloradjustment_p = alloca(sizeof(COLORADJUSTMENT));
+  object arg0;
+  arg0 = popSTACK();
+  processCOLORADJUSTMENT(coloradjustment_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = SetColorAdjustment(hdc,coloradjustment_p);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetColorAdjustment");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetDeviceGammaRamp, hdc pvoid)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  void* pvoid;
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = SetDeviceGammaRamp(hdc,pvoid);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetDeviceGammaRamp");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetICMProfileA, hdc lpstr)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  LPSTR lpstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpstr = TheAsciz(string_to_asciz(arg,encoding));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = SetICMProfileA(hdc,lpstr);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetICMProfileA");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// requires a S16string object as lpwstr
+DEFUN( GDI:SetICMProfileW, hdc lpwstr)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  LPWSTR lpwstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpwstr = WIDECHAR(arg,encoding);
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = SetICMProfileW(hdc,lpwstr);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetICMProfileW");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetPixel, hdc int0 int1 colorref)
+{
+  object arg;
+  COLORREF colorref0;
+  HDC hdc;
+  int int0;
+  int int1;
+  COLORREF colorref;
+  arg = popSTACK();
+  colorref = processCOLORREF(arg);
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  colorref0 = SetPixel(hdc,int0,int1,colorref);
+  end_system_call();
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetPixelV, hdc int0 int1 colorref)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  COLORREF colorref;
+  arg = popSTACK();
+  colorref = processCOLORREF(arg);
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = SetPixelV(hdc,int0,int1,colorref);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetPixelV");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetTextColor, hdc colorref)
+{
+  object arg;
+  COLORREF colorref0;
+  HDC hdc;
+  COLORREF colorref;
+  arg = popSTACK();
+  colorref = processCOLORREF(arg);
+  getHDC(hdc,arg);
+  begin_system_call();
+  colorref0 = SetTextColor(hdc,colorref);
+  end_system_call();
+  if(CLR_INVALID == colorref0){
+    GDI_ERROR("SetTextColor");
+  }
+  else
+  {
+    VALUES1(fixnum(colorref0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetWorldTransform, hdc xform_p)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  XFORM* xform_p = alloca(sizeof(XFORM));
+  object arg0;
+  arg0 = popSTACK();
+  processXFORM(xform_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = SetWorldTransform(hdc,xform_p);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetWorldTransform");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:DestroyCursor, hcursor)
+{
+  object arg;
+  BOOL bool0;
+  HCURSOR hcursor;
+  object arg0;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hcursor = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  bool0 = DestroyCursor(hcursor);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("DestroyCursor");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// written by hand
+DEFUN( GDI:SetCursor, hcursor)
+{
+  object arg;
+  BOOL bool0;
+  HCURSOR hcursor, hcursor0;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hcursor = (HCURSOR)TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hcursor0 = SetCursor(hcursor);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetCursor");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hcursor0));
+  }
+  return;
+}
+// untested - was never called
+// written by hand
+DEFUN( GDI:GetCursor,)
+{
+  HCURSOR hcursor;
+  begin_system_call();
+  hcursor = GetCursor();
+  end_system_call();
+  if(!hcursor){
+    GDI_ERROR("GetCursor");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hcursor));
+  }
+  return;
+}
+// untested - was never called
+// written by hand
+DEFUN( GDI:ChangeCursor, hwnd hcursor0)
+{
+  object arg;
+  HWND hwnd;
+  HCURSOR hcursor0, hcursor;
+  object arg0;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hcursor0 = TheFpointer(arg)->fp_pointer;
+  arg0 = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg0);
+  hwnd = TheFpointer(arg0)->fp_pointer;
+  begin_system_call();
+  hcursor = (HCURSOR)SetClassLong(hwnd, GCL_HCURSOR, (LONG) hcursor0);
+  end_system_call();
+  if(!hcursor){
+    GDI_ERROR("SetClassLong");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hcursor));
+  }
+  return;
+}
+// untested - was never called
+// written by hand
+DEFUN( GDI:GetCursorPos,lppoint)
+{
+  BOOL bool0;
+  POINT *lppoint = alloca(sizeof(POINT));
+  object arg0; 
+  arg0 = popSTACK();
+  processPOINT(lppoint,arg0); 
+  begin_system_call();
+  bool0 = GetCursorPos(lppoint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetCursorPos");
+  }
+  else
+  {
+    value1 = sint32_to_I(lppoint->x);
+    value2 = sint32_to_I(lppoint->y);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// written by hand
+DEFUN( GDI:SetCursorPos, int0 int1)
+{
+  BOOL bool0;
+  int int0, int1;
+  object arg; 
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  begin_system_call();
+  bool0 = SetCursorPos(int0, int1);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("SetCursorPos");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// written by hand
+DEFUN( GDI:GetCursorInfo, cursorinfo)
+{
+  BOOL bool0;
+  CURSORINFO cursorinfo;
+  object arg0; 
+  arg0 = popSTACK();
+  processCURSORINFO(&cursorinfo,arg0); 
+  begin_system_call();
+  bool0 = GetCursorInfo(&cursorinfo);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetCursorInfo");
+  }
+  else
+  {
+    VALUES1(outputCURSORINFO(&cursorinfo));
+  }
+  return;
+}
+// cygwin w32api error: linked to msimg32, but defined in gdi32
+// written by hand
+/*
+DEFUN( GDI:GetDCPenColor, hdc)
+{
+  object arg;
+  HDC hdc;
+  COLORREF colorref;
+  getHDC(hdc,arg);
+  begin_system_call();
+  colorref = GetDCPenColor(hdc);
+  end_system_call();
+  if(CLR_INVALID == colorref){
+    GDI_ERROR("GetDCPenColor");
+  }
+  else
+  {
+    VALUES1(fixnum(colorref));
+  }
+  return;
+}
+*/
+// untested - was never called
+// written by hand
+DEFUN( GDI:SetDCPenColor, hdc colorref)
+{
+  object arg;
+  COLORREF colorref0;
+  HDC hdc;
+  COLORREF colorref;
+  arg = popSTACK();
+  colorref = processCOLORREF(arg);
+  getHDC(hdc,arg);
+  begin_system_call();
+  colorref0 = SetDCPenColor(hdc,colorref);
+  end_system_call();
+  if(CLR_INVALID == colorref0){
+    GDI_ERROR("SetDCPenColor");
+  }
+  else
+  {
+    VALUES1(fixnum(colorref0));
+  }
+  return;
+}
+// cygwin w32api error: linked to msimg32, but defined in gdi32
+// written by hand
+/*
+DEFUN( GDI:GetDCBrushColor, hdc)
+{
+  object arg;
+  HDC hdc;
+  COLORREF colorref;
+  getHDC(hdc,arg);
+  begin_system_call();
+  colorref = GetDCBrushColor(hdc);
+  end_system_call();
+  if(CLR_INVALID == colorref){
+    GDI_ERROR("GetDCBrushColor");
+  }
+  else
+  {
+    VALUES1(fixnum(colorref));
+  }
+  return;
+}
+*/
+// untested - was never called
+// written by hand
+DEFUN( GDI:SetDCBrushColor, hdc colorref)
+{
+  object arg;
+  COLORREF colorref0;
+  HDC hdc;
+  COLORREF colorref;
+  arg = popSTACK();
+  colorref = processCOLORREF(arg);
+  getHDC(hdc,arg);
+  begin_system_call();
+  colorref0 = SetDCBrushColor(hdc,colorref);
+  end_system_call();
+  if(CLR_INVALID == colorref0){
+    GDI_ERROR("SetDCBrushColor");
+  }
+  else
+  {
+    VALUES1(fixnum(colorref0));
+  }
+  return;
+}
+// untested - was never called
+// written by hand
+DEFUN(GDI:GetDCEx, hwnd hrgnClip flags)
+{
+  object arg = popSTACK();
+  DWORD e = 0;
+  HDC h0;
+  DWORD flags = I_to_uint32(check_uint(popSTACK()));
+  HRGN hrgnClip = (nullp(arg))?0:(TheFpointer(arg)->fp_pointer);
+  HWND hwnd = (nullp(arg))?0:(TheFpointer(arg)->fp_pointer);
+  begin_system_call();
+  h0 = GetDCEx(hwnd, hrgnClip, flags);
+  end_system_call();
+  if(NULL == h0){
+    GDI_ERROR("GetDCEx");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)h0));
+  }
+  return;
+}
+// untested - was never called
+// written by hand
+DEFUN(GDI:GetWindowDC, hwnd)
+{
+  object arg = popSTACK();
+  DWORD e = 0;
+  HDC h0;
+  HWND hwnd = (nullp(arg))?0:(TheFpointer(arg)->fp_pointer);
+  begin_system_call();
+  h0 = GetWindowDC(hwnd);
+  end_system_call();
+  if(NULL == h0){
+    GDI_ERROR("GetWindowDC");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)h0));
+  }
+  return;
+}
+
+/*
+ * Local variables:
+ *   c-file-style: "parrot"
+ * End:
+ * vim: expandtab shiftwidth=2:
+ */
diff -burN origsrc/clisp-2.48/modules/gdi/funcs-prob.h src/clisp-2.48/modules/gdi/funcs-prob.h
--- origsrc/clisp-2.48/modules/gdi/funcs-prob.h	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/funcs-prob.h	2009-07-21 10:14:19.000000000 +0000
@@ -0,0 +1,59 @@
+int          AddFontResourceA(LPCSTR);
+int          AddFontResourceW(LPCWSTR);
+HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE,LPCSTR);
+HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE,LPCWSTR);
+HMETAFILE    CopyMetaFileA(HMETAFILE,LPCSTR);
+HMETAFILE    CopyMetaFileW(HMETAFILE,LPCWSTR);
+HBITMAP      CreateBitmapIndirect( BITMAP_P);
+HBRUSH       CreateBrushIndirect( LOGBRUSH_P);
+HCOLORSPACE  CreateColorSpaceA(LPLOGCOLORSPACEA);
+HCOLORSPACE  CreateColorSpaceW(LPLOGCOLORSPACEW);
+HDC          CreateDCA(LPCSTR,LPCSTR,LPCSTR, DEVMODEA_P);
+HDC          CreateDCW(LPCWSTR,LPCWSTR,LPCWSTR, DEVMODEW_P);
+HRGN         CreateEllipticRgnIndirect(LPCRECT);
+HDC          CreateEnhMetaFileA(HDC,LPCSTR,LPCRECT,LPCSTR);
+HDC          CreateEnhMetaFileW(HDC,LPCWSTR,LPCRECT,LPCWSTR);
+HFONT        CreateFontIndirectA( LOGFONTA_P);
+HFONT        CreateFontIndirectW( LOGFONTW_P);
+HDC          CreateICA(LPCSTR,LPCSTR,LPCSTR, DEVMODEA_P);
+HDC          CreateICW(LPCWSTR,LPCWSTR,LPCWSTR, DEVMODEW_P);
+HICON        CreateIconFromResource(PBYTE,DWORD,BOOL,DWORD);
+HICON        CreateIconIndirect(PICONINFO);
+HDC          CreateMetaFileA(LPCSTR);
+HDC          CreateMetaFileW(LPCWSTR);
+HPALETTE     CreatePalette( LOGPALETTE_P);
+HPEN         CreatePenIndirect( LOGPEN_P);
+HRGN         CreateRectRgnIndirect(LPCRECT);
+BOOL         FillRect(HDC,LPCRECT,HBRUSH);
+HCURSOR      LoadCursorA(HINSTANCE,LPCSTR);
+HCURSOR      LoadCursorW(HINSTANCE,LPCWSTR);
+BOOL         PlayEnhMetaFile(HDC,HENHMETAFILE,LPCRECT);
+BOOL         RectInRegion(HRGN,LPCRECT);
+BOOL         RectVisible(HDC,LPCRECT);
+ATOM         RegisterClassA(WNDCLASSA_P);
+ATOM         RegisterClassW(WNDCLASSW_P);
+BOOL         RemoveFontResourceA(LPCSTR);
+BOOL         RemoveFontResourceW(LPCWSTR);
+HDC          ResetDCA(HDC, DEVMODEA_P);
+HDC          ResetDCW(HDC, DEVMODEW_P);
+HPALETTE     SelectPalette(HDC,HPALETTE,BOOL);
+BOOL         SetColorAdjustment(HDC, COLORADJUSTMENT_P);
+BOOL         SetDeviceGammaRamp(HDC,PVOID);
+BOOL         SetICMProfileA(HDC,LPSTR);
+BOOL         SetICMProfileW(HDC,LPWSTR);
+COLORREF     SetPixel(HDC,int,int,COLORREF);
+BOOL         SetPixelV(HDC,int,int,COLORREF);
+COLORREF     SetTextColor(HDC,COLORREF);
+BOOL         SetWorldTransform(HDC, XFORM_P);
+BOOL         DestroyCursor(HCURSOR);
+HCURSOR      SetCursor(HCURSOR);
+HCURSOR      GetCursor(void);
+BOOL         GetCursorPos(LPPOINT);
+BOOL         SetCursorPos(int,int);
+BOOL         GetCursorInfo(PCURSORINFO);
+/*COLORREF     GetDCPenColor(HDC);*/
+COLORREF     SetDCPenColor(HDC,COLORREF);
+/*COLORREF     GetDCBrushColor(HDC);*/
+COLORREF     SetDCBrushColor(HDC,COLORREF);
+HDC          GetWindowDC(HWND);
+HDC          GetDCEx(HWND,HRGN,DWORD);
diff -burN origsrc/clisp-2.48/modules/gdi/funcs-rest.c src/clisp-2.48/modules/gdi/funcs-rest.c
--- origsrc/clisp-2.48/modules/gdi/funcs-rest.c	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/funcs-rest.c	2009-07-30 17:02:33.000000000 +0000
@@ -0,0 +1,1624 @@
+#line 2 "funcs-rest.c"
+
+/* functions that have more than 5 parameters, has been hand edited */
+
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:AngleArc,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  DWORD dword;
+  FLOAT float0;
+  FLOAT float1;
+  ffloatjanus jfloat;
+  FF_to_c_float(check_ffloat(popSTACK()),&jfloat);
+  float1 = (float)(jfloat.eksplicit);
+  FF_to_c_float(check_ffloat(popSTACK()),&jfloat);
+  float0 = (float)(jfloat.eksplicit);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = AngleArc(hdc,int0,int1,dword,float0,float1);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("AngleArc");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+/* This must be lowercase, because used in gdi.lisp.
+   modern package bootstrapping problem within modprep
+*/
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:Arc,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int int4;
+  int int5;
+  int int6;
+  int int7;
+  int7 = I_to_sint32(check_sint(popSTACK()));
+  int6 = I_to_sint32(check_sint(popSTACK()));
+  int5 = I_to_sint32(check_sint(popSTACK()));
+  int4 = I_to_sint32(check_sint(popSTACK()));
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = Arc(hdc,int0,int1,int2,int3,int4,int5,int6,int7);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("Arc");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ArcTo,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int int4;
+  int int5;
+  int int6;
+  int int7;
+  int7 = I_to_sint32(check_sint(popSTACK()));
+  int6 = I_to_sint32(check_sint(popSTACK()));
+  int5 = I_to_sint32(check_sint(popSTACK()));
+  int4 = I_to_sint32(check_sint(popSTACK()));
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = ArcTo(hdc,int0,int1,int2,int3,int4,int5,int6,int7);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("ArcTo");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:BitBlt,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  HDC hdc0;
+  int int4;
+  int int5;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  int5 = I_to_sint32(check_sint(popSTACK()));
+  int4 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hdc0 = TheFpointer(arg)->fp_pointer;
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = BitBlt(hdc,int0,int1,int2,int3,hdc0,int4,int5,dword);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("BitBlt");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:Chord,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int int4;
+  int int5;
+  int int6;
+  int int7;
+  int7 = I_to_sint32(check_sint(popSTACK()));
+  int6 = I_to_sint32(check_sint(popSTACK()));
+  int5 = I_to_sint32(check_sint(popSTACK()));
+  int4 = I_to_sint32(check_sint(popSTACK()));
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = Chord(hdc,int0,int1,int2,int3,int4,int5,int6,int7);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("Chord");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateDIBitmap,&rest r)
+{
+  object arg;
+  HBITMAP hbitmap;
+  HDC hdc;
+  BITMAPINFOHEADER* bitmapinfoheader_p = alloca(sizeof(BITMAPINFOHEADER));
+  object arg0;
+  DWORD dword;
+  void* pcvoid;
+  BITMAPINFO* bitmapinfo_p = alloca(sizeof(BITMAPINFO));
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(BITMAPINFO*,bitmapinfo_p,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pcvoid = &(TheSbvector(arg)->data);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(BITMAPINFOHEADER*,bitmapinfoheader_p,arg0);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  hbitmap = CreateDIBitmap(hdc,bitmapinfoheader_p,dword,pcvoid,bitmapinfo_p,uint);
+  end_system_call();
+  if(NULL ==hbitmap){
+    GDI_ERROR("CreateDIBitmap");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hbitmap));
+  }
+  return;
+}
+// tested ok
+DEFUN( GDI:CreateFontA,&rest r)
+{
+  object arg;
+  HFONT hfont;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int int4;
+  DWORD dword;
+  DWORD dword0;
+  DWORD dword1;
+  DWORD dword2;
+  DWORD dword3;
+  DWORD dword4;
+  DWORD dword5;
+  DWORD dword6;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+     dword6 = I_to_uint32(check_uint(popSTACK()));
+     dword5 = I_to_uint32(check_uint(popSTACK()));
+     dword4 = I_to_uint32(check_uint(popSTACK()));
+     dword3 = I_to_uint32(check_uint(popSTACK()));
+     dword2 = I_to_uint32(check_uint(popSTACK()));
+     dword1 = I_to_uint32(check_uint(popSTACK()));
+     dword0 = I_to_uint32(check_uint(popSTACK()));
+     dword = I_to_uint32(check_uint(popSTACK()));
+     arg = popSTACK();
+     check_sint(arg);
+     int4 = I_to_sint32(arg);
+     arg = popSTACK();
+     check_sint(arg);
+     int3 = I_to_sint32(arg);
+     arg = popSTACK();
+     check_sint(arg);
+     int2 = I_to_sint32(arg);
+     arg = popSTACK();
+     check_sint(arg);
+     int1 = I_to_sint32(arg);
+     arg = popSTACK();
+     check_sint(arg);
+     int0 = I_to_sint32(arg);
+     begin_system_call();
+     hfont = CreateFontA(int0,int1,int2,int3,int4,dword,dword0,dword1,dword2,dword3,dword4,dword5,dword6,lpcstr);
+     end_system_call();
+  });
+  if(NULL ==hfont){
+    GDI_ERROR("CreateFontA");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hfont));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateFontW,&rest r)
+{
+  object arg;
+  HFONT hfont;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int int4;
+  DWORD dword;
+  DWORD dword0;
+  DWORD dword1;
+  DWORD dword2;
+  DWORD dword3;
+  DWORD dword4;
+  DWORD dword5;
+  DWORD dword6;
+  LPCWSTR lpcwstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  dword6 = I_to_uint32(check_uint(popSTACK()));
+  dword5 = I_to_uint32(check_uint(popSTACK()));
+  dword4 = I_to_uint32(check_uint(popSTACK()));
+  dword3 = I_to_uint32(check_uint(popSTACK()));
+  dword2 = I_to_uint32(check_uint(popSTACK()));
+  dword1 = I_to_uint32(check_uint(popSTACK()));
+  dword0 = I_to_uint32(check_uint(popSTACK()));
+  dword = I_to_uint32(check_uint(popSTACK()));
+  int4 = I_to_sint32(check_sint(popSTACK()));
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  begin_system_call();
+  hfont = CreateFontW(int0,int1,int2,int3,int4,dword,dword0,dword1,dword2,dword3,dword4,dword5,dword6,lpcwstr);
+  end_system_call();
+  if(NULL ==hfont){
+    GDI_ERROR("CreateFontW");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hfont));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateIcon,&rest r)
+{
+  object arg;
+  object arg0;
+  HICON hicon;
+  HINSTANCE hinstance;
+  int int0;
+  int int1;
+  BYTE byte;
+  BYTE byte0;
+  PBYTE pbyte;
+  PBYTE pbyte0;
+  arg0 = popSTACK();
+  processPBYTE(pbyte0,arg0);
+  arg0 = popSTACK();
+  processPBYTE(pbyte,arg0);
+  arg0 = popSTACK();
+  processBYTE(&byte0,arg0);
+  arg0 = popSTACK();
+  processBYTE(&byte,arg0);
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hinstance = TheFpointer(arg)->fp_pointer;
+  begin_system_call();
+  hicon = CreateIcon(hinstance,int0,int1,byte,byte0,pbyte,pbyte0);
+  end_system_call();
+  if(NULL ==hicon){
+    GDI_ERROR("CreateIcon");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hicon));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateIconFromResourceEx,&rest r)
+{
+  object arg;
+  object arg0;
+  HICON hicon;
+  PBYTE pbyte;
+  DWORD dword;
+  BOOL bool0;
+  DWORD dword0;
+  int int0;
+  int int1;
+  UINT uint;
+  uint = I_to_uint32(check_uint(popSTACK()));;
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  dword0 = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processBOOL(&bool0,arg0);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processPBYTE(pbyte,arg0);
+  begin_system_call();
+  hicon = CreateIconFromResourceEx(pbyte,dword,bool0,dword0,int0,int1,uint);
+  end_system_call();
+  if(NULL ==hicon){
+    GDI_ERROR("CreateIconFromResourceEx");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hicon));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateRoundRectRgn,&rest r)
+{
+  object arg;
+  HRGN hrgn;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int int4;
+  int int5;
+  int5 = I_to_sint32(check_sint(popSTACK()));
+  int4 = I_to_sint32(check_sint(popSTACK()));
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  begin_system_call();
+  hrgn = CreateRoundRectRgn(int0,int1,int2,int3,int4,int5);
+  end_system_call();
+  if(NULL ==hrgn){
+    GDI_ERROR("CreateRoundRectRgn");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hrgn));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateWindowExA,&rest r)
+{
+  object arg;
+  HWND hwnd0;
+  DWORD dword;
+  LPCSTR lpcstr;
+  LPCSTR lpcstr0;
+  DWORD dword0;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  HWND hwnd;
+  HMENU hmenu;
+  HINSTANCE hinstance;
+  void* lpvoid = alloca(sizeof(long));
+  object arg0;
+  arg0 = popSTACK();
+  arg = popSTACK();
+  processvoid(lpvoid,arg0);
+  if(!fpointerp(arg))invalid_argument(arg);
+  hinstance = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hmenu = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hwnd = TheFpointer(arg)->fp_pointer;
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  dword0 = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding,lpcstr0, {
+    arg = popSTACK();
+    if(!stringp(arg))invalid_argument(arg);
+    with_string_0(arg,encoding, lpcstr,{
+      dword = I_to_uint32(check_uint(popSTACK()));
+      begin_system_call();
+      hwnd0 = CreateWindowExA(dword,lpcstr,lpcstr0,dword0,int0,int1,int2,int3,hwnd,hmenu,hinstance,lpvoid);
+      end_system_call();
+      if(NULL ==hwnd0){
+          GDI_ERROR("CreateWindowExA");
+      }
+      else
+      {
+          VALUES1(allocate_fpointer((FOREIGN)hwnd0));
+      }
+      return;
+    });
+  });
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:CreateWindowExW,&rest r)
+{
+  object arg;
+  HWND hwnd0;
+  DWORD dword;
+  LPCWSTR lpcwstr;
+  LPCWSTR lpcwstr0;
+  DWORD dword0;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  HWND hwnd;
+  HMENU hmenu;
+  HINSTANCE hinstance;
+  void* lpvoid = alloca(sizeof(long));
+  object arg0;
+  arg0 = popSTACK();
+  processvoid(lpvoid,arg0);
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hinstance = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hmenu = TheFpointer(arg)->fp_pointer;
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hwnd = TheFpointer(arg)->fp_pointer;
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  dword0 = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr0 = 0; //(WIDECHAR(arg,encoding));
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = 0; //(WIDECHAR(arg,encoding));
+  dword = I_to_uint32(check_uint(popSTACK()));
+
+  begin_system_call();
+  hwnd0 = CreateWindowExW(dword,lpcwstr,lpcwstr0,dword0,int0,int1,int2,int3,hwnd,hmenu,hinstance,lpvoid);
+  end_system_call();
+  if(NULL ==hwnd0){
+    GDI_ERROR("CreateWindowExW");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)hwnd0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ExtEscape,&rest r)
+{
+  object arg;
+  int int3;
+  HDC hdc;
+  int int0;
+  int int1;
+  LPCSTR lpcstr;
+  int int2;
+  LPSTR lpstr;
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpstr, {
+    arg = popSTACK();
+    check_sint(arg);
+    int2 = I_to_sint32(arg);
+    arg = popSTACK();
+    if(!stringp(arg))invalid_argument(arg);
+    with_string_0(arg,encoding, lpcstr, {
+      arg = popSTACK();
+      check_sint(arg);
+      int1 = I_to_sint32(arg);
+      arg = popSTACK();
+      check_sint(arg);
+      int0 = I_to_sint32(arg);
+      arg = popSTACK();
+      if(!fpointerp(arg))invalid_argument(arg);
+      hdc = TheFpointer(arg)->fp_pointer;
+      begin_system_call();
+      int3 = ExtEscape(hdc,int0,int1,lpcstr,int2,lpstr);
+      end_system_call();
+      if(0 <=int3){
+          GDI_ERROR("ExtEscape");
+      }
+      else
+      {
+          VALUES1(sint32_to_I(int3));
+      }
+    });
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ExtTextOutA,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  UINT uint;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  LPCSTR lpcstr;
+  UINT uint0;
+  PINT pint;
+  arg0 = popSTACK();
+  processPINT(pint,arg0);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg0 = popSTACK();
+    processRECT(lpcrect,arg0);
+    uint = I_to_uint32(check_uint(popSTACK()));
+    arg = popSTACK();
+    check_sint(arg);
+    int1 = I_to_sint32(arg);
+    arg = popSTACK();
+    check_sint(arg);
+    int0 = I_to_sint32(arg);
+    arg = popSTACK();
+    if(!fpointerp(arg))invalid_argument(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+
+    begin_system_call();
+    bool0 = ExtTextOutA(hdc,int0,int1,uint,lpcrect,lpcstr,uint0,pint);
+    end_system_call();
+    if(!bool0){
+        GDI_ERROR("ExtTextOutA");
+    }
+    else
+    {
+      VALUES1(T);
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ExtTextOutW,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  UINT uint;
+  RECT* lpcrect = alloca(sizeof(RECT));
+  object arg0;
+  LPCWSTR lpcwstr;
+  UINT uint0;
+  PINT pint;
+  arg0 = popSTACK();
+  processPINT(pint,arg0);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  arg0 = popSTACK();
+  processRECT(lpcrect,arg0);
+  uint = I_to_uint32(check_uint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = ExtTextOutW(hdc,int0,int1,uint,lpcrect,lpcwstr,uint0,pint);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("ExtTextOutW");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FindFirstFileExA,&rest r)
+{
+  object arg;
+  object arg0;
+  HANDLE handle;
+  LPCSTR lpcstr;
+  FINDEX_INFO_LEVELS findex_info_levels;
+  void* pvoid;
+  FINDEX_SEARCH_OPS findex_search_ops;
+  void* pvoid0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pvoid0 = &(TheSbvector(arg)->data);
+  arg0 = popSTACK();
+  processFPTYPE(FINDEX_SEARCH_OPS,findex_search_ops,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  arg0 = popSTACK();
+  processFPTYPE(FINDEX_INFO_LEVELS,findex_info_levels,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    begin_system_call();
+    handle = FindFirstFileExA(lpcstr,findex_info_levels,pvoid,findex_search_ops,pvoid0,dword);
+    end_system_call();
+    if(NULL ==handle){
+        GDI_ERROR("FindFirstFileExA");
+    }
+    else
+    {
+        VALUES1(allocate_fpointer((FOREIGN)handle));
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:FindFirstFileExW,&rest r)
+{
+  object arg;
+  object arg0;
+  HANDLE handle;
+  LPCWSTR lpcwstr;
+  FINDEX_INFO_LEVELS findex_info_levels;
+  void* pvoid;
+  FINDEX_SEARCH_OPS findex_search_ops;
+  void* pvoid0;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pvoid0 = &(TheSbvector(arg)->data);
+  arg0 = popSTACK();
+  processFPTYPE(FINDEX_SEARCH_OPS,findex_search_ops,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  arg0 = popSTACK();
+  processFPTYPE(FINDEX_INFO_LEVELS,findex_info_levels,arg0);
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  begin_system_call();
+  handle = FindFirstFileExW(lpcwstr,findex_info_levels,pvoid,findex_search_ops,pvoid0,dword);
+  end_system_call();
+  if(NULL ==handle){
+    GDI_ERROR("FindFirstFileExW");
+  }
+  else
+  {
+    VALUES1(allocate_fpointer((FOREIGN)handle));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:GetCharacterPlacementA, hdc string nCount nMaxExtent dwFlags)
+/*
+    string
+    nCount     - number of characters in string
+    nMaxExtent - maximum extent for displayed string
+    dwFlags    - GCP_ placement flags
+
+    returns SIZE (width + height) + GCP_RESULTS* pointer to buffer for placement result
+*/
+{
+  object arg;
+  DWORD dword;
+  HDC hdc;
+  LPCSTR lpcstr;
+  int nCount, nMaxExtent;
+  GCP_RESULTSA* lpgcp_resultsa = alloca(sizeof(GCP_RESULTSA));
+  DWORD dwFlags;
+  dwFlags = I_to_uint32(check_uint(popSTACK()));
+  nMaxExtent = I_to_sint32(check_sint(popSTACK()));
+  nCount = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    getHDC(hdc,arg);
+
+    begin_system_call();
+    dword = GetCharacterPlacementA(hdc,lpcstr,nCount,nMaxExtent,lpgcp_resultsa,dwFlags);
+    end_system_call();
+    if(!dword){
+        GDI_ERROR("GetCharacterPlacementA");
+    }
+    else
+    {
+        value1 = outputLPSIZE((SIZE *)&dword);
+        value2 = outputGCP_RESULTSA(lpgcp_resultsa);
+        mv_count=2;
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetCharacterPlacementW, hdc string nCount nMaxExtent dwFlags)
+{
+  object arg;
+  DWORD dword;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  int nCount, nMaxExtent;
+  GCP_RESULTSW* lpgcp_resultsw = alloca(sizeof(GCP_RESULTSW));
+  DWORD dwFlags;
+  dwFlags = I_to_uint32(check_uint(popSTACK()));
+  nMaxExtent = I_to_sint32(check_sint(popSTACK()));
+  nCount = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  dword = GetCharacterPlacementW(hdc,lpcwstr,nCount,nMaxExtent,lpgcp_resultsw,dwFlags);
+  end_system_call();
+  if(!dword){
+    GDI_ERROR("GetCharacterPlacementW");
+  }
+  else
+  {
+    value1 = outputLPSIZE((SIZE *)&dword);
+    value2 = outputGCP_RESULTSW(lpgcp_resultsw);
+    mv_count=2;
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetDIBits,&rest r)
+{
+  object arg;
+  int int0;
+  HDC hdc;
+  HBITMAP hbitmap;
+  UINT uint;
+  UINT uint0;
+  void* pvoid;
+  BITMAPINFO* lpbitmapinfo = alloca(sizeof(BITMAPINFO));
+  object arg0;
+  UINT uint1;
+  uint1 = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(BITMAPINFO*,lpbitmapinfo,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  processFPTYPE(HBITMAP,hbitmap,arg);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  int0 = GetDIBits(hdc,hbitmap,uint,uint0,pvoid,lpbitmapinfo,uint1);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("GetDIBits");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetGlyphOutlineA,&rest r)
+{
+  object arg;
+  DWORD dword0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  GLYPHMETRICS* lpglyphmetrics = alloca(sizeof(GLYPHMETRICS));
+  object arg0;
+  DWORD dword;
+  void* pvoid;
+  MAT2 pmat2;
+  arg0 = popSTACK();
+  processMAT2(&pmat2,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(GLYPHMETRICS*,lpglyphmetrics,arg0);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  dword0 = GetGlyphOutlineA(hdc,uint,uint0,lpglyphmetrics,dword,pvoid,&pmat2);
+  end_system_call();
+  if(!dword0){
+    GDI_ERROR("GetGlyphOutlineA");
+  }
+  else
+  {
+    VALUES1(uint32_to_I(dword0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetGlyphOutlineW,&rest r)
+{
+  object arg;
+  DWORD dword0;
+  HDC hdc;
+  UINT uint;
+  UINT uint0;
+  GLYPHMETRICS* lpglyphmetrics = alloca(sizeof(GLYPHMETRICS));
+  object arg0;
+  DWORD dword;
+  void* pvoid;
+  MAT2 pmat2;
+  arg0 = popSTACK();
+  processMAT2(&pmat2,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  dword = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(GLYPHMETRICS*,lpglyphmetrics,arg0);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  dword0 = GetGlyphOutlineW(hdc,uint,uint0,lpglyphmetrics,dword,pvoid,&pmat2);
+  end_system_call();
+  if(!dword0){
+    GDI_ERROR("GetGlyphOutlineW");
+  }
+  else
+  {
+    VALUES1(uint32_to_I(dword0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetTextExtentExPointA,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  LPCSTR lpcstr;
+  int int0;
+  int int1;
+  int* lpint;
+  int* lpint0;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  processLPSIZE(lpsize,popSTACK());
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))invalid_argument(arg);
+  lpint0 = (int*)&(TheSbvector(arg)->data);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))invalid_argument(arg);
+  lpint = (int*)&(TheSbvector(arg)->data);
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    if(!fpointerp(arg))invalid_argument(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+
+    begin_system_call();
+    bool0 = GetTextExtentExPointA(hdc,lpcstr,int0,int1,lpint,lpint0,lpsize);
+    end_system_call();
+    if(!bool0){
+      GDI_ERROR("GetTextExtentExPointA");
+    }
+    else
+    {
+      VALUES1(T);
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:GetTextExtentExPointW,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  LPCWSTR lpcwstr;
+  int int0;
+  int int1;
+  int* lpint;
+  int* lpint0;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  processLPSIZE(lpsize,popSTACK());
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))invalid_argument(arg);
+  lpint0 = (int*)&(TheSbvector(arg)->data);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))invalid_argument(arg);
+  lpint = (int*)&(TheSbvector(arg)->data);
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = GetTextExtentExPointW(hdc,lpcwstr,int0,int1,lpint,lpint0,lpsize);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("GetTextExtentExPointW");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:MaskBlt,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  HDC hdc0;
+  int int4;
+  int int5;
+  HBITMAP hbitmap;
+  int int6;
+  int int7;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  int7 = I_to_sint32(check_sint(popSTACK()));
+  int6 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hbitmap = TheFpointer(arg)->fp_pointer;
+  int5 = I_to_sint32(check_sint(popSTACK()));
+  int4 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hdc0 = TheFpointer(arg)->fp_pointer;
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = MaskBlt(hdc,int0,int1,int2,int3,hdc0,int4,int5,hbitmap,int6,int7,dword);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("MaskBlt");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PatBlt,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = PatBlt(hdc,int0,int1,int2,int3,dword);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("PatBlt");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:Pie,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int int4;
+  int int5;
+  int int6;
+  int int7;
+  int7 = I_to_sint32(check_sint(popSTACK()));
+  int6 = I_to_sint32(check_sint(popSTACK()));
+  int5 = I_to_sint32(check_sint(popSTACK()));
+  int4 = I_to_sint32(check_sint(popSTACK()));
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = Pie(hdc,int0,int1,int2,int3,int4,int5,int6,int7);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("Pie");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:PlgBlt,&rest r)
+{
+  object arg;
+  object arg0;
+  BOOL bool0;
+  HDC hdc;
+  POINT point;
+  HDC hdc0;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  HBITMAP hbitmap;
+  int int4;
+  int int5;
+  int5 = I_to_sint32(check_sint(popSTACK()));
+  int4 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hbitmap = TheFpointer(arg)->fp_pointer;
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hdc0 = TheFpointer(arg)->fp_pointer;
+  arg0 = popSTACK();
+  processPOINT(&point,arg0);
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = PlgBlt(hdc,&point,hdc0,int0,int1,int2,int3,hbitmap,int4,int5);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("PlgBlt");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:RoundRect,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int int4;
+  int int5;
+  int5 = I_to_sint32(check_sint(popSTACK()));
+  int4 = I_to_sint32(check_sint(popSTACK()));
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = RoundRect(hdc,int0,int1,int2,int3,int4,int5);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("RoundRect");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:ScaleViewportExtEx,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  SIZE* lpsize = alloca(sizeof(SIZE));
+  object arg0;
+  processLPSIZE(lpsize,popSTACK());
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = ScaleViewportExtEx(hdc,int0,int1,int2,int3,lpsize);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("ScaleViewportExtEx");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:ScaleWindowExtEx, hdc Xnum Xdenom Ynum Ydenom lpSize)
+/*
+    HDC hdc,	- handle of device context 
+    int Xnum,	- horizontal multiplicand 
+    int Xdenom,	- horizontal divisor 
+    int Ynum,	- vertical multiplicand 
+    int Ydenom,	- vertical divisor 
+    LPSIZE lpSize - address of previous window extents
+*/
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int Xnum,Xdenom,Ynum,Ydenom;
+  SIZE* lpSize = alloca(sizeof(SIZE));
+  processLPSIZE(lpSize,popSTACK());
+  Ydenom = I_to_sint32(check_sint(popSTACK()));
+  Ynum   = I_to_sint32(check_sint(popSTACK()));
+  Xdenom = I_to_sint32(check_sint(popSTACK()));
+  Xnum   = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  bool0 = ScaleWindowExtEx(hdc,Xnum,Xdenom,Ynum,Ydenom,lpSize);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("ScaleWindowExtEx");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetDIBits,&rest r)
+{
+  object arg;
+  object arg0;
+  int int0;
+  HDC hdc;
+  HBITMAP hbitmap;
+  UINT uint;
+  UINT uint0;
+  void* pcvoid;
+  PBITMAPINFO pbitmapinfo;
+  UINT uint1;
+  uint1 = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(PBITMAPINFO,pbitmapinfo,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pcvoid = &(TheSbvector(arg)->data);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  processFPTYPE(HBITMAP,hbitmap,arg);
+  getHDC(hdc,arg);
+
+  begin_system_call();
+  int0 = SetDIBits(hdc,hbitmap,uint,uint0,pcvoid,pbitmapinfo,uint1);
+  end_system_call();
+  if(0 <=int0){
+    GDI_ERROR("SetDIBits");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int0));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:SetDIBitsToDevice,&rest r)
+{
+  object arg;
+  object arg0;
+  int int4;
+  HDC hdc;
+  int int0;
+  int int1;
+  DWORD dword;
+  DWORD dword0;
+  int int2;
+  int int3;
+  UINT uint;
+  UINT uint0;
+  void* pcvoid;
+  PBITMAPINFO pbitmapinfo;
+  UINT uint1;
+  uint1 = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(PBITMAPINFO,pbitmapinfo,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pcvoid = &(TheSbvector(arg)->data);
+  uint0 = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  dword0 = I_to_uint32(check_uint(popSTACK()));
+  dword = I_to_uint32(check_uint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  int4 = SetDIBitsToDevice(hdc,int0,int1,dword,dword0,int2,int3,uint,uint0,pcvoid,pbitmapinfo,uint1);
+  end_system_call();
+  if(0 <=int4){
+    GDI_ERROR("SetDIBitsToDevice");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int4));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:StretchBlt,&rest r)
+{
+  object arg;
+  BOOL bool0;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  HDC hdc0;
+  int int4;
+  int int5;
+  int int6;
+  int int7;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  int7 = I_to_sint32(check_sint(popSTACK()));
+  int6 = I_to_sint32(check_sint(popSTACK()));
+  int5 = I_to_sint32(check_sint(popSTACK()));
+  int4 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!fpointerp(arg))invalid_argument(arg);
+  hdc0 = TheFpointer(arg)->fp_pointer;
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  bool0 = StretchBlt(hdc,int0,int1,int2,int3,hdc0,int4,int5,int6,int7,dword);
+  end_system_call();
+  if(!bool0){
+    GDI_ERROR("StretchBlt");
+  }
+  else
+  {
+    VALUES1(T);
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:StretchDIBits,&rest r)
+{
+  object arg;
+  object arg0;
+  int int8;
+  HDC hdc;
+  int int0;
+  int int1;
+  int int2;
+  int int3;
+  int int4;
+  int int5;
+  int int6;
+  int int7;
+  void* pvoid;
+  PBITMAPINFO pbitmapinfo;
+  UINT uint;
+  DWORD dword;
+  dword = I_to_uint32(check_uint(popSTACK()));
+  uint = I_to_uint32(check_uint(popSTACK()));
+  arg0 = popSTACK();
+  processFPTYPE(PBITMAPINFO,pbitmapinfo,arg0);
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_8Bit,arg))invalid_argument(arg);
+  pvoid = &(TheSbvector(arg)->data);
+  int7 = I_to_sint32(check_sint(popSTACK()));
+  int6 = I_to_sint32(check_sint(popSTACK()));
+  int5 = I_to_sint32(check_sint(popSTACK()));
+  int4 = I_to_sint32(check_sint(popSTACK()));
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  int8 = StretchDIBits(hdc,int0,int1,int2,int3,int4,int5,int6,int7,pvoid,pbitmapinfo,uint,dword);
+  end_system_call();
+  if(0 <=int8){
+    GDI_ERROR("StretchDIBits");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(int8));
+  }
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:TabbedTextOutA,&rest r)
+{
+  object arg;
+  LONG long0;
+  HDC hdc;
+  int int0;
+  int int1;
+  LPCSTR lpcstr;
+  int int2;
+  int int3;
+  int* lpint;
+  int int4;
+  int4 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))invalid_argument(arg);
+  lpint = (int*)&(TheSbvector(arg)->data);
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpcstr, {
+    arg = popSTACK();
+    check_sint(arg);
+    int1 = I_to_sint32(arg);
+    arg = popSTACK();
+    check_sint(arg);
+    int0 = I_to_sint32(arg);
+    arg = popSTACK();
+    if(!fpointerp(arg))invalid_argument(arg);
+    hdc = TheFpointer(arg)->fp_pointer;
+    begin_system_call();
+    long0 = TabbedTextOutA(hdc,int0,int1,lpcstr,int2,int3,lpint,int4);
+    end_system_call();
+    if(0 <=long0){
+        GDI_ERROR("TabbedTextOutA");
+    }
+    else
+    {
+        VALUES1(sint32_to_I(long0));
+    }
+  });
+  return;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+DEFUN( GDI:TabbedTextOutW,&rest r)
+{
+  object arg;
+  LONG long0;
+  HDC hdc;
+  int int0;
+  int int1;
+  LPCWSTR lpcwstr;
+  int int2;
+  int int3;
+  int* lpint;
+  int int4;
+  int4 = I_to_sint32(check_sint(popSTACK()));
+  arg = popSTACK();
+  if(!simple_bit_vector_p(Atype_32Bit,arg))invalid_argument(arg);
+  lpint = (int*)&(TheSbvector(arg)->data);
+  int3 = I_to_sint32(check_sint(popSTACK()));
+  int2 = I_to_sint32(check_sint(popSTACK()));
+  processLPWSTR(lpcwstr,popSTACK());
+  int1 = I_to_sint32(check_sint(popSTACK()));
+  int0 = I_to_sint32(check_sint(popSTACK()));
+  getHDC(hdc,arg);
+  begin_system_call();
+  long0 = TabbedTextOutW(hdc,int0,int1,lpcwstr,int2,int3,lpint,int4);
+  end_system_call();
+  if(0 <=long0){
+    GDI_ERROR("TabbedTextOutW");
+  }
+  else
+  {
+    VALUES1(sint32_to_I(long0));
+  }
+  return;
+}
+// untested - was never called
+DEFUN( GDI:SearchPathA, lpPath lpFileName lpExtension nBufferLength lpBuffer)
+/* Accepts 3 strings and a number of foreign allocated chars for the last arg.
+   Returns two strings (path + filename only) and the length of the path.
+*/
+{
+  object arg, arg0;
+  DWORD nPathLength;
+  LPCSTR lpPath;
+  LPCSTR lpFileName;
+  LPCSTR lpExtension;
+  DWORD nBufferLength;
+  LPSTR lpBuffer;
+  LPSTR lpFilePart;
+  /*
+  arg = popSTACK();
+  processFPTYPE(LPSTR,lpBuffer,arg);
+  nBufferLength = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  with_string_0(arg,encoding, lpExtension, {
+    arg0 = popSTACK();
+    if(!stringp(arg0))invalid_argument(arg0);
+    with_string_0(arg0,encoding, lpFileName, {
+      arg = popSTACK();
+      if (nullp(arg)) {
+        lpPath = NULL;
+      } else {
+        if(!stringp(arg))invalid_argument(arg);
+        lpPath = string_to_asciz(arg,encoding);
+      }
+      begin_system_call();
+      nPathLength = SearchPathA(lpPath,lpFileName,lpExtension,nBufferLength,
+                                lpBuffer,&lpFilePart);
+      end_system_call();
+      if(!nPathLength){
+        GDI_ERROR("SearchPathA");
+      }
+      else {
+        VALUES3(asciz_to_string(lpBuffer,encoding),
+                allocate_fpointer(lpFilePart),
+                uint32_to_I(nPathLength));
+      }
+    });
+  });
+  */
+  return;
+}
+// untested - was never called
+// looks wrong
+DEFUN( GDI:SearchPathW, lpPath lpFileName lpExtension nBufferLength lpBuffer)
+{
+  object arg;
+  DWORD nPathLength;
+  LPCWSTR lpPath;
+  LPCWSTR lpFileName;
+  LPCWSTR lpExtension;
+  DWORD nBufferLength;
+  LPWSTR lpBuffer;
+  LPWSTR lpFilePart;
+  object arg0;
+  arg0 = popSTACK();
+  processFPTYPE(LPWSTR,lpBuffer,arg0);
+  nBufferLength = I_to_uint32(check_uint(popSTACK()));
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpExtension = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if(!stringp(arg))invalid_argument(arg);
+  lpFileName = WIDECHAR(arg,encoding);
+  arg = popSTACK();
+  if (nullp(arg))
+    lpPath = NULL;
+  else {
+    if(!stringp(arg))invalid_argument(arg);
+    lpPath = WIDECHAR(arg,encoding);
+  }
+
+  begin_system_call();
+  nPathLength = SearchPathW(lpPath,lpFileName,lpExtension,nBufferLength,
+                            lpBuffer,&lpFilePart);
+  end_system_call();
+  if(!nPathLength){
+    GDI_ERROR("SearchPathW");
+  }
+  else
+  {
+    VALUES3(outputLPWSTR(lpBuffer,nPathLength),
+            allocate_fpointer(lpFilePart),
+            uint32_to_I(nPathLength));
+  }
+  return;
+}
diff -burN origsrc/clisp-2.48/modules/gdi/funcs-rest.h src/clisp-2.48/modules/gdi/funcs-rest.h
--- origsrc/clisp-2.48/modules/gdi/funcs-rest.h	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/funcs-rest.h	2006-08-13 14:24:15.000000000 +0000
@@ -0,0 +1,41 @@
+BOOL         AngleArc(HDC,int,int,DWORD,FLOAT,FLOAT);
+BOOL         Arc(HDC,int,int,int,int,int,int,int,int);
+BOOL         ArcTo(HDC,int,int,int,int,int,int,int,int);
+BOOL         BitBlt(HDC,int,int,int,int,HDC,int,int,DWORD);
+BOOL         Chord(HDC,int,int,int,int,int,int,int,int);
+HBITMAP      CreateDIBitmap(HDC, BITMAPINFOHEADER_P,DWORD,PCVOID, BITMAPINFO_P,UINT);
+HFONT        CreateFontA(int,int,int,int,int,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPCSTR);
+HFONT        CreateFontW(int,int,int,int,int,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPCWSTR);
+HICON        CreateIcon(HINSTANCE,int,int,BYTE,BYTE,PBYTE,PBYTE);
+HICON        CreateIconFromResourceEx(PBYTE,DWORD,BOOL,DWORD,int,int,UINT);
+HRGN         CreateRoundRectRgn(int,int,int,int,int,int);
+HWND         CreateWindowExA(DWORD,LPCSTR,LPCSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);
+HWND         CreateWindowExW(DWORD,LPCWSTR,LPCWSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);
+int          ExtEscape(HDC,int,int,LPCSTR,int,LPSTR);
+BOOL         ExtTextOutA(HDC,int,int,UINT,LPCRECT,LPCSTR,UINT,PINT);
+BOOL         ExtTextOutW(HDC,int,int,UINT,LPCRECT,LPCWSTR,UINT,PINT);
+HANDLE       FindFirstFileExA(LPCSTR,FINDEX_INFO_LEVELS,PVOID,FINDEX_SEARCH_OPS,PVOID,DWORD);
+HANDLE       FindFirstFileExW(LPCWSTR,FINDEX_INFO_LEVELS,PVOID,FINDEX_SEARCH_OPS,PVOID,DWORD);
+DWORD        GetCharacterPlacementA(HDC,LPCSTR,int,int,LPGCP_RESULTSA,DWORD);
+DWORD        GetCharacterPlacementW(HDC,LPCWSTR,int,int,LPGCP_RESULTSW,DWORD);
+int          GetDIBits(HDC,HBITMAP,UINT,UINT,PVOID,LPBITMAPINFO,UINT);
+DWORD        GetGlyphOutlineA(HDC,UINT,UINT,LPGLYPHMETRICS,DWORD,PVOID,PMAT2);
+DWORD        GetGlyphOutlineW(HDC,UINT,UINT,LPGLYPHMETRICS,DWORD,PVOID,PMAT2);
+BOOL         GetTextExtentExPointA(HDC,LPCSTR,int,int,LPINT,LPINT,LPSIZE);
+BOOL         GetTextExtentExPointW( HDC,LPCWSTR,int,int,LPINT,LPINT,LPSIZE );
+BOOL         MaskBlt(HDC,int,int,int,int,HDC,int,int,HBITMAP,int,int,DWORD);
+BOOL         PatBlt(HDC,int,int,int,int,DWORD);
+BOOL         Pie(HDC,int,int,int,int,int,int,int,int);
+BOOL         PlgBlt(HDC,PPOINT,HDC,int,int,int,int,HBITMAP,int,int);
+BOOL         RoundRect(HDC,int,int,int,int,int,int);
+BOOL         ScaleViewportExtEx(HDC,int,int,int,int,LPSIZE);
+BOOL         ScaleWindowExtEx(HDC,int,int,int,int,LPSIZE);
+int          SetDIBits(HDC,HBITMAP,UINT,UINT,PCVOID,PBITMAPINFO,UINT);
+int          SetDIBitsToDevice(HDC,int,int,DWORD,DWORD,int,int,UINT,UINT,PCVOID,PBITMAPINFO,UINT);
+int          SetDIBitsToDevice(HDC,int,int,DWORD,DWORD,int,int,UINT,UINT,PCVOID,PBITMAPINFO,UINT);
+BOOL         StretchBlt(HDC,int,int,int,int,HDC,int,int,int,int,DWORD);
+int          StretchDIBits(HDC,int,int,int,int,int,int,int,int,PVOID,PBITMAPINFO,UINT,DWORD);
+LONG         TabbedTextOutA(HDC,int,int,LPCSTR,int,int,LPINT,int);
+LONG         TabbedTextOutW(HDC,int,int,LPCWSTR,int,int,LPINT,int);
+DWORD        SearchPathA(LPCSTR,LPCSTR,LPCSTR,DWORD,LPSTR,LPSTR_P);
+DWORD        SearchPathW(LPCWSTR,LPCWSTR,LPCWSTR,DWORD,LPWSTR,LPWSTR_P);
diff -burN origsrc/clisp-2.48/modules/gdi/funcs-rest.sh src/clisp-2.48/modules/gdi/funcs-rest.sh
--- origsrc/clisp-2.48/modules/gdi/funcs-rest.sh	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/funcs-rest.sh	2006-08-13 14:24:15.000000000 +0000
@@ -0,0 +1,3 @@
+awk -f func.awk <funcs-rest.h >funcs-rest.c
+sed "s/popSTACK()/BEFORE(args_end_pointer)/" <funcs-rest.c >funcs-rest.c1
+mv funcs-rest.c1 funcs-rest.c
diff -burN origsrc/clisp-2.48/modules/gdi/gdi-docs.patch src/clisp-2.48/modules/gdi/gdi-docs.patch
--- origsrc/clisp-2.48/modules/gdi/gdi-docs.patch	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/gdi-docs.patch	2009-07-28 22:03:00.000000000 +0000
@@ -0,0 +1,21 @@
+difforig doc/impnotes.xml.in
+
+diff -u doc/impnotes.xml.in.orig doc/impnotes.xml.in
+--- doc/impnotes.xml.in.orig	2009-06-25 23:41:26.390625000 +0200
++++ doc/impnotes.xml.in	2009-07-11 00:17:48.484375000 +0200
+@@ -27,6 +27,7 @@
+   <!ENTITY dirkey-file SYSTEM "../modules/dirkey/dirkey.xml">
+   <!ENTITY fastcgi-file SYSTEM "../modules/fastcgi/fastcgi.xml">
+   <!ENTITY gdbm-file SYSTEM "../modules/gdbm/gdbm.xml">
++  <!ENTITY gdi-file SYSTEM "../modules/gdi/gdi.xml">
+   <!ENTITY gtk-file SYSTEM "../modules/gtk2/gtk.xml">
+   <!ENTITY i18n-file SYSTEM "../modules/i18n/i18n.xml">
+   <!ENTITY libsvm-file SYSTEM "../modules/libsvm/svm.xml">
+@@ -205,6 +206,7 @@
+ 
+ <!-- gui -->
+ &gtk-file;
++&gdi-file;
+ 
+ </chapter>
+ 
diff -burN origsrc/clisp-2.48/modules/gdi/gdi-preload.lisp src/clisp-2.48/modules/gdi/gdi-preload.lisp
--- origsrc/clisp-2.48/modules/gdi/gdi-preload.lisp	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/gdi-preload.lisp	2009-07-10 20:09:58.000000000 +0000
@@ -0,0 +1,2 @@
+(make-package "GDI" :case-sensitive t :case-inverted t)
+;(CS-COMMON-LISP:make-package "GDI" :case-sensitive t)
diff -burN origsrc/clisp-2.48/modules/gdi/gdi.lisp src/clisp-2.48/modules/gdi/gdi.lisp
--- origsrc/clisp-2.48/modules/gdi/gdi.lisp	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/gdi.lisp	2009-07-30 14:31:37.000000000 +0000
@@ -0,0 +1,2139 @@
+(CS-COMMON-LISP:defpackage "GDI"
+  (:modern t) (:use #:cl)
+  (:documentation "The GDI module provides a 'modern', i.e. case-sensitive 
+and case-inverted interface to all Windows gdi32.dll functions, structs and constants.
+
+All int, DWORD, WORD, LONG, UINT, LPARAM arguments are mapped to
+direct integer types, all strings, pointers and handles are converted
+to foreign-pointers, some known structs are returned as structs, 
+the rest as foreign-pointers.
+")
+  (:export
+   *last-error* POINT POINT-FLOAT RECT *white* *black* pixarray-1-element-type 
+   pixarray-4-element-type pixarray-8-element-type pixarray-16-element-type
+   pixarray-24-element-type pixarray-32-element-type
+   make-point make-point-float make-logfont make-rgb make-textmetric make-iconinfo
+   make-createstruct make-wndclass add-callbacks remove-callback *current-event*
+   bitmap-image handle-textmetric max-char-ascent max-char-descent
+   GetIDC MakeFPointer MessageLoop GetKeyState GetKeyboardState
+   ; constants
+   SM_CXSCREEN SM_CYSCREEN SM_CXVSCROLL SM_CYHSCROLL SM_CYCAPTION
+   SM_CXBORDER SM_CYBORDER SM_CXDLGFRAME SM_CXFIXEDFRAME SM_CYDLGFRAME
+   SM_CYFIXEDFRAME SM_CYVTHUMB SM_CXHTHUMB SM_CXICON SM_CYICON SM_CXCURSOR
+   SM_CYCURSOR SM_CYMENU SM_CXFULLSCREEN SM_CYFULLSCREEN SM_CYKANJIWINDOW
+   SM_MOUSEPRESENT SM_CYVSCROLL SM_CXHSCROLL SM_DEBUG SM_SWAPBUTTON
+   SM_RESERVED1 SM_RESERVED2 SM_RESERVED3 SM_RESERVED4 SM_CXMIN SM_CYMIN
+   SM_CXSIZE SM_CYSIZE SM_CXSIZEFRAME SM_CXFRAME SM_CYSIZEFRAME SM_CYFRAME
+   SM_CXMINTRACK SM_CYMINTRACK SM_CXDOUBLECLK SM_CYDOUBLECLK SM_CXICONSPACING
+   SM_CYICONSPACING SM_MENUDROPALIGNMENT SM_PENWINDOWS SM_DBCSENABLED
+   SM_CMOUSEBUTTONS SM_SECURE SM_CXEDGE SM_CYEDGE SM_CXMINSPACING
+   SM_CYMINSPACING SM_CXSMICON SM_CYSMICON SM_CYSMCAPTION SM_CXSMSIZE
+   SM_CYSMSIZE SM_CXMENUSIZE SM_CYMENUSIZE SM_ARRANGE SM_CXMINIMIZED
+   SM_CYMINIMIZED SM_CXMAXTRACK SM_CYMAXTRACK SM_CXMAXIMIZED SM_CYMAXIMIZED
+   SM_NETWORK SM_CLEANBOOT SM_CXDRAG SM_CYDRAG SM_SHOWSOUNDS SM_CXMENUCHECK
+   SM_CYMENUCHECK SM_SLOWMACHINE SM_MIDEASTENABLED SM_MOUSEWHEELPRESENT
+   SM_XVIRTUALSCREEN SM_YVIRTUALSCREEN SM_CXVIRTUALSCREEN SM_CYVIRTUALSCREEN
+   SM_CMONITORS SM_SAMEDISPLAYFORMAT SM_CMETRICS
+   BI_RGB BI_RLE8 BI_RLE4 BI_BITFIELDS LF_FACESIZE LF_FULLFACESIZE
+   CA_NEGATIVE CA_LOG_FILTER ILLUMINANT_DEVICE_DEFAULT ILLUMINANT_A
+   ILLUMINANT_B ILLUMINANT_C ILLUMINANT_D50 ILLUMINANT_D55 ILLUMINANT_D65
+   ILLUMINANT_D75 ILLUMINANT_F2 ILLUMINANT_MAX_INDEX ILLUMINANT_FLUORESCENT
+   RGB_GAMMA_MIN RGB_GAMMA_MAX REFERENCE_WHITE_MIN REFERENCE_WHITE_MAX
+   REFERENCE_BLACK_MIN REFERENCE_BLACK_MAX COLOR_ADJ_MAX CCHDEVICENAME
+   CCHFORMNAME DI_COMPAT DI_DEFAULTSIZE DI_IMAGE DI_MASK DI_NORMAL
+   DI_APPBANDING EMR_HEADER EMR_POLYBEZIER EMR_POLYGON EMR_POLYLINE
+   EMR_POLYBEZIERTO EMR_POLYLINETO EMR_POLYPOLYLINE EMR_POLYPOLYGON
+   EMR_SETWINDOWEXTEX EMR_SETWINDOWORGEX EMR_SETVIEWPORTEXTEX
+   EMR_SETVIEWPORTORGEX EMR_SETBRUSHORGEX EMR_EOF EMR_SETPIXELV
+   EMR_SETMAPPERFLAGS EMR_SETMAPMODE EMR_SETBKMODE EMR_SETPOLYFILLMODE
+   EMR_SETROP2 EMR_SETSTRETCHBLTMODE EMR_SETTEXTALIGN EMR_SETCOLORADJUSTMENT
+   EMR_SETTEXTCOLOR EMR_SETBKCOLOR EMR_OFFSETCLIPRGN EMR_MOVETOEX
+   EMR_SETMETARGN EMR_EXCLUDECLIPRECT EMR_INTERSECTCLIPRECT
+   EMR_SCALEVIEWPORTEXTEX EMR_SCALEWINDOWEXTEX EMR_SAVEDC EMR_RESTOREDC
+   EMR_SETWORLDTRANSFORM EMR_MODIFYWORLDTRANSFORM EMR_SELECTOBJECT
+   EMR_CREATEPEN EMR_CREATEBRUSHINDIRECT EMR_DELETEOBJECT EMR_ANGLEARC
+   EMR_ELLIPSE EMR_RECTANGLE EMR_ROUNDRECT EMR_ARC EMR_CHORD EMR_PIE
+   EMR_SELECTPALETTE EMR_CREATEPALETTE EMR_SETPALETTEENTRIES
+   EMR_RESIZEPALETTE EMR_REALIZEPALETTE EMR_EXTFLOODFILL EMR_LINETO EMR_ARCTO
+   EMR_POLYDRAW EMR_SETARCDIRECTION EMR_SETMITERLIMIT EMR_BEGINPATH
+   EMR_ENDPATH EMR_CLOSEFIGURE EMR_FILLPATH EMR_STROKEANDFILLPATH
+   EMR_STROKEPATH EMR_FLATTENPATH EMR_WIDENPATH EMR_SELECTCLIPPATH
+   EMR_ABORTPATH EMR_GDICOMMENT EMR_FILLRGN EMR_FRAMERGN EMR_INVERTRGN
+   EMR_PAINTRGN EMR_EXTSELECTCLIPRGN EMR_BITBLT EMR_STRETCHBLT EMR_MASKBLT
+   EMR_PLGBLT EMR_SETDIBITSTODEVICE EMR_STRETCHDIBITS EMR_EXTCREATEFONTINDIRECTW
+   EMR_EXTTEXTOUTA EMR_EXTTEXTOUTW EMR_POLYBEZIER16 EMR_POLYGON16 EMR_POLYLINE16
+   EMR_POLYBEZIERTO16 EMR_POLYLINETO16 EMR_POLYPOLYLINE16 EMR_POLYPOLYGON16
+   EMR_POLYDRAW16 EMR_CREATEMONOBRUSH EMR_CREATEDIBPATTERNBRUSHPT
+   EMR_EXTCREATEPEN EMR_POLYTEXTOUTA EMR_POLYTEXTOUTW EMR_SETICMMODE
+   EMR_CREATECOLORSPACE EMR_SETCOLORSPACE EMR_DELETECOLORSPACE EMR_GLSRECORD
+   EMR_GLSBOUNDEDRECORD EMR_PIXELFORMAT ENHMETA_SIGNATURE EPS_SIGNATURE
+   META_SETBKCOLOR META_SETBKMODE META_SETMAPMODE META_SETROP2 META_SETRELABS
+   META_SETPOLYFILLMODE META_SETSTRETCHBLTMODE META_SETTEXTCHAREXTRA
+   META_SETTEXTCOLOR META_SCALEWINDOWEXT META_OFFSETVIEWPORTORG
+   META_SCALEVIEWPORTEXT META_LINETO META_MOVETO META_EXCLUDECLIPRECT
+   META_INTERSECTCLIPRECT META_ARC META_ELLIPSE META_FLOODFILL
+   META_OFFSETCLIPRGN META_TEXTOUT META_BITBLT META_STRETCHBLT META_POLYGON
+   META_POLYLINE META_ESCAPE META_RESTOREDC META_FILLREGION META_FRAMEREGION
+   META_CHORD META_SETMAPPERFLAGS META_EXTTEXTOUT META_SETDIBTODEV
+   META_SELECTPALETTE META_REALIZEPALETTE META_ANIMATEPALETTE META_SETPALENTRIES
+   META_POLYPOLYGON META_RESIZEPALETTE META_DIBBITBLT META_DIBSTRETCHBLT
+   META_DIBCREATEPATTERNBRUSH META_STRETCHDIB META_EXTFLOODFILL
+   META_DELETEOBJECT META_CREATEPALETTE META_CREATEPATTERNBRUSH
+   PT_MOVETO PT_LINETO PT_BEZIERTO PT_CLOSEFIGURE ELF_VENDOR_SIZE
+   ELF_VERSION ELF_CULTURE_LATIN PFD_TYPE_RGBA PFD_TYPE_COLORINDEX
+   PFD_MAIN_PLANE PFD_OVERLAY_PLANE PFD_DOUBLEBUFFER PFD_STEREO
+   PFD_DRAW_TO_WINDOW PFD_DRAW_TO_BITMAP PFD_SUPPORT_GDI PFD_SUPPORT_OPENGL
+   PFD_GENERIC_FORMAT PFD_NEED_PALETTE PFD_NEED_SYSTEM_PALETTE PFD_SWAP_EXCHANGE
+   PFD_SWAP_COPY PFD_DOUBLEBUFFER_DONTCARE PFD_STEREO_DONTCARE
+   BLACKNESS NOTSRCERASE NOTSRCCOPY SRCERASE DSTINVERT PATINVERT SRCINVERT
+   SRCAND MERGEPAINT SRCCOPY SRCPAINT PATCOPY PATPAINT WHITENESS R2_BLACK
+   R2_COPYPEN R2_MASKNOTPEN R2_MASKPEN R2_MASKPENNOT R2_MERGENOTPEN
+   R2_MERGEPEN R2_MERGEPENNOT R2_NOP R2_NOT R2_NOTCOPYPEN R2_NOTMASKPEN
+   R2_NOTMERGEPEN R2_NOTXORPEN R2_WHITE R2_XORPEN CM_OUT_OF_GAMUT
+   CM_IN_GAMUT RGN_AND RGN_COPY RGN_DIFF RGN_OR RGN_XOR NULLREGION SIMPLEREGION
+   COMPLEXREGION CBM_INIT DIB_PAL_COLORS DIB_RGB_COLORS FW_DONTCARE
+   FW_THIN FW_EXTRALIGHT FW_LIGHT FW_NORMAL FW_REGULAR FW_MEDIUM FW_SEMIBOLD
+   FW_BOLD FW_EXTRABOLD FW_HEAVY ANSI_CHARSET DEFAULT_CHARSET SYMBOL_CHARSET
+   SHIFTJIS_CHARSET HANGEUL_CHARSET HANGUL_CHARSET GB2312_CHARSET
+   CHINESEBIG5_CHARSET GREEK_CHARSET TURKISH_CHARSET HEBREW_CHARSET
+   ARABIC_CHARSET BALTIC_CHARSET RUSSIAN_CHARSET THAI_CHARSET EASTEUROPE_CHARSET
+   OEM_CHARSET JOHAB_CHARSET VIETNAMESE_CHARSET MAC_CHARSET BALTIC_CHARSET
+   JOHAB_CHARSET VIETNAMESE_CHARSET OUT_DEFAULT_PRECIS OUT_STRING_PRECIS
+   OUT_CHARACTER_PRECIS OUT_STROKE_PRECIS OUT_TT_PRECIS OUT_DEVICE_PRECIS
+   OUT_RASTER_PRECIS OUT_TT_ONLY_PRECIS OUT_OUTLINE_PRECIS CLIP_DEFAULT_PRECIS
+   CLIP_CHARACTER_PRECIS CLIP_STROKE_PRECIS CLIP_MASK CLIP_LH_ANGLES
+   CLIP_TT_ALWAYS CLIP_EMBEDDED DEFAULT_QUALITY DRAFT_QUALITY PROOF_QUALITY
+   NONANTIALIASED_QUALITY ANTIALIASED_QUALITY DEFAULT_PITCH FIXED_PITCH
+   VARIABLE_PITCH MONO_FONT FF_DECORATIVE FF_DONTCARE FF_MODERN FF_ROMAN
+   FF_SCRIPT FF_SWISS PANOSE_COUNT PAN_FAMILYTYPE_INDEX PAN_SERIFSTYLE_INDEX
+   PAN_WEIGHT_INDEX PAN_PROPORTION_INDEX PAN_CONTRAST_INDEX
+   PAN_STROKEVARIATION_INDEX PAN_ARMSTYLE_INDEX PAN_LETTERFORM_INDEX
+   PAN_MIDLINE_INDEX PAN_XHEIGHT_INDEX PAN_CULTURE_LATIN PAN_ANY PAN_NO_FIT
+   PAN_FAMILY_TEXT_DISPLAY PAN_FAMILY_SCRIPT PAN_FAMILY_DECORATIVE
+   PAN_FAMILY_PICTORIAL PAN_SERIF_COVE PAN_SERIF_OBTUSE_COVE
+   PAN_SERIF_SQUARE_COVE PAN_SERIF_OBTUSE_SQUARE_COVE PAN_SERIF_SQUARE
+   PAN_SERIF_THIN PAN_SERIF_BONE PAN_SERIF_EXAGGERATED PAN_SERIF_TRIANGLE
+   PAN_SERIF_NORMAL_SANS PAN_SERIF_OBTUSE_SANS PAN_SERIF_PERP_SANS
+   PAN_SERIF_FLARED PAN_SERIF_ROUNDED PAN_WEIGHT_VERY_LIGHT PAN_WEIGHT_LIGHT
+   PAN_WEIGHT_THIN PAN_WEIGHT_BOOK PAN_WEIGHT_MEDIUM PAN_WEIGHT_DEMI
+   PAN_WEIGHT_BOLD PAN_WEIGHT_HEAVY PAN_WEIGHT_BLACK PAN_WEIGHT_NORD
+   PAN_PROP_OLD_STYLE PAN_PROP_MODERN PAN_PROP_EVEN_WIDTH
+   PAN_PROP_EXPANDED PAN_PROP_CONDENSED PAN_PROP_VERY_EXPANDED
+   PAN_PROP_VERY_CONDENSED PAN_PROP_MONOSPACED PAN_CONTRAST_NONE
+   PAN_CONTRAST_VERY_LOW PAN_CONTRAST_LOW PAN_CONTRAST_MEDIUM_LOW
+   PAN_CONTRAST_MEDIUM PAN_CONTRAST_MEDIUM_HIGH PAN_CONTRAST_HIGH
+   PAN_CONTRAST_VERY_HIGH PAN_STROKE_GRADUAL_DIAG PAN_STROKE_GRADUAL_TRAN
+   PAN_STROKE_GRADUAL_VERT PAN_STROKE_GRADUAL_HORZ PAN_STROKE_RAPID_VERT
+   PAN_STROKE_RAPID_HORZ PAN_STROKE_INSTANT_VERT PAN_STRAIGHT_ARMS_HORZ
+   PAN_STRAIGHT_ARMS_WEDGE PAN_STRAIGHT_ARMS_VERT PAN_STRAIGHT_ARMS_SINGLE_SERIF
+   PAN_STRAIGHT_ARMS_DOUBLE_SERIF PAN_BENT_ARMS_HORZ PAN_BENT_ARMS_WEDGE
+   PAN_BENT_ARMS_VERT PAN_BENT_ARMS_SINGLE_SERIF PAN_BENT_ARMS_DOUBLE_SERIF
+   PAN_LETT_NORMAL_CONTACT PAN_LETT_NORMAL_WEIGHTED PAN_LETT_NORMAL_BOXED
+   PAN_LETT_NORMAL_FLATTENED PAN_LETT_NORMAL_ROUNDED PAN_LETT_NORMAL_OFF_CENTER
+   PAN_LETT_NORMAL_SQUARE PAN_LETT_OBLIQUE_CONTACT PAN_LETT_OBLIQUE_WEIGHTED
+   PAN_LETT_OBLIQUE_BOXED PAN_LETT_OBLIQUE_FLATTENED PAN_LETT_OBLIQUE_ROUNDED
+   PAN_LETT_OBLIQUE_OFF_CENTER PAN_LETT_OBLIQUE_SQUARE
+   PAN_MIDLINE_STANDARD_TRIMMED PAN_MIDLINE_STANDARD_POINTED
+   PAN_MIDLINE_STANDARD_SERIFED PAN_MIDLINE_HIGH_TRIMMED
+   PAN_MIDLINE_HIGH_POINTED PAN_MIDLINE_HIGH_SERIFED
+   PAN_MIDLINE_CONSTANT_TRIMMED PAN_MIDLINE_CONSTANT_POINTED
+   PAN_MIDLINE_CONSTANT_SERIFED PAN_MIDLINE_LOW_TRIMMED PAN_MIDLINE_LOW_POINTED
+   PAN_MIDLINE_LOW_SERIFED PAN_XHEIGHT_CONSTANT_SMALL PAN_XHEIGHT_CONSTANT_STD
+   PAN_XHEIGHT_CONSTANT_LARGE PAN_XHEIGHT_DUCKING_SMALL PAN_XHEIGHT_DUCKING_STD
+   PAN_XHEIGHT_DUCKING_LARGE FS_LATIN1 FS_LATIN2 FS_CYRILLIC FS_GREEK FS_TURKISH
+   FS_HEBREW FS_ARABIC FS_BALTIC FS_THAI FS_JISJAPAN FS_CHINESESIMP FS_WANSUNG
+   FS_CHINESETRAD FS_JOHAB FS_SYMBOL HS_BDIAGONAL HS_CROSS HS_DIAGCROSS
+   HS_FDIAGONAL HS_HORIZONTAL HS_VERTICAL PS_GEOMETRIC PS_COSMETIC
+   PS_ALTERNATE PS_SOLID PS_DASH PS_DOT PS_DASHDOT PS_DASHDOTDOT
+   PS_NULL PS_USERSTYLE PS_INSIDEFRAME PS_ENDCAP_ROUND PS_ENDCAP_SQUARE
+   PS_ENDCAP_FLAT PS_JOIN_BEVEL PS_JOIN_MITER PS_JOIN_ROUND PS_STYLE_MASK
+   PS_ENDCAP_MASK PS_TYPE_MASK ALTERNATE WINDING DC_BINNAMES DC_BINS
+   DC_COPIES DC_DRIVER DC_DATATYPE_PRODUCED DC_DUPLEX DC_EMF_COMPLIANT
+   DC_ENUMRESOLUTIONS DC_EXTRA DC_FIELDS DC_FILEDEPENDENCIES DC_MAXEXTENT
+   DC_MINEXTENT DC_ORIENTATION DC_PAPERNAMES DC_PAPERS DC_PAPERSIZE
+   DC_SIZE DC_TRUETYPE DCTT_BITMAP DCTT_DOWNLOAD DCTT_SUBDEV-lmsimg32
+   DCTT_DOWNLOAD_OUTLINE DC_VERSION DC_BINADJUST DC_EMF_COMPLIANT
+   DC_DATATYPE_PRODUCED DC_MANUFACTURER DC_MODqEL DCBA_FACEUPNONE
+   DCBA_FACEUPCENTER DCBA_FACEUPLEFT DCBA_FACEUPRIGHT DCBA_FACEDOWNNONE
+   DCBA_FACEDOWNCENTER DCBA_FACEDOWNLEFT DCBA_FACEDOWNRIGHT FLOODFILLBORDER
+   FLOODFILLSURFACE ETO_CLIPPED ETO_GLYPH_INDEX ETO_OPAQUE ETO_RTLREADING
+   GDICOMMENT_BEGINGROUP GDICOMMENT_ENDGROUP GDICOMMENT_MULTIFORMATS
+   GDICOMMENT_IDENTIFIER AD_COUNTERCLOCKWISE AD_CLOCKWISE RDH_RECTANGLES
+   GCPCLASS_LATIN GCPCLASS_HEBREW GCPCLASS_ARABIC GCPCLASS_NEUTRAL
+   GCPCLASS_LOCALNUMBER GCPCLASS_LATINNUMBER GCPCLASS_LATINNUMERICTERMINATOR
+   GCPCLASS_LATINNUMERICSEPARATOR GCPCLASS_NUMERICSEPARATOR GCPCLASS_PREBOUNDLTR
+   GCPCLASS_PREBOUNDRTL GCPCLASS_POSTBOUNDLTR GCPCLASS_POSTBOUNDRTL
+   GCPGLYPH_LINKBEFORE GCPGLYPH_LINKAFTER DCB_DISABLE DCB_ENABLE DCB_RESET
+   DCB_SET DCB_ACCUMULATE DCB_DIRTY OBJ_BRUSH OBJ_PEN OBJ_PAL OBJ_FONT
+   OBJ_BITMAP OBJ_EXTPEN OBJ_REGION OBJ_DC OBJ_MEMDC OBJ_METAFILE OBJ_METADC
+   OBJ_ENHMETAFILE OBJ_ENHMETADC DRIVERVERSION TECHNOLOGY DT_PLOTTER
+   DT_RASDISPLAY DT_RASPRINTER DT_RASCAMERA DT_CHARSTREAM DT_METAFILE
+   DT_DISPFILE HORZSIZE VERTSIZE HORZRES VERTRES LOGPIXELSX LOGPIXELSY BITSPIXEL
+   PLANES NUMBRUSHES NUMPENS NUMFONTS NUMCOLORS NUMMARKERS ASPECTX
+   ASPECTY ASPECTXY PDEVICESIZE CLIPCAPS SIZEPALETTE NUMRESERVED
+   COLORRES PHYSICALWIDTH PHYSICALHEIGHT PHYSICALOFFSETX PHYSICALOFFSETY
+   SCALINGFACTORX SCALINGFACTORY VREFRESH DESKTOPHORZRES DESKTOPVERTRES
+   BLTALIGNMENT RASTERCAPS RC_BANDING RC_BITBLT RC_BITMAP64 RC_DI_BITMAP
+   RC_DIBTODEV RC_FLOODFILL RC_GDI20_OUTPUT RC_PALETTE RC_SCALING
+   RC_STRETCHBLT RC_STRETCHDIB RC_DEVBITS RC_OP_DX_OUTPUT CURVECAPS
+   CC_NONE CC_CIRCLES CC_PIE CC_CHORD CC_ELLIPSES CC_WIDE CC_STYLED
+   CC_WIDESTYLED CC_INTERIORS CC_ROUNDRECT LINECAPS LC_NONE LC_POLYLINE
+   LC_MARKER LC_POLYMARKER LC_WIDE LC_STYLED LC_WIDESTYLED LC_INTERIORS
+   POLYGONALCAPS RC_BANDING RC_BIGFONT RC_BITBLT RC_BITMAP64 RC_DEVBITS
+   RC_DI_BITMAP RC_GDI20_OUTPUT RC_GDI20_STATE RC_NONE RC_OP_DX_OUTPUT
+   RC_PALETTE RC_SAVEBITMAP RC_SCALING PC_NONE PC_POLYGON PC_POLYPOLYGON
+   PC_PATHS PC_RECTANGLE PC_WINDPOLYGON PC_SCANLINE PC_TRAPEZOID PC_WIDE
+   PC_STYLED PC_WIDESTYLED PC_INTERIORS PC_PATHS TEXTCAPS TC_OP_CHARACTER
+   TC_OP_STROKE TC_CP_STROKE TC_CR_90 TC_CR_ANY TC_SF_X_YINDEP TC_SA_DOUBLE
+   TC_SA_INTEGER TC_SA_CONTIN TC_EA_DOUBLE TC_IA_ABLE TC_UA_ABLE TC_SO_ABLE
+   TC_RA_ABLE TC_VA_ABLE TC_RESERVED TC_SCROLLBLT GCP_DBCS GCP_ERROR GCP_CLASSIN
+   GCP_DIACRITIC GCP_DISPLAYZWG GCP_GLYPHSHAPE GCP_JUSTIFY GCP_JUSTIFYIN
+   GCP_KASHIDA GCP_LIGATE GCP_MAXEXTENT GCP_NEUTRALOVERRIDE GCP_NUMERICOVERRIDE
+   GCP_NUMERICSLATIN GCP_NUMERICSLOCAL GCP_REORDER GCP_SYMSWAPOFF GCP_USEKERNING
+   FLI_GLYPHS GGO_BITMAP GGO_NATIVE GGO_METRICS GGO_GRAY2_BITMAP
+   GGO_GRAY4_BITMAP GGO_GRAY8_BITMAP GGO_GLYPH_INDEX GM_COMPATIBLE GM_ADVANCED
+   MM_ANISOTROPIC MM_HIENGLISH MM_HIMETRIC MM_ISOTROPIC MM_LOENGLISH MM_LOMETRIC
+   MM_TEXT MM_TWIPS ABSOLUTE RELATIVE PC_EXPLICIT PC_NOCOLLAPSE PC_RESERVED
+   CLR_DEFAULT PT_MOVETO PT_LINETO PT_BEZIERTO PT_CLOSEFIGURE TT_AVAILABLE
+   TT_ENABLED BLACK_BRUSH DKGRAY_BRUSH GRAY_BRUSH HOLLOW_BRUSH LTGRAY_BRUSH
+   NULL_BRUSH WHITE_BRUSH BLACK_PEN NULL_PEN WHITE_PEN ANSI_FIXED_FONT
+   ANSI_VAR_FONT DEVICE_DEFAULT_FONT DEFAULT_GUI_FONT OEM_FIXED_FONT
+   SYSTEM_FONT SYSTEM_FIXED_FONT DEFAULT_PALETTE SYSPAL_NOSTATIC SYSPAL_STATIC
+   SYSPAL_ERROR TA_BASELINE TA_BOTTOM TA_TOP TA_CENTER TA_LEFT TA_RIGHT
+   TA_RTLREADING TA_NOUPDATECP TA_UPDATECP VTA_BASELINE VTA_CENTER MWT_IDENTITY
+   MWT_LEFTMULTIPLY MWT_RIGHTMULTIPLY OPAQUE TRANSPARENT BLACKONWHITE
+   WHITEONBLACK COLORONCOLOR HALFTONE MAXSTRETCHBLTMODE STRETCH_ANDSCANS
+   STRETCH_DELETESCANS STRETCH_HALFTONE STRETCH_ORSCANS TCI_SRCCHARSET
+   TCI_SRCCODEPAGE TCI_SRCFONTSIG ICM_ON ICM_OFF ICM_QUERY NEWFRAME ABORTDOC
+   NEXTBAND SETCOLORTABLE GETCOLORTABLE FLUSHOUTPUT DRAFTMODE QUERYESCSUPPORT
+   SETABORTPROC STARTDOC ENDDOC GETPHYSPAGESIZE GETPRINTINGOFFSET
+   GETSCALINGFACTOR MFCOMMENT GETPENWIDTH SETCOPYCOUNT SELECTPAPERSOURCE
+   DEVICEDATA PASSTHROUGH GETTECHNOLGY GETTECHNOLOGY SETLINECAP SETLINEJOIN
+   SETMITERLIMIT BANDINFO DRAWPATTERNRECT GETVECTORPENSIZE GETVECTORBRUSHSIZE
+   ENABLEDUPLEX GETSETPAPERBINS GETSETPRINTORIENT ENUMPAPERBINS SETDIBSCALING
+   EPSPRINTING ENUMPAPERMETRICS GETSETPAPERMETRICS POSTSCRIPT_DATA
+   POSTSCRIPT_IGNORE MOUSETRAILS GETDEVICEUNITS GETEXTENDEDTEXTMETRICS
+   GETEXTENTTABLE GETPAIRKERNTABLE GETTRACKKERNTABLE EXTTEXTOUT GETFACENAME
+   DOWNLOADFACE ENABLERELATIVEWIDTHS ENABLEPAIRKERNING SETKERNTRACK
+   SETALLJUSTVALUES SETCHARSET STRETCHBLT GETSETSCREENPARAMS QUERYDIBSUPPORT
+   BEGIN_PATH CLIP_TO_PATH END_PATH EXT_DEVICE_CAPS RESTORE_CTM SAVE_CTM
+   SET_ARC_DIRECTION SET_BACKGROUND_COLOR SET_POLY_MODE SET_SCREEN_ANGLE
+   SET_SPREAD TRANSFORM_CTM SET_CLIP_BOX SET_BOUNDS SET_MIRROR_MODE
+   OPENCHANNEL DOWNLOADHEADER CLOSECHANNEL POSTSCRIPT_PASSTHROUGH
+   ENCAPSULATED_POSTSCRIPT QDI_SETDIBITS QDI_GETDIBITS QDI_DIBTOSCREEN
+   QDI_STRETCHDIB SP_NOTREPORTED PR_JOBSTATUS ASPECT_FILTERING BS_SOLID
+   BS_NULL BS_HOLLOW BS_HATCHED BS_PATTERN BS_INDEXED BS_DIBPATTERN
+   BS_DIBPATTERNPT BS_PATTERN8X8 BS_DIBPATTERN8X8 LCS_CALIBRATED_RGB
+   LCS_DEVICE_RGB LCS_DEVICE_CMYK LCS_GM_BUSINESS LCS_GM_GRAPHICS
+   LCS_GM_IMAGES RASTER_FONTTYPE DEVICE_FONTTYPE TRUETYPE_FONTTYPE
+   DMORIENT_PORTRAIT DMORIENT_LANDSCAPE DMPAPER_FIRST DMPAPER_LETTER
+   DMPAPER_LETTERSMALL DMPAPER_TABLOID DMPAPER_LEDGER DMPAPER_LEGAL
+   DMPAPER_STATEMENT DMPAPER_EXECUTIVE DMPAPER_A3 DMPAPER_A4 DMPAPER_A4SMALL
+   DMPAPER_A5 DMPAPER_B4 DMPAPER_B5 DMPAPER_FOLIO DMPAPER_QUARTO DMPAPER_10X14
+   DMPAPER_11X17 DMPAPER_NOTE DMPAPER_ENV_9 DMPAPER_ENV_10 DMPAPER_ENV_11
+   DMPAPER_ENV_12 DMPAPER_ENV_14 DMPAPER_CSHEET DMPAPER_DSHEET DMPAPER_ESHEET
+   DMPAPER_ENV_DL DMPAPER_ENV_C5 DMPAPER_ENV_C3 DMPAPER_ENV_C4 DMPAPER_ENV_C6
+   DMPAPER_ENV_C65 DMPAPER_ENV_B4 DMPAPER_ENV_B5 DMPAPER_ENV_B6
+   DMPAPER_ENV_ITALY DMPAPER_ENV_MONARCH DMPAPER_ENV_PERSONAL DMPAPER_FANFOLD_US
+   DMPAPER_FANFOLD_STD_GERMAN DMPAPER_FANFOLD_LGL_GERMAN DMPAPER_ISO_B4
+   DMPAPER_JAPANESE_POSTCARD DMPAPER_9X11 DMPAPER_10X11 DMPAPER_15X11
+   DMPAPER_ENV_INVITE DMPAPER_RESERVED_48 DMPAPER_RESERVED_49
+   DMPAPER_LETTER_EXTRA DMPAPER_LEGAL_EXTRA DMPAPER_TABLOID_EXTRA
+   DMPAPER_A4_EXTRA DMPAPER_LETTER_TRANSVERSE DMPAPER_A4_TRANSVERSE
+   DMPAPER_LETTER_EXTRA_TRANSVERSE DMPAPER_A_PLUS DMPAPER_B_PLUS
+   DMPAPER_LETTER_PLUS DMPAPER_A4_PLUS DMPAPER_A5_TRANSVERSE
+   DMPAPER_B5_TRANSVERSE DMPAPER_A3_EXTRA DMPAPER_A5_EXTRA DMPAPER_B5_EXTRA
+   DMPAPER_A2 DMPAPER_A3_TRANSVERSE DMPAPER_A3_EXTRA_TRANSVERSE DMPAPER_LAST
+   DMPAPER_USER DMBIN_FIRST DMBIN_UPPER DMBIN_ONLYONE DMBIN_LOWER DMBIN_MIDDLE
+   DMBIN_MANUAL DMBIN_ENVELOPE DMBIN_ENVMANUAL DMBIN_AUTO DMBIN_TRACTOR
+   DMBIN_SMALLFMT DMBIN_LARGEFMT DMBIN_LARGECAPACITY DMBIN_CASSETTE
+   DMBIN_FORMSOURCE DMBIN_LAST DMBIN_USER DMCOLOR_MONOCHROME DMCOLOR_COLOR
+   DMDUP_SIMPLEX DMDUP_VERTICAL DMDUP_HORIZONTAL DMTT_BITMAP DMTT_DOWNLOAD
+   DMTT_SUBDEV DMTT_DOWNLOAD_OUTLINE DMCOLLATE_FALSE DMCOLLATE_TRUE
+   DM_GRAYSCALE DM_INTERLACED DM_UPDATE DM_COPY DM_PROMPT DM_MODIFY
+   DM_ORIENTATION DM_PAPERSIZE DM_PAPERLENGTH DM_PAPERWIDTH DM_SCALE DM_COPIES
+   DM_DEFAULTSOURCE DM_PRINTQUALITY DM_COLOR DM_DUPLEX DM_YRESOLUTION
+   DM_TTOPTION DM_COLLATE DM_FORMNAME DM_LOGPIXELS DM_BITSPERPEL DM_PELSWIDTH
+   DM_PELSHEIGHT DM_DISPLAYFLAGS DM_DISPLAYFREQUENCY DM_ICMMETHOD DM_ICMINTENT
+   DM_MEDIATYPE DM_DITHERTYPE DMICMMETHOD_NONE DMICMMETHOD_SYSTEM
+   DMICMMETHOD_DRIVER DMICMMETHOD_DEVICE DMICMMETHOD_USER DMICM_SATURATE
+   DMICM_CONTRAST DMICM_COLORMETRIC DMICM_USER DMMEDIA_STANDARD
+   DMMEDIA_TRANSPARENCY DMMEDIA_GLOSSY DMMEDIA_USER DMDITHER_NONE
+   DMDITHER_COARSE DMDITHER_FINE DMDITHER_LINEART DMDITHER_ERRORDIFFUSION
+   DMDITHER_RESERVED6 DMDITHER_RESERVED7 DMDITHER_RESERVED8 DMDITHER_RESERVED9
+   DMDITHER_GRAYSCALE DMDITHER_USER TMPF_FIXED_PITCH TMPF_VECTOR TMPF_TRUETYPE
+   TMPF_DEVICE NTM_ITALIC NTM_BOLD NTM_REGULAR TT_POLYGON_TYPE TT_PRIM_LINE
+   TT_PRIM_QSPLINE FONTMAPPER_MAX ENHMETA_STOCK_OBJECT WGL_FONT_LINES
+   WGL_FONT_POLYGONS LPD_DOUBLEBUFFER LPD_STEREO LPD_SUPPORT_GDI
+   LPD_SUPPORT_OPENGL LPD_SHARE_DEPTH LPD_SHARE_STENCIL LPD_SHARE_ACCUM
+   LPD_SWAP_EXCHANGE LPD_SWAP_COPY LPD_TRANSPARENT LPD_TYPE_RGBA
+   LPD_TYPE_COLORINDEX IDC_STATIC IDC_ARROW IDC_IBEAM IDC_WAIT IDC_CROSS
+   IDC_UPARROW IDC_SIZENWSE IDC_SIZENESW IDC_SIZEWE IDC_SIZENS IDC_SIZEALL
+   IDC_NO IDC_HAND IDC_APPSTARTING IDC_HELP IDC_ICON IDC_SIZE
+   WGL_SWAP_MAIN_PLANE WGL_SWAP_OVERLAY1 WGL_SWAP_OVERLAY2
+   WGL_SWAP_OVERLAY3 WGL_SWAP_OVERLAY4 WGL_SWAP_OVERLAY5 WGL_SWAP_OVERLAY6
+   WGL_SWAP_OVERLAY7 WGL_SWAP_OVERLAY8 WGL_SWAP_OVERLAY9 WGL_SWAP_OVERLAY10
+   WGL_SWAP_OVERLAY11 WGL_SWAP_OVERLAY12 WGL_SWAP_OVERLAY13 WGL_SWAP_OVERLAY14
+   WGL_SWAP_OVERLAY15 WGL_SWAP_UNDERLAY1 WGL_SWAP_UNDERLAY2 WGL_SWAP_UNDERLAY3
+   WGL_SWAP_UNDERLAY4 WGL_SWAP_UNDERLAY5 WGL_SWAP_UNDERLAY6 WGL_SWAP_UNDERLAY7
+   WGL_SWAP_UNDERLAY8 WGL_SWAP_UNDERLAY9 WGL_SWAP_UNDERLAY10 WGL_SWAP_UNDERLAY11
+   WGL_SWAP_UNDERLAY12 WGL_SWAP_UNDERLAY13 WGL_SWAP_UNDERLAY14
+   WGL_SWAP_UNDERLAY15 RGB
+   WS_BORDER WS_CAPTION WS_CHILD WS_CHILDWINDOW WS_CLIPCHILDREN WS_CLIPSIBLINGS
+   WS_DISABLED WS_DLGFRAME WS_GROUP WS_HSCROLL WS_ICONIC WS_MAXIMIZE
+   WS_MAXIMIZEBOX WS_MINIMIZE WS_MINIMIZEBOX WS_OVERLAPPED WS_OVERLAPPEDWINDOW
+   WS_POPUP WS_POPUPWINDOW WS_SIZEBOX WS_SYSMENU WS_TABSTOP WS_THICKFRAME
+   WS_TILED WS_TILEDWINDOW WS_VISIBLE WS_VSCROLL WS_EX_ACCEPTFILES
+   WS_EX_APPWINDOW WS_EX_CLIENTEDGE WS_EX_CONTEXTHELP WS_EX_CONTROLPARENT
+   WS_EX_DLGMODALFRAME WS_EX_LEFT WS_EX_LEFTSCROLLBAR WS_EX_LTRREADING
+   WS_EX_MDICHILD WS_EX_NOPARENTNOTIFY WS_EX_OVERLAPPEDWINDOW
+   WS_EX_PALETTEWINDOW WS_EX_RIGHT WS_EX_RIGHTSCROLLBAR WS_EX_RTLREADING
+   WS_EX_STATICEDGE WS_EX_TOOLWINDOW WS_EX_TOPMOST WS_EX_TRANSPARENT
+   WS_EX_WINDOWEDGE
+   WM_ACTIVATE WM_ACTIVATEAPP WM_AFXFIRST WM_AFXLAST WM_ASKCBFORMATNAME
+   WM_CANCELJOURNAL WM_CANCELMODE WM_CAPTURECHANGED WM_CHANGECBCHAIN
+   WM_CHAR WM_CHARTOITEM WM_CHILDACTIVATE WM_CLEAR WM_CLOSE WM_COMMAND
+   WM_COMPACTING WM_COMPAREITEM WM_CONTEXTMENU WM_COPY WM_COPYDATA WM_CREATE
+   WM_CTLCOLORBTN WM_CTLCOLORDLG WM_CTLCOLOREDIT WM_CTLCOLORLISTBOX
+   WM_CTLCOLORMSGBOX WM_CTLCOLORSCROLLBAR WM_CTLCOLORSTATIC WM_CUT WM_DEADCHAR
+   WM_DELETEITEM WM_DESTROY WM_DESTROYCLIPBOARD WM_DEVICECHANGE WM_DEVMODECHANGE
+   WM_DISPLAYCHANGE WM_DRAWCLIPBOARD WM_DRAWITEM WM_DROPFILES WM_ENABLE
+   WM_ENDSESSION WM_ENTERIDLE WM_ENTERMENULOOP WM_ENTERSIZEMOVE WM_ERASEBKGND
+   WM_EXITMENULOOP WM_EXITSIZEMOVE WM_FONTCHANGE WM_GETDLGCODE WM_GETFONT
+   WM_GETHOTKEY WM_GETICON WM_GETMINMAXINFO WM_GETTEXT WM_GETTEXTLENGTH
+   WM_HANDHELDFIRST WM_HANDHELDLAST WM_HELP WM_HOTKEY WM_HSCROLL
+   WM_HSCROLLCLIPBOARD WM_ICONERASEBKGND WM_INITDIALOG WM_INITMENU
+   WM_INITMENUPOPUP WM_INPUTLANGCHANGE WM_INPUTLANGCHANGEREQUEST WM_KEYDOWN
+   WM_KEYUP WM_KILLFOCUS WM_MDIACTIVATE WM_MDICASCADE WM_MDICREATE WM_MDIDESTROY
+   WM_MDIGETACTIVE WM_MDIICONARRANGE WM_MDIMAXIMIZE WM_MDINEXT WM_MDIREFRESHMENU
+   WM_MDIRESTORE WM_MDISETMENU WM_MDITILE WM_MEASUREITEM WM_MENUCHAR
+   WM_MENUSELECT WM_NEXTMENU WM_MOVE WM_MOVING WM_NCACTIVATE WM_NCCALCSIZE
+   WM_NCCREATE WM_NCDESTROY WM_NCHITTEST WM_NCLBUTTONDBLCLK WM_NCLBUTTONDOWN
+   WM_NCLBUTTONUP WM_NCMBUTTONDBLCLK WM_NCMBUTTONDOWN WM_NCMBUTTONUP
+   WM_NCMOUSEMOVE WM_NCPAINT WM_NCRBUTTONDBLCLK WM_NCRBUTTONDOWN WM_NCRBUTTONUP
+   WM_NEXTDLGCTL WM_NEXTMENU WM_NOTIFY WM_NOTIFYFORMAT WM_NULL WM_PAINT
+   WM_PAINTCLIPBOARD WM_PAINTICON WM_PALETTECHANGED WM_PALETTEISCHANGING
+   WM_PARENTNOTIFY WM_PASTE WM_PENWINFIRST WM_PENWINLAST WM_POWER
+   WM_POWERBROADCAST WM_PRINT WM_PRINTCLIENT WM_QUERYDRAGICON
+   WM_QUERYENDSESSION WM_QUERYNEWPALETTE WM_QUERYOPEN WM_QUEUESYNC WM_QUIT
+   WM_RENDERALLFORMATS WM_RENDERFORMAT WM_SETCURSOR WM_SETFOCUS WM_SETFONT
+   WM_SETHOTKEY WM_SETICON WM_SETREDRAW WM_SETTEXT WM_SETTINGCHANGE
+   WM_SHOWWINDOW WM_SIZE WM_SIZECLIPBOARD WM_SIZING WM_SPOOLERSTATUS
+   WM_STYLECHANGED WM_STYLECHANGING WM_SYSCHAR WM_SYSCOLORCHANGE WM_SYSCOMMAND
+   WM_SYSDEADCHAR WM_SYSKEYDOWN WM_SYSKEYUP WM_TCARD WM_TIMECHANGE WM_TIMER
+   WM_UNDO WM_USER WM_USERCHANGED WM_VKEYTOITEM WM_VSCROLL WM_VSCROLLCLIPBOARD
+   WM_WINDOWPOSCHANGED WM_WINDOWPOSCHANGING WM_WININICHANGE WM_KEYFIRST
+   WM_KEYLAST WM_SYNCPAINT WM_MOUSEACTIVATE WM_MOUSEMOVE WM_LBUTTONDOWN
+   WM_LBUTTONUP WM_LBUTTONDBLCLK WM_RBUTTONDOWN WM_RBUTTONUP WM_RBUTTONDBLCLK
+   WM_MBUTTONDOWN WM_MBUTTONUP WM_MBUTTONDBLCLK WM_MOUSEWHEEL WM_MOUSEFIRST
+   WM_MOUSELAST WM_MOUSEHOVER WM_MOUSELEAVE
+   SW_HIDE SW_NORMAL SW_SHOWNORMAL SW_SHOWMINIMIZED SW_MAXIMIZE
+   SW_SHOWMAXIMIZED SW_SHOWNOACTIVATE SW_SHOW SW_MINIMIZE SW_SHOWMINNOACTIVE
+   SW_SHOWNA SW_RESTORE SW_SHOWDEFAULT SW_FORCEMINIMIZE SW_MAX
+   SW_PARENTCLOSING SW_OTHERZOOM SW_PARENTOPENING SW_OTHERUNZOOM
+   SW_SCROLLCHILDREN SW_INVALIDATE SW_ERASE
+   ; functions
+   AnimatePalette ChoosePixelFormat CreateBitmap CreateDIBPatternBrushPt
+CreatePolyPolygonRgn CreatePolygonRgn CreateScalableFontResourceA
+CreateScalableFontResourceW DPtoLP DescribePixelFormat DrawEscape ExtCreatePen
+ExtCreateRegion FixBrushOrgEx GdiComment GdiFlush GDIGetBatchLimit LPtoDP
+ModifyWorldTransform MoveToEx OffsetViewportOrgEx OffsetWindowOrgEx
+PlayEnhMetaFileRecord PlayMetaFileRecord PolyBezier PolyBezierTo PolyDraw
+PolyPolygon PolyPolyline PolyTextOutA PolyTextOutW Polygon Polyline PolylineTo
+SetBitmapBits SetBitmapDimensionEx SetBoundsRect SetBrushOrgEx SetDIBColorTable
+SetEnhMetaFileBits SetMetaFileBitsEx SetPaletteEntries SetPixelFormat
+SetViewportExtEx SetViewportOrgEx SetWinMetaFileBits SetWindowExtEx
+SetWindowOrgEx StartDocA StartDocW TextOutA TextOutW UpdateICMRegKeyA
+UpdateICMRegKeyW AbortDoc AbortPath AddAtomA AddAtomW BeginPath CancelDC
+CloseEnhMetaFile CloseFigure CloseMetaFile ColorMatchToTarget CombineRgn
+CreateCompatibleBitmap CreateCompatibleDC CreateDIBPatternBrush
+CreateDiscardableBitmap CreateEllipticRgn CreateHalftonePalette CreateHatchBrush
+CreatePatternBrush CreatePen CreateRectRgn CreateSolidBrush DeleteColorSpace
+DeleteDC DeleteEnhMetaFile DeleteMetaFile DeleteObject Ellipse EndDoc EndPage
+EndPath EqualRgn EscapeCommFunction ExcludeClipRect ExtFloodFill
+ExtSelectClipRgn FillPath FillRgn FindAtomA FindAtomW FlattenPath FloodFill
+FrameRgn GdiSetBatchLimit GetArcDirection GetBkColor GetBkMode GetClipRgn
+GetColorSpace GetCurrentObject GetFontLanguageInfo GetGraphicsMode GetMapMode
+GetMetaRgn GetNearestColor GetNearestPaletteIndex GetObjectType GetPixel
+GetPixelFormat GetPolyFillMode GETROP2 GetStockObject GetStretchBltMode
+GetSystemPaletteUse GetTextAlign GetTextCharacterExtra GetTextCharset
+GetTextColor GlobalAddAtomA GlobalAddAtomW GlobalFindAtomA GlobalFindAtomW
+IntersectClipRect InvertRgn LineTo LoadCursorFromFileA LoadCursorFromFileW
+OffsetClipRgn OffsetRgn PaintRgn PathToRegion PlayMetaFile PtInRegion PtVisible
+RealizePalette Rectangle ResizePalette RestoreDC SaveDC SelectClipPath
+SelectClipRgn SelectObject SetArcDirection SetBkColor SetBkMode SetColorSpace
+SetGraphicsMode SetICMMode SetMapMode SetMapperFlags SetMetaRgn SetPolyFillMode
+SETROP2 SetRectRgn SetStretchBltMode SetSystemPaletteUse SetTextAlign
+SetTextCharacterExtra SetTextJustification ShowWindow ShowWindowAsync StartPage
+StrokeAndFillPath StrokePath SwapBuffers UnrealizeObject UpdateColors
+UpdateWindow WidenPath CheckColorsInGamut CombineTransform CreateDIBSection
+EnumEnhMetaFile EnumFontFamiliesA EnumFontFamiliesExA EnumFontFamiliesExW
+EnumFontFamiliesW EnumFontsA EnumFontsW EnumICMProfilesA EnumICMProfilesW
+EnumMetaFile EnumObjects GetAspectRatioFilterEx GetBitmapBits
+GetBitmapDimensionEx GetBoundsRect GetBrushOrgEx GetCharABCWidthsA
+GetCharABCWidthsFloatA GetCharABCWidthsFloatW GetCharABCWidthsW GETCHARWIDTH32A
+GETCHARWIDTH32W GetCharWidthA GetCharWidthW GETCLIENTRECT GetClipBox
+GetColorAdjustment GetCurrentPositionEx GetDCOrgEx GetDIBColorTable
+GetDeviceGammaRamp GetEnhMetaFileA GetEnhMetaFileDescriptionA
+GetEnhMetaFileDescriptionW GetEnhMetaFileHeader GetEnhMetaFilePaletteEntries
+GetEnhMetaFilePixelFormat GetEnhMetaFileW GetFontData GetICMProfileA
+GetICMProfileW GetKerningPairsA GetKerningPairsW GetLogColorSpaceA
+GetLogColorSpaceW GetMetaFileA GetMetaFileBitsEx GetMetaFileW GetObjectA
+GetObjectW GetOutlineTextMetricsA GetOutlineTextMetricsW GetPaletteEntries
+GetPath GetRasterizerCaps GetRegionData GetRgnBox GetSystemPaletteEntries
+GetTextCharsetInfo GetTextExtentPoint32A GetTextExtentPoint32W
+GetTextExtentPointA GetTextExtentPointW GetTextFaceA GetTextFaceW
+GetTextMetricsA GetTextMetricsW GetViewportExtEx GetViewportOrgEx
+GetWinMetaFileBits GetWindowExtEx GetWindowOrgEx GetWorldTransform Escape
+SetAbortProc GetCharWidthFloatA GetCharWidthFloatW GetMiterLimit SetMiterLimit
+LineDDA TranslateCharsetInfo AddFontResourceA AddFontResourceW CopyEnhMetaFileA
+CopyEnhMetaFileW CopyMetaFileA CopyMetaFileW CreateBitmapIndirect
+CreateBrushIndirect CreateColorSpaceA CreateColorSpaceW CreateDCA CreateDCW
+CreateEllipticRgnIndirect CreateEnhMetaFileA CreateEnhMetaFileW
+CreateFontIndirectA CreateFontIndirectW CreateICA CreateICW
+CreateIconFromResource CreateIconIndirect CreateMetaFileA CreateMetaFileW
+CreatePalette CreatePenIndirect CreateRectRgnIndirect CREATEWINDOWINDIRECTA
+FillRect GetDeviceCaps GetSystemMetrics LoadCursorA LoadCursorW PlayEnhMetaFile
+RectInRegion RectVisible RegisterClassA RegisterClassW RemoveFontResourceA
+RemoveFontResourceW ResetDCA ResetDCW SelectPalette SetColorAdjustment
+SetDeviceGammaRamp SetICMProfileA SetICMProfileW SetPixel SetPixelV SetTextColor
+SetWorldTransform Arc AngleArc ArcTo BitBlt Chord CreateDIBitmap CreateFontA
+CreateFontW CreateIcon CreateIconFromResourceEx CreateRoundRectRgn
+CreateWindowExA CreateWindowExW ExtEscape ExtTextOutA ExtTextOutW
+FindFirstFileExA FindFirstFileExW GetCharacterPlacementA GetCharacterPlacementW
+GetDIBits GetGlyphOutlineA GetGlyphOutlineW GetTextExtentExPointA
+GetTextExtentExPointW MaskBlt PatBlt Pie PlgBlt RoundRect ScaleViewportExtEx
+ScaleWindowExtEx SetDIBits SetDIBitsToDevice StretchBlt StretchDIBits
+TabbedTextOutA TabbedTextOutW SearchPathA SearchPathW
+SetCursor GetCursor GetCursorPos SetCursorPos GetCursorInfo #|GetDCPenColor|#
+SetDCPenColor #|GetDCBrushColor|# SetDCBrushColor GetWindowDC GetDCEx
+))
+;;; ERROR deleted manually from above
+;;; GetDCPenColor and GetDCBrushColor are buggy in the cygwin w32api-3.13-1 package
+
+(in-package "GDI")
+
+(defconstant SM_CXSCREEN 0)
+(defconstant SM_CYSCREEN 1)
+(defconstant SM_CXVSCROLL 2)
+(defconstant SM_CYHSCROLL 3)
+(defconstant SM_CYCAPTION 4)
+(defconstant SM_CXBORDER 5)
+(defconstant SM_CYBORDER 6)
+(defconstant SM_CXDLGFRAME 7)
+(defconstant SM_CXFIXEDFRAME 7)
+(defconstant SM_CYDLGFRAME 8)
+(defconstant SM_CYFIXEDFRAME 8)
+(defconstant SM_CYVTHUMB 9)
+(defconstant SM_CXHTHUMB 10)
+(defconstant SM_CXICON 11)
+(defconstant SM_CYICON 12)
+(defconstant SM_CXCURSOR 13)
+(defconstant SM_CYCURSOR 14)
+(defconstant SM_CYMENU 15)
+(defconstant SM_CXFULLSCREEN 16)
+(defconstant SM_CYFULLSCREEN 17)
+(defconstant SM_CYKANJIWINDOW 18)
+(defconstant SM_MOUSEPRESENT 19)
+(defconstant SM_CYVSCROLL 20)
+(defconstant SM_CXHSCROLL 21)
+(defconstant SM_DEBUG 22)
+(defconstant SM_SWAPBUTTON 23)
+(defconstant SM_RESERVED1 24)
+(defconstant SM_RESERVED2 25)
+(defconstant SM_RESERVED3 26)
+(defconstant SM_RESERVED4 27)
+(defconstant SM_CXMIN 28)
+(defconstant SM_CYMIN 29)
+(defconstant SM_CXSIZE 30)
+(defconstant SM_CYSIZE 31)
+(defconstant SM_CXSIZEFRAME 32)
+(defconstant SM_CXFRAME 32)
+(defconstant SM_CYSIZEFRAME 33)
+(defconstant SM_CYFRAME 33)
+(defconstant SM_CXMINTRACK 34)
+(defconstant SM_CYMINTRACK 35)
+(defconstant SM_CXDOUBLECLK 36)
+(defconstant SM_CYDOUBLECLK 37)
+(defconstant SM_CXICONSPACING 38)
+(defconstant SM_CYICONSPACING 39)
+(defconstant SM_MENUDROPALIGNMENT 40)
+(defconstant SM_PENWINDOWS 41)
+(defconstant SM_DBCSENABLED 42)
+(defconstant SM_CMOUSEBUTTONS 43)
+(defconstant SM_SECURE 44)
+(defconstant SM_CXEDGE 45)
+(defconstant SM_CYEDGE 46)
+(defconstant SM_CXMINSPACING 47)
+(defconstant SM_CYMINSPACING 48)
+(defconstant SM_CXSMICON 49)
+(defconstant SM_CYSMICON 50)
+(defconstant SM_CYSMCAPTION 51)
+(defconstant SM_CXSMSIZE 52)
+(defconstant SM_CYSMSIZE 53)
+(defconstant SM_CXMENUSIZE 54)
+(defconstant SM_CYMENUSIZE 55)
+(defconstant SM_ARRANGE 56)
+(defconstant SM_CXMINIMIZED 57)
+(defconstant SM_CYMINIMIZED 58)
+(defconstant SM_CXMAXTRACK 59)
+(defconstant SM_CYMAXTRACK 60)
+(defconstant SM_CXMAXIMIZED 61)
+(defconstant SM_CYMAXIMIZED 62)
+(defconstant SM_NETWORK 63)
+(defconstant SM_CLEANBOOT 67)
+(defconstant SM_CXDRAG 68)
+(defconstant SM_CYDRAG 69)
+(defconstant SM_SHOWSOUNDS 70)
+(defconstant SM_CXMENUCHECK 71)
+(defconstant SM_CYMENUCHECK 72)
+(defconstant SM_SLOWMACHINE 73)
+(defconstant SM_MIDEASTENABLED 74)
+(defconstant SM_MOUSEWHEELPRESENT 75)
+(defconstant SM_XVIRTUALSCREEN 76)
+(defconstant SM_YVIRTUALSCREEN 77)
+(defconstant SM_CXVIRTUALSCREEN 78)
+(defconstant SM_CYVIRTUALSCREEN 79)
+(defconstant SM_CMONITORS 80)
+(defconstant SM_SAMEDISPLAYFORMAT 81)
+;(defconstant SM_CMETRICS 76) use on versions of nt < 4.0
+(defconstant SM_CMETRICS 83)
+
+(defconstant BI_RGB 0)
+(defconstant BI_RLE8 1)
+(defconstant BI_RLE4 2)
+(defconstant BI_BITFIELDS 3)
+(defconstant LF_FACESIZE 32)
+(defconstant LF_FULLFACESIZE 64)
+(defconstant CA_NEGATIVE 1)
+(defconstant CA_LOG_FILTER 2)
+(defconstant ILLUMINANT_DEVICE_DEFAULT 0)
+(defconstant ILLUMINANT_A 1)
+(defconstant ILLUMINANT_B 2)
+(defconstant ILLUMINANT_C 3)
+(defconstant ILLUMINANT_D50 4)
+(defconstant ILLUMINANT_D55 5)
+(defconstant ILLUMINANT_D65 6)
+(defconstant ILLUMINANT_D75 7)
+(defconstant ILLUMINANT_F2 8)
+(defconstant ILLUMINANT_MAX_INDEX ILLUMINANT_F2)
+(defconstant ILLUMINANT_FLUORESCENT ILLUMINANT_F2)
+(defconstant RGB_GAMMA_MIN 2500)
+(defconstant RGB_GAMMA_MAX 65000)
+(defconstant REFERENCE_WHITE_MIN 6000)
+(defconstant REFERENCE_WHITE_MAX 10000)
+(defconstant REFERENCE_BLACK_MIN 0)
+(defconstant REFERENCE_BLACK_MAX 4000)
+(defconstant COLOR_ADJ_MAX 100)
+(defconstant CCHDEVICENAME 32)
+(defconstant CCHFORMNAME 32)
+(defconstant DI_COMPAT 4)
+(defconstant DI_DEFAULTSIZE 8)
+(defconstant DI_IMAGE 2)
+(defconstant DI_MASK 1)
+(defconstant DI_NORMAL 3)
+(defconstant DI_APPBANDING 1)
+(defconstant EMR_HEADER 1)
+(defconstant EMR_POLYBEZIER 2)
+(defconstant EMR_POLYGON 3)
+(defconstant EMR_POLYLINE 4)
+(defconstant EMR_POLYBEZIERTO 5)
+(defconstant EMR_POLYLINETO 6)
+(defconstant EMR_POLYPOLYLINE 7)
+(defconstant EMR_POLYPOLYGON 8)
+(defconstant EMR_SETWINDOWEXTEX 9)
+(defconstant EMR_SETWINDOWORGEX 10)
+(defconstant EMR_SETVIEWPORTEXTEX 11)
+(defconstant EMR_SETVIEWPORTORGEX 12)
+(defconstant EMR_SETBRUSHORGEX 13)
+(defconstant EMR_EOF 14)
+(defconstant EMR_SETPIXELV 15)
+(defconstant EMR_SETMAPPERFLAGS 16)
+(defconstant EMR_SETMAPMODE 17)
+(defconstant EMR_SETBKMODE 18)
+(defconstant EMR_SETPOLYFILLMODE 19)
+(defconstant EMR_SETROP2 20)
+(defconstant EMR_SETSTRETCHBLTMODE 21)
+(defconstant EMR_SETTEXTALIGN 22)
+(defconstant EMR_SETCOLORADJUSTMENT 23)
+(defconstant EMR_SETTEXTCOLOR 24)
+(defconstant EMR_SETBKCOLOR 25)
+(defconstant EMR_OFFSETCLIPRGN 26)
+(defconstant EMR_MOVETOEX 27)
+(defconstant EMR_SETMETARGN 28)
+(defconstant EMR_EXCLUDECLIPRECT 29)
+(defconstant EMR_INTERSECTCLIPRECT 30)
+(defconstant EMR_SCALEVIEWPORTEXTEX 31)
+(defconstant EMR_SCALEWINDOWEXTEX 32)
+(defconstant EMR_SAVEDC 33)
+(defconstant EMR_RESTOREDC 34)
+(defconstant EMR_SETWORLDTRANSFORM 35)
+(defconstant EMR_MODIFYWORLDTRANSFORM 36)
+(defconstant EMR_SELECTOBJECT 37)
+(defconstant EMR_CREATEPEN 38)
+(defconstant EMR_CREATEBRUSHINDIRECT 39)
+(defconstant EMR_DELETEOBJECT 40)
+(defconstant EMR_ANGLEARC 41)
+(defconstant EMR_ELLIPSE 42)
+(defconstant EMR_RECTANGLE 43)
+(defconstant EMR_ROUNDRECT 44)
+(defconstant EMR_ARC 45)
+(defconstant EMR_CHORD 46)
+(defconstant EMR_PIE 47)
+(defconstant EMR_SELECTPALETTE 48)
+(defconstant EMR_CREATEPALETTE 49)
+(defconstant EMR_SETPALETTEENTRIES 50)
+(defconstant EMR_RESIZEPALETTE 51)
+(defconstant EMR_REALIZEPALETTE 52)
+(defconstant EMR_EXTFLOODFILL 53)
+(defconstant EMR_LINETO 54)
+(defconstant EMR_ARCTO 55)
+(defconstant EMR_POLYDRAW 56)
+(defconstant EMR_SETARCDIRECTION 57)
+(defconstant EMR_SETMITERLIMIT 58)
+(defconstant EMR_BEGINPATH 59)
+(defconstant EMR_ENDPATH 60)
+(defconstant EMR_CLOSEFIGURE 61)
+(defconstant EMR_FILLPATH 62)
+(defconstant EMR_STROKEANDFILLPATH 63)
+(defconstant EMR_STROKEPATH 64)
+(defconstant EMR_FLATTENPATH 65)
+(defconstant EMR_WIDENPATH 66)
+(defconstant EMR_SELECTCLIPPATH 67)
+(defconstant EMR_ABORTPATH 68)
+(defconstant EMR_GDICOMMENT 70)
+(defconstant EMR_FILLRGN 71)
+(defconstant EMR_FRAMERGN 72)
+(defconstant EMR_INVERTRGN 73)
+(defconstant EMR_PAINTRGN 74)
+(defconstant EMR_EXTSELECTCLIPRGN 75)
+(defconstant EMR_BITBLT 76)
+(defconstant EMR_STRETCHBLT 77)
+(defconstant EMR_MASKBLT 78)
+(defconstant EMR_PLGBLT 79)
+(defconstant EMR_SETDIBITSTODEVICE 80)
+(defconstant EMR_STRETCHDIBITS 81)
+(defconstant EMR_EXTCREATEFONTINDIRECTW 82)
+(defconstant EMR_EXTTEXTOUTA 83)
+(defconstant EMR_EXTTEXTOUTW 84)
+(defconstant EMR_POLYBEZIER16 85)
+(defconstant EMR_POLYGON16 86)
+(defconstant EMR_POLYLINE16 87)
+(defconstant EMR_POLYBEZIERTO16 88)
+(defconstant EMR_POLYLINETO16 89)
+(defconstant EMR_POLYPOLYLINE16 90)
+(defconstant EMR_POLYPOLYGON16 91)
+(defconstant EMR_POLYDRAW16 92)
+(defconstant EMR_CREATEMONOBRUSH 93)
+(defconstant EMR_CREATEDIBPATTERNBRUSHPT 94)
+(defconstant EMR_EXTCREATEPEN 95)
+(defconstant EMR_POLYTEXTOUTA 96)
+(defconstant EMR_POLYTEXTOUTW 97)
+(defconstant EMR_SETICMMODE 98)
+(defconstant EMR_CREATECOLORSPACE 99)
+(defconstant EMR_SETCOLORSPACE 100)
+(defconstant EMR_DELETECOLORSPACE 101)
+(defconstant EMR_GLSRECORD 102)
+(defconstant EMR_GLSBOUNDEDRECORD 103)
+(defconstant EMR_PIXELFORMAT 104)
+(defconstant ENHMETA_SIGNATURE 1179469088)
+(defconstant EPS_SIGNATURE #x46535045)
+(defconstant META_SETBKCOLOR #x201)
+(defconstant META_SETBKMODE #x102)
+(defconstant META_SETMAPMODE #x103)
+(defconstant META_SETROP2 #x104)
+(defconstant META_SETRELABS #x105)
+(defconstant META_SETPOLYFILLMODE #x106)
+(defconstant META_SETSTRETCHBLTMODE #x107)
+(defconstant META_SETTEXTCHAREXTRA #x108)
+(defconstant META_SETTEXTCOLOR #x209)
+(defconstant META_SCALEWINDOWEXT #x410)
+(defconstant META_OFFSETVIEWPORTORG #x211)
+(defconstant META_SCALEVIEWPORTEXT #x412)
+(defconstant META_LINETO #x213)
+(defconstant META_MOVETO #x214)
+(defconstant META_EXCLUDECLIPRECT #x415)
+(defconstant META_INTERSECTCLIPRECT #x416)
+(defconstant META_ARC #x817)
+(defconstant META_ELLIPSE #x418)
+(defconstant META_FLOODFILL #x419)
+(defconstant META_OFFSETCLIPRGN #x220)
+(defconstant META_TEXTOUT #x521)
+(defconstant META_BITBLT #x922)
+(defconstant META_STRETCHBLT #xB23)
+(defconstant META_POLYGON #x324)
+(defconstant META_POLYLINE #x325)
+(defconstant META_ESCAPE #x626)
+(defconstant META_RESTOREDC #x127)
+(defconstant META_FILLREGION #x228)
+(defconstant META_FRAMEREGION #x429)
+(defconstant META_CHORD #x830)
+(defconstant META_SETMAPPERFLAGS #x231)
+(defconstant META_EXTTEXTOUT #xa32)
+(defconstant META_SETDIBTODEV #xd33)
+(defconstant META_SELECTPALETTE #x234)
+(defconstant META_REALIZEPALETTE #x35)
+(defconstant META_ANIMATEPALETTE #x436)
+(defconstant META_SETPALENTRIES #x37)
+(defconstant META_POLYPOLYGON #x538)
+(defconstant META_RESIZEPALETTE #x139)
+(defconstant META_DIBBITBLT #x940)
+(defconstant META_DIBSTRETCHBLT #xb41)
+(defconstant META_DIBCREATEPATTERNBRUSH #x142)
+(defconstant META_STRETCHDIB #xf43)
+(defconstant META_EXTFLOODFILL #x548)
+(defconstant META_DELETEOBJECT #x1f0)
+(defconstant META_CREATEPALETTE #xf7)
+(defconstant META_CREATEPATTERNBRUSH #x1F9)
+(defconstant PT_MOVETO 6)
+(defconstant PT_LINETO 2)
+(defconstant PT_BEZIERTO 4)
+(defconstant PT_CLOSEFIGURE 1)
+(defconstant ELF_VENDOR_SIZE 4)
+(defconstant ELF_VERSION 0)
+(defconstant ELF_CULTURE_LATIN 0)
+(defconstant PFD_TYPE_RGBA 0)
+(defconstant PFD_TYPE_COLORINDEX 1)
+(defconstant PFD_MAIN_PLANE 0)
+(defconstant PFD_OVERLAY_PLANE 1)
+(defconstant PFD_DOUBLEBUFFER 1)
+(defconstant PFD_STEREO 2)
+(defconstant PFD_DRAW_TO_WINDOW 4)
+(defconstant PFD_DRAW_TO_BITMAP 8)
+(defconstant PFD_SUPPORT_GDI 16)
+(defconstant PFD_SUPPORT_OPENGL 32)
+(defconstant PFD_GENERIC_FORMAT 64)
+(defconstant PFD_NEED_PALETTE 128)
+(defconstant PFD_NEED_SYSTEM_PALETTE #x00000100)
+(defconstant PFD_SWAP_EXCHANGE #x00000200)
+(defconstant PFD_SWAP_COPY #x00000400)
+(defconstant PFD_DOUBLEBUFFER_DONTCARE #x40000000)
+(defconstant PFD_STEREO_DONTCARE #x80000000)
+(defconstant BLACKNESS #x42)
+(defconstant NOTSRCERASE #x1100A6)
+(defconstant NOTSRCCOPY #x330008)
+(defconstant SRCERASE #x440328)
+(defconstant DSTINVERT #x550009)
+(defconstant PATINVERT #x5A0049)
+(defconstant SRCINVERT #x660046)
+(defconstant SRCAND #x8800C6)
+(defconstant MERGEPAINT #xBB0226)
+(defconstant SRCCOPY #xCC0020)
+(defconstant SRCPAINT #xEE0086)
+(defconstant PATCOPY #xF00021)
+(defconstant PATPAINT #xFB0A09)
+(defconstant WHITENESS #xFF0062)
+(defconstant R2_BLACK 1)
+(defconstant R2_COPYPEN 13)
+(defconstant R2_MASKNOTPEN 3)
+(defconstant R2_MASKPEN 9)
+(defconstant R2_MASKPENNOT 5)
+(defconstant R2_MERGENOTPEN 12)
+(defconstant R2_MERGEPEN 15)
+(defconstant R2_MERGEPENNOT 14)
+(defconstant R2_NOP 11)
+(defconstant R2_NOT 6)
+(defconstant R2_NOTCOPYPEN 4)
+(defconstant R2_NOTMASKPEN 8)
+(defconstant R2_NOTMERGEPEN 2)
+(defconstant R2_NOTXORPEN 10)
+(defconstant R2_WHITE 16)
+(defconstant R2_XORPEN 7)
+(defconstant CM_OUT_OF_GAMUT 255)
+(defconstant CM_IN_GAMUT 0)
+(defconstant RGN_AND 1)
+(defconstant RGN_COPY 5)
+(defconstant RGN_DIFF 4)
+(defconstant RGN_OR 2)
+(defconstant RGN_XOR 3)
+(defconstant NULLREGION 1)
+(defconstant SIMPLEREGION 2)
+(defconstant COMPLEXREGION 3)
+(defconstant ERROR 0)
+(defconstant CBM_INIT 4)
+(defconstant DIB_PAL_COLORS 1)
+(defconstant DIB_RGB_COLORS 0)
+(defconstant FW_DONTCARE 0)
+(defconstant FW_THIN 100)
+(defconstant FW_EXTRALIGHT 200)
+(defconstant FW_LIGHT 300)
+(defconstant FW_NORMAL 400)
+(defconstant FW_REGULAR 400)
+(defconstant FW_MEDIUM 500)
+(defconstant FW_SEMIBOLD 600)
+(defconstant FW_BOLD 700)
+(defconstant FW_EXTRABOLD 800)
+(defconstant FW_HEAVY 900)
+(defconstant ANSI_CHARSET 0)
+(defconstant DEFAULT_CHARSET 1)
+(defconstant SYMBOL_CHARSET 2)
+(defconstant SHIFTJIS_CHARSET 128)
+(defconstant HANGEUL_CHARSET 129)
+(defconstant HANGUL_CHARSET 129)
+(defconstant GB2312_CHARSET 134)
+(defconstant CHINESEBIG5_CHARSET 136)
+(defconstant GREEK_CHARSET 161)
+(defconstant TURKISH_CHARSET 162)
+(defconstant HEBREW_CHARSET 177)
+(defconstant ARABIC_CHARSET 178)
+(defconstant BALTIC_CHARSET 186)
+(defconstant RUSSIAN_CHARSET 204)
+(defconstant THAI_CHARSET 222)
+(defconstant EASTEUROPE_CHARSET 238)
+(defconstant OEM_CHARSET 255)
+(defconstant JOHAB_CHARSET 130)
+(defconstant VIETNAMESE_CHARSET 163)
+(defconstant MAC_CHARSET 77)
+(defconstant BALTIC_CHARSET 186)
+(defconstant JOHAB_CHARSET 130)
+(defconstant VIETNAMESE_CHARSET 163)
+(defconstant OUT_DEFAULT_PRECIS 0)
+(defconstant OUT_STRING_PRECIS 1)
+(defconstant OUT_CHARACTER_PRECIS 2)
+(defconstant OUT_STROKE_PRECIS 3)
+(defconstant OUT_TT_PRECIS 4)
+(defconstant OUT_DEVICE_PRECIS 5)
+(defconstant OUT_RASTER_PRECIS 6)
+(defconstant OUT_TT_ONLY_PRECIS 7)
+(defconstant OUT_OUTLINE_PRECIS 8)
+(defconstant CLIP_DEFAULT_PRECIS 0)
+(defconstant CLIP_CHARACTER_PRECIS 1)
+(defconstant CLIP_STROKE_PRECIS 2)
+(defconstant CLIP_MASK 15)
+(defconstant CLIP_LH_ANGLES 16)
+(defconstant CLIP_TT_ALWAYS 32)
+(defconstant CLIP_EMBEDDED 128)
+(defconstant DEFAULT_QUALITY 0)
+(defconstant DRAFT_QUALITY 1)
+(defconstant PROOF_QUALITY 2)
+(defconstant NONANTIALIASED_QUALITY 3)
+(defconstant ANTIALIASED_QUALITY 4)
+(defconstant DEFAULT_PITCH 0)
+(defconstant FIXED_PITCH 1)
+(defconstant VARIABLE_PITCH 2)
+(defconstant MONO_FONT 8)
+(defconstant FF_DECORATIVE 80)
+(defconstant FF_DONTCARE 0)
+(defconstant FF_MODERN 48)
+(defconstant FF_ROMAN 16)
+(defconstant FF_SCRIPT 64)
+(defconstant FF_SWISS 32)
+(defconstant PANOSE_COUNT 10)
+(defconstant PAN_FAMILYTYPE_INDEX 0)
+(defconstant PAN_SERIFSTYLE_INDEX 1)
+(defconstant PAN_WEIGHT_INDEX 2)
+(defconstant PAN_PROPORTION_INDEX 3)
+(defconstant PAN_CONTRAST_INDEX 4)
+(defconstant PAN_STROKEVARIATION_INDEX 5)
+(defconstant PAN_ARMSTYLE_INDEX 6)
+(defconstant PAN_LETTERFORM_INDEX 7)
+(defconstant PAN_MIDLINE_INDEX 8)
+(defconstant PAN_XHEIGHT_INDEX 9)
+(defconstant PAN_CULTURE_LATIN 0)
+(defconstant PAN_ANY 0)
+(defconstant PAN_NO_FIT 1)
+(defconstant PAN_FAMILY_TEXT_DISPLAY 2)
+(defconstant PAN_FAMILY_SCRIPT 3)
+(defconstant PAN_FAMILY_DECORATIVE 4)
+(defconstant PAN_FAMILY_PICTORIAL 5)
+(defconstant PAN_SERIF_COVE 2)
+(defconstant PAN_SERIF_OBTUSE_COVE 3)
+(defconstant PAN_SERIF_SQUARE_COVE 4)
+(defconstant PAN_SERIF_OBTUSE_SQUARE_COVE 5)
+(defconstant PAN_SERIF_SQUARE 6)
+(defconstant PAN_SERIF_THIN 7)
+(defconstant PAN_SERIF_BONE 8)
+(defconstant PAN_SERIF_EXAGGERATED 9)
+(defconstant PAN_SERIF_TRIANGLE 10)
+(defconstant PAN_SERIF_NORMAL_SANS 11)
+(defconstant PAN_SERIF_OBTUSE_SANS 12)
+(defconstant PAN_SERIF_PERP_SANS 13)
+(defconstant PAN_SERIF_FLARED 14)
+(defconstant PAN_SERIF_ROUNDED 15)
+(defconstant PAN_WEIGHT_VERY_LIGHT 2)
+(defconstant PAN_WEIGHT_LIGHT 3)
+(defconstant PAN_WEIGHT_THIN 4)
+(defconstant PAN_WEIGHT_BOOK 5)
+(defconstant PAN_WEIGHT_MEDIUM 6)
+(defconstant PAN_WEIGHT_DEMI 7)
+(defconstant PAN_WEIGHT_BOLD 8)
+(defconstant PAN_WEIGHT_HEAVY 9)
+(defconstant PAN_WEIGHT_BLACK 10)
+(defconstant PAN_WEIGHT_NORD 11)
+(defconstant PAN_PROP_OLD_STYLE 2)
+(defconstant PAN_PROP_MODERN 3)
+(defconstant PAN_PROP_EVEN_WIDTH 4)
+(defconstant PAN_PROP_EXPANDED 5)
+(defconstant PAN_PROP_CONDENSED 6)
+(defconstant PAN_PROP_VERY_EXPANDED 7)
+(defconstant PAN_PROP_VERY_CONDENSED 8)
+(defconstant PAN_PROP_MONOSPACED 9)
+(defconstant PAN_CONTRAST_NONE 2)
+(defconstant PAN_CONTRAST_VERY_LOW 3)
+(defconstant PAN_CONTRAST_LOW 4)
+(defconstant PAN_CONTRAST_MEDIUM_LOW 5)
+(defconstant PAN_CONTRAST_MEDIUM 6)
+(defconstant PAN_CONTRAST_MEDIUM_HIGH 7)
+(defconstant PAN_CONTRAST_HIGH 8)
+(defconstant PAN_CONTRAST_VERY_HIGH 9)
+(defconstant PAN_STROKE_GRADUAL_DIAG 2)
+(defconstant PAN_STROKE_GRADUAL_TRAN 3)
+(defconstant PAN_STROKE_GRADUAL_VERT 4)
+(defconstant PAN_STROKE_GRADUAL_HORZ 5)
+(defconstant PAN_STROKE_RAPID_VERT 6)
+(defconstant PAN_STROKE_RAPID_HORZ 7)
+(defconstant PAN_STROKE_INSTANT_VERT 8)
+(defconstant PAN_STRAIGHT_ARMS_HORZ 2)
+(defconstant PAN_STRAIGHT_ARMS_WEDGE 3)
+(defconstant PAN_STRAIGHT_ARMS_VERT 4)
+(defconstant PAN_STRAIGHT_ARMS_SINGLE_SERIF 5)
+(defconstant PAN_STRAIGHT_ARMS_DOUBLE_SERIF 6)
+(defconstant PAN_BENT_ARMS_HORZ 7)
+(defconstant PAN_BENT_ARMS_WEDGE 8)
+(defconstant PAN_BENT_ARMS_VERT 9)
+(defconstant PAN_BENT_ARMS_SINGLE_SERIF 10)
+(defconstant PAN_BENT_ARMS_DOUBLE_SERIF 11)
+(defconstant PAN_LETT_NORMAL_CONTACT 2)
+(defconstant PAN_LETT_NORMAL_WEIGHTED 3)
+(defconstant PAN_LETT_NORMAL_BOXED 4)
+(defconstant PAN_LETT_NORMAL_FLATTENED 5)
+(defconstant PAN_LETT_NORMAL_ROUNDED 6)
+(defconstant PAN_LETT_NORMAL_OFF_CENTER 7)
+(defconstant PAN_LETT_NORMAL_SQUARE 8)
+(defconstant PAN_LETT_OBLIQUE_CONTACT 9)
+(defconstant PAN_LETT_OBLIQUE_WEIGHTED 10)
+(defconstant PAN_LETT_OBLIQUE_BOXED 11)
+(defconstant PAN_LETT_OBLIQUE_FLATTENED 12)
+(defconstant PAN_LETT_OBLIQUE_ROUNDED 13)
+(defconstant PAN_LETT_OBLIQUE_OFF_CENTER 14)
+(defconstant PAN_LETT_OBLIQUE_SQUARE 15)
+(defconstant PAN_MIDLINE_STANDARD_TRIMMED 2)
+(defconstant PAN_MIDLINE_STANDARD_POINTED 3)
+(defconstant PAN_MIDLINE_STANDARD_SERIFED 4)
+(defconstant PAN_MIDLINE_HIGH_TRIMMED 5)
+(defconstant PAN_MIDLINE_HIGH_POINTED 6)
+(defconstant PAN_MIDLINE_HIGH_SERIFED 7)
+(defconstant PAN_MIDLINE_CONSTANT_TRIMMED 8)
+(defconstant PAN_MIDLINE_CONSTANT_POINTED 9)
+(defconstant PAN_MIDLINE_CONSTANT_SERIFED 10)
+(defconstant PAN_MIDLINE_LOW_TRIMMED 11)
+(defconstant PAN_MIDLINE_LOW_POINTED 12)
+(defconstant PAN_MIDLINE_LOW_SERIFED 13)
+(defconstant PAN_XHEIGHT_CONSTANT_SMALL 2)
+(defconstant PAN_XHEIGHT_CONSTANT_STD 3)
+(defconstant PAN_XHEIGHT_CONSTANT_LARGE 4)
+(defconstant PAN_XHEIGHT_DUCKING_SMALL 5)
+(defconstant PAN_XHEIGHT_DUCKING_STD 6)
+(defconstant PAN_XHEIGHT_DUCKING_LARGE 7)
+(defconstant FS_LATIN1 1)
+(defconstant FS_LATIN2 2)
+(defconstant FS_CYRILLIC 4)
+(defconstant FS_GREEK 8)
+(defconstant FS_TURKISH 16)
+(defconstant FS_HEBREW 32)
+(defconstant FS_ARABIC 64)
+(defconstant FS_BALTIC 128)
+(defconstant FS_THAI #x10000)
+(defconstant FS_JISJAPAN #x20000)
+(defconstant FS_CHINESESIMP #x40000)
+(defconstant FS_WANSUNG #x80000)
+(defconstant FS_CHINESETRAD #x100000)
+(defconstant FS_JOHAB #x200000)
+(defconstant FS_SYMBOL #x80000000)
+(defconstant HS_BDIAGONAL 3)
+(defconstant HS_CROSS 4)
+(defconstant HS_DIAGCROSS 5)
+(defconstant HS_FDIAGONAL 2)
+(defconstant HS_HORIZONTAL 0)
+(defconstant HS_VERTICAL 1)
+(defconstant PS_GEOMETRIC 65536)
+(defconstant PS_COSMETIC 0)
+(defconstant PS_ALTERNATE 8)
+(defconstant PS_SOLID 0)
+(defconstant PS_DASH 1)
+(defconstant PS_DOT 2)
+(defconstant PS_DASHDOT 3)
+(defconstant PS_DASHDOTDOT 4)
+(defconstant PS_NULL 5)
+(defconstant PS_USERSTYLE 7)
+(defconstant PS_INSIDEFRAME 6)
+(defconstant PS_ENDCAP_ROUND 0)
+(defconstant PS_ENDCAP_SQUARE 256)
+(defconstant PS_ENDCAP_FLAT 512)
+(defconstant PS_JOIN_BEVEL 4096)
+(defconstant PS_JOIN_MITER 8192)
+(defconstant PS_JOIN_ROUND 0)
+(defconstant PS_STYLE_MASK 15)
+(defconstant PS_ENDCAP_MASK 3840)
+(defconstant PS_TYPE_MASK 983040)
+(defconstant ALTERNATE 1)
+(defconstant WINDING 2)
+(defconstant DC_BINNAMES 12)
+(defconstant DC_BINS 6)
+(defconstant DC_COPIES 18)
+(defconstant DC_DRIVER 11)
+(defconstant DC_DATATYPE_PRODUCED 21)
+(defconstant DC_DUPLEX 7)
+(defconstant DC_EMF_COMPLIANT 20)
+(defconstant DC_ENUMRESOLUTIONS 13)
+(defconstant DC_EXTRA 9)
+(defconstant DC_FIELDS 1)
+(defconstant DC_FILEDEPENDENCIES 14)
+(defconstant DC_MAXEXTENT 5)
+(defconstant DC_MINEXTENT 4)
+(defconstant DC_ORIENTATION 17)
+(defconstant DC_PAPERNAMES 16)
+(defconstant DC_PAPERS 2)
+(defconstant DC_PAPERSIZE 3)
+(defconstant DC_SIZE 8)
+(defconstant DC_TRUETYPE 15)
+(defconstant DCTT_BITMAP 1)
+(defconstant DCTT_DOWNLOAD 2)
+(defconstant DCTT_SUBDEV 4)
+(defconstant DCTT_DOWNLOAD_OUTLINE 8)
+(defconstant DC_VERSION 10)
+(defconstant DC_BINADJUST 19)
+(defconstant DC_EMF_COMPLIANT 20)
+(defconstant DC_DATATYPE_PRODUCED 21)
+(defconstant DC_MANUFACTURER 23)
+(defconstant DC_MODEL 24)
+(defconstant DC_PERSONALITY 25)
+(defconstant DC_PRINTRATE 26)
+(defconstant DC_PRINTRATEUNIT 27)
+(defconstant DC_PRINTERMEM 28)
+(defconstant DC_MEDIAREADY 29)
+(defconstant DC_STAPLE 30)
+(defconstant DC_PRINTRATEPPM 31)
+(defconstant DC_COLORDEVICE 32)
+(defconstant DC_NUP 33)
+(defconstant DC_MEDIATYPENAMES 34)
+(defconstant DC_MEDIATYPES 35)
+(defconstant DCBA_FACEUPNONE 0)
+(defconstant DCBA_FACEUPCENTER 1)
+(defconstant DCBA_FACEUPLEFT 2)
+(defconstant DCBA_FACEUPRIGHT 3)
+(defconstant DCBA_FACEDOWNNONE 256)
+(defconstant DCBA_FACEDOWNCENTER 257)
+(defconstant DCBA_FACEDOWNLEFT 258)
+(defconstant DCBA_FACEDOWNRIGHT 259)
+(defconstant FLOODFILLBORDER 0)
+(defconstant FLOODFILLSURFACE 1)
+(defconstant ETO_CLIPPED 4)
+(defconstant ETO_GLYPH_INDEX 16)
+(defconstant ETO_OPAQUE 2)
+(defconstant ETO_RTLREADING 128)
+(defconstant GDICOMMENT_BEGINGROUP 2)
+(defconstant GDICOMMENT_ENDGROUP 3)
+(defconstant GDICOMMENT_MULTIFORMATS 1073741828)
+(defconstant GDICOMMENT_IDENTIFIER 1128875079)
+(defconstant AD_COUNTERCLOCKWISE 1)
+(defconstant AD_CLOCKWISE 2)
+(defconstant RDH_RECTANGLES 1)
+(defconstant GCPCLASS_LATIN 1)
+(defconstant GCPCLASS_HEBREW 2)
+(defconstant GCPCLASS_ARABIC 2)
+(defconstant GCPCLASS_NEUTRAL 3)
+(defconstant GCPCLASS_LOCALNUMBER 4)
+(defconstant GCPCLASS_LATINNUMBER 5)
+(defconstant GCPCLASS_LATINNUMERICTERMINATOR 6)
+(defconstant GCPCLASS_LATINNUMERICSEPARATOR 7)
+(defconstant GCPCLASS_NUMERICSEPARATOR 8)
+(defconstant GCPCLASS_PREBOUNDLTR 128)
+(defconstant GCPCLASS_PREBOUNDRTL 64)
+(defconstant GCPCLASS_POSTBOUNDLTR 32)
+(defconstant GCPCLASS_POSTBOUNDRTL 16)
+(defconstant GCPGLYPH_LINKBEFORE #x8000)
+(defconstant GCPGLYPH_LINKAFTER #x4000)
+(defconstant DCB_DISABLE 8)
+(defconstant DCB_ENABLE 4)
+(defconstant DCB_RESET 1)
+(defconstant DCB_SET 3)
+(defconstant DCB_ACCUMULATE 2)
+(defconstant DCB_DIRTY 2)
+(defconstant OBJ_BRUSH 2)
+(defconstant OBJ_PEN 1)
+(defconstant OBJ_PAL 5)
+(defconstant OBJ_FONT 6)
+(defconstant OBJ_BITMAP 7)
+(defconstant OBJ_EXTPEN 11)
+(defconstant OBJ_REGION 8)
+(defconstant OBJ_DC 3)
+(defconstant OBJ_MEMDC 10)
+(defconstant OBJ_METAFILE 9)
+(defconstant OBJ_METADC 4)
+(defconstant OBJ_ENHMETAFILE 13)
+(defconstant OBJ_ENHMETADC 12)
+(defconstant DRIVERVERSION 0)
+(defconstant TECHNOLOGY 2)
+(defconstant DT_PLOTTER 0)
+(defconstant DT_RASDISPLAY 1)
+(defconstant DT_RASPRINTER 2)
+(defconstant DT_RASCAMERA 3)
+(defconstant DT_CHARSTREAM 4)
+(defconstant DT_METAFILE 5)
+(defconstant DT_DISPFILE 6)
+(defconstant HORZSIZE 4)
+(defconstant VERTSIZE 6)
+(defconstant HORZRES 8)
+(defconstant VERTRES 10)
+(defconstant LOGPIXELSX 88)
+(defconstant LOGPIXELSY 90)
+(defconstant BITSPIXEL 12)
+(defconstant PLANES 14)
+(defconstant NUMBRUSHES 16)
+(defconstant NUMPENS 18)
+(defconstant NUMFONTS 22)
+(defconstant NUMCOLORS 24)
+(defconstant NUMMARKERS 20)
+(defconstant ASPECTX 40)
+(defconstant ASPECTY 42)
+(defconstant ASPECTXY 44)
+(defconstant PDEVICESIZE 26)
+(defconstant CLIPCAPS 36)
+(defconstant SIZEPALETTE 104)
+(defconstant NUMRESERVED 106)
+(defconstant COLORRES 108)
+(defconstant PHYSICALWIDTH 110)
+(defconstant PHYSICALHEIGHT 111)
+(defconstant PHYSICALOFFSETX 112)
+(defconstant PHYSICALOFFSETY 113)
+(defconstant SCALINGFACTORX 114)
+(defconstant SCALINGFACTORY 115)
+(defconstant VREFRESH 116)
+(defconstant DESKTOPHORZRES 118)
+(defconstant DESKTOPVERTRES 117)
+(defconstant BLTALIGNMENT 119)
+(defconstant SHADEBLENDCAPS 120)
+(defconstant SB_NONE 0)
+(defconstant SB_CONST_ALPHA 1)
+(defconstant SB_PIXEL_ALPHA 2)
+(defconstant SB_PREMULT_ALPHA 4)
+(defconstant SB_GRAD_RECT 16)
+(defconstant SB_GRAD_TRI 32)
+(defconstant COLORMGMTCAPS 121)
+(defconstant CM_NONE 0)
+(defconstant CM_DEVICE_ICM 1)
+(defconstant CM_GAMMA_RAMP 2)
+(defconstant CM_CMYK_COLOR 4)
+(defconstant RASTERCAPS 38)
+(defconstant RC_BANDING 2)
+(defconstant RC_BITBLT 1)
+(defconstant RC_BITMAP64 8)
+(defconstant RC_DI_BITMAP 128)
+(defconstant RC_DIBTODEV 512)
+(defconstant RC_FLOODFILL 4096)
+(defconstant RC_GDI20_OUTPUT 16)
+(defconstant RC_PALETTE 256)
+(defconstant RC_SCALING 4)
+(defconstant RC_STRETCHBLT 2048)
+(defconstant RC_STRETCHDIB 8192)
+(defconstant RC_DEVBITS #x8000)
+(defconstant RC_OP_DX_OUTPUT #x4000)
+(defconstant CURVECAPS 28)
+(defconstant CC_NONE 0)
+(defconstant CC_CIRCLES 1)
+(defconstant CC_PIE 2)
+(defconstant CC_CHORD 4)
+(defconstant CC_ELLIPSES 8)
+(defconstant CC_WIDE 16)
+(defconstant CC_STYLED 32)
+(defconstant CC_WIDESTYLED 64)
+(defconstant CC_INTERIORS 128)
+(defconstant CC_ROUNDRECT 256)
+(defconstant LINECAPS 30)
+(defconstant LC_NONE 0)
+(defconstant LC_POLYLINE 2)
+(defconstant LC_MARKER 4)
+(defconstant LC_POLYMARKER 8)
+(defconstant LC_WIDE 16)
+(defconstant LC_STYLED 32)
+(defconstant LC_WIDESTYLED 64)
+(defconstant LC_INTERIORS 128)
+(defconstant POLYGONALCAPS 32)
+(defconstant RC_BANDING 2)
+(defconstant RC_BIGFONT 1024)
+(defconstant RC_BITBLT 1)
+(defconstant RC_BITMAP64 8)
+(defconstant RC_DEVBITS #x8000)
+(defconstant RC_DI_BITMAP 128)
+(defconstant RC_GDI20_OUTPUT 16)
+(defconstant RC_GDI20_STATE 32)
+(defconstant RC_NONE 0)
+(defconstant RC_OP_DX_OUTPUT #x4000)
+(defconstant RC_PALETTE 256)
+(defconstant RC_SAVEBITMAP 64)
+(defconstant RC_SCALING 4)
+(defconstant PC_NONE 0)
+(defconstant PC_POLYGON 1)
+(defconstant PC_POLYPOLYGON 256)
+(defconstant PC_PATHS 512)
+(defconstant PC_RECTANGLE 2)
+(defconstant PC_WINDPOLYGON 4)
+(defconstant PC_SCANLINE 8)
+(defconstant PC_TRAPEZOID 4)
+(defconstant PC_WIDE 16)
+(defconstant PC_STYLED 32)
+(defconstant PC_WIDESTYLED 64)
+(defconstant PC_INTERIORS 128)
+(defconstant PC_PATHS 512)
+(defconstant TEXTCAPS 34)
+(defconstant TC_OP_CHARACTER 1)
+(defconstant TC_OP_STROKE 2)
+(defconstant TC_CP_STROKE 4)
+(defconstant TC_CR_90 8)
+(defconstant TC_CR_ANY 16)
+(defconstant TC_SF_X_YINDEP 32)
+(defconstant TC_SA_DOUBLE 64)
+(defconstant TC_SA_INTEGER 128)
+(defconstant TC_SA_CONTIN 256)
+(defconstant TC_EA_DOUBLE 512)
+(defconstant TC_IA_ABLE 1024)
+(defconstant TC_UA_ABLE 2048)
+(defconstant TC_SO_ABLE 4096)
+(defconstant TC_RA_ABLE 8192)
+(defconstant TC_VA_ABLE 16384)
+(defconstant TC_RESERVED 32768)
+(defconstant TC_SCROLLBLT 65536)
+(defconstant GCP_DBCS 1)
+(defconstant GCP_ERROR #x8000)
+(defconstant GCP_CLASSIN #x80000)
+(defconstant GCP_DIACRITIC 256)
+(defconstant GCP_DISPLAYZWG #x400000)
+(defconstant GCP_GLYPHSHAPE 16)
+(defconstant GCP_JUSTIFY #x10000)
+(defconstant GCP_JUSTIFYIN #x200000)
+(defconstant GCP_KASHIDA 1024)
+(defconstant GCP_LIGATE 32)
+(defconstant GCP_MAXEXTENT #x100000)
+(defconstant GCP_NEUTRALOVERRIDE #x2000000)
+(defconstant GCP_NUMERICOVERRIDE #x1000000)
+(defconstant GCP_NUMERICSLATIN #x4000000)
+(defconstant GCP_NUMERICSLOCAL #x8000000)
+(defconstant GCP_REORDER 2)
+(defconstant GCP_SYMSWAPOFF #x800000)
+(defconstant GCP_USEKERNING 8)
+(defconstant FLI_GLYPHS #x40000)
+(defconstant GGO_BITMAP 1)
+(defconstant GGO_NATIVE 2)
+(defconstant GGO_METRICS 0)
+(defconstant GGO_GRAY2_BITMAP 4)
+(defconstant GGO_GRAY4_BITMAP 5)
+(defconstant GGO_GRAY8_BITMAP 6)
+(defconstant GGO_GLYPH_INDEX 128)
+(defconstant GGO_UNHINTED 256)
+(defconstant GM_COMPATIBLE 1)
+(defconstant GM_ADVANCED 2)
+(defconstant MM_ANISOTROPIC 8)
+(defconstant MM_HIENGLISH 5)
+(defconstant MM_HIMETRIC 3)
+(defconstant MM_ISOTROPIC 7)
+(defconstant MM_LOENGLISH 4)
+(defconstant MM_LOMETRIC 2)
+(defconstant MM_TEXT 1)
+(defconstant MM_TWIPS 6)
+(defconstant ABSOLUTE 1)
+(defconstant RELATIVE 2)
+(defconstant PC_EXPLICIT 2)
+(defconstant PC_NOCOLLAPSE 4)
+(defconstant PC_RESERVED 1)
+(defconstant CLR_DEFAULT #xff000000)
+(defconstant PT_MOVETO 6)
+(defconstant PT_LINETO 2)
+(defconstant PT_BEZIERTO 4)
+(defconstant PT_CLOSEFIGURE 1)
+(defconstant TT_AVAILABLE 1)
+(defconstant TT_ENABLED 2)
+(defconstant BLACK_BRUSH 4)
+(defconstant DKGRAY_BRUSH 3)
+(defconstant GRAY_BRUSH 2)
+(defconstant HOLLOW_BRUSH 5)
+(defconstant LTGRAY_BRUSH 1)
+(defconstant NULL_BRUSH 5)
+(defconstant WHITE_BRUSH 0)
+(defconstant BLACK_PEN 7)
+(defconstant NULL_PEN 8)
+(defconstant WHITE_PEN 6)
+(defconstant ANSI_FIXED_FONT 11)
+(defconstant ANSI_VAR_FONT 12)
+(defconstant DEVICE_DEFAULT_FONT 14)
+(defconstant DEFAULT_GUI_FONT 17)
+(defconstant OEM_FIXED_FONT 10)
+(defconstant SYSTEM_FONT 13)
+(defconstant SYSTEM_FIXED_FONT 16)
+(defconstant DEFAULT_PALETTE 15)
+(defconstant SYSPAL_NOSTATIC 2)
+(defconstant SYSPAL_STATIC 1)
+(defconstant SYSPAL_ERROR 0)
+(defconstant TA_BASELINE 24)
+(defconstant TA_BOTTOM 8)
+(defconstant TA_TOP 0)
+(defconstant TA_CENTER 6)
+(defconstant TA_LEFT 0)
+(defconstant TA_RIGHT 2)
+(defconstant TA_RTLREADING 256)
+(defconstant TA_NOUPDATECP 0)
+(defconstant TA_UPDATECP 1)
+(defconstant VTA_BASELINE 24)
+(defconstant VTA_CENTER 6)
+(defconstant MWT_IDENTITY 1)
+(defconstant MWT_LEFTMULTIPLY 2)
+(defconstant MWT_RIGHTMULTIPLY 3)
+(defconstant OPAQUE 2)
+(defconstant TRANSPARENT 1)
+(defconstant BLACKONWHITE 1)
+(defconstant WHITEONBLACK 2)
+(defconstant COLORONCOLOR 3)
+(defconstant HALFTONE 4)
+(defconstant MAXSTRETCHBLTMODE 4)
+(defconstant STRETCH_ANDSCANS 1)
+(defconstant STRETCH_DELETESCANS 3)
+(defconstant STRETCH_HALFTONE 4)
+(defconstant STRETCH_ORSCANS 2)
+(defconstant TCI_SRCCHARSET 1)
+(defconstant TCI_SRCCODEPAGE 2)
+(defconstant TCI_SRCFONTSIG 3)
+(defconstant ICM_ON 2)
+(defconstant ICM_OFF 1)
+(defconstant ICM_QUERY 3)
+(defconstant NEWFRAME 1)
+(defconstant ABORTDOC 2)
+(defconstant NEXTBAND 3)
+(defconstant SETCOLORTABLE 4)
+(defconstant GETCOLORTABLE 5)
+(defconstant FLUSHOUTPUT 6)
+(defconstant DRAFTMODE 7)
+(defconstant QUERYESCSUPPORT 8)
+(defconstant SETABORTPROC 9)
+(defconstant STARTDOC 10)
+(defconstant ENDDOC 11)
+(defconstant GETPHYSPAGESIZE 12)
+(defconstant GETPRINTINGOFFSET 13)
+(defconstant GETSCALINGFACTOR 14)
+(defconstant MFCOMMENT 15)
+(defconstant GETPENWIDTH 16)
+(defconstant SETCOPYCOUNT 17)
+(defconstant SELECTPAPERSOURCE 18)
+(defconstant DEVICEDATA 19)
+(defconstant PASSTHROUGH 19)
+(defconstant GETTECHNOLGY 20)
+(defconstant GETTECHNOLOGY 20)
+(defconstant SETLINECAP 21)
+(defconstant SETLINEJOIN 22)
+(defconstant SETMITERLIMIT 23)
+(defconstant BANDINFO 24)
+(defconstant DRAWPATTERNRECT 25)
+(defconstant GETVECTORPENSIZE 26)
+(defconstant GETVECTORBRUSHSIZE 27)
+(defconstant ENABLEDUPLEX 28)
+(defconstant GETSETPAPERBINS 29)
+(defconstant GETSETPRINTORIENT 30)
+(defconstant ENUMPAPERBINS 31)
+(defconstant SETDIBSCALING 32)
+(defconstant EPSPRINTING 33)
+(defconstant ENUMPAPERMETRICS 34)
+(defconstant GETSETPAPERMETRICS 35)
+(defconstant POSTSCRIPT_DATA 37)
+(defconstant POSTSCRIPT_IGNORE 38)
+(defconstant MOUSETRAILS 39)
+(defconstant GETDEVICEUNITS 42)
+(defconstant GETEXTENDEDTEXTMETRICS 256)
+(defconstant GETEXTENTTABLE 257)
+(defconstant GETPAIRKERNTABLE 258)
+(defconstant GETTRACKKERNTABLE 259)
+(defconstant EXTTEXTOUT 512)
+(defconstant GETFACENAME 513)
+(defconstant DOWNLOADFACE 514)
+(defconstant ENABLERELATIVEWIDTHS 768)
+(defconstant ENABLEPAIRKERNING 769)
+(defconstant SETKERNTRACK 770)
+(defconstant SETALLJUSTVALUES 771)
+(defconstant SETCHARSET 772)
+(defconstant STRETCHBLT 2048)
+(defconstant GETSETSCREENPARAMS 3072)
+(defconstant QUERYDIBSUPPORT 3073)
+(defconstant BEGIN_PATH 4096)
+(defconstant CLIP_TO_PATH 4097)
+(defconstant END_PATH 4098)
+(defconstant EXT_DEVICE_CAPS 4099)
+(defconstant RESTORE_CTM 4100)
+(defconstant SAVE_CTM 4101)
+(defconstant SET_ARC_DIRECTION 4102)
+(defconstant SET_BACKGROUND_COLOR 4103)
+(defconstant SET_POLY_MODE 4104)
+(defconstant SET_SCREEN_ANGLE 4105)
+(defconstant SET_SPREAD 4106)
+(defconstant TRANSFORM_CTM 4107)
+(defconstant SET_CLIP_BOX 4108)
+(defconstant SET_BOUNDS 4109)
+(defconstant SET_MIRROR_MODE 4110)
+(defconstant OPENCHANNEL 4110)
+(defconstant DOWNLOADHEADER 4111)
+(defconstant CLOSECHANNEL 4112)
+(defconstant POSTSCRIPT_PASSTHROUGH 4115)
+(defconstant ENCAPSULATED_POSTSCRIPT 4116)
+(defconstant QDI_SETDIBITS 1)
+(defconstant QDI_GETDIBITS 2)
+(defconstant QDI_DIBTOSCREEN 4)
+(defconstant QDI_STRETCHDIB 8)
+(defconstant SP_NOTREPORTED #x4000)
+(defconstant PR_JOBSTATUS 0)
+(defconstant ASPECT_FILTERING 1)
+(defconstant BS_SOLID 0)
+(defconstant BS_NULL 1)
+(defconstant BS_HOLLOW 1)
+(defconstant BS_HATCHED 2)
+(defconstant BS_PATTERN 3)
+(defconstant BS_INDEXED 4)
+(defconstant BS_DIBPATTERN 5)
+(defconstant BS_DIBPATTERNPT 6)
+(defconstant BS_PATTERN8X8 7)
+(defconstant BS_DIBPATTERN8X8 8)
+(defconstant LCS_CALIBRATED_RGB 0)
+(defconstant LCS_DEVICE_RGB 1)
+(defconstant LCS_DEVICE_CMYK 2)
+(defconstant LCS_GM_BUSINESS 1)
+(defconstant LCS_GM_GRAPHICS 2)
+(defconstant LCS_GM_IMAGES 4)
+(defconstant RASTER_FONTTYPE 1)
+(defconstant DEVICE_FONTTYPE 2)
+(defconstant TRUETYPE_FONTTYPE 4)
+(defconstant DMORIENT_PORTRAIT 1)
+(defconstant DMORIENT_LANDSCAPE 2)
+(defconstant DMPAPER_FIRST 1)
+(defconstant DMPAPER_LETTER 1)
+(defconstant DMPAPER_LETTERSMALL 2)
+(defconstant DMPAPER_TABLOID 3)
+(defconstant DMPAPER_LEDGER 4)
+(defconstant DMPAPER_LEGAL 5)
+(defconstant DMPAPER_STATEMENT 6)
+(defconstant DMPAPER_EXECUTIVE 7)
+(defconstant DMPAPER_A3 8)
+(defconstant DMPAPER_A4 9)
+(defconstant DMPAPER_A4SMALL 10)
+(defconstant DMPAPER_A5 11)
+(defconstant DMPAPER_B4 12)
+(defconstant DMPAPER_B5 13)
+(defconstant DMPAPER_FOLIO 14)
+(defconstant DMPAPER_QUARTO 15)
+(defconstant DMPAPER_10X14 16)
+(defconstant DMPAPER_11X17 17)
+(defconstant DMPAPER_NOTE 18)
+(defconstant DMPAPER_ENV_9 19)
+(defconstant DMPAPER_ENV_10 20)
+(defconstant DMPAPER_ENV_11 21)
+(defconstant DMPAPER_ENV_12 22)
+(defconstant DMPAPER_ENV_14 23)
+(defconstant DMPAPER_CSHEET 24)
+(defconstant DMPAPER_DSHEET 25)
+(defconstant DMPAPER_ESHEET 26)
+(defconstant DMPAPER_ENV_DL 27)
+(defconstant DMPAPER_ENV_C5 28)
+(defconstant DMPAPER_ENV_C3 29)
+(defconstant DMPAPER_ENV_C4 30)
+(defconstant DMPAPER_ENV_C6 31)
+(defconstant DMPAPER_ENV_C65 32)
+(defconstant DMPAPER_ENV_B4 33)
+(defconstant DMPAPER_ENV_B5 34)
+(defconstant DMPAPER_ENV_B6 35)
+(defconstant DMPAPER_ENV_ITALY 36)
+(defconstant DMPAPER_ENV_MONARCH 37)
+(defconstant DMPAPER_ENV_PERSONAL 38)
+(defconstant DMPAPER_FANFOLD_US 39)
+(defconstant DMPAPER_FANFOLD_STD_GERMAN 40)
+(defconstant DMPAPER_FANFOLD_LGL_GERMAN 41)
+(defconstant DMPAPER_ISO_B4 42)
+(defconstant DMPAPER_JAPANESE_POSTCARD 43)
+(defconstant DMPAPER_9X11 44)
+(defconstant DMPAPER_10X11 45)
+(defconstant DMPAPER_15X11 46)
+(defconstant DMPAPER_ENV_INVITE 47)
+(defconstant DMPAPER_RESERVED_48 48)
+(defconstant DMPAPER_RESERVED_49 49)
+(defconstant DMPAPER_LETTER_EXTRA 50)
+(defconstant DMPAPER_LEGAL_EXTRA 51)
+(defconstant DMPAPER_TABLOID_EXTRA 52)
+(defconstant DMPAPER_A4_EXTRA 53)
+(defconstant DMPAPER_LETTER_TRANSVERSE 54)
+(defconstant DMPAPER_A4_TRANSVERSE 55)
+(defconstant DMPAPER_LETTER_EXTRA_TRANSVERSE 56)
+(defconstant DMPAPER_A_PLUS 57)
+(defconstant DMPAPER_B_PLUS 58)
+(defconstant DMPAPER_LETTER_PLUS 59)
+(defconstant DMPAPER_A4_PLUS 60)
+(defconstant DMPAPER_A5_TRANSVERSE 61)
+(defconstant DMPAPER_B5_TRANSVERSE 62)
+(defconstant DMPAPER_A3_EXTRA 63)
+(defconstant DMPAPER_A5_EXTRA 64)
+(defconstant DMPAPER_B5_EXTRA 65)
+(defconstant DMPAPER_A2 66)
+(defconstant DMPAPER_A3_TRANSVERSE 67)
+(defconstant DMPAPER_A3_EXTRA_TRANSVERSE 68)
+(defconstant DMPAPER_DBL_JAPANESE_POSTCARD 69)
+(defconstant DMPAPER_A6 70)
+(defconstant DMPAPER_JENV_KAKU2 71)
+(defconstant DMPAPER_JENV_KAKU3 72)
+(defconstant DMPAPER_JENV_CHOU3 73)
+(defconstant DMPAPER_JENV_CHOU4 74)
+(defconstant DMPAPER_LETTER_ROTATED 75)
+(defconstant DMPAPER_A3_ROTATED 76)
+(defconstant DMPAPER_A4_ROTATED 77)
+(defconstant DMPAPER_A5_ROTATED 78)
+(defconstant DMPAPER_B4_JIS_ROTATED 79)
+(defconstant DMPAPER_B5_JIS_ROTATED 80)
+(defconstant DMPAPER_JAPANESE_POSTCARD_ROTATED 81)
+(defconstant DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED 82)
+(defconstant DMPAPER_A6_ROTATED 83)
+(defconstant DMPAPER_JENV_KAKU2_ROTATED 84)
+(defconstant DMPAPER_JENV_KAKU3_ROTATED 85)
+(defconstant DMPAPER_JENV_CHOU3_ROTATED 86)
+(defconstant DMPAPER_JENV_CHOU4_ROTATED 87)
+(defconstant DMPAPER_B6_JIS 88)
+(defconstant DMPAPER_B6_JIS_ROTATED 89)
+(defconstant DMPAPER_12X11 90)
+(defconstant DMPAPER_JENV_YOU4 91)
+(defconstant DMPAPER_JENV_YOU4_ROTATED 92)
+(defconstant DMPAPER_P16K 93)
+(defconstant DMPAPER_P32K 94)
+(defconstant DMPAPER_P32KBIG 95)
+(defconstant DMPAPER_PENV_1 96)
+(defconstant DMPAPER_PENV_2 97)
+(defconstant DMPAPER_PENV_3 98)
+(defconstant DMPAPER_PENV_4 99)
+(defconstant DMPAPER_PENV_5 100)
+(defconstant DMPAPER_PENV_6 101)
+(defconstant DMPAPER_PENV_7 102)
+(defconstant DMPAPER_PENV_8 103)
+(defconstant DMPAPER_PENV_9 104)
+(defconstant DMPAPER_PENV_10 105)
+(defconstant DMPAPER_P16K_ROTATED 106)
+(defconstant DMPAPER_P32K_ROTATED 107)
+(defconstant DMPAPER_P32KBIG_ROTATED 108)
+(defconstant DMPAPER_PENV_1_ROTATED 109)
+(defconstant DMPAPER_PENV_2_ROTATED 110)
+(defconstant DMPAPER_PENV_3_ROTATED 111)
+(defconstant DMPAPER_PENV_4_ROTATED 112)
+(defconstant DMPAPER_PENV_5_ROTATED 113)
+(defconstant DMPAPER_PENV_6_ROTATED 114)
+(defconstant DMPAPER_PENV_7_ROTATED 115)
+(defconstant DMPAPER_PENV_8_ROTATED 116)
+(defconstant DMPAPER_PENV_9_ROTATED 117)
+(defconstant DMPAPER_PENV_10_ROTATED 118)
+(defconstant DMPAPER_LAST 118)
+(defconstant DMPAPER_USER 256)
+(defconstant DMBIN_FIRST 1)
+(defconstant DMBIN_UPPER 1)
+(defconstant DMBIN_ONLYONE 1)
+(defconstant DMBIN_LOWER 2)
+(defconstant DMBIN_MIDDLE 3)
+(defconstant DMBIN_MANUAL 4)
+(defconstant DMBIN_ENVELOPE 5)
+(defconstant DMBIN_ENVMANUAL 6)
+(defconstant DMBIN_AUTO 7)
+(defconstant DMBIN_TRACTOR 8)
+(defconstant DMBIN_SMALLFMT 9)
+(defconstant DMBIN_LARGEFMT 10)
+(defconstant DMBIN_LARGECAPACITY 11)
+(defconstant DMBIN_CASSETTE 14)
+(defconstant DMBIN_FORMSOURCE 15)
+(defconstant DMBIN_LAST 15)
+(defconstant DMBIN_USER 256)
+(defconstant DMCOLOR_MONOCHROME 1)
+(defconstant DMCOLOR_COLOR 2)
+(defconstant DMDUP_SIMPLEX 1)
+(defconstant DMDUP_VERTICAL 2)
+(defconstant DMDUP_HORIZONTAL 3)
+(defconstant DMTT_BITMAP 1)
+(defconstant DMTT_DOWNLOAD 2)
+(defconstant DMTT_SUBDEV 3)
+(defconstant DMTT_DOWNLOAD_OUTLINE 4)
+(defconstant DMCOLLATE_FALSE 0)
+(defconstant DMCOLLATE_TRUE 1)
+(defconstant DM_GRAYSCALE 1)
+(defconstant DM_INTERLACED 2)
+(defconstant DM_UPDATE 1)
+(defconstant DM_COPY 2)
+(defconstant DM_PROMPT 4)
+(defconstant DM_MODIFY 8)
+(defconstant DM_ORIENTATION 1)
+(defconstant DM_PAPERSIZE 2)
+(defconstant DM_PAPERLENGTH 4)
+(defconstant DM_PAPERWIDTH 8)
+(defconstant DM_SCALE 16)
+(defconstant DM_COPIES 256)
+(defconstant DM_DEFAULTSOURCE 512)
+(defconstant DM_PRINTQUALITY 1024)
+(defconstant DM_COLOR 2048)
+(defconstant DM_DUPLEX 4096)
+(defconstant DM_YRESOLUTION 8192)
+(defconstant DM_TTOPTION 16384)
+(defconstant DM_COLLATE 32768)
+(defconstant DM_FORMNAME 65536)
+(defconstant DM_LOGPIXELS #x20000)
+(defconstant DM_BITSPERPEL #x40000)
+(defconstant DM_PELSWIDTH #x80000)
+(defconstant DM_PELSHEIGHT #x100000)
+(defconstant DM_DISPLAYFLAGS #x200000)
+(defconstant DM_DISPLAYFREQUENCY #x400000)
+(defconstant DM_ICMMETHOD #x800000)
+(defconstant DM_ICMINTENT #x1000000)
+(defconstant DM_MEDIATYPE #x2000000)
+(defconstant DM_DITHERTYPE #x4000000)
+(defconstant DM_PANNINGWIDTH #x08000000)
+(defconstant DM_PANNINGHEIGHT #x10000000)
+(defconstant DM_DISPLAYFIXEDOUTPUT #x20000000)
+(defconstant DM_DISPLAYORIENTATION #x00000080)
+(defconstant DMDO_DEFAULT #x00000000)
+(defconstant DMDO_90 #x00000001)
+(defconstant DMDO_180 #x00000002)
+(defconstant DMDO_270 #x00000003)
+(defconstant DMDFO_DEFAULT #x00000000)
+(defconstant DMDFO_STRETCH #x00000001)
+(defconstant DMDFO_CENTER #x00000002)
+(defconstant DMICMMETHOD_NONE 1)
+(defconstant DMICMMETHOD_SYSTEM 2)
+(defconstant DMICMMETHOD_DRIVER 3)
+(defconstant DMICMMETHOD_DEVICE 4)
+(defconstant DMICMMETHOD_USER 256)
+(defconstant DMICM_SATURATE 1)
+(defconstant DMICM_CONTRAST 2)
+(defconstant DMICM_COLORMETRIC 3)
+(defconstant DMICM_USER 256)
+(defconstant DMMEDIA_STANDARD 1)
+(defconstant DMMEDIA_TRANSPARENCY 2)
+(defconstant DMMEDIA_GLOSSY 3)
+(defconstant DMMEDIA_USER 256)
+(defconstant DMDITHER_NONE 1)
+(defconstant DMDITHER_COARSE 2)
+(defconstant DMDITHER_FINE 3)
+(defconstant DMDITHER_LINEART 4)
+(defconstant DMDITHER_ERRORDIFFUSION 5)
+(defconstant DMDITHER_RESERVED6 6)
+(defconstant DMDITHER_RESERVED7 7)
+(defconstant DMDITHER_RESERVED8 8)
+(defconstant DMDITHER_RESERVED9 9)
+(defconstant DMDITHER_GRAYSCALE 10)
+(defconstant DMDITHER_USER 256)
+(defconstant TMPF_FIXED_PITCH 1)
+(defconstant TMPF_VECTOR 2)
+(defconstant TMPF_TRUETYPE 4)
+(defconstant TMPF_DEVICE 8)
+(defconstant NTM_ITALIC 1)
+(defconstant NTM_BOLD 32)
+(defconstant NTM_REGULAR 64)
+(defconstant TT_POLYGON_TYPE 24)
+(defconstant TT_PRIM_LINE 1)
+(defconstant TT_PRIM_QSPLINE 2)
+(defconstant FONTMAPPER_MAX 10)
+(defconstant ENHMETA_STOCK_OBJECT #x80000000)
+(defconstant WGL_FONT_LINES 0)
+(defconstant WGL_FONT_POLYGONS 1)
+(defconstant LPD_DOUBLEBUFFER 1)
+(defconstant LPD_STEREO 2)
+(defconstant LPD_SUPPORT_GDI 16)
+(defconstant LPD_SUPPORT_OPENGL 32)
+(defconstant LPD_SHARE_DEPTH 64)
+(defconstant LPD_SHARE_STENCIL 128)
+(defconstant LPD_SHARE_ACCUM 256)
+(defconstant LPD_SWAP_EXCHANGE 512)
+(defconstant LPD_SWAP_COPY 1024)
+(defconstant LPD_TRANSPARENT 4096)
+(defconstant LPD_TYPE_RGBA 0)
+(defconstant LPD_TYPE_COLORINDEX 1)
+(defconstant WGL_SWAP_MAIN_PLANE 1)
+(defconstant WGL_SWAP_OVERLAY1 2)
+(defconstant WGL_SWAP_OVERLAY2 4)
+(defconstant WGL_SWAP_OVERLAY3 8)
+(defconstant WGL_SWAP_OVERLAY4 16)
+(defconstant WGL_SWAP_OVERLAY5 32)
+(defconstant WGL_SWAP_OVERLAY6 64)
+(defconstant WGL_SWAP_OVERLAY7 128)
+(defconstant WGL_SWAP_OVERLAY8 256)
+(defconstant WGL_SWAP_OVERLAY9 512)
+(defconstant WGL_SWAP_OVERLAY10 1024)
+(defconstant WGL_SWAP_OVERLAY11 2048)
+(defconstant WGL_SWAP_OVERLAY12 4096)
+(defconstant WGL_SWAP_OVERLAY13 8192)
+(defconstant WGL_SWAP_OVERLAY14 16384)
+(defconstant WGL_SWAP_OVERLAY15 32768)
+(defconstant WGL_SWAP_UNDERLAY1 65536)
+(defconstant WGL_SWAP_UNDERLAY2 #x20000)
+(defconstant WGL_SWAP_UNDERLAY3 #x40000)
+(defconstant WGL_SWAP_UNDERLAY4 #x80000)
+(defconstant WGL_SWAP_UNDERLAY5 #x100000)
+(defconstant WGL_SWAP_UNDERLAY6 #x200000)
+(defconstant WGL_SWAP_UNDERLAY7 #x400000)
+(defconstant WGL_SWAP_UNDERLAY8 #x800000)
+(defconstant WGL_SWAP_UNDERLAY9 #x1000000)
+(defconstant WGL_SWAP_UNDERLAY10 #x2000000)
+(defconstant WGL_SWAP_UNDERLAY11 #x4000000)
+(defconstant WGL_SWAP_UNDERLAY12 #x8000000)
+(defconstant WGL_SWAP_UNDERLAY13 #x10000000)
+(defconstant WGL_SWAP_UNDERLAY14 #x20000000)
+(defconstant WGL_SWAP_UNDERLAY15 #x40000000)
+(defconstant AC_SRC_OVER	 #x00)
+(defconstant AC_SRC_ALPHA	 #x01)
+(defconstant AC_SRC_NO_PREMULT_ALPHA #x01)
+(defconstant AC_SRC_NO_ALPHA	 #x02)
+(defconstant AC_DST_NO_PREMULT_ALPHA #x10)
+(defconstant AC_DST_NO_ALPHA	 #x20)
+(defconstant LAYOUT_RTL 1)
+(defconstant LAYOUT_BITMAPORIENTATIONPRESERVED 8)
+(defconstant CS_ENABLE           #x00000001)
+(defconstant CS_DISABLE          #x00000002)
+(defconstant CS_DELETE_TRANSFORM #x00000003)
+(defconstant GRADIENT_FILL_RECT_H #x00)
+(defconstant GRADIENT_FILL_RECT_V #x01)
+(defconstant GRADIENT_FILL_TRIANGLE #x02)
+(defconstant GRADIENT_FILL_OP_FLAG #xff)
+(defconstant COLORMATCHTOTARGET_EMBEDED #x00000001)
+(defconstant CREATECOLORSPACE_EMBEDED   #x00000001)
+(defconstant SETICMPROFILE_EMBEDED      #x00000001)
+(defconstant DISPLAY_DEVICE_ATTACHED_TO_DESKTOP #x00000001)
+(defconstant DISPLAY_DEVICE_MULTI_DRIVER        #x00000002)
+(defconstant DISPLAY_DEVICE_PRIMARY_DEVICE      #x00000004)
+(defconstant DISPLAY_DEVICE_MIRRORING_DRIVER    #x00000008)
+(defconstant DISPLAY_DEVICE_VGA_COMPATIBLE      #x00000010)
+(defconstant DISPLAY_DEVICE_REMOVABLE           #x00000020)
+(defconstant DISPLAY_DEVICE_MODESPRUNED         #x08000000)
+(defconstant NTM_NONNEGATIVE_AC  #x00010000)
+(defconstant NTM_PS_OPENTYPE     #x00020000)
+(defconstant NTM_TT_OPENTYPE     #x00040000)
+(defconstant NTM_MULTIPLEMASTER  #x00080000)
+(defconstant NTM_TYPE1           #x00100000)
+(defconstant NTM_DSIG            #x00200000)
+(defconstant GGI_MARK_NONEXISTING_GLYPHS 1)
+(defconstant WS_BORDER	#x800000)
+(defconstant WS_CAPTION	#xc00000)
+(defconstant WS_CHILD	#x40000000)
+(defconstant WS_CHILDWINDOW	#x40000000)
+(defconstant WS_CLIPCHILDREN #x2000000)
+(defconstant WS_CLIPSIBLINGS #x4000000)
+(defconstant WS_DISABLED	#x8000000)
+(defconstant WS_DLGFRAME	#x400000)
+(defconstant WS_GROUP	#x20000)
+(defconstant WS_HSCROLL	#x100000)
+(defconstant WS_ICONIC	#x20000000)
+(defconstant WS_MAXIMIZE	#x1000000)
+(defconstant WS_MAXIMIZEBOX	#x10000)
+(defconstant WS_MINIMIZE	#x20000000)
+(defconstant WS_MINIMIZEBOX	#x20000)
+(defconstant WS_OVERLAPPED	0)
+(defconstant WS_OVERLAPPEDWINDOW	#xcf0000)
+(defconstant WS_POPUP	#x80000000)
+(defconstant WS_POPUPWINDOW	#x80880000)
+(defconstant WS_SIZEBOX	#x40000)
+(defconstant WS_SYSMENU	#x80000)
+(defconstant WS_TABSTOP	#x10000)
+(defconstant WS_THICKFRAME	#x40000)
+(defconstant WS_TILED	0)
+(defconstant WS_TILEDWINDOW	#xcf0000)
+(defconstant WS_VISIBLE	#x10000000)
+(defconstant WS_VSCROLL	#x200000)
+(defconstant WS_EX_ACCEPTFILES 16)
+(defconstant WS_EX_APPWINDOW #x40000)
+(defconstant WS_EX_CLIENTEDGE 512)
+(defconstant WS_EX_CONTEXTHELP #x400)
+(defconstant WS_EX_CONTROLPARENT #x10000)
+(defconstant WS_EX_DLGMODALFRAME 1)
+(defconstant WS_EX_LEFT 0)
+(defconstant WS_EX_LEFTSCROLLBAR #x4000)
+(defconstant WS_EX_LTRREADING 0)
+(defconstant WS_EX_MDICHILD 64)
+(defconstant WS_EX_NOPARENTNOTIFY 4)
+(defconstant WS_EX_OVERLAPPEDWINDOW #x300)
+(defconstant WS_EX_PALETTEWINDOW #x188)
+(defconstant WS_EX_RIGHT #x1000)
+(defconstant WS_EX_RIGHTSCROLLBAR 0)
+(defconstant WS_EX_RTLREADING #x2000)
+(defconstant WS_EX_STATICEDGE #x20000)
+(defconstant WS_EX_TOOLWINDOW 128)
+(defconstant WS_EX_TOPMOST 8)
+(defconstant WS_EX_TRANSPARENT 32)
+(defconstant WS_EX_WINDOWEDGE 256)
+(defconstant IDC_STATIC 0)
+(defconstant IDC_ARROW 1)
+(defconstant IDC_IBEAM 2)
+(defconstant IDC_WAIT 3)
+(defconstant IDC_CROSS 4)
+(defconstant IDC_UPARROW 5)
+(defconstant IDC_SIZENWSE 6)
+(defconstant IDC_SIZENESW 7)
+(defconstant IDC_SIZEWE 8)
+(defconstant IDC_SIZENS 9)
+(defconstant IDC_SIZEALL 10)
+(defconstant IDC_NO 11)
+(defconstant IDC_HAND 12)
+(defconstant IDC_APPSTARTING 13)
+(defconstant IDC_HELP 14)
+(defconstant IDC_ICON 15)
+(defconstant IDC_SIZE 16)
+(defconstant WM_ACTIVATE 6)
+(defconstant WM_ACTIVATEAPP 28)
+(defconstant WM_AFXFIRST 864)
+(defconstant WM_AFXLAST 895)
+(defconstant WM_ASKCBFORMATNAME 780)
+(defconstant WM_CANCELJOURNAL 75)
+(defconstant WM_CANCELMODE 31)
+(defconstant WM_CAPTURECHANGED 533)
+(defconstant WM_CHANGECBCHAIN 781)
+(defconstant WM_CHAR 258)
+(defconstant WM_CHARTOITEM 47)
+(defconstant WM_CHILDACTIVATE 34)
+(defconstant WM_CLEAR 771)
+(defconstant WM_CLOSE 16)
+(defconstant WM_COMMAND 273)
+(defconstant WM_COMPACTING 65)
+(defconstant WM_COMPAREITEM 57)
+(defconstant WM_CONTEXTMENU 123)
+(defconstant WM_COPY 769)
+(defconstant WM_COPYDATA 74)
+(defconstant WM_CREATE 1)
+(defconstant WM_CTLCOLORBTN 309)
+(defconstant WM_CTLCOLORDLG 310)
+(defconstant WM_CTLCOLOREDIT 307)
+(defconstant WM_CTLCOLORLISTBOX 308)
+(defconstant WM_CTLCOLORMSGBOX 306)
+(defconstant WM_CTLCOLORSCROLLBAR 311)
+(defconstant WM_CTLCOLORSTATIC 312)
+(defconstant WM_CUT 768)
+(defconstant WM_DEADCHAR 259)
+(defconstant WM_DELETEITEM 45)
+(defconstant WM_DESTROY 2)
+(defconstant WM_DESTROYCLIPBOARD 775)
+(defconstant WM_DEVICECHANGE 537)
+(defconstant WM_DEVMODECHANGE 27)
+(defconstant WM_DISPLAYCHANGE 126)
+(defconstant WM_DRAWCLIPBOARD 776)
+(defconstant WM_DRAWITEM 43)
+(defconstant WM_DROPFILES 563)
+(defconstant WM_ENABLE 10)
+(defconstant WM_ENDSESSION 22)
+(defconstant WM_ENTERIDLE 289)
+(defconstant WM_ENTERMENULOOP 529)
+(defconstant WM_ENTERSIZEMOVE 561)
+(defconstant WM_ERASEBKGND 20)
+(defconstant WM_EXITMENULOOP 530)
+(defconstant WM_EXITSIZEMOVE 562)
+(defconstant WM_FONTCHANGE 29)
+(defconstant WM_GETDLGCODE 135)
+(defconstant WM_GETFONT 49)
+(defconstant WM_GETHOTKEY 51)
+(defconstant WM_GETICON 127)
+(defconstant WM_GETMINMAXINFO 36)
+(defconstant WM_GETTEXT 13)
+(defconstant WM_GETTEXTLENGTH 14)
+(defconstant WM_HANDHELDFIRST 856)
+(defconstant WM_HANDHELDLAST 863)
+(defconstant WM_HELP 83)
+(defconstant WM_HOTKEY 786)
+(defconstant WM_HSCROLL 276)
+(defconstant WM_HSCROLLCLIPBOARD 782)
+(defconstant WM_ICONERASEBKGND 39)
+(defconstant WM_INITDIALOG 272)
+(defconstant WM_INITMENU 278)
+(defconstant WM_INITMENUPOPUP 279)
+(defconstant WM_INPUTLANGCHANGE 81)
+(defconstant WM_INPUTLANGCHANGEREQUEST 80)
+(defconstant WM_KEYDOWN 256)
+(defconstant WM_KEYUP 257)
+(defconstant WM_KILLFOCUS 8)
+(defconstant WM_MDIACTIVATE 546)
+(defconstant WM_MDICASCADE 551)
+(defconstant WM_MDICREATE 544)
+(defconstant WM_MDIDESTROY 545)
+(defconstant WM_MDIGETACTIVE 553)
+(defconstant WM_MDIICONARRANGE 552)
+(defconstant WM_MDIMAXIMIZE 549)
+(defconstant WM_MDINEXT 548)
+(defconstant WM_MDIREFRESHMENU 564)
+(defconstant WM_MDIRESTORE 547)
+(defconstant WM_MDISETMENU 560)
+(defconstant WM_MDITILE 550)
+(defconstant WM_MEASUREITEM 44)
+(defconstant WM_MENUCHAR 288)
+(defconstant WM_MENUSELECT 287)
+(defconstant WM_NEXTMENU 531)
+(defconstant WM_MOVE 3)
+(defconstant WM_MOVING 534)
+(defconstant WM_NCACTIVATE 134)
+(defconstant WM_NCCALCSIZE 131)
+(defconstant WM_NCCREATE 129)
+(defconstant WM_NCDESTROY 130)
+(defconstant WM_NCHITTEST 132)
+(defconstant WM_NCLBUTTONDBLCLK 163)
+(defconstant WM_NCLBUTTONDOWN 161)
+(defconstant WM_NCLBUTTONUP 162)
+(defconstant WM_NCMBUTTONDBLCLK 169)
+(defconstant WM_NCMBUTTONDOWN 167)
+(defconstant WM_NCMBUTTONUP 168)
+(defconstant WM_NCMOUSEMOVE 160)
+(defconstant WM_NCPAINT 133)
+(defconstant WM_NCRBUTTONDBLCLK 166)
+(defconstant WM_NCRBUTTONDOWN 164)
+(defconstant WM_NCRBUTTONUP 165)
+(defconstant WM_NEXTDLGCTL 40)
+(defconstant WM_NEXTMENU 531)
+(defconstant WM_NOTIFY 78)
+(defconstant WM_NOTIFYFORMAT 85)
+(defconstant WM_NULL 0)
+(defconstant WM_PAINT 15)
+(defconstant WM_PAINTCLIPBOARD 777)
+(defconstant WM_PAINTICON 38)
+(defconstant WM_PALETTECHANGED 785)
+(defconstant WM_PALETTEISCHANGING 784)
+(defconstant WM_PARENTNOTIFY 528)
+(defconstant WM_PASTE 770)
+(defconstant WM_PENWINFIRST 896)
+(defconstant WM_PENWINLAST 911)
+(defconstant WM_POWER 72)
+(defconstant WM_POWERBROADCAST 536)
+(defconstant WM_PRINT 791)
+(defconstant WM_PRINTCLIENT 792)
+(defconstant WM_QUERYDRAGICON 55)
+(defconstant WM_QUERYENDSESSION 17)
+(defconstant WM_QUERYNEWPALETTE 783)
+(defconstant WM_QUERYOPEN 19)
+(defconstant WM_QUEUESYNC 35)
+(defconstant WM_QUIT 18)
+(defconstant WM_RENDERALLFORMATS 774)
+(defconstant WM_RENDERFORMAT 773)
+(defconstant WM_SETCURSOR 32)
+(defconstant WM_SETFOCUS 7)
+(defconstant WM_SETFONT 48)
+(defconstant WM_SETHOTKEY 50)
+(defconstant WM_SETICON 128)
+(defconstant WM_SETREDRAW 11)
+(defconstant WM_SETTEXT 12)
+(defconstant WM_SETTINGCHANGE 26)
+(defconstant WM_SHOWWINDOW 24)
+(defconstant WM_SIZE 5)
+(defconstant WM_SIZECLIPBOARD 779)
+(defconstant WM_SIZING 532)
+(defconstant WM_SPOOLERSTATUS 42)
+(defconstant WM_STYLECHANGED 125)
+(defconstant WM_STYLECHANGING 124)
+(defconstant WM_SYSCHAR 262)
+(defconstant WM_SYSCOLORCHANGE 21)
+(defconstant WM_SYSCOMMAND 274)
+(defconstant WM_SYSDEADCHAR 263)
+(defconstant WM_SYSKEYDOWN 260)
+(defconstant WM_SYSKEYUP 261)
+(defconstant WM_TCARD 82)
+(defconstant WM_TIMECHANGE 30)
+(defconstant WM_TIMER 275)
+(defconstant WM_UNDO 772)
+(defconstant WM_USER 1024)
+(defconstant WM_USERCHANGED 84)
+(defconstant WM_VKEYTOITEM 46)
+(defconstant WM_VSCROLL 277)
+(defconstant WM_VSCROLLCLIPBOARD 778)
+(defconstant WM_WINDOWPOSCHANGED 71)
+(defconstant WM_WINDOWPOSCHANGING 70)
+(defconstant WM_WININICHANGE 26)
+(defconstant WM_KEYFIRST 256)
+(defconstant WM_KEYLAST 264)
+(defconstant WM_SYNCPAINT  136)
+(defconstant WM_MOUSEACTIVATE 33)
+(defconstant WM_MOUSEMOVE 512)
+(defconstant WM_LBUTTONDOWN 513)
+(defconstant WM_LBUTTONUP 514)
+(defconstant WM_LBUTTONDBLCLK 515)
+(defconstant WM_RBUTTONDOWN 516)
+(defconstant WM_RBUTTONUP 517)
+(defconstant WM_RBUTTONDBLCLK 518)
+(defconstant WM_MBUTTONDOWN 519)
+(defconstant WM_MBUTTONUP 520)
+(defconstant WM_MBUTTONDBLCLK 521)
+(defconstant WM_MOUSEWHEEL 522)
+(defconstant WM_MOUSEFIRST 512)
+(defconstant WM_MOUSELAST 522)
+(defconstant WM_MOUSEHOVER #x2A1)
+(defconstant WM_MOUSELEAVE #x2A3)
+(defconstant SW_HIDE 0)
+(defconstant SW_NORMAL 1)
+(defconstant SW_SHOWNORMAL 1)
+(defconstant SW_SHOWMINIMIZED 2)
+(defconstant SW_MAXIMIZE 3)
+(defconstant SW_SHOWMAXIMIZED 3)
+(defconstant SW_SHOWNOACTIVATE 4)
+(defconstant SW_SHOW 5)
+(defconstant SW_MINIMIZE 6)
+(defconstant SW_SHOWMINNOACTIVE 7)
+(defconstant SW_SHOWNA 8)
+(defconstant SW_RESTORE 9)
+(defconstant SW_SHOWDEFAULT 10)
+(defconstant SW_FORCEMINIMIZE 11)
+(defconstant SW_MAX  11)
+(defconstant SW_PARENTCLOSING 1)
+(defconstant SW_OTHERZOOM 2)
+(defconstant SW_PARENTOPENING 3)
+(defconstant SW_OTHERUNZOOM 4)
+(defconstant SW_SCROLLCHILDREN 1)
+(defconstant SW_INVALIDATE 2)
+(defconstant SW_ERASE 4)
+
+;;; TODO: bitshift with fixnum as under windows: r + g<<8 + b<<16
+(defstruct (RGB (:constructor make-rgb (r g b))) r g b)
+(defconstant *black* (make-rgb 0 0 0))
+(defconstant *white* (make-rgb #xff #xff #xff))
+
+(deftype pixarray-1-element-type ()  'bit)
+(deftype pixarray-4-element-type ()  '(unsigned-byte 4))
+(deftype pixarray-8-element-type ()  '(unsigned-byte 8))
+(deftype pixarray-16-element-type () '(unsigned-byte 16))
+(deftype pixarray-24-element-type () '(unsigned-byte 24))
+(deftype pixarray-32-element-type () '(unsigned-byte 32))
+
+(defstruct (RECT (:constructor make-rect (&optional left top right bottom)))
+   left top right bottom)
+
+(defstruct (POINT (:constructor make-point (&optional x y)))
+  (x 0 :type integer) (y 0 :type integer))
+(defstruct (POINT-FLOAT (:constructor make-point-float (&optional x y)))
+  (x 0.0 :type short-float) (y 0.0 :type short-float))
+
+(defstruct (LOGFONT (:constructor make-logfont (&optional
+   lfheight lfwidth lfescapement lforientation lfweight lfitalic
+   lfunderline lfstrikeout lfcharset lfoutprecision lfclipprecision
+   lfquality lfpitchandfamily lffacename)))
+   (lfheight 0 :type fixnum)
+   (lfwidth 0 :type fixnum)
+   (lfescapement 0 :type fixnum)
+   (lforientation 0 :type fixnum)
+   (lfweight 0 :type fixnum)
+   (lfitalic 0 :type fixnum)
+   (lfunderline 0 :type fixnum)
+   (lfstrikeout 0 :type fixnum)
+   (lfcharset 0 :type fixnum)
+   (lfoutprecision 0 :type fixnum)
+   (lfclipprecision 0 :type fixnum)
+   (lfquality 0 :type fixnum)
+   (lfpitchandfamily 0 :type fixnum)
+   (lffacename "" :type STRING))
+
+(defstruct (CREATESTRUCT (:constructor make-createstruct (&optional
+   dwexstyle lpszclass lpszname style x y cx cy hwndparent hmenu 
+   hinstance lpcreateparams)))
+   (dwexstyle 0 :type (UNSIGNED 32))
+   (lpszclass "" :type STRING)
+   (lpszname "" :type STRING)
+   (style 0 :type (unsigned 32))
+   (x 0 :type fixnum)
+   (y 0 :type fixnum)
+   (cx 0 :type fixnum)
+   (cy 0 :type fixnum)
+   (hwndparent 0 :type foreign)
+   (hmenu 0 :type foreign)
+   (hinstance 0 :type foreign)
+   (lpcreateparams 0 :type foreign))
+
+(defstruct (ICONINFO (:constructor make-iconinfo (&optional
+   fIcon xHotspot yHotspot hbmMask hbmColor)))
+  (fIcon 0 :type fixnum) ; BOOL
+  (xHotspot 0 :type fixnum)
+  (yHotspot 0 :type fixnum)
+  (hbmMask 0 :type foreign)
+  (hbmColor 0 :type foreign))
+
+(defstruct (WNDCLASS (:constructor make-wndclass (&optional
+   style cbclsextra cbwndextra hinstance hicon hcursor
+   hbrbackground lpszmenuname lpszclassname)))
+   (style 0 :type fixnum)
+   (cbclsextra 0 :type fixnum)
+   (cbwndextra 0 :type fixnum)
+   (hinstance 0 :type foreign)
+   (hicon 0 :type foreign)
+   (hcursor 0 :type foreign)
+   (hbrbackground 0 :type foreign)
+   (lpszmenuname "" :type STRING)
+   (lpszclassname "" :type STRING))
+
+(defstruct (TEXTMETRIC (:constructor make-textmetric (&optional
+    tmheight tmascent tmdescent tminternalleading tmexternalleading
+    tmavecharwidth tmmaxcharwidth tmweight tmoverhang tmdigitizedaspectx
+    tmdigitizedaspecty tmfirstchar tmlastchar tmdefaultchar tmbreakchar
+    tmitalic tmunderlined tmstruckout tmpitchandfamily tmcharset)))
+   (tmheight 0 :type fixnum)
+   (tmascent 0 :type fixnum)
+   (tmdescent 0 :type fixnum)
+   (tminternalleading 0 :type fixnum)
+   (tmexternalleading 0 :type fixnum)
+   (tmavecharwidth 0 :type fixnum)
+   (tmmaxcharwidth 0 :type fixnum)
+   (tmweight 0 :type fixnum)
+   (tmoverhang 0 :type fixnum)
+   (tmdigitizedaspectx 0 :type fixnum)
+   (tmdigitizedaspecty 0 :type fixnum)
+   (tmfirstchar #\space :type character)
+   (tmlastchar #\space :type character)
+   (tmdefaultchar #\space :type fixnum)
+   (tmbreakchar #\space :type fixnum)
+   (tmitalic 0 :type fixnum)
+   (tmunderlined 0 :type fixnum)
+   (tmstruckout 0 :type fixnum)
+   (tmpitchandfamily 0 :type fixnum)
+   (tmcharset 0 :type fixnum))
+
+;;; This function is similar to the clx function draw-arc.
+;;; To avoid using optional arguments, args are passed in as points.
+(defun draw-arc (hdc pPosition pDimension pAngle)
+   (let* ((x (POINT-x pPosition))
+          (y (POINT-y pPosition))
+          (width (POINT-x pDimension))
+          (height (POINT-y pDimension))
+          (angle (POINT-FLOAT-y pAngle))
+          angle1 angle2)
+      (if (>= angle 0.0)
+          (setf angle1 (POINT-FLOAT-x pAngle) angle2 (+ angle angle1))
+          (setf angle2 (POINT-FLOAT-x pAngle) angle1 (- angle2 angle)))
+      (GDI::Arc hdc x y (+ x width -1) (+ y height -1)
+          (truncate (+ x (/ width 2) (* width (cos angle1))))
+          (truncate (+ y (/ height 2) (- (* height (sin angle1)))))
+          (truncate (+ x (/ width 2) (* width (cos angle2))))
+          (truncate (+ y (/ height 2) (- (* height (sin angle2))))))))
+
+(defun bitmap-image (&rest r)(declare (ignore r)) t)
+
+(defvar *last-error* nil)
+; I am not sure if this is needed, it is from the mac implementation
+(defvar *current-event* nil)
+; If we switch to a fixnum for this, it will be faster
+; but for now, get it working
+(defvar *functions* (make-hash-table :test #'equalp))
+(defun onCreate (hWnd)
+   (let* ((k (cons 0 WM_NCCREATE))
+          (alist (gethash k *functions*)))
+      (when alist (remhash k *functions*))
+      (mapc #'(lambda (c)
+              (setf (gethash (cons hWnd (car c)) *functions*) (cdr c)))
+         alist)))
+
+(defun init-gdi () (GDI::initc *functions* #'onCreate))
+(defvar *hinstance* (init-gdi))
+
+(defun create-gcontext (&rest r)(declare (ignore r)) t)
+
+(defun add-callbacks (message-id a)
+   (let ((key (cons  0 message-id )))
+        (setf (gethash key *functions*) a)))
+(defun remove-callback (hwnd message-id)
+   (remhash (cons hwnd message-id) *functions*))
+
+(defun handle-textmetric (hfont)
+  (let* ((hdc (GDI::GetDC nil))
+         (tm (make-textmetric))
+         (hOldFont (if hdc (GDI::SelectObject hdc hfont) (error "GetDC ~S" GDI:*last-error*))))
+     (if (null hOldFont) (error "SelectObject ~S" GDI:*last-error*))
+     (if (null (GDI::GetTextMetricsA hdc tm)) (error "GetTextMetricsA ~S" GDI:*last-error*))
+     (GDI::SelectObject hdc hOldFont)
+     tm))
+
+(defun max-char-ascent (hfont)
+   (TEXTMETRIC-tmascent (handle-textmetric hfont)))
+
+(defun max-char-descent (hfont)
+   (TEXTMETRIC-tmdescent (handle-textmetric hfont)))
+
+(pushnew :gdi *features*)
+(provide "gdi")
+(pushnew "GDI" custom:*system-package-list* :test #'string=)
diff -burN origsrc/clisp-2.48/modules/gdi/gdi.m src/clisp-2.48/modules/gdi/gdi.m
--- origsrc/clisp-2.48/modules/gdi/gdi.m	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/gdi.m	2009-07-30 13:38:19.000000000 +0000
@@ -0,0 +1,292 @@
+#line 1 "gdi.m"  /* -*- C -*- */
+/*
+   The basic idea of this module is to create lisp callable functions
+   for the T symbols in the w32api library libgdi32.a. To do this, I
+   used a awk program which parsed the function headers, and created
+   the functions here. So most of them are not tested.
+   Once a function is tested remove the untested comment from the function.
+   This file is LGPL'd, and copyright assigned to the FSF.
+     Dan Stanger 4/9/02
+   Changed to MODERN (case sensitive) and make it work under clisp-2.39
+     Reini Urban 2006-08-13
+   Checked all compiler warnings, modprep fixes (cs-modprep.patch), 
+   removed T return values on success, changed most new functions,
+   added documentation, published at http://code.google.com/p/clisp-gdi/
+     Reini Urban 2009-07
+
+  ../src/lndir ../modules/gdi gdi; make all -C gdi
+  rm -rf full+gdi; CLISP_LINKKIT=. MAKE=make ./clisp-link add base full+gdi gdi
+*/
+#define NO_STRICT
+#define WIN32_LEAN_AND_MEAN
+/* for the new msimg32 functions: GetDCPenColor, ... */
+#define WINVER 0x0501
+#include <stdio.h>
+#include <windows.h>
+#include <assert.h>
+
+#include "clisp.h"
+#undef  DEFMODULE
+#define DEFMODULE(a,b,c)
+#define DEFUN(funname,lambdalist,signature) LISPFUN signature
+#define DEFVAR(varname)
+#define WIDECHAR(o,e)  &TheS16string(o)->data[0]
+#define memclr(p,n) memset(p,0,n)
+#define encoding GLO(misc_encoding)
+DEFMODULE(GDI,"GDI",(:modern t))
+
+static object lookupHash(HWND hwnd, int message);
+
+LRESULT CALLBACK WindowProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);
+LRESULT CALLBACK WindowProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
+{
+#ifdef DEBUG_OS_ERROR
+  printf("HWND %x UINT %d WPARAM %d LPARAM %d\n",hWnd,message,wParam,lParam);
+#endif
+  switch (message) {
+   // When window is created, the callback gets done before the createwindow
+   // returns with a handle.  To get around this, and this is NOT thread
+   // safe, store a alist of messages and functions.  Then call a
+   // lisp function with the window handle and the alist, and store
+   // the new list in the hash table.
+   case WM_NCCREATE:
+   {
+     object p;
+     begin_callback();
+     p = allocate_fpointer((FOREIGN)hWnd);
+     pushSTACK(p);
+     funcall(O(onCreate),1);
+     end_callback();
+     return TRUE;
+   }
+   case WM_CREATE:
+   {
+      break;
+   }
+   case WM_PAINT:
+   {
+     PAINTSTRUCT paintStruct;
+     object func;
+//asm("int3");
+     BeginPaint(hWnd,&paintStruct);
+     begin_callback();
+     func = lookupHash(hWnd, message);
+     if(!nullp(func))
+     {
+        pushSTACK(allocate_fpointer((FOREIGN)paintStruct.hdc));
+        funcall(func,1);
+     }
+     end_callback();
+     EndPaint(hWnd,&paintStruct);
+     break;
+   }
+   case WM_CLOSE:
+   {
+     object func;
+//asm("int3");
+     begin_callback();
+     func = lookupHash(hWnd, message);
+     if(!nullp(func))
+     {
+        pushSTACK(allocate_fpointer((FOREIGN)hWnd));
+        funcall(func,1);
+        end_callback();
+     }
+     else
+     {
+        end_callback();
+        return (DefWindowProc(hWnd, message, wParam, lParam));
+     }
+     break;
+   }
+   case WM_KEYDOWN:
+     switch (wParam)
+     {
+       case VK_CANCEL:
+       case VK_CLEAR:
+       case VK_PAUSE:
+       case VK_PRIOR:
+       case VK_NEXT:
+       case VK_END:
+       case VK_HOME:
+       case VK_LEFT:
+       case VK_UP:
+       case VK_RIGHT:
+       case VK_DOWN:
+       case VK_SELECT:
+       case VK_PRINT:
+       case VK_EXECUTE:
+       case VK_INSERT:
+       case VK_DELETE:
+       case VK_HELP:
+       case VK_NUMLOCK:
+       case VK_SCROLL:
+       case VK_F1:
+       case VK_F2:
+       case VK_F3:
+       case VK_F4:
+       case VK_F5:
+       case VK_F6:
+       case VK_F7:
+       case VK_F8:
+       case VK_F9:
+       case VK_F10:
+       case VK_F11:
+       case VK_F12:
+       default:
+       {
+         begin_callback();
+         object func = lookupHash(hWnd, message);
+         if(!nullp(func))
+         {
+            /* This cast assumes that sizeof(void*)==sizeof(LPARAM) */
+            pushSTACK(allocate_fpointer((FOREIGN)lParam));
+            pushSTACK(fixnum(wParam));
+            funcall(func,2);
+         }
+         end_callback();
+         break;
+       }
+     }
+     break;
+   case WM_LBUTTONDOWN:
+   case WM_MBUTTONDOWN:
+   case WM_RBUTTONDOWN:
+   case WM_MBUTTONUP:
+   case WM_LBUTTONUP:
+   case WM_RBUTTONUP:
+   case WM_MOUSEMOVE:
+   case WM_MOUSEWHEEL:
+   case WM_ERASEBKGND:
+   case WM_KILLFOCUS:
+   case WM_SETFOCUS:
+   case WM_QUIT:
+   case WM_DESTROY:
+   case WM_SYSCHAR: /* alt-keys go here */
+   case WM_CHAR:
+   case WM_LBUTTONDBLCLK:
+   case WM_MBUTTONDBLCLK:
+   case WM_RBUTTONDBLCLK:
+   case WM_MOVE:	
+   case WM_SIZE:			
+   case WM_DESTROYCLIPBOARD:
+   default:        /* Passes it on if unproccessed    */
+     return (DefWindowProc(hWnd, message, wParam, lParam));
+    }
+    return 0L;
+}
+
+static object lookupHash(HWND hwnd, int message){
+#ifdef DEBUG_OS_ERROR
+   printf("lookupHash hwnd %x message %d\n",hwnd,message);
+#endif
+   Car(O(localCons)) = allocate_fpointer((FOREIGN)hwnd);
+   Cdr(O(localCons)) = fixnum(message);
+   pushSTACK(O(localCons));
+   pushSTACK(O(functions));
+   funcall(S(gethash),2);
+   return value1;
+}
+
+DEFVAR(functions,`NIL`)
+DEFVAR(localCons,`NIL`)
+DEFVAR(onCreate,`NIL`)
+DEFVAR(fp_zero,`NIL`)
+/* TODO: on case-sensitive T change to GDI:InitC */
+DEFUN( GDI:initc, h f)
+{
+  O(localCons) = allocate_cons();
+  O(onCreate) = popSTACK();
+  O(functions) = popSTACK();
+  O(fp_zero) = allocate_fpointer((FOREIGN)0);
+  value1 = allocate_fpointer((FOREIGN)GetModuleHandle(0));
+  mv_count=1;
+  return;
+}
+static LPSTR idc[] ={
+   0,
+   (LPSTR)IDC_ARROW,
+   (LPSTR)IDC_IBEAM,
+   (LPSTR)IDC_WAIT,
+   (LPSTR)IDC_CROSS,
+   (LPSTR)IDC_UPARROW,
+   (LPSTR)IDC_SIZENWSE,
+   (LPSTR)IDC_SIZENESW,
+   (LPSTR)IDC_SIZEWE,
+   (LPSTR)IDC_SIZENS,
+   (LPSTR)IDC_SIZEALL,
+   (LPSTR)IDC_NO,
+   (LPSTR)IDC_HAND,
+   (LPSTR)IDC_APPSTARTING,
+   (LPSTR)IDC_HELP,
+   (LPSTR)IDC_ICON,
+   (LPSTR)IDC_SIZE
+};
+DEFUN( GDI:GetIDC, h)
+{
+  object arg = popSTACK();
+  check_uint32(arg);
+  value1 = allocate_fpointer((FOREIGN)idc[I_to_uint32(arg)]);
+  mv_count=1;
+  return;
+}
+ 
+DEFUN( GDI:MakeFPointer, h)
+{
+  /* This cast assumes that sizeof(void*)==sizeof(uint32) */
+  value1 = allocate_fpointer((FOREIGN)I_to_uint32(popSTACK()));
+  mv_count=1;
+  return;
+}
+DEFUN( GDI:MessageLoop,)
+{
+  MSG m;
+  while (GetMessage(&m, (HWND) NULL, 0, 0)) { 
+    TranslateMessage(&m); 
+    DispatchMessage(&m); 
+  } 
+  value1 = fixnum(m.wParam);
+  mv_count=1;
+  return;
+}
+
+// Retrieve the status of the specified virtual key at the time the last
+// keyboard message was retrieved from the message queue.
+DEFUN( GDI:GetKeyState, int0)
+{
+  object arg;
+  int int0, int1;
+  arg = popSTACK();
+  check_sint(arg);
+  int0 = I_to_sint32(arg);
+  begin_system_call();
+  int1 = GetKeyState(int0);
+  end_system_call();
+  value1 = ((int1 & 0x8000) >> 15) ? T :  NIL;   // up or down
+  value2 = (int1 & 0x0001) ? T : NIL;            // toggled or not
+  value3 = sint32_to_I(int1);                    // the whole
+  mv_count=3;
+  return;
+}
+// from array.c
+extern object allocate_bit_vector_0 (uintL len);
+// Returns bivector of size 256 with the status of the 256 virtual keys.
+// The index in the array is the virtual key code. If the value 
+// is true, that key is pressed.
+DEFUN( GDI:GetKeyboardState,)
+{
+  int i;
+  BYTE keys[256];
+  object newvec;
+  begin_system_call();
+  GetKeyboardState(keys);
+  end_system_call();
+  newvec = allocate_bit_vector_0(256);
+  for (i=0; i < 256; i++) {
+      if (keys[i] & 128)
+          TheSbvector(newvec)->data[i/8] |= bit((~i) % 8);
+  }
+  VALUES1(newvec);
+  return;
+}
+
diff -burN origsrc/clisp-2.48/modules/gdi/gdi.txt src/clisp-2.48/modules/gdi/gdi.txt
--- origsrc/clisp-2.48/modules/gdi/gdi.txt	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/gdi.txt	2006-08-13 14:24:15.000000000 +0000
@@ -0,0 +1,17 @@
+/*
+do we need a with a with-pen macro or a  with-dc macro?
+following the motifzone document
+we define a device-context structure (or should it be a class)
+we use functions which call the corresponding win32 function to
+manipulate the the device context.
+The gdi uses handles which is a 32 bit unsigned int.
+Since the most-positive-fixnum in clisp is 24 bits, the
+foreign-pointer is used (pointer to void).  All handles are
+this type.
+Since out parameters are passed as multiple values,
+adopt the convention that the return value is first,
+
+change of plan we use cparse to generate structure assignment
+code in c.  then call directly from c.
+ */
+
diff -burN origsrc/clisp-2.48/modules/gdi/gdi.xml src/clisp-2.48/modules/gdi/gdi.xml
--- origsrc/clisp-2.48/modules/gdi/gdi.xml	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/gdi.xml	2009-07-28 22:06:56.000000000 +0000
@@ -0,0 +1,1283 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<section id="gdi"><title>GDI Interface</title>
+
+<para>This is an module-based interface to the Windows 
+<filename>GDI32.dll</filename>, to allow writing native Windows GUI's.</para>
+
+<para>The package <quote role="package">GDI</quote>
+ is <link linkend="package-case">case-sensitive</link>,
+ e.g., you would need to use the command-line option &opt-modern;
+ or be in &cs-clu; package, and write <code>(GDI::CreateFontA ...)</code> 
+ when you need to call the &c-lang; function <function>CreateFontA</function>. 
+ See <xref linkend="defpack"/></para>
+
+<simpara>When this module is present, &features-my;
+ contains the symbol <constant>:GDI</constant>. </simpara>
+
+<para>See <filename>modules/gdi/p1.lisp</filename> or
+<filename>modules/gdi/p2.lisp</filename> for sample usage.</para>
+
+<section id="gdi-struct"><title>Structs</title>
+<para>All data is kept on the &c-lang; side as much as possible, 
+ there are no &clos; counterparts.</para>
+<para>Struct names are uppercase matching the Windows struct name, 
+ the constructor is lowercase with the <function>make-</function> prefix.</para>
+<variablelist>
+ <varlistentry id="RGB"><term><type>RGB</type></term>
+  <listitem><simpara>Constructor <code>(make-rgb r g b)</code>,
+  predefined instances are <constant>*black*</constant> and <constant>*white*</constant>.
+  </simpara></listitem></varlistentry>
+ <varlistentry id="RECT"><term><type>RECT</type></term>
+  <listitem><simpara>Constructor <code>(make-rect &optional-amp; left top right bottom)</code>.
+  </simpara></listitem></varlistentry>
+ <varlistentry id="POINT"><term><type>POINT</type></term>
+  <listitem><simpara>Constructor <code>(make-point &optional-amp; x y)</code>, 
+  x and y are of type <type>integer</type>.
+  </simpara></listitem></varlistentry>
+ <varlistentry id="POINT-FLOAT"><term><type>POINT-FLOAT</type></term>
+  <listitem><simpara>Constructor <code>(make-point-float &optional-amp; x y)</code>, 
+  x and y are of type <type>short-float</type>.
+  </simpara></listitem></varlistentry>
+ <varlistentry id="LOGFONT"><term><type>LOGFONT</type></term>
+  <simpara>Struct slots:</simpara>
+  <programlisting>
+    <![CDATA[
+   (lfheight 0 :type fixnum)
+   (lfwidth 0 :type fixnum)
+   (lfescapement 0 :type fixnum)
+   (lforientation 0 :type fixnum)
+   (lfweight 0 :type fixnum)
+   (lfitalic 0 :type fixnum)
+   (lfunderline 0 :type fixnum)
+   (lfstrikeout 0 :type fixnum)
+   (lfcharset 0 :type fixnum)
+   (lfoutprecision 0 :type fixnum)
+   (lfclipprecision 0 :type fixnum)
+   (lfquality 0 :type fixnum)
+   (lfpitchandfamily 0 :type fixnum)
+   (lffacename "" :type STRING)
+    ]]>
+  </programlisting>
+ </varlistentry>
+ <varlistentry id="CREATESTRUCT"><term><type>CREATESTRUCT</type></term>
+  <simpara>Struct slots:</simpara>
+  <programlisting>
+    <![CDATA[
+   (dwexstyle 0 :type (UNSIGNED 32))
+   (lpszclass "" :type STRING)
+   (lpszname "" :type STRING)
+   (style 0 :type (unsigned 32))
+   (x 0 :type fixnum)
+   (y 0 :type fixnum)
+   (cx 0 :type fixnum)
+   (cy 0 :type fixnum)
+   (hwndparent 0 :type foreign)
+   (hmenu 0 :type foreign)
+   (hinstance 0 :type foreign)
+   (lpcreateparams 0 :type foreign)
+    ]]>
+  </programlisting>
+ </varlistentry>
+ <varlistentry id="ICONINFO"><term><type>ICONINFO</type></term>
+  <simpara>Struct slots:</simpara>
+  <programlisting>
+    <![CDATA[
+        fIcon
+	xHotspot
+	yHotspot
+	hbmMask
+	hbmColor
+    ]]>
+  </programlisting>
+ </varlistentry>
+ <varlistentry id="WNDCLASS"><term><type>WNDCLASS</type></term>
+  <simpara>Struct slots:</simpara>
+  <programlisting>
+    <![CDATA[
+   (style 0 :type fixnum)
+   (cbclsextra 0 :type fixnum)
+   (cbwndextra 0 :type fixnum)
+   (hinstance 0 :type foreign)
+   (hicon 0 :type foreign)
+   (hcursor 0 :type foreign)
+   (hbrbackground 0 :type foreign)
+   (lpszmenuname "" :type STRING)
+   (lpszclassname "" :type STRING)
+    ]]>
+  </programlisting>
+ </varlistentry>
+ <varlistentry id="TEXTMETRIC"><term><type>TEXTMETRIC</type></term>
+  <simpara>Struct slots:</simpara>
+  <programlisting>
+    <![CDATA[
+   (tmheight 0 :type fixnum)
+   (tmascent 0 :type fixnum)
+   (tmdescent 0 :type fixnum)
+   (tminternalleading 0 :type fixnum)
+   (tmexternalleading 0 :type fixnum)
+   (tmavecharwidth 0 :type fixnum)
+   (tmmaxcharwidth 0 :type fixnum)
+   (tmweight 0 :type fixnum)
+   (tmoverhang 0 :type fixnum)
+   (tmdigitizedaspectx 0 :type fixnum)
+   (tmdigitizedaspecty 0 :type fixnum)
+   (tmfirstchar #\space :type character)
+   (tmlastchar #\space :type character)
+   (tmdefaultchar #\space :type fixnum)
+   (tmbreakchar #\space :type fixnum)
+   (tmitalic 0 :type fixnum)
+   (tmunderlined 0 :type fixnum)
+   (tmstruckout 0 :type fixnum)
+   (tmpitchandfamily 0 :type fixnum)
+   (tmcharset 0 :type fixnum)
+    ]]>
+  </programlisting>
+ </varlistentry>
+ </variablelist>
+</section>
+
+<section id="gdi-functions"><title>GDI Functions</title>
+  <subtitle>Argument types:</subtitle>
+  <simpara><code>int DWORD WORD LONG UINT LPARAM</code> arguments are mapped to direct &integer-t; 
+   types.</simpara> 
+  <simpara>All strings <code>(LPCSTR, LPCWSTR, ...)</code> are converted automatically to 
+   &foreign-pointer;.</simpara> 
+  <para><warning>Unsure about he struct types. To be verified!</warning>
+   All handles <code>(ATOM, H*)</code> which are no explicitly handled structs from 
+   above must be &foreign-pointer; types. See the <code>process*</code> functions in local.c</para>
+  
+  <subtitle>Return values:</subtitle> 
+  <simpara><type>BOOL</type> GDI functions return on success just <constant>&t;</constant>, 
+   on failure <constant>&nil;</constant> as first value and <code>GetLastError</code> (&integer-t;)
+   as second value.</simpara>
+  <simpara><type>integer</type> GDI functions return on success &t; and the returned integer as second value, 
+   on failure also <constant>&nil;</constant> as first value and <code>GetLastError</code> (&integer-t;)
+   as second value.</simpara>
+  <simpara>The other functions returning a struct may return them as &foreign-pointer; in the 
+   second value, the first value is <constant>&t;</constant> on success, or as multiple values. 
+   The error behaviour is the same as above.</simpara>
+  <simpara>Some functions which in c would return a struct return multiple values
+   if it was more convenient to do so.  For example <link linkend="GetTextExtentPoint32A">
+   <code>GetTextExtentPoint32A</code></link> would return a <type>SIZE</type> as &foreign-pointer;, 
+   but most of the time, the size will be used directly. If this proves not to be the case, change 
+   it.</simpara>
+
+<variablelist>
+<varlistentry id="AddFontResourceA"><term><code>(AddFontResourceA LPCSTR)</code></term>
+  <para>See <term><ulink url="http://social.msdn.microsoft.com/search/en-us/?query=AddFontResourceA">MSDN</ulink></term></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;. On failure <constant>&nil;</constant> and as second value the error code as &integer-t; is returned.</para></varlistentry>
+<varlistentry id="AddFontResourceW"><term><code>(AddFontResourceW LPCWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=AddFontResourceW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;. On failure <constant>&nil;</constant> and as second value the error code as &integer-t; is returned.</para></varlistentry>
+<varlistentry id="AnimatePalette"><term><code>(AnimatePalette HPALETTE UINT UINT  PALETTEENTRY_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=AnimatePalette">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="ChoosePixelFormat"><term><code>(ChoosePixelFormat HDC   PIXELFORMATDESCRIPTOR_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ChoosePixelFormat">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="CreateBitmap"><term><code>(CreateBitmap int int UINT UINT PCVOID)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateBitmap">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HBITMAP</type> structure.</para></varlistentry>
+<varlistentry id="CreateDIBPatternBrushPt"><term><code>(CreateDIBPatternBrushPt PCVOID UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateDIBPatternBrushPt">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HBRUSH</type> structure.</para></varlistentry>
+<varlistentry id="CreatePolyPolygonRgn"><term><code>(CreatePolyPolygonRgn  POINT_P  INT_P int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreatePolyPolygonRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HRGN</type> structure.</para></varlistentry>
+<varlistentry id="CreatePolygonRgn"><term><code>(CreatePolygonRgn  POINT_P int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreatePolygonRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HRGN</type> structure.</para></varlistentry>
+<varlistentry id="CreateScalableFontResourceA"><term><code>(CreateScalableFontResourceA DWORD LPCSTR LPCSTR LPCSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateScalableFontResourceA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="CreateScalableFontResourceW"><term><code>(CreateScalableFontResourceW DWORD LPCWSTR LPCWSTR LPCWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateScalableFontResourceW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="DPtoLP"><term><code>(DPtoLP HDC LPPOINT int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=DPtoLP">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="DescribePixelFormat"><term><code>(DescribePixelFormat HDC int UINT LPPIXELFORMATDESCRIPTOR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=DescribePixelFormat">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="DrawEscape"><term><code>(DrawEscape HDC int int LPCSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=DrawEscape">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="ExtCreatePen"><term><code>(ExtCreatePen DWORD DWORD  LOGBRUSH_P DWORD  DWORD_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ExtCreatePen">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HPEN</type> structure.</para></varlistentry>
+<varlistentry id="ExtCreateRegion"><term><code>(ExtCreateRegion  XFORM_P DWORD  RGNDATA_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ExtCreateRegion">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HRGN</type> structure.</para></varlistentry>
+<varlistentry id="FixBrushOrgEx"><term><code>(FixBrushOrgEx HDC int int LPPOINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=FixBrushOrgEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GdiComment"><term><code>(GdiComment HDC UINT  BYTE_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GdiComment">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GdiFlush"><term><code>(GdiFlush  )</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GdiFlush">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GdiGetBatchLimit"><term><code>(GdiGetBatchLimit  )</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GdiGetBatchLimit">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="LPtoDP"><term><code>(LPtoDP HDC LPPOINT int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=LPtoDP">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="ModifyWorldTransform"><term><code>(ModifyWorldTransform HDC  XFORM_P DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ModifyWorldTransform">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="MoveToEx"><term><code>(MoveToEx HDC int int LPPOINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=MoveToEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="OffsetViewportOrgEx"><term><code>(OffsetViewportOrgEx HDC int int LPPOINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=OffsetViewportOrgEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="OffsetWindowOrgEx"><term><code>(OffsetWindowOrgEx HDC int int LPPOINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=OffsetWindowOrgEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="PlayEnhMetaFileRecord"><term><code>(PlayEnhMetaFileRecord HDC LPHANDLETABLE  ENHMETARECORD_P UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=PlayEnhMetaFileRecord">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="PlayMetaFileRecord"><term><code>(PlayMetaFileRecord HDC LPHANDLETABLE LPMETARECORD UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=PlayMetaFileRecord">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="PolyBezier"><term><code>(PolyBezier HDC  POINT_P DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=PolyBezier">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="PolyBezierTo"><term><code>(PolyBezierTo HDC  POINT_P DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=PolyBezierTo">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="PolyDraw"><term><code>(PolyDraw HDC  POINT_P  BYTE_P int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=PolyDraw">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="PolyPolygon"><term><code>(PolyPolygon HDC  POINT_P  INT_P int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=PolyPolygon">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="PolyPolyline"><term><code>(PolyPolyline HDC  POINT_P  DWORD_P DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=PolyPolyline">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="PolyTextOutA"><term><code>(PolyTextOutA HDC  POLYTEXTA_P int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=PolyTextOutA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="PolyTextOutW"><term><code>(PolyTextOutW HDC  POLYTEXTW_P int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=PolyTextOutW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="Polygon"><term><code>(Polygon HDC  POINT_P int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=Polygon">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="Polyline"><term><code>(Polyline HDC  POINT_P int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=Polyline">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="PolylineTo"><term><code>(PolylineTo HDC  POINT_P DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=PolylineTo">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SetBitmapBits"><term><code>(SetBitmapBits HBITMAP DWORD PCVOID)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetBitmapBits">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetBitmapDimensionEx"><term><code>(SetBitmapDimensionEx HBITMAP int int LPSIZE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetBitmapDimensionEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SetBoundsRect"><term><code>(SetBoundsRect HDC LPCRECT UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetBoundsRect">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetBrushOrgEx"><term><code>(SetBrushOrgEx HDC int int LPPOINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetBrushOrgEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SetDIBColorTable"><term><code>(SetDIBColorTable HDC UINT UINT  RGBQUAD_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetDIBColorTable">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetEnhMetaFileBits"><term><code>(SetEnhMetaFileBits UINT  BYTE_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetEnhMetaFileBits">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HENHMETAFILE</type> structure.</para></varlistentry>
+<varlistentry id="SetMetaFileBitsEx"><term><code>(SetMetaFileBitsEx UINT  BYTE_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetMetaFileBitsEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HMETAFILE</type> structure.</para></varlistentry>
+<varlistentry id="SetPaletteEntries"><term><code>(SetPaletteEntries HPALETTE UINT UINT  PALETTEENTRY_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetPaletteEntries">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetPixelFormat"><term><code>(SetPixelFormat HDC int PIXELFORMATDESCRIPTOR_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetPixelFormat">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SetViewportExtEx"><term><code>(SetViewportExtEx HDC int int LPSIZE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetViewportExtEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SetViewportOrgEx"><term><code>(SetViewportOrgEx HDC int int LPPOINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetViewportOrgEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SetWinMetaFileBits"><term><code>(SetWinMetaFileBits UINT  BYTE_P HDC  METAFILEPICT_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetWinMetaFileBits">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HENHMETAFILE</type> structure.</para></varlistentry>
+<varlistentry id="SetWindowExtEx"><term><code>(SetWindowExtEx HDC int int LPSIZE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetWindowExtEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SetWindowOrgEx"><term><code>(SetWindowOrgEx HDC int int LPPOINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetWindowOrgEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="StartDocA"><term><code>(StartDocA HDC  DOCINFOA_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=StartDocA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="StartDocW"><term><code>(StartDocW HDC  DOCINFOW_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=StartDocW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="TextOutA"><term><code>(TextOutA HDC int int LPCSTR int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=TextOutA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="TextOutW"><term><code>(TextOutW HDC int int LPCWSTR int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=TextOutW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="UpdateICMRegKeyA"><term><code>(UpdateICMRegKeyA DWORD DWORD LPSTR UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=UpdateICMRegKeyA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="UpdateICMRegKeyW"><term><code>(UpdateICMRegKeyW DWORD DWORD LPWSTR UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=UpdateICMRegKeyW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="AbortDoc"><term><code>(AbortDoc HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=AbortDoc">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="AbortPath"><term><code>(AbortPath HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=AbortPath">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="AddAtomA"><term><code>(AddAtomA LPCSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=AddAtomA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>ATOM</type> structure.</para></varlistentry>
+<varlistentry id="AddAtomW"><term><code>(AddAtomW LPCWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=AddAtomW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>ATOM</type> structure.</para></varlistentry>
+<varlistentry id="BeginPath"><term><code>(BeginPath HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=BeginPath">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="CancelDC"><term><code>(CancelDC HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CancelDC">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="CloseEnhMetaFile"><term><code>(CloseEnhMetaFile HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CloseEnhMetaFile">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HENHMETAFILE</type> structure.</para></varlistentry>
+<varlistentry id="CloseFigure"><term><code>(CloseFigure HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CloseFigure">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="CloseMetaFile"><term><code>(CloseMetaFile HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CloseMetaFile">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HMETAFILE</type> structure.</para></varlistentry>
+<varlistentry id="ColorMatchToTarget"><term><code>(ColorMatchToTarget HDC HDC DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ColorMatchToTarget">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="CombineRgn"><term><code>(CombineRgn HRGN HRGN HRGN int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CombineRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="CreateCompatibleBitmap"><term><code>(CreateCompatibleBitmap HDC int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateCompatibleBitmap">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HBITMAP</type> structure.</para></varlistentry>
+<varlistentry id="CreateCompatibleDC"><term><code>(CreateCompatibleDC HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateCompatibleDC">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HDC</type> structure.</para></varlistentry>
+<varlistentry id="CreateDIBPatternBrush"><term><code>(CreateDIBPatternBrush HGLOBAL UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateDIBPatternBrush">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HBRUSH</type> structure.</para></varlistentry>
+<varlistentry id="CreateDiscardableBitmap"><term><code>(CreateDiscardableBitmap HDC int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateDiscardableBitmap">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HBITMAP</type> structure.</para></varlistentry>
+<varlistentry id="CreateEllipticRgn"><term><code>(CreateEllipticRgn int int int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateEllipticRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HRGN</type> structure.</para></varlistentry>
+<varlistentry id="CreateHalftonePalette"><term><code>(CreateHalftonePalette HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateHalftonePalette">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HPALETTE</type> structure.</para></varlistentry>
+<varlistentry id="CreateHatchBrush"><term><code>(CreateHatchBrush int COLORREF)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateHatchBrush">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HBRUSH</type> structure.</para></varlistentry>
+<varlistentry id="CreatePatternBrush"><term><code>(CreatePatternBrush HBITMAP)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreatePatternBrush">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HBRUSH</type> structure.</para></varlistentry>
+<varlistentry id="CreatePen"><term><code>(CreatePen int int COLORREF)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreatePen">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HPEN</type> structure.</para></varlistentry>
+<varlistentry id="CreateRectRgn"><term><code>(CreateRectRgn int int int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateRectRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HRGN</type> structure.</para></varlistentry>
+<varlistentry id="CreateSolidBrush"><term><code>(CreateSolidBrush COLORREF)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateSolidBrush">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HBRUSH</type> structure.</para></varlistentry>
+<varlistentry id="DeleteColorSpace"><term><code>(DeleteColorSpace HCOLORSPACE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=DeleteColorSpace">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="DeleteDC"><term><code>(DeleteDC HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=DeleteDC">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="DeleteEnhMetaFile"><term><code>(DeleteEnhMetaFile HENHMETAFILE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=DeleteEnhMetaFile">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="DeleteMetaFile"><term><code>(DeleteMetaFile HMETAFILE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=DeleteMetaFile">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="DeleteObject"><term><code>(DeleteObject HGDIOBJ)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=DeleteObject">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="Ellipse"><term><code>(Ellipse HDC int int int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=Ellipse">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="EndDoc"><term><code>(EndDoc HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=EndDoc">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="EndPage"><term><code>(EndPage HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=EndPage">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="EndPath"><term><code>(EndPath HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=EndPath">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="EqualRgn"><term><code>(EqualRgn HRGN HRGN)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=EqualRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="EscapeCommFunction"><term><code>(EscapeCommFunction HANDLE DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=EscapeCommFunction">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="ExcludeClipRect"><term><code>(ExcludeClipRect HDC int int int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ExcludeClipRect">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="ExtFloodFill"><term><code>(ExtFloodFill HDC int int COLORREF UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ExtFloodFill">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="ExtSelectClipRgn"><term><code>(ExtSelectClipRgn HDC HRGN int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ExtSelectClipRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="FillPath"><term><code>(FillPath HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=FillPath">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="FillRgn"><term><code>(FillRgn HDC HRGN HBRUSH)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=FillRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="FindAtomA"><term><code>(FindAtomA LPCSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=FindAtomA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>ATOM</type> structure.</para></varlistentry>
+<varlistentry id="FindAtomW"><term><code>(FindAtomW LPCWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=FindAtomW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>ATOM</type> structure.</para></varlistentry>
+<varlistentry id="FlattenPath"><term><code>(FlattenPath HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=FlattenPath">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="FloodFill"><term><code>(FloodFill HDC int int COLORREF)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=FloodFill">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="FrameRgn"><term><code>(FrameRgn HDC HRGN HBRUSH int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=FrameRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GdiSetBatchLimit"><term><code>(GdiSetBatchLimit DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GdiSetBatchLimit">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetArcDirection"><term><code>(GetArcDirection HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetArcDirection">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetBkColor"><term><code>(GetBkColor HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetBkColor">MSDN</ulink></para>
+   <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>COLORREF</type> structure.</para></varlistentry>
+<varlistentry id="GetBkMode"><term><code>(GetBkMode HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetBkMode">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetClipRgn"><term><code>(GetClipRgn HDC HRGN)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetClipRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetColorSpace"><term><code>(GetColorSpace HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetColorSpace">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HANDLE</type> structure.</para></varlistentry>
+<varlistentry id="GetCurrentObject"><term><code>(GetCurrentObject HDC UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetCurrentObject">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HGDIOBJ</type> structure.</para></varlistentry>
+<varlistentry id="GetFontLanguageInfo"><term><code>(GetFontLanguageInfo HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetFontLanguageInfo">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetGraphicsMode"><term><code>(GetGraphicsMode HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetGraphicsMode">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetMapMode"><term><code>(GetMapMode HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetMapMode">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetMetaRgn"><term><code>(GetMetaRgn HDC HRGN)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetMetaRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetNearestColor"><term><code>(GetNearestColor HDC COLORREF)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetNearestColor">MSDN</ulink></para>
+   <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>COLORREF</type> structure.</para></varlistentry>
+<varlistentry id="GetNearestPaletteIndex"><term><code>(GetNearestPaletteIndex HPALETTE COLORREF)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetNearestPaletteIndex">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetObjectType"><term><code>(GetObjectType HGDIOBJ)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetObjectType">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetPixel"><term><code>(GetPixel HDC int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetPixel">MSDN</ulink></para>
+   <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>COLORREF</type> structure.</para></varlistentry>
+<varlistentry id="GetPixelFormat"><term><code>(GetPixelFormat HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetPixelFormat">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetPolyFillMode"><term><code>(GetPolyFillMode HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetPolyFillMode">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetROP2"><term><code>(GetROP2 HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetROP2">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetStockObject"><term><code>(GetStockObject int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetStockObject">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HGDIOBJ</type> structure.</para></varlistentry>
+<varlistentry id="GetStretchBltMode"><term><code>(GetStretchBltMode HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetStretchBltMode">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetSystemPaletteUse"><term><code>(GetSystemPaletteUse HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetSystemPaletteUse">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetTextAlign"><term><code>(GetTextAlign HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetTextAlign">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetTextCharacterExtra"><term><code>(GetTextCharacterExtra HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetTextCharacterExtra">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetTextCharset"><term><code>(GetTextCharset HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetTextCharset">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetTextColor"><term><code>(GetTextColor HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetTextColor">MSDN</ulink></para>
+   <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>COLORREF</type> structure.</para></varlistentry>
+<varlistentry id="GlobalAddAtomA"><term><code>(GlobalAddAtomA LPCSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GlobalAddAtomA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>ATOM</type> structure.</para></varlistentry>
+<varlistentry id="GlobalAddAtomW"><term><code>(GlobalAddAtomW  LPCWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GlobalAddAtomW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>ATOM</type> structure.</para></varlistentry>
+<varlistentry id="GlobalFindAtomA"><term><code>(GlobalFindAtomA LPCSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GlobalFindAtomA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>ATOM</type> structure.</para></varlistentry>
+<varlistentry id="GlobalFindAtomW"><term><code>(GlobalFindAtomW LPCWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GlobalFindAtomW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>ATOM</type> structure.</para></varlistentry>
+<varlistentry id="IntersectClipRect"><term><code>(IntersectClipRect HDC int int int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=IntersectClipRect">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="InvertRgn"><term><code>(InvertRgn HDC HRGN)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=InvertRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="LineTo"><term><code>(LineTo HDC int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=LineTo">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="LoadCursorFromFileA"><term><code>(LoadCursorFromFileA LPCSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=LoadCursorFromFileA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HCURSOR</type> structure.</para></varlistentry>
+<varlistentry id="LoadCursorFromFileW"><term><code>(LoadCursorFromFileW LPCWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=LoadCursorFromFileW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HCURSOR</type> structure.</para></varlistentry>
+<varlistentry id="OffsetClipRgn"><term><code>(OffsetClipRgn HDC int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=OffsetClipRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="OffsetRgn"><term><code>(OffsetRgn HRGN int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=OffsetRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="PaintRgn"><term><code>(PaintRgn HDC HRGN)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=PaintRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="PathToRegion"><term><code>(PathToRegion HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=PathToRegion">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HRGN</type> structure.</para></varlistentry>
+<varlistentry id="PlayMetaFile"><term><code>(PlayMetaFile HDC HMETAFILE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=PlayMetaFile">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="PtInRegion"><term><code>(PtInRegion HRGN int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=PtInRegion">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="PtVisible"><term><code>(PtVisible HDC int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=PtVisible">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="RealizePalette"><term><code>(RealizePalette HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=RealizePalette">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="Rectangle"><term><code>(Rectangle HDC int int int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=Rectangle">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="ResizePalette"><term><code>(ResizePalette HPALETTE UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ResizePalette">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="RestoreDC"><term><code>(RestoreDC HDC int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=RestoreDC">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SaveDC"><term><code>(SaveDC HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SaveDC">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SelectClipPath"><term><code>(SelectClipPath HDC int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SelectClipPath">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SelectClipRgn"><term><code>(SelectClipRgn HDC HRGN)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SelectClipRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SelectObject"><term><code>(SelectObject HDC HGDIOBJ)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SelectObject">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HGDIOBJ</type> structure.</para></varlistentry>
+<varlistentry id="SetArcDirection"><term><code>(SetArcDirection HDC int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetArcDirection">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetBkColor"><term><code>(SetBkColor HDC COLORREF)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetBkColor">MSDN</ulink></para>
+   <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>COLORREF</type> structure.</para></varlistentry>
+<varlistentry id="SetBkMode"><term><code>(SetBkMode HDC int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetBkMode">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetColorSpace"><term><code>(SetColorSpace HDC HCOLORSPACE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetColorSpace">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SetGraphicsMode"><term><code>(SetGraphicsMode HDC int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetGraphicsMode">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetICMMode"><term><code>(SetICMMode HDC int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetICMMode">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetMapMode"><term><code>(SetMapMode HDC int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetMapMode">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetMapperFlags"><term><code>(SetMapperFlags HDC DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetMapperFlags">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetMetaRgn"><term><code>(SetMetaRgn HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetMetaRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetPolyFillMode"><term><code>(SetPolyFillMode HDC int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetPolyFillMode">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetROP2"><term><code>(SetROP2 HDC int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetROP2">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetRectRgn"><term><code>(SetRectRgn HRGN int int int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetRectRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SetStretchBltMode"><term><code>(SetStretchBltMode HDC int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetStretchBltMode">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetSystemPaletteUse"><term><code>(SetSystemPaletteUse HDC UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetSystemPaletteUse">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetTextAlign"><term><code>(SetTextAlign HDC UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetTextAlign">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetTextCharacterExtra"><term><code>(SetTextCharacterExtra HDC int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetTextCharacterExtra">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetTextJustification"><term><code>(SetTextJustification HDC int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetTextJustification">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="ShowWindow"><term><code>(ShowWindow HWND int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ShowWindow">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="ShowWindowAsync"><term><code>(ShowWindowAsync HWND int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ShowWindowAsync">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="StartPage"><term><code>(StartPage HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=StartPage">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="StrokeAndFillPath"><term><code>(StrokeAndFillPath HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=StrokeAndFillPath">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="StrokePath"><term><code>(StrokePath HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=StrokePath">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SwapBuffers"><term><code>(SwapBuffers HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SwapBuffers">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="UnrealizeObject"><term><code>(UnrealizeObject HGDIOBJ)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=UnrealizeObject">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="UpdateColors"><term><code>(UpdateColors HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=UpdateColors">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="UpdateWindow"><term><code>(UpdateWindow HWND)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=UpdateWindow">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="WidenPath"><term><code>(WidenPath HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=WidenPath">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="CheckColorsInGamut"><term><code>(CheckColorsInGamut HDC PVOID PVOID DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CheckColorsInGamut">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="CombineTransform"><term><code>(CombineTransform LPXFORM  XFORM_P  XFORM_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CombineTransform">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="CreateDIBSection"><term><code>(CreateDIBSection HDC  BITMAPINFO_P UINT HANDLE DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateDIBSection">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HBITMAP</type> structure.</para></varlistentry>
+<varlistentry id="EnumEnhMetaFile"><term><code>(EnumEnhMetaFile HDC HENHMETAFILE ENHMFENUMPROC PVOID LPCRECT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=EnumEnhMetaFile">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="EnumFontFamiliesA"><term><code>(EnumFontFamiliesA HDC LPCSTR FONTENUMPROCA LPARAM)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=EnumFontFamiliesA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="EnumFontFamiliesExA"><term><code>(EnumFontFamiliesExA HDC PLOGFONTA FONTENUMPROCA LPARAM DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=EnumFontFamiliesExA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="EnumFontFamiliesExW"><term><code>(EnumFontFamiliesExW HDC PLOGFONTW FONTENUMPROCW LPARAM DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=EnumFontFamiliesExW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="EnumFontFamiliesW"><term><code>(EnumFontFamiliesW HDC LPCWSTR FONTENUMPROCW LPARAM)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=EnumFontFamiliesW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="EnumFontsA"><term><code>(EnumFontsA HDC LPCSTR FONTENUMPROCA LPARAM)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=EnumFontsA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="EnumFontsW"><term><code>(EnumFontsW HDC LPCWSTR FONTENUMPROCA LPARAM)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=EnumFontsW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="EnumICMProfilesA"><term><code>(EnumICMProfilesA HDC ICMENUMPROCA LPARAM)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=EnumICMProfilesA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="EnumICMProfilesW"><term><code>(EnumICMProfilesW HDC ICMENUMPROCW LPARAM)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=EnumICMProfilesW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="EnumMetaFile"><term><code>(EnumMetaFile HDC HMETAFILE MFENUMPROC LPARAM)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=EnumMetaFile">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="EnumObjects"><term><code>(EnumObjects HDC int GOBJENUMPROC LPARAM)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=EnumObjects">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetAspectRatioFilterEx"><term><code>(GetAspectRatioFilterEx HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetAspectRatioFilterEx">MSDN</ulink></para>
+  <para>Returns a SIZE struct or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetBitmapBits"><term><code>(GetBitmapBits HBITMAP LONG PVOID)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetBitmapBits">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetBitmapDimensionEx"><term><code>(GetBitmapDimensionEx HBITMAP LPSIZE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetBitmapDimensionEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetBoundsRect"><term><code>(GetBoundsRect HDC LPRECT UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetBoundsRect">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetBrushOrgEx"><term><code>(GetBrushOrgEx HDC LPPOINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetBrushOrgEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetCharABCWidthsA"><term><code>(GetCharABCWidthsA HDC UINT UINT LPABC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetCharABCWidthsA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetCharABCWidthsFloatA"><term><code>(GetCharABCWidthsFloatA HDC UINT UINT LPABCFLOAT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetCharABCWidthsFloatA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetCharABCWidthsFloatW"><term><code>(GetCharABCWidthsFloatW HDC UINT UINT LPABCFLOAT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetCharABCWidthsFloatW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetCharABCWidthsW"><term><code>(GetCharABCWidthsW HDC UINT UINT LPABC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetCharABCWidthsW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetCharWidth32A"><term><code>(GetCharWidth32A HDC UINT UINT LPINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetCharWidth32A">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetCharWidth32W"><term><code>(GetCharWidth32W HDC UINT UINT LPINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetCharWidth32W">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetCharWidthA"><term><code>(GetCharWidthA HDC UINT UINT LPINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetCharWidthA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetCharWidthW"><term><code>(GetCharWidthW HDC UINT UINT LPINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetCharWidthW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetClientRect"><term><code>(GetClientRect HWND LPRECT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetClientRect">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetClipBox"><term><code>(GetClipBox HDC LPRECT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetClipBox">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetColorAdjustment"><term><code>(GetColorAdjustment HDC LPCOLORADJUSTMENT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetColorAdjustment">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetCurrentPositionEx"><term><code>(GetCurrentPositionEx HDC LPPOINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetCurrentPositionEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetDCOrgEx"><term><code>(GetDCOrgEx HDC LPPOINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetDCOrgEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetDIBColorTable"><term><code>(GetDIBColorTable HDC UINT UINT RGBQUAD_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetDIBColorTable">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetDeviceGammaRamp"><term><code>(GetDeviceGammaRamp HDC PVOID)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetDeviceGammaRamp">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetEnhMetaFileA"><term><code>(GetEnhMetaFileA LPCSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetEnhMetaFileA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HENHMETAFILE</type> structure.</para></varlistentry>
+<varlistentry id="GetEnhMetaFileDescriptionA"><term><code>(GetEnhMetaFileDescriptionA HENHMETAFILE UINT LPSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetEnhMetaFileDescriptionA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetEnhMetaFileDescriptionW"><term><code>(GetEnhMetaFileDescriptionW HENHMETAFILE UINT LPWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetEnhMetaFileDescriptionW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetEnhMetaFileHeader"><term><code>(GetEnhMetaFileHeader HENHMETAFILE UINT LPENHMETAHEADER)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetEnhMetaFileHeader">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetEnhMetaFilePaletteEntries"><term><code>(GetEnhMetaFilePaletteEntries HENHMETAFILE UINT LPPALETTEENTRY)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetEnhMetaFilePaletteEntries">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetEnhMetaFilePixelFormat"><term><code>(GetEnhMetaFilePixelFormat HENHMETAFILE DWORD PIXELFORMATDESCRIPTOR_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetEnhMetaFilePixelFormat">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetEnhMetaFileW"><term><code>(GetEnhMetaFileW LPCWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetEnhMetaFileW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HENHMETAFILE</type> structure.</para></varlistentry>
+<varlistentry id="GetFontData"><term><code>(GetFontData HDC DWORD DWORD PVOID DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetFontData">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetICMProfileA"><term><code>(GetICMProfileA HDC LPDWORD LPSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetICMProfileA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> , the value of LPDWORD as &integer-t; and the value LPWSTR as &string-t;, or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetICMProfileW"><term><code>(GetICMProfileW HDC LPDWORD LPWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetICMProfileW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> , the value of LPDWORD as &integer-t; and the value LPWSTR as &string-t;, or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetKerningPairsA"><term><code>(GetKerningPairsA HDC DWORD LPKERNINGPAIR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetKerningPairsA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetKerningPairsW"><term><code>(GetKerningPairsW HDC DWORD LPKERNINGPAIR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetKerningPairsW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetLogColorSpaceA"><term><code>(GetLogColorSpaceA HCOLORSPACE LPLOGCOLORSPACEA DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetLogColorSpaceA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetLogColorSpaceW"><term><code>(GetLogColorSpaceW HCOLORSPACE LPLOGCOLORSPACEW DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetLogColorSpaceW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetMetaFileA"><term><code>(GetMetaFileA LPCSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetMetaFileA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HMETAFILE</type> structure.</para></varlistentry>
+<varlistentry id="GetMetaFileBitsEx"><term><code>(GetMetaFileBitsEx HMETAFILE UINT PVOID)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetMetaFileBitsEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetMetaFileW"><term><code>(GetMetaFileW LPCWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetMetaFileW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HMETAFILE</type> structure.</para></varlistentry>
+<varlistentry id="GetObjectA"><term><code>(GetObjectA HGDIOBJ int PVOID)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetObjectA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetObjectW"><term><code>(GetObjectW HGDIOBJ int PVOID)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetObjectW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetOutlineTextMetricsA"><term><code>(GetOutlineTextMetricsA HDC UINT LPOUTLINETEXTMETRICA)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetOutlineTextMetricsA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetOutlineTextMetricsW"><term><code>(GetOutlineTextMetricsW HDC UINT LPOUTLINETEXTMETRICW)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetOutlineTextMetricsW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetPaletteEntries"><term><code>(GetPaletteEntries HPALETTE UINT UINT LPPALETTEENTRY)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetPaletteEntries">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetPath"><term><code>(GetPath HDC LPPOINT PBYTE int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetPath">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetRasterizerCaps"><term><code>(GetRasterizerCaps LPRASTERIZER_STATUS UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetRasterizerCaps">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetRegionData"><term><code>(GetRegionData HRGN DWORD LPRGNDATA)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetRegionData">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetRgnBox"><term><code>(GetRgnBox HRGN LPRECT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetRgnBox">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetSystemPaletteEntries"><term><code>(GetSystemPaletteEntries HDC UINT UINT LPPALETTEENTRY)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetSystemPaletteEntries">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetTextCharsetInfo"><term><code>(GetTextCharsetInfo HDC LPFONTSIGNATURE DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetTextCharsetInfo">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetTextExtentPoint32A"><term><code>(GetTextExtentPoint32A HDC LPCSTR int LPSIZE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetTextExtentPoint32A">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetTextExtentPoint32W"><term><code>(GetTextExtentPoint32W  HDC LPCWSTR int LPSIZE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetTextExtentPoint32W">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetTextExtentPointA"><term><code>(GetTextExtentPointA HDC LPCSTR int LPSIZE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetTextExtentPointA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetTextExtentPointW"><term><code>(GetTextExtentPointW HDC LPCWSTR int LPSIZE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetTextExtentPointW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetTextFaceA"><term><code>(GetTextFaceA HDC int LPSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetTextFaceA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetTextFaceW"><term><code>(GetTextFaceW HDC int LPWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetTextFaceW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetTextMetricsA"><term><code>(GetTextMetricsA HDC LPTEXTMETRICA)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetTextMetricsA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetTextMetricsW"><term><code>(GetTextMetricsW HDC LPTEXTMETRICW)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetTextMetricsW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetViewportExtEx"><term><code>(GetViewportExtEx HDC LPSIZE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetViewportExtEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetViewportOrgEx"><term><code>(GetViewportOrgEx HDC LPPOINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetViewportOrgEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetWinMetaFileBits"><term><code>(GetWinMetaFileBits HENHMETAFILE UINT LPBYTE INT HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetWinMetaFileBits">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetWindowExtEx"><term><code>(GetWindowExtEx HDC LPSIZE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetWindowExtEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetWindowOrgEx"><term><code>(GetWindowOrgEx HDC LPPOINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetWindowOrgEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetWorldTransform"><term><code>(GetWorldTransform HDC LPXFORM)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetWorldTransform">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="Escape"><term><code>(Escape HDC int int LPCSTR PVOID)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=Escape">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetAbortProc"><term><code>(SetAbortProc HDC ABORTPROC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetAbortProc">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetCharWidthFloatA"><term><code>(GetCharWidthFloatA HDC UINT UINT PFLOAT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetCharWidthFloatA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetCharWidthFloatW"><term><code>(GetCharWidthFloatW HDC UINT UINT PFLOAT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetCharWidthFloatW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetMiterLimit"><term><code>(GetMiterLimit HDC PFLOAT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetMiterLimit">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SetMiterLimit"><term><code>(SetMiterLimit HDC FLOAT PFLOAT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetMiterLimit">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="LineDDA"><term><code>(LineDDA LPPOINT LPPOINT LINEDDAPROC LPARAM)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=LineDDA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="TranslateCharsetInfo"><term><code>(TranslateCharsetInfo DWORD_P LPCHARSETINFO DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=TranslateCharsetInfo">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="CopyEnhMetaFileA"><term><code>(CopyEnhMetaFileA HENHMETAFILE LPCSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CopyEnhMetaFileA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HENHMETAFILE</type> structure.</para></varlistentry>
+<varlistentry id="CopyEnhMetaFileW"><term><code>(CopyEnhMetaFileW HENHMETAFILE LPCWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CopyEnhMetaFileW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HENHMETAFILE</type> structure.</para></varlistentry>
+<varlistentry id="CopyMetaFileA"><term><code>(CopyMetaFileA HMETAFILE LPCSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CopyMetaFileA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HMETAFILE</type> structure.</para></varlistentry>
+<varlistentry id="CopyMetaFileW"><term><code>(CopyMetaFileW HMETAFILE LPCWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CopyMetaFileW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HMETAFILE</type> structure.</para></varlistentry>
+<varlistentry id="CreateBitmapIndirect"><term><code>(CreateBitmapIndirect  BITMAP_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateBitmapIndirect">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HBITMAP</type> structure.</para></varlistentry>
+<varlistentry id="CreateBrushIndirect"><term><code>(CreateBrushIndirect  LOGBRUSH_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateBrushIndirect">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HBRUSH</type> structure.</para></varlistentry>
+<varlistentry id="CreateColorSpaceA"><term><code>(CreateColorSpaceA LPLOGCOLORSPACEA)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateColorSpaceA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HCOLORSPACE</type> structure.</para></varlistentry>
+<varlistentry id="CreateColorSpaceW"><term><code>(CreateColorSpaceW LPLOGCOLORSPACEW)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateColorSpaceW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HCOLORSPACE</type> structure.</para></varlistentry>
+<varlistentry id="CreateDCA"><term><code>(CreateDCA LPCSTR LPCSTR LPCSTR  DEVMODEA_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateDCA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HDC</type> structure.</para></varlistentry>
+<varlistentry id="CreateDCW"><term><code>(CreateDCW LPCWSTR LPCWSTR LPCWSTR  DEVMODEW_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateDCW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HDC</type> structure.</para></varlistentry>
+<varlistentry id="CreateEllipticRgnIndirect"><term><code>(CreateEllipticRgnIndirect LPCRECT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateEllipticRgnIndirect">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HRGN</type> structure.</para></varlistentry>
+<varlistentry id="CreateEnhMetaFileA"><term><code>(CreateEnhMetaFileA HDC LPCSTR LPCRECT LPCSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateEnhMetaFileA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HDC</type> structure.</para></varlistentry>
+<varlistentry id="CreateEnhMetaFileW"><term><code>(CreateEnhMetaFileW HDC LPCWSTR LPCRECT LPCWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateEnhMetaFileW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HDC</type> structure.</para></varlistentry>
+<varlistentry id="CreateFontIndirectA"><term><code>(CreateFontIndirectA  LOGFONTA_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateFontIndirectA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HFONT</type> structure.</para></varlistentry>
+<varlistentry id="CreateFontIndirectW"><term><code>(CreateFontIndirectW  LOGFONTW_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateFontIndirectW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HFONT</type> structure.</para></varlistentry>
+<varlistentry id="CreateICA"><term><code>(CreateICA LPCSTR LPCSTR LPCSTR  DEVMODEA_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateICA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HDC</type> structure.</para></varlistentry>
+<varlistentry id="CreateICW"><term><code>(CreateICW LPCWSTR LPCWSTR LPCWSTR  DEVMODEW_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateICW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HDC</type> structure.</para></varlistentry>
+<varlistentry id="CreateIconFromResource"><term><code>(CreateIconFromResource PBYTE DWORD BOOL DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateIconFromResource">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HICON</type> structure.</para></varlistentry>
+<varlistentry id="CreateIconIndirect"><term><code>(CreateIconIndirect PICONINFO)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateIconIndirect">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HICON</type> structure.</para></varlistentry>
+<varlistentry id="CreateMetaFileA"><term><code>(CreateMetaFileA LPCSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateMetaFileA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HDC</type> structure.</para></varlistentry>
+<varlistentry id="CreateMetaFileW"><term><code>(CreateMetaFileW LPCWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateMetaFileW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HDC</type> structure.</para></varlistentry>
+<varlistentry id="CreatePalette"><term><code>(CreatePalette  LOGPALETTE_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreatePalette">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HPALETTE</type> structure.</para></varlistentry>
+<varlistentry id="CreatePenIndirect"><term><code>(CreatePenIndirect  LOGPEN_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreatePenIndirect">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HPEN</type> structure.</para></varlistentry>
+<varlistentry id="CreateRectRgnIndirect"><term><code>(CreateRectRgnIndirect LPCRECT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateRectRgnIndirect">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HRGN</type> structure.</para></varlistentry>
+<varlistentry id="FillRect"><term><code>(FillRect HDC LPCRECT HBRUSH)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=FillRect">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+
+<varlistentry id="GetDC"><term><code>(GetDC HWND)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetDC">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HDC</type> structure.</para></varlistentry>
+<varlistentry id="GetDeviceCaps"><term><code>(GetDeviceCaps HDC int)</code></term>
+  <para>Retrieve device-specific information for the specified device. The return value specifies the value of the desired item. See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetDeviceCaps">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetSystemMetrics"><term><code>(GetSystemMetrics int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetSystemMetrics">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+
+<varlistentry id="LoadCursorA"><term><code>(LoadCursorA HINSTANCE LPCSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=LoadCursorA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HCURSOR</type> structure.</para></varlistentry>
+<varlistentry id="LoadCursorW"><term><code>(LoadCursorW HINSTANCE LPCWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=LoadCursorW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HCURSOR</type> structure.</para></varlistentry>
+<varlistentry id="PlayEnhMetaFile"><term><code>(PlayEnhMetaFile HDC HENHMETAFILE LPCRECT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=PlayEnhMetaFile">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="RectInRegion"><term><code>(RectInRegion HRGN LPCRECT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=RectInRegion">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="RectVisible"><term><code>(RectVisible HDC LPCRECT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=RectVisible">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="RegisterClassA"><term><code>(RegisterClassA WNDCLASSA_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=RegisterClassA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>ATOM</type> structure.</para></varlistentry>
+<varlistentry id="RegisterClassW"><term><code>(RegisterClassW WNDCLASSW_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=RegisterClassW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>ATOM</type> structure.</para></varlistentry>
+<varlistentry id="RemoveFontResourceA"><term><code>(RemoveFontResourceA LPCSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=RemoveFontResourceA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="RemoveFontResourceW"><term><code>(RemoveFontResourceW LPCWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=RemoveFontResourceW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="ResetDCA"><term><code>(ResetDCA HDC  DEVMODEA_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ResetDCA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HDC</type> structure.</para></varlistentry>
+<varlistentry id="ResetDCW"><term><code>(ResetDCW HDC  DEVMODEW_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ResetDCW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HDC</type> structure.</para></varlistentry>
+<varlistentry id="SelectPalette"><term><code>(SelectPalette HDC HPALETTE BOOL)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SelectPalette">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HPALETTE</type> structure.</para></varlistentry>
+<varlistentry id="SetColorAdjustment"><term><code>(SetColorAdjustment HDC  COLORADJUSTMENT_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetColorAdjustment">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SetDeviceGammaRamp"><term><code>(SetDeviceGammaRamp HDC PVOID)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetDeviceGammaRamp">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SetICMProfileA"><term><code>(SetICMProfileA HDC LPSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetICMProfileA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SetICMProfileW"><term><code>(SetICMProfileW HDC LPWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetICMProfileW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SetPixel"><term><code>(SetPixel HDC int int COLORREF)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetPixel">MSDN</ulink></para>
+   <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>COLORREF</type> structure.</para></varlistentry>
+<varlistentry id="SetPixelV"><term><code>(SetPixelV HDC int int COLORREF)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetPixelV">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SetTextColor"><term><code>(SetTextColor HDC COLORREF)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetTextColor">MSDN</ulink></para>
+   <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>COLORREF</type> structure.</para></varlistentry>
+<varlistentry id="SetWorldTransform"><term><code>(SetWorldTransform HDC  XFORM_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetWorldTransform">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="AngleArc"><term><code>(AngleArc HDC int int DWORD FLOAT FLOAT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=AngleArc">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="Arc"><term><code>(Arc HDC int int int int int int int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=Arc">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="ArcTo"><term><code>(ArcTo HDC int int int int int int int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ArcTo">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="BitBlt"><term><code>(BitBlt HDC int int int int HDC int int DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=BitBlt">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="Chord"><term><code>(Chord HDC int int int int int int int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=Chord">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="CreateDIBitmap"><term><code>(CreateDIBitmap HDC  BITMAPINFOHEADER_P DWORD PCVOID  BITMAPINFO_P UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateDIBitmap">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HBITMAP</type> structure.</para></varlistentry>
+<varlistentry id="CreateFontA"><term><code>(CreateFontA int int int int int DWORD DWORD DWORD DWORD DWORD DWORD DWORD DWORD LPCSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateFontA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HFONT</type> structure.</para></varlistentry>
+<varlistentry id="CreateFontW"><term><code>(CreateFontW int int int int int DWORD DWORD DWORD DWORD DWORD DWORD DWORD DWORD LPCWSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateFontW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HFONT</type> structure.</para></varlistentry>
+<varlistentry id="CreateIcon"><term><code>(CreateIcon HINSTANCE int int BYTE BYTE PBYTE PBYTE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateIcon">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HICON</type> structure.</para></varlistentry>
+<varlistentry id="CreateIconFromResourceEx"><term><code>(CreateIconFromResourceEx PBYTE DWORD BOOL DWORD int int UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateIconFromResourceEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HICON</type> structure.</para></varlistentry>
+<varlistentry id="CreateRoundRectRgn"><term><code>(CreateRoundRectRgn int int int int int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateRoundRectRgn">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HRGN</type> structure.</para></varlistentry>
+<varlistentry id="CreateWindowExA"><term><code>(CreateWindowExA DWORD LPCSTR LPCSTR DWORD int int int int HWND HMENU HINSTANCE LPVOID)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateWindowExA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HWND</type> structure.</para></varlistentry>
+<varlistentry id="CreateWindowExW"><term><code>(CreateWindowExW DWORD LPCWSTR LPCWSTR DWORD int int int int HWND HMENU HINSTANCE LPVOID)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=CreateWindowExW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HWND</type> structure.</para></varlistentry>
+<varlistentry id="ExtEscape"><term><code>(ExtEscape HDC int int LPCSTR int LPSTR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ExtEscape">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="ExtTextOutA"><term><code>(ExtTextOutA HDC int int UINT LPCRECT LPCSTR UINT PINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ExtTextOutA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="ExtTextOutW"><term><code>(ExtTextOutW HDC int int UINT LPCRECT LPCWSTR UINT PINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ExtTextOutW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="FindFirstFileExA"><term><code>(FindFirstFileExA LPCSTR FINDEX_INFO_LEVELS PVOID FINDEX_SEARCH_OPS PVOID DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=FindFirstFileExA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HANDLE</type>.</para></varlistentry>
+<varlistentry id="FindFirstFileExW"><term><code>(FindFirstFileExW LPCWSTR FINDEX_INFO_LEVELS PVOID FINDEX_SEARCH_OPS PVOID DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=FindFirstFileExW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HANDLE</type>.</para></varlistentry>
+<varlistentry id="GetCharacterPlacementA"><term><code>(GetCharacterPlacementA HDC LPCSTR int int LPGCP_RESULTSA DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetCharacterPlacementA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetCharacterPlacementW"><term><code>(GetCharacterPlacementW HDC LPCWSTR int int LPGCP_RESULTSW DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetCharacterPlacementW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetDIBits"><term><code>(GetDIBits HDC HBITMAP UINT UINT PVOID LPBITMAPINFO UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetDIBits">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetGlyphOutlineA"><term><code>(GetGlyphOutlineA HDC UINT UINT LPGLYPHMETRICS DWORD PVOID PMAT2)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetGlyphOutlineA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetGlyphOutlineW"><term><code>(GetGlyphOutlineW HDC UINT UINT LPGLYPHMETRICS DWORD PVOID PMAT2)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetGlyphOutlineW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="GetTextExtentExPointA"><term><code>(GetTextExtentExPointA HDC LPCSTR int int LPINT LPINT LPSIZE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetTextExtentExPointA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="GetTextExtentExPointW"><term><code>(GetTextExtentExPointW  HDC LPCWSTR int int LPINT LPINT LPSIZE )</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetTextExtentExPointW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="MaskBlt"><term><code>(MaskBlt HDC int int int int HDC int int HBITMAP int int DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=MaskBlt">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="PatBlt"><term><code>(PatBlt HDC int int int int DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=PatBlt">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="Pie"><term><code>(Pie HDC int int int int int int int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=Pie">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="PlgBlt"><term><code>(PlgBlt HDC PPOINT HDC int int int int HBITMAP int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=PlgBlt">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="RoundRect"><term><code>(RoundRect HDC int int int int int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=RoundRect">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="ScaleViewportExtEx"><term><code>(ScaleViewportExtEx HDC int int int int LPSIZE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ScaleViewportExtEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="ScaleWindowExtEx"><term><code>(ScaleWindowExtEx HDC int int int int LPSIZE)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ScaleWindowExtEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SetDIBits"><term><code>(SetDIBits HDC HBITMAP UINT UINT PCVOID PBITMAPINFO UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetDIBits">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SetDIBitsToDevice"><term><code>(SetDIBitsToDevice HDC int int DWORD DWORD int int UINT UINT PCVOID PBITMAPINFO UINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetDIBitsToDevice">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="StretchBlt"><term><code>(StretchBlt HDC int int int int HDC int int int int DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=StretchBlt">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="StretchDIBits"><term><code>(StretchDIBits HDC int int int int int int int int PVOID PBITMAPINFO UINT DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=StretchDIBits">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="TabbedTextOutA"><term><code>(TabbedTextOutA HDC int int LPCSTR int int LPINT int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=TabbedTextOutA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="TabbedTextOutW"><term><code>(TabbedTextOutW HDC int int LPCWSTR int int LPINT int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=TabbedTextOutW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SearchPathA"><term><code>(SearchPathA LPCSTR LPCSTR LPCSTR DWORD LPSTR LPSTR_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SearchPathA">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="SearchPathW"><term><code>(SearchPathW LPCWSTR LPCWSTR LPCWSTR DWORD LPWSTR LPWSTR_P)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SearchPathW">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &integer-t;.</para></varlistentry>
+<varlistentry id="DestroyCursor"><term><code>(DestroyCursor HCURSOR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=DestroyCursor">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> or <constant>&nil;</constant>.</para></varlistentry>
+<varlistentry id="SetCursor"><term><code>(SetCursor HCURSOR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetCursor">MSDN</ulink></para>
+  <para>Draws the specified <type>HCURSOR</type>. Returns the
+  handle of the previously displayed cursor. Note that the cursor will
+  change back to the default one as soon as the mouse moves or a system
+  command is performed. To change the cursor persistantly, use <link linkend="ChangeCursor"><function role="win32">ChangeCursor</function></link>.</para>
+  <para>Returns <constant>&t;</constant> and a foreign pointer to the <type>HCURSOR</type> structure.</para></varlistentry>
+<varlistentry id="GetCursor"><term><code>(GetCursor)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetCursor">MSDN</ulink></para>
+  <para>Returns the handle of the current cursor. Returns <constant>&t;</constant> and a foreign pointer to the <type>HCURSOR</type> structure.</para></varlistentry>
+<varlistentry id="ChangeCursor"><term><code>(ChangeCursor HWND HCURSOR)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=ChangeCursor">MSDN</ulink></para>
+  <para>Changes the default cursor for a window to <type>CURSOR</type>. Returns <constant>&t;</constant> and a foreign pointer to the previous <type>HCURSOR</type></para></varlistentry>
+<varlistentry id="GetCursorPos"><term><code>(GetCursorPos LPPOINT)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetCursorPos">MSDN</ulink></para>
+  <para>Gets the absolute mouse cursor position. Returns <constant>&t;</constant> and the x and y coordinate of the mouse. Or <constant>&nil;</constant></para></varlistentry>
+<varlistentry id="SetCursorPos"><term><code>(SetCursorPos int int)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetCursorPos">MSDN</ulink></para>
+  <para>Moves the mouse cursor to the specified screen coordinates. Accepts x und y integers. Returns <constant>&t;</constant> or <constant>&nil;</constant></para></varlistentry>
+<varlistentry id="GetCursorInfo"><term><code>(GetCursorInfo PCURSORINFO)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetCursorInfo">MSDN</ulink></para>
+  <para>Sets the slots in the record <type>PCURSORINFO</type>. Returns <constant>&t;</constant> or <constant>&nil;</constant></para></varlistentry>
+<!--
+<varlistentry id="GetDCPenColor"><term><code>(GetDCPenColor HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetDCPenColor">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and the color as &integer-t; for the current DC pen color. On <code>CLR_INVALID</code> return &nil;.</para></varlistentry>
+-->
+<varlistentry id="SetDCPenColor"><term><code>(SetDCPenColor HDC COLORREF)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetDCPenColor">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and the previous DC_BRUSH value as &integer-t;.</para></varlistentry>
+<!--
+<varlistentry id="GetDCBrushColor"><term><code>(GetDCBrushColor HDC)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetDCBrushColor">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and the color as &integer-t; for the current DC brush color. On <code>CLR_INVALID</code> return &nil;.</para></varlistentry>
+-->
+<varlistentry id="SetDCBrushColor"><term><code>(SetDCBrushColor HDC COLORREF)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=SetDCBrushColor">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and the previous DC_BRUSH value as &integer-t;.</para></varlistentry>
+<varlistentry id="GetWindowDC"><term><code>(GetWindowDC HWND)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetWindowDC">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HDC</type> handle.</para></varlistentry>
+<varlistentry id="GetDCEx"><term><code>(GetDCEx HWND HRGN DWORD)</code></term>
+  <para>See <ulink url="http://social.msdn.microsoft.com/search/en-us/?query=GetDCEx">MSDN</ulink></para>
+  <para>Returns <constant>&t;</constant> and a &foreign-pointer; to the <type>HDC</type> handle.</para></varlistentry>
+
+</variablelist>
+</section>
+
+<section id="helper-functions"><title>Helper Functions</title>
+<variablelist>
+<varlistentry id="initc"><term><code>(initc *functions* #'onCreate)</code></term>
+  <para>Internally used by init-gdi.</para></varlistentry>
+<varlistentry id="init-gdi"><term><code>(init-gdi)</code></term>
+  <para>Prepare collecting all <function>OnCreate</function> callbacks. The results is on startup stored in <constant>*hinstance*</constant>.</para></varlistentry>
+<varlistentry id="add-callbacks"><term><code>(add-callbacks message-id a)</code></term>
+  </varlistentry>
+<varlistentry id="remove-callbacks"><term><code>(remove-callback hwnd message-id)</code></term>
+  </varlistentry>
+<varlistentry id="handle-textmetric"><term><code>(handle-textmetric hfont)</code></term>
+  </varlistentry>
+<varlistentry id="max-char-ascent"><term><code>(max-char-ascent hfont)</code></term>
+  <para>Return the <term><structfield>tmascent</structfield></term> slot of the <type>hfont</type>.</para></varlistentry>
+<varlistentry id="max-char-descent"><term><code>(max-char-descent hfont)</code></term>
+  <para>Return the <term><structfield>tmdescent</structfield></term> slot of the <type>hfont</type>.</para></varlistentry>
+<varlistentry id="draw-arc"><term><code>(draw-arc hdc pPosition pDimension pAngle)</code></term>
+  <para>This function is similar to the clx function draw-arc. To avoid using optional arguments, 
+   args are passed in as <type>POINT</type>s.</para></varlistentry>
+</variablelist>
+</section>
+
+</section>
diff -burN origsrc/clisp-2.48/modules/gdi/input.awk src/clisp-2.48/modules/gdi/input.awk
--- origsrc/clisp-2.48/modules/gdi/input.awk	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/input.awk	2006-08-13 14:24:15.000000000 +0000
@@ -0,0 +1,42 @@
+function doIdent( type, name, arg) {
+    if(type ~ /^H.*/) {
+       return (name " = TheFpointer("arg")->fp_pointer;")
+    }
+    else if( "DWORD" == type || "UINT" == type || "DWORD32" == type ||
+              "COLORREF" == type) {
+       return (name " = I_to_uint32("arg");")
+    }
+    else if( "int" == type || "INT" == type || "LONG" == type || "LPARAM"==type){
+       return (name " = I_to_sint32("arg");")
+    }
+    else if( "LPSTR" == type || "LPCSTR" == type) {
+       return (name " = string_to_asciz("arg",encoding);")
+    }
+    else if( "LPWSTR" == type || "LPCWSTR" == type) {
+       return (name " = WIDECHAR("arg",encoding);")
+    }
+    else if( "float" == type || "FLOAT" == type) {
+       return (name " = ffloat_value("arg");")
+    }
+    else if("BYTE_P" == type) {
+       return (name " = &(TheSbvector("arg")->data);")
+    }
+    else if("INT_P" == type || "DWORD_P" == type || "LPINT" == type) {
+       return (name " = &(TheSbvector("arg")->data);")
+    }
+    else if("PVOID" == type || "PCVOID" == type) {
+       return (name " = &(TheSbvector("arg")->data);")
+    }
+    else if(type ~ /^LPC.*/) {
+       return (name " = &(TheSbvector("arg")->data);")
+    }
+    else if(type ~ /^LP.*/) {
+       return (name " = &(TheSbvector("arg")->data);")
+    }
+    else
+    {
+       sub("_P$","",type)
+       return (name " = &(TheSbvector("arg")->data);")
+    }
+}
+{ print doIdent( $1, "  p->" gensub(/;/, / /, "g",$2), "TheRecord(arg)->recdata[i++]") }
diff -burN origsrc/clisp-2.48/modules/gdi/link.sh src/clisp-2.48/modules/gdi/link.sh
--- origsrc/clisp-2.48/modules/gdi/link.sh	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/link.sh	2009-07-14 20:50:32.000000000 +0000
@@ -0,0 +1,7 @@
+make clisp-module INCLUDES='-I.. -I'"$absolute_linkkitdir"
+NEW_FILES='gdi-preload.lisp gdi.o'
+# on mingw/w32api we need to add -lmsimg32 
+NEW_LIBS='gdi.o -lgdi32 -lmsimg32'
+NEW_MODULES='GDI'
+TO_LOAD='gdi'
+TO_PRELOAD='gdi-preload.lisp'
diff -burN origsrc/clisp-2.48/modules/gdi/local.c src/clisp-2.48/modules/gdi/local.c
--- origsrc/clisp-2.48/modules/gdi/local.c	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/local.c	2009-07-30 17:32:38.531250000 +0000
@@ -0,0 +1,688 @@
+#line 1 "local.c"
+/* Process incoming args and create return values (lisp structs and foreign ptrs) */
+/* processTYPE(c-ptr, object): lisp => C
+   object = outputTYPE(c-ptr): C => lisp */
+
+extern object allocate_ffloat (ffloat value);
+
+/* Global error handling */
+/* TODO: call customizable lisp handler, like
+   (GDI::error-handler fn) to be able to use
+   (error signature) or popup a window or ignore the error.
+*/
+#define GDI_ERROR(fn)           \
+  DWORD e;			\
+  begin_system_call();          \
+  e = GetLastError();		\
+  end_system_call();		\
+  value1 = NIL;                 \
+  value2 = uint32_to_I(e);	\
+  mv_count=2
+
+#define GDI_ERROR_ext(fn)       \
+    DWORD e;			\
+    begin_system_call();	\
+    e = GetLastError();		\
+    end_system_call();		\
+    value1 = NIL;		\
+    value2 = uint32_to_I(e);	\
+    /* dynamic_bind(``*last-error*``, value2), */  \
+    /*pushSTACK(value2);*/      \
+    /*pushSTACK(``last-error``);*/  \
+    /*funcall(L(setq),2);*/      \
+    /*pushSTACK(TheSubr(subr_self)->name);*/ \
+    /*GDI::error-handler;*/     \
+    /*OS_error();*/             \
+    mv_count=2
+
+nonreturning_function(static, invalid_argument, (object obj)) {
+  pushSTACK(obj);
+  error(error_condition,GETTEXT("~ is an invalid argument"));
+}
+nonreturning_function(static, invalid_named_argument, (object obj, char *name)) {
+  pushSTACK(asciz_to_string(name, encoding));
+  pushSTACK(obj);
+  error(error_condition,GETTEXT("~ is an invalid argument for ~"));
+}
+
+#define getHDC(hdc,arg)                         	\
+  arg = popSTACK(); 					\
+  if(!fpointerp(arg))invalid_named_argument(arg, "hdc");\
+  hdc = TheFpointer(arg)->fp_pointer
+
+/* allow processFPTYPE_fn(HPALETTE,hpalette,popSTACK()); */
+#define processFPTYPE_fn(type, ptr, arg) 	  \
+    { object obj = arg;			  \
+      if(!fpointerp(obj))invalid_argument(obj); \
+      ptr = (type)TheFpointer(obj)->fp_pointer;}
+
+/* only processFPTYPE(HPALETTE,hpalette,arg); */
+#define processFPTYPE(type, ptr, arg) 		\
+      if(!fpointerp(arg))invalid_argument(arg); \
+      ptr = (type)TheFpointer(arg)->fp_pointer
+
+static void processBOOL(void *p,object arg){
+    // arg: T or nil => 0 or 1
+    BOOL b;
+    b = (BOOL)I_to_uint32(arg);
+    p = &b;
+}
+//static void processFINDEX_INFO_LEVELS(void *p,object arg){ assert(0); }
+//static void processFINDEX_SEARCH_OPS(void *p,object arg){ assert(0); }
+//static void processLPSTR(void *p,object arg){ assert(0); }
+static void processLPWSTR(LPCWSTR lpcwstr,object arg){ 
+  if(!stringp(arg))invalid_argument(arg);
+  lpcwstr = WIDECHAR(arg,encoding);
+}
+// create a S16string how? size includes the ending 0
+static object outputLPWSTR(LPCWSTR lpcwstr, uint size){ 
+  /*object string = allocate_imm_s16string(size-1);
+    copy_16bit_16bit(lpcwstr, &TheS16string(string)->data[0],size-1);*/
+  assert(0);
+  return asciz_to_string(lpcwstr,GLO(misc_encoding));
+}
+// size includes the ending 0
+static object outputLPSTR(LPCSTR lpcstr, uint size){
+  return asciz_to_string(lpcstr,GLO(misc_encoding));
+}
+//static void processPBITMAPINFO(void *p,object arg){ assert(0); }
+static void processPINT(void *p,object arg){
+    int i;
+    i = I_to_uint32(check_uint(arg));
+    p = &i;
+}
+//static void processSTR_P(void *p,object arg){ assert(0); }
+//static void processWSTR_P(void *p,object arg){ assert(0); }
+//static void processABC(ABC *p, object arg){ assert(0); }
+static void processPBYTE(BYTE *p, object arg){
+    BYTE i;
+    i = I_to_uint32(check_uint(arg));
+    p = &i;
+}
+static void processBYTE(BYTE *p, object arg){
+    BYTE i;
+    i = I_to_sint32(check_sint(arg));
+    p = &i;
+}
+//static void processABCFLOAT(ABCFLOAT *p, object arg){ assert(0); }
+//static void processENHMETAHEADER(void *p, object arg){ assert(0); }
+//static void processFONTSIGNATURE(void *p, object arg){ assert(0); }
+//static void processKERNINGPAIR(void *p, object arg){ assert(0); }
+//static void processOUTLINETEXTMETRICA(void *p, object arg){ assert(0); }
+//static void processOUTLINETEXTMETRICW(void *p, object arg){ assert(0); }
+//static void processRASTERIZER_STATUS(void *p, object arg){ assert(0); }
+//static void processRGBQUAD(RGBQUAD *p, object arg){ assert(0); }
+//static void processTEXTMETRICW(TEXTMETRICW*p, object arg){ assert(0); }
+//static void outputGLYPHMETRICS(GLYPHMETRICS* p, object arg){ assert(0); }
+//static void processGCP_RESULTSA(GCP_RESULTSA* p, object arg){ assert(0); }
+//static void processGCP_RESULTSW(GCP_RESULTSW* p, object arg){ assert(0); }
+//static void processHANDLETABLE_C(HANDLETABLE* p, object arg, unsigned int count){}
+//static void processLOGCOLORSPACEA(LOGCOLORSPACEA* p, object arg){ assert(0); }
+//static void processLOGCOLORSPACEW(LOGCOLORSPACEW* p, object arg){ assert(0); }
+//static void processMETARECORD(METARECORD* p, object arg){ assert(0); }
+//static void processPOLYTEXTW(POLYTEXTW* p, object arg){ assert(0); }
+//static void processSIZE(SIZE* p, object arg){ assert(0); }
+static void processvoid(void* p, object arg){
+  p = (void *)I_to_uint32(arg);
+}
+//static void processABORTPROC(ABORTPROC *p,object arg){ assert(0); }
+//static void processBITMAPINFO(BITMAPINFO *p,object arg){ assert(0); }
+//static void processBITMAPINFOHEADER(BITMAPINFOHEADER *p,object arg){ assert(0); }
+//static void processDEVMODEA(DEVMODEA *p,object arg){ assert(0); }
+//static void processDEVMODEW(DEVMODEW *p,object arg){ assert(0); }
+//static void processDOCINFOA(DOCINFOA *p,object arg){ assert(0); }
+//static void processDOCINFOW(DOCINFOW *p,object arg){ assert(0); }
+//static void processENHMETARECORD(ENHMETARECORD *p,object arg){ assert(0); }
+//static void processENHMFENUMPROC(ENHMFENUMPROC *p,object arg){ assert(0); }
+static void processFONTENUMPROCA(FONTENUMPROCA *p,object arg){ 
+  if(!fpointerp(arg))invalid_argument(arg);
+  p = (FONTENUMPROCA *)TheFpointer(arg)->fp_pointer;
+}
+//static void processFONTENUMPROCW(FONTENUMPROCW *p,object arg){ assert(0); }
+//static void processGLYPHMETRICS(GLYPHMETRICS *p,object arg){ assert(0); }
+//static void processGOBJENUMPROC(GOBJENUMPROC *p,object arg){ assert(0); }
+//static void processICMENUMPROCA(ICMENUMPROCA *p,object arg){ assert(0); }
+//static void processICMENUMPROCW(ICMENUMPROCW *p,object arg){ assert(0); }
+//static void processLINEDDAPROC(LINEDDAPROC *p,object arg){ assert(0); }
+//static void processLOGPALETTE(LOGPALETTE *p,object arg){ assert(0); }
+//static void processLOGPEN(LOGPEN *p,object arg){ assert(0); }
+//static void processLPABC(LPABC *p,object arg){ assert(0); }
+//static void processLPABCFLOAT(LPABCFLOAT *p,object arg){ assert(0); }
+//static void processLPBITMAPINFO(LPBITMAPINFO *p,object arg){ assert(0); }
+//static void processLPCHARSETINFO(LPCHARSETINFO *p,object arg){ assert(0); }
+//static void processLPCOLORADJUSTMENT(LPCOLORADJUSTMENT *p,object arg){ assert(0); }
+//static void processLPCRECT(LPCRECT *p,object arg){ assert(0); }
+//static void processLPENHMETAHEADER(LPENHMETAHEADER *p,object arg){ assert(0); }
+//static void processLPFONTSIGNATURE(LPFONTSIGNATURE *p,object arg){ assert(0); }
+//static void processLPGCP_RESULTSA(LPGCP_RESULTSA *p,object arg){ assert(0); }
+//static void processLPGCP_RESULTSW(LPGCP_RESULTSW *p,object arg){ assert(0); }
+//static void processLPHANDLETABLE(LPHANDLETABLE *p,object arg){ assert(0); }
+//static void processLPINT(LPINT *p,object arg){ assert(0); }
+//static void processLPKERNINGPAIR(LPKERNINGPAIR *p,object arg){ assert(0); }
+//static void processLPLOGCOLORSPACEA(LPLOGCOLORSPACEA *p,object arg){ assert(0); }
+//static void processLPLOGCOLORSPACEW(LPLOGCOLORSPACEW *p,object arg){ assert(0); }
+//static void processLPMETARECORD(LPMETARECORD *p,object arg){ assert(0); }
+//static void processLPOUTLINETEXTMETRICA(LPOUTLINETEXTMETRICA *p,object arg){ assert(0); }
+//static void processLPOUTLINETEXTMETRICW(LPOUTLINETEXTMETRICW *p,object arg){ assert(0); }
+//static void processLPPALETTEENTRY(LPPALETTEENTRY *p,object arg){ assert(0); }
+//static void processLPPIXELFORMATDESCRIPTOR(LPPIXELFORMATDESCRIPTOR *p,object arg){ assert(0); }
+//static void processLPPOINT(LPPOINT *p,object arg){ assert(0); }
+//static void processLPRASTERIZER_STATUS(LPRASTERIZER_STATUS *p,object arg){ assert(0); }
+//static void processLPRECT(LPRECT *p,object arg){ assert(0); }
+//static void processLPSIZE(LPSIZE *p,object arg){ assert(0); }
+//static void processLPTEXTMETRICA(LPTEXTMETRICA *p,object arg){ assert(0); }
+//static void processLPTEXTMETRICW(LPTEXTMETRICW *p,object arg){ assert(0); }
+//static void processLPXFORM(LPXFORM *p,object arg){ assert(0); }
+//static void processMFENUMPROC(MFENUMPROC *p,object arg){ assert(0); }
+//static void processPFLOAT(PFLOAT *p,object arg){ assert(0); }
+//static void processRGNDATA(RGNDATA *p,object arg){ assert(0); }
+//static void processRGNDATA_C(RGNDATA *p,object arg, int count){}
+
+static void processICONINFO(ICONINFO *p,object arg)
+{
+   int i = 1;
+   p->fIcon = nullp(TheRecord(arg)->recdata[i++]);
+   p->xHotspot = I_to_L(TheRecord(arg)->recdata[i++]);
+   p->yHotspot = I_to_L(TheRecord(arg)->recdata[i++]);
+   p->hbmMask = TheFpointer(TheRecord(arg)->recdata[i++])->fp_pointer;
+   p->hbmColor = TheFpointer(TheRecord(arg)->recdata[i++])->fp_pointer;
+}
+static void processLOGFONTA(LOGFONTA *p,object arg)
+{
+   int i = 1;
+   p->lfHeight = I_to_L(TheRecord(arg)->recdata[i++]);
+   p->lfWidth = I_to_L(TheRecord(arg)->recdata[i++]);
+   p->lfEscapement = I_to_L(TheRecord(arg)->recdata[i++]);
+   p->lfOrientation = I_to_L(TheRecord(arg)->recdata[i++]);
+   p->lfWeight = I_to_L(TheRecord(arg)->recdata[i++]);
+   p->lfItalic = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->lfUnderline = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->lfStrikeOut = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->lfCharSet = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->lfOutPrecision = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->lfClipPrecision = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->lfQuality = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->lfPitchAndFamily = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   strncpy(p->lfFaceName,
+      (LPCSTR)TheAsciz(string_to_asciz(TheRecord(arg)->recdata[i++],encoding)),
+      sizeof(p->lfFaceName));
+}
+static void processPLOGFONTA(LOGFONTA *p,object arg)
+{
+  if(!fpointerp(arg))invalid_argument(arg);
+  p = (LOGFONTA *)TheFpointer(arg)->fp_pointer;
+}
+static void processLOGFONTW(LOGFONTW *p,object arg){ assert(0); }
+static object outputRECT(RECT *r)
+{
+  int i = 0;
+  object p;
+  object num;
+  pushSTACK(p); // Push the record to keep it safe from gc
+  num = UL_to_I(r->left); // Can cause gc
+  TheRecord(STACK_0)->recdata[i++] = num;
+  num = UL_to_I(r->top); // Can cause gc
+  TheRecord(STACK_0)->recdata[i++] = num;
+  num = UL_to_I(r->right); // Can cause gc
+  TheRecord(STACK_0)->recdata[i++] = num;
+  num = UL_to_I(r->bottom); // Can cause gc
+  TheRecord(popSTACK())->recdata[i++] = num;
+  return p;
+}
+// untested - was never called
+// used in: 
+// removed from: AnimatePallette SetPaletteEntries GetPaletteEntries 
+//               GetEnhMetaFilePaletteEntries GetSystemPaletteEntries
+/*
+static void processPALETTEENTRY(PALETTEENTRY* p, object arg)
+{
+   int i = 0;
+   p->peRed = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->peGreen = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->peBlue = I_to_uint8(TheRecord(arg)->recdata[i++]);
+   p->peFlags = I_to_uint8(TheRecord(arg)->recdata[i++]);
+}
+*/
+// untested - was never called
+// could be used in CheckColorsInGamut, but we use 8-bit bitvectors
+static void processRGBQUAD_C(RGBQUAD* p, object args,DWORD length)
+{
+   int j;
+   for(j = 0; j < length; j++,p++)
+   {
+      int i = 0;
+      object arg = TheSvector(args)->data[j];
+      p->rgbRed = I_to_uint8(TheRecord(arg)->recdata[i++]);
+      p->rgbGreen = I_to_uint8(TheRecord(arg)->recdata[i++]);
+      p->rgbBlue = I_to_uint8(TheRecord(arg)->recdata[i++]);
+      p->rgbReserved = 0;
+   }
+}
+static DWORD processCOLORREF(object arg)
+{
+  // check for int or struct
+  if (integerp(arg)) {
+    return I_to_uint32(arg);
+  } else {
+    int i = 0;
+    BYTE r = I_to_uint8(TheRecord(arg)->recdata[i++]);
+    BYTE g = I_to_uint8(TheRecord(arg)->recdata[i++]);
+    BYTE b = I_to_uint8(TheRecord(arg)->recdata[i++]);
+    return RGB(r,g,b);
+  }
+}
+// untested - was never called
+// NULL is for the identity transform
+static void processXFORM(XFORM *p, object arg)
+{
+  if (nullp(arg)) {
+    p = NULL;
+  } else {
+    int i = 0;
+    ffloatjanus jfloat;
+#if 0
+    if (fpointerp(arg)) {
+      //p = TheFvariable(obj)->fv_address;
+      //pushSTACK(arg);
+      //`foreign_pointer`;
+      p = (XFORM*)ulong_to_I((uintP)TheFpointer(arg)->fp_pointer);
+      return;
+    }
+#endif
+    FF_to_c_float(TheRecord(arg)->recdata[i++],&jfloat);
+    p->eM11 = (float)(jfloat.eksplicit);
+    FF_to_c_float(TheRecord(arg)->recdata[i++],&jfloat);
+    p->eM12 = (float)(jfloat.eksplicit);
+    FF_to_c_float(TheRecord(arg)->recdata[i++],&jfloat);
+    p->eM21 = (float)(jfloat.eksplicit);
+    FF_to_c_float(TheRecord(arg)->recdata[i++],&jfloat);
+    p->eM22 = (float)(jfloat.eksplicit);
+    FF_to_c_float(TheRecord(arg)->recdata[i++],&jfloat);
+    p->eDx = (float)(jfloat.eksplicit);
+    FF_to_c_float(TheRecord(arg)->recdata[i++],&jfloat);
+    p->eDy = (float)(jfloat.eksplicit);
+  }
+}
+static object outputXFORM(XFORM *p){ 
+  int i = 1;
+  object arg;
+  pushSTACK(arg);
+  TheRecord(STACK_0)->recdata[i++] = allocate_ffloat(p->eM11);
+  TheRecord(STACK_0)->recdata[i++] = allocate_ffloat(p->eM12);
+  TheRecord(STACK_0)->recdata[i++] = allocate_ffloat(p->eM21);
+  TheRecord(STACK_0)->recdata[i++] = allocate_ffloat(p->eM22);
+  TheRecord(STACK_0)->recdata[i++] = allocate_ffloat(p->eDx);
+  TheRecord(popSTACK())->recdata[i++] = allocate_ffloat(p->eDy);
+  return arg;
+}
+static object outputABCFLOAT(ABCFLOAT *p){ 
+  int i = 1;
+  object arg;
+  pushSTACK(arg);
+  TheRecord(STACK_0)->recdata[i++] = allocate_ffloat(p->abcfA);
+  TheRecord(STACK_0)->recdata[i++] = allocate_ffloat(p->abcfB);
+  TheRecord(popSTACK())->recdata[i++] = allocate_ffloat(p->abcfC);
+  return arg;
+}
+static void processLPSIZE(SIZE *p, object arg)
+{
+   int i = 1;
+   p->cx = I_to_L(TheRecord(arg)->recdata[i++]);
+   p->cy = I_to_L(TheRecord(arg)->recdata[i++]);
+}
+// Return a SIZE structure
+static object outputLPSIZE(SIZE *lpsize)
+{
+  int i = 1;
+  object arg;
+  pushSTACK(arg);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(lpsize->cx);
+  TheRecord(popSTACK())->recdata[i++] = fixnum(lpsize->cy);
+  return arg;
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+static void processPOINT(POINT* p, object arg)
+{
+   int i = 0;
+   p->x = I_to_sint32(TheRecord(arg)->recdata[i++]);
+   p->y = I_to_sint32(TheRecord(arg)->recdata[i++]);
+}
+static object outputPOINT(POINT *p)
+{
+  int i = 1;
+  object arg;
+  pushSTACK(arg);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->x);
+  TheRecord(popSTACK())->recdata[i++] = fixnum(p->y);
+  return arg;
+}
+
+// untested - was never called
+// uninspected - compiles but code was not checked
+static void processRECT(RECT* p, object arg)
+{
+  int i = 0;
+  p->left = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->top = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->right = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->bottom = I_to_sint32(TheRecord(arg)->recdata[i++]);
+}
+static void processPOLYTEXTA(POLYTEXTA* p, object arg)
+{
+  int i = 0;
+  p->x = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->y = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->n = I_to_uint32(TheRecord(arg)->recdata[i++]);
+  p->lpstr = (LPCSTR)TheAsciz(TheRecord(arg)->recdata[i++]);
+  p->uiFlags = I_to_uint32(TheRecord(arg)->recdata[i++]);
+  processRECT(&p->rcl, TheRecord(arg)->recdata[i++]);
+  p->pdx = (int*)I_to_uint32(TheRecord(arg)->recdata[i++]);
+}
+// untested - was never called
+static void processCOLORADJUSTMENT(COLORADJUSTMENT *p, object arg)
+{
+   int i;
+   WORD *w = (WORD*)p;
+   SHORT *s = (SHORT*)p;
+   for(i = 0; i < 8; i++)w[i]= I_to_uint16(TheRecord(arg)->recdata[i]);
+   for(; i < 12; i++)s[i] = I_to_sint16(TheRecord(arg)->recdata[i]);
+}
+static object outputCOLORADJUSTMENT(COLORADJUSTMENT *p){
+    return allocate_fpointer((FOREIGN)p);
+}
+// untested - was never called
+static void processPIXELFORMATDESCRIPTOR(PIXELFORMATDESCRIPTOR* p,object arg)
+{
+  int i = 0;
+  p->nSize = I_to_uint16(TheRecord(arg)->recdata[i++]);
+  p->nVersion = I_to_uint16(TheRecord(arg)->recdata[i++]);
+  p->dwFlags = I_to_uint32(TheRecord(arg)->recdata[i++]);
+  p->iPixelType = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cColorBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cRedBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cRedShift = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cGreenBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cGreenShift = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cBlueBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cBlueShift = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cAlphaBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cAlphaShift = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cAccumBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cAccumRedBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cAccumGreenBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cAccumBlueBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cAccumAlphaBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cDepthBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cStencilBits = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->cAuxBuffers = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->iLayerType = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->bReserved = I_to_uint8(TheRecord(arg)->recdata[i++]);
+  p->dwLayerMask = I_to_uint32(TheRecord(arg)->recdata[i++]);
+  p->dwVisibleMask = I_to_uint32(TheRecord(arg)->recdata[i++]);
+  p->dwDamageMask = I_to_uint32(TheRecord(arg)->recdata[i++]);
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+// known not to work
+static FIXED toFixed(float f)
+{
+  FIXED fixed;
+  fixed.value = (int)f;
+  fixed.fract = (WORD)(10000*(f - fixed.value));
+  return fixed;
+}
+
+static void processMAT2(MAT2 *p, object arg)
+{
+  int i = 0;
+  ffloatjanus f;
+  FF_to_c_float(TheRecord(arg)->recdata[i++],&f);
+  p->eM11 = toFixed((float)(f.eksplicit));
+  FF_to_c_float(TheRecord(arg)->recdata[i++],&f);
+  p->eM12 = toFixed((float)(f.eksplicit));
+  FF_to_c_float(TheRecord(arg)->recdata[i++],&f);
+  p->eM21 = toFixed((float)(f.eksplicit));
+  FF_to_c_float(TheRecord(arg)->recdata[i++],&f);
+  p->eM22 = toFixed((float)(f.eksplicit));
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+static void processBITMAP(BITMAP *p,object arg)
+{
+  int i = 0;
+  p->bmType = (LONG)I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->bmWidth = (LONG)I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->bmHeight = (LONG)I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->bmWidthBytes = (LONG)I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->bmPlanes = (WORD)I_to_uint16(TheRecord(arg)->recdata[i++]);
+  p->bmBitsPixel = (WORD)I_to_uint16(TheRecord(arg)->recdata[i++]);
+  p->bmBits = (LPVOID)&TheSbvector( TheRecord(arg)->recdata[i++])->data[0];
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+static void processLOGBRUSH(LOGBRUSH* p, object arg)
+{
+   int i = 0;
+   p->lbStyle = I_to_uint32(TheRecord(arg)->recdata[i++]);
+   p->lbColor = processCOLORREF(TheRecord(arg)->recdata[i++]);
+   p->lbHatch = I_to_sint32(TheRecord(arg)->recdata[i++]);
+}
+// untested - was never called
+// uninspected - compiles but code was not checked
+static void processMETAFILEPICT(METAFILEPICT *p,object arg)
+{
+  int i = 0;
+  p->mm = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->xExt = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->yExt = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->hMF = TheFpointer(TheRecord(arg)->recdata[i++])->fp_pointer;
+}
+
+static void processWNDCLASSA(WNDCLASSA *p, object arg)
+{
+  object s;
+  int i = 1;
+  p->style = I_to_uint32(TheRecord(arg)->recdata[i++]);
+  p->lpfnWndProc  = WindowProc;
+  p->cbClsExtra = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->cbWndExtra = I_to_sint32(TheRecord(arg)->recdata[i++]);
+  p->hInstance = TheFpointer(TheRecord(arg)->recdata[i++])->fp_pointer;
+  s = TheRecord(arg)->recdata[i++];
+  p->hIcon = nullp(s)?0:TheFpointer(s)->fp_pointer;
+  p->hCursor = TheFpointer(TheRecord(arg)->recdata[i++])->fp_pointer;
+  p->hbrBackground = TheFpointer(TheRecord(arg)->recdata[i++])->fp_pointer;
+  s = TheRecord(arg)->recdata[i++];
+  if(nullp(s))
+  {
+     p->lpszMenuName = NULL;
+  }
+  else if(stringp(s))
+  {
+     p->lpszMenuName = (LPCSTR)TheAsciz(string_to_asciz(s,encoding));
+  }
+  else if(fpointerp(s))
+  {
+     p->lpszMenuName = TheFpointer(s)->fp_pointer;
+  }
+  else invalid_argument(s);
+  s = TheRecord(arg)->recdata[i++];
+  p->lpszClassName = (LPCSTR)(stringp(s)?
+                              TheAsciz(string_to_asciz(s,encoding)):
+                              TheFpointer(s)->fp_pointer);
+}
+
+static void processWNDCLASSW(WNDCLASSW *p, object arg){ assert(0); }
+
+static void processCREATESTRUCTA(CREATESTRUCT *p, object arg)
+{
+  object s;
+  int i = 1;
+  p->dwExStyle = I_to_uint32(TheRecord(arg)->recdata[i++]);
+  s = TheRecord(arg)->recdata[i++];
+  p->lpszClass = stringp(s)?
+      (LPCSTR)TheAsciz(string_to_asciz(s,encoding)):
+      TheFpointer(s)->fp_pointer;
+  p->lpszName = stringp(s)?
+      (LPCSTR)TheAsciz(string_to_asciz(TheRecord(arg)->recdata[i++],encoding)):
+      TheFpointer(s)->fp_pointer;
+  p->style = I_to_uint32(TheRecord(arg)->recdata[i++]);
+  p->x = I_to_L(TheRecord(arg)->recdata[i++]);
+  p->y = I_to_L(TheRecord(arg)->recdata[i++]);
+  p->cx = I_to_L(TheRecord(arg)->recdata[i++]);
+  p->cy = I_to_L(TheRecord(arg)->recdata[i++]);
+  s = TheRecord(arg)->recdata[i++];
+  p->hwndParent = nullp(s)?0:TheFpointer(s)->fp_pointer;
+  s = TheRecord(arg)->recdata[i++];
+  p->hMenu = nullp(s)?0:TheFpointer(s)->fp_pointer;
+  s = TheRecord(arg)->recdata[i++];
+  p->hInstance = nullp(s)?0:TheFpointer(s)->fp_pointer;
+  p->lpCreateParams = 0;  //= I_to_uint8(TheRecord(arg)->recdata[i++]);
+}
+// unused
+static object outputCREATESTRUCTA(CREATESTRUCT *p)
+{
+  int i = 1;
+  object arg;
+  pushSTACK(arg);
+  TheRecord(STACK_0)->recdata[i++] = UL_to_I(p->dwExStyle);
+  TheRecord(STACK_0)->recdata[i++] = p->lpszClass?
+      asciz_to_string((const char*)p->lpszClass,encoding):
+      O(fp_zero);
+  TheRecord(STACK_0)->recdata[i++] = p->lpszName?
+      asciz_to_string((const char*)p->lpszName,encoding):
+      O(fp_zero);
+  TheRecord(STACK_0)->recdata[i++] = UL_to_I(p->style);
+  TheRecord(STACK_0)->recdata[i++] = L_to_I(p->x);
+  TheRecord(STACK_0)->recdata[i++] = L_to_I(p->y);
+  TheRecord(STACK_0)->recdata[i++] = L_to_I(p->cx);
+  TheRecord(STACK_0)->recdata[i++] = L_to_I(p->cy);
+  TheRecord(STACK_0)->recdata[i++] = allocate_fpointer((FOREIGN)p->hwndParent);
+  TheRecord(STACK_0)->recdata[i++] = allocate_fpointer((FOREIGN)p->hMenu);
+  TheRecord(STACK_0)->recdata[i++] = allocate_fpointer((FOREIGN)p->hInstance);
+  TheRecord(popSTACK())->recdata[i++] = NIL; //L_to_I(p->lpCreateParams);
+  return arg;
+}
+static object outputTEXTMETRICA(TEXTMETRICA *p)
+{
+  int i = 1;
+  object arg;
+  pushSTACK(arg);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmHeight);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmAscent);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmDescent);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmInternalLeading);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmExternalLeading);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmAveCharWidth);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmMaxCharWidth);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmWeight);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmOverhang);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmDigitizedAspectX);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmDigitizedAspectY);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmFirstChar);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmLastChar);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmDefaultChar);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmBreakChar);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmItalic);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmUnderlined);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmStruckOut);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmPitchAndFamily);
+  TheRecord(popSTACK())->recdata[i++] = fixnum(p->tmCharSet);
+  return arg;
+}
+static object outputTEXTMETRICW(TEXTMETRICW *p)
+{
+  int i = 1;
+  object arg;
+  pushSTACK(arg);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmHeight);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmAscent);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmDescent);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmInternalLeading);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmExternalLeading);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmAveCharWidth);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmMaxCharWidth);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmWeight);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmOverhang);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmDigitizedAspectX);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmDigitizedAspectY);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmFirstChar);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmLastChar);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmDefaultChar);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmBreakChar);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmItalic);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmUnderlined);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmStruckOut);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->tmPitchAndFamily);
+  TheRecord(popSTACK())->recdata[i++] = fixnum(p->tmCharSet);
+  return arg;
+}
+static object outputFLOATS(FLOAT *f, UINT length){
+    return allocate_ffloat((ffloat)*f);
+}
+static void processCURSORINFO(CURSORINFO *c, object arg){
+  object s;
+  int i = 1;
+  c->cbSize  = I_to_uint32(TheRecord(arg)->recdata[i++]);
+  c->flags   = I_to_uint32(TheRecord(arg)->recdata[i++]);
+  s = TheRecord(arg)->recdata[i++];
+  c->hCursor = nullp(s)?0:TheFpointer(s)->fp_pointer;
+  c->ptScreenPos.x = I_to_L(TheRecord(arg)->recdata[i++]);
+  c->ptScreenPos.y = I_to_L(TheRecord(arg)->recdata[i++]);
+}
+static object outputCURSORINFO(CURSORINFO *c)
+{
+  int i = 1;
+  object arg;
+  pushSTACK(arg);
+  TheRecord(STACK_0)->recdata[i++] = UL_to_I(c->cbSize);
+  TheRecord(STACK_0)->recdata[i++] = UL_to_I(c->flags);
+  TheRecord(STACK_0)->recdata[i++] = allocate_fpointer((FOREIGN)c->hCursor);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(c->ptScreenPos.x);
+  TheRecord(popSTACK())->recdata[i++] = fixnum(c->ptScreenPos.y);
+  return arg;
+}
+static object outputGCP_RESULTSA(GCP_RESULTSA* p){
+  int i = 1;
+  object arg;
+  pushSTACK(arg);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->lStructSize);
+  TheRecord(STACK_0)->recdata[i++] = p->lpOutString?
+      asciz_to_string((const char*)p->lpOutString,encoding):
+      O(fp_zero);
+  /* TODO: simple_int bitvectors */
+  TheRecord(STACK_0)->recdata[i++] = p->lpOrder?
+      allocate_fpointer((FOREIGN)p->lpOrder):O(fp_zero);
+  TheRecord(STACK_0)->recdata[i++] = p->lpDx?
+      allocate_fpointer((FOREIGN)p->lpDx):O(fp_zero);
+  TheRecord(STACK_0)->recdata[i++] = p->lpCaretPos?
+      allocate_fpointer((FOREIGN)p->lpCaretPos):O(fp_zero);
+  TheRecord(STACK_0)->recdata[i++] = p->lpClass?
+      asciz_to_string((const char*)p->lpClass,encoding):
+      O(fp_zero);
+  TheRecord(STACK_0)->recdata[i++] = UL_to_I(p->nGlyphs);
+  TheRecord(popSTACK())->recdata[i++] = UL_to_I(p->nMaxFit);
+  return arg;
+}
+static object outputGCP_RESULTSW(GCP_RESULTSW* p){ 
+  int i = 1;
+  object arg;
+  pushSTACK(arg);
+  TheRecord(STACK_0)->recdata[i++] = fixnum(p->lStructSize);
+  /* TODO: convert to widechar */
+  TheRecord(STACK_0)->recdata[i++] = p->lpOutString?
+    allocate_fpointer((FOREIGN)p->lpOutString):O(fp_zero);
+  /* TODO: simple_int bitvectors */
+  TheRecord(STACK_0)->recdata[i++] = p->lpOrder?
+    allocate_fpointer((FOREIGN)p->lpOrder):O(fp_zero);
+  TheRecord(STACK_0)->recdata[i++] = p->lpDx?
+    allocate_fpointer((FOREIGN)p->lpDx):O(fp_zero);
+  TheRecord(STACK_0)->recdata[i++] = p->lpCaretPos?
+    allocate_fpointer((FOREIGN)p->lpCaretPos):O(fp_zero);
+  /* TODO: convert to widechar */
+  TheRecord(STACK_0)->recdata[i++] = p->lpClass?
+    allocate_fpointer((FOREIGN)p->lpClass):O(fp_zero);
+  TheRecord(STACK_0)->recdata[i++] = UL_to_I(p->nGlyphs);
+  TheRecord(popSTACK())->recdata[i++] = UL_to_I(p->nMaxFit);
+  return arg;
+}
diff -burN origsrc/clisp-2.48/modules/gdi/make-rest.sh src/clisp-2.48/modules/gdi/make-rest.sh
--- origsrc/clisp-2.48/modules/gdi/make-rest.sh	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/make-rest.sh	2009-07-11 13:37:37.000000000 +0000
@@ -0,0 +1,36 @@
+# This file was used to recover from a problem with the funcs-rest.h file
+grep -ih ANGLEARC *.h
+grep -ih ARC *.h
+grep -ih ARCTO *.h
+grep -ih BITBLT *.h
+grep -ih CHORD *.h
+grep -ih CREATEDIBITMAP *.h
+grep -ih CREATEFONTA *.h
+grep -ih CREATEFONTW *.h
+grep -ih CREATEROUNDRECTRGN *.h
+grep -ih CREATEWINDOWEXA *.h
+grep -ih CREATEWINDOWEXW *.h
+grep -ih EXTESCAPE *.h
+grep -ih EXTTEXTOUTA *.h
+grep -ih EXTTEXTOUTW *.h
+grep -ih GETCHARACTERPLACEMENTA *.h
+grep -ih GETCHARACTERPLACEMENTW *.h
+grep -ih GETDIBITS *.h
+grep -ih GETGLYPHOUTLINEA *.h
+grep -ih GETGLYPHOUTLINEW *.h
+grep -ih GETTEXTEXTENTEXPOINTA *.h
+grep -ih GETTEXTEXTENTEXPOINTW *.h
+grep -ih MASKBLT *.h
+grep -ih PATBLT *.h
+grep -ih PIE *.h
+grep -ih PLGBLT *.h
+grep -ih ROUNDRECT *.h
+grep -ih SCALEVIEWPORTEXTEX *.h
+grep -ih SCALEWINDOWEXTEX *.h
+grep -ih SETDIBITS *.h
+grep -ih SETDIBITSTODEVICE *.h
+grep -ih STRETCHBLT *.h
+grep -ih STRETCHDIBITS *.h
+grep -ih TABBEDTEXTOUTA *.h
+grep -ih TABBEDTEXTOUTW *.h
+
diff -burN origsrc/clisp-2.48/modules/gdi/modernize.pl src/clisp-2.48/modules/gdi/modernize.pl
--- origsrc/clisp-2.48/modules/gdi/modernize.pl	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/modernize.pl	2009-07-10 20:45:38.000000000 +0000
@@ -0,0 +1,28 @@
+#!/usr/bin/perl
+
+# modernize.pl funcs-*.c
+# Reini Urban
+
+while (my $fn = shift) {
+  my %F;
+  open F, "< $fn";
+  open OUT, "> $fn.new";
+  # passthru pararaphs of defun's
+  local $/ = "\nDEFUN";
+  while (<F>) {
+    my ($func, $defun);
+    if (/begin_system_call\(\);\n\s+\w+ = (\w+)\(.+\);\n\s+end_system_call/) {
+      $func = $1;
+      if (/^\( GDI:([A-Z]+)[,)]/) {
+        $defun = $1;
+        print "$defun => $func\n";
+        $F{$defun} = $func;
+        s/^\( GDI:([A-Z]+)/( GDI:$func/;
+      }
+    }
+    print OUT;
+  }
+  close F;
+  close OUT;
+}
+
diff -burN origsrc/clisp-2.48/modules/gdi/p1.lisp src/clisp-2.48/modules/gdi/p1.lisp
--- origsrc/clisp-2.48/modules/gdi/p1.lisp	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/p1.lisp	2009-07-28 22:32:21.000000000 +0000
@@ -0,0 +1,43 @@
+;(in-package :cs-user)
+(use-package "GDI")
+(defun f ()
+  (let* ((hdc (GDI::GetDC nil))
+         (sy  (GDI::GetDeviceCaps hdc GDI::LOGPIXELSY))
+         (logfont (GDI::make-logfont
+              (- sy) 0 0 0 GDI::FW_BOLD 1 0 0 GDI::ANSI_CHARSET
+              GDI::OUT_TT_PRECIS GDI::CLIP_DEFAULT_PRECIS
+              GDI::PROOF_QUALITY GDI::VARIABLE_PITCH
+              "Times New Roman"))
+         (hfont (GDI::CreateFontIndirectA logfont))
+         (x (/ (GDI::GetSystemMetrics GDI::SM_CXSCREEN) 2))
+         (y (/ (GDI::GetSystemMetrics GDI::SM_CYSCREEN) 2))
+         (hold (GDI::SelectObject hdc hfont)))
+     (GDI::SetTextAlign hdc (logior GDI::TA_CENTER GDI::TA_BASELINE))
+     (GDI::SetBkMode hdc GDI::TRANSPARENT)
+     (GDI::SetTextColor hdc (GDI::make-rgb 0 0 #xff))
+     (GDI::TextOutA hdc x y "HELLO WORLD" 11)
+     (GDI::SelectObject hdc hold)
+     (GDI::DeleteObject hfont)))
+
+#|
+(trace GDI::CreateFontIndirectA)
+(trace GDI::DeleteObject)
+(trace GDI::GetDC)
+(trace GDI::GetDeviceCaps)
+(trace GDI::GetSystemMetrics)
+(trace GDI::make-rgb)
+(trace GDI::make-logfont)
+(trace GDI::SelectObject)
+(trace GDI::SetBkMode)
+(trace GDI::SetTextAlign)
+(trace GDI::SetTextColor)
+(trace GDI::TextOutA)
+|#
+
+(f)
+
+;; case tests:
+;; (in-package :cs-user)(use-package "GDI")(setq lst '())(do-external-symbols (s (find-package 'gdi) lst) (push s lst))
+;; (setq lst '())(do-symbols (s (find-package 'gdi) lst) (push s lst))
+;; (in-package :user)(use-package "GDI")(setq lst '())(do-external-symbols (s (find-package 'gdi) lst) (push s lst))
+;; ./clisp -K full -norc -q -x "(in-package :cs-user)(use-package :GDI)(setq lst '())(do-symbols (s (find-package 'gdi) lst) (push s lst))"
diff -burN origsrc/clisp-2.48/modules/gdi/p2.lisp src/clisp-2.48/modules/gdi/p2.lisp
--- origsrc/clisp-2.48/modules/gdi/p2.lisp	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/p2.lisp	2009-07-29 10:32:23.000000000 +0000
@@ -0,0 +1,53 @@
+;(in-package :cs-user)
+(use-package "GDI")
+(defun f ()
+  (let* ((hwnd (GDI::CreateFontA (- (GDI::GetDeviceCaps hdc LOGPIXELSY))
+                                 0 0 0 GDI::FW_BOLD T NIL NIL GDI::ANSI_CHARSET
+                                 GDI::OUT_TT_PRECIS GDI::CLIP_DEFAULT_PRECIS
+                                 GDI::PROOF_QUALITY GDI::VARIABLE_PITCH
+                                 "Times New Roman"))
+         (x (/ (GDI::GetSystemMetrics GDI::SM_CXSCREEN) 2))
+         (y (/ (GDI::GetSystemMetrics GDI::SM_CYSCREEN) 2))
+         (hold (GDI::SelectObject hdc hfont)))
+     (GDI::SetTextAlign hdc (logior GDI::TA_CENTER GDI::TA_BASELINE))
+     (GDI::SetBkMode hdc GDI::TRANSPARENT)
+     (GDI::SetTextColor hdc (GDI::make-rgb 0 0 #xff))
+     (GDI::TextOutA hdc x y "HELLO WORLD" 11)
+     (GDI::SelectObject hdc hold)
+     (GDI::DeleteObject hfont)))
+
+(defun onDraw (hdc) (GDI::TextOutA hdc 0 0 "HELLO WORLD cb" 11))
+(defun onKeyDown (wparam lparam) (quit))
+
+(defun main ()
+  (GDI::add-callbacks GDI::WM_NCCREATE 
+                      (list (cons GDI::WM_PAINT #'onDraw)
+                            (cons GDI::WM_KEYDOWN #'onKeyDown)))
+  (let* ((cn "HelloWorld")
+         (wndclass 
+          (or (GDI::FindAtomA cn) 
+              (GDI::GlobalFindAtomA cn)
+              (GDI::RegisterClassA
+               (GDI::make-wndclass 0 0 0 GDI::*hinstance* NIL
+                                   (GDI::LoadCursorA NIL (GDI::GetIDC GDI::IDC_ARROW))
+                                   (GDI::GetStockObject GDI::WHITE_BRUSH)
+                                   NIL cn))))
+         (cr (GDI::make-createstruct 0 wndclass "HelloWorld"
+                                     GDI::WS_POPUP 0 0 
+                                     (/ (GDI::GetSystemMetrics GDI::SM_CXSCREEN) 2)
+                                     (/ (GDI::GetSystemMetrics GDI::SM_CYSCREEN) 2)
+                                     NIL NIL GDI::*hinstance* NIL))
+         (win (GDI::CreateWindowIndirectA cr)))
+    (GDI::ShowWindow win GDI::SW_SHOWNORMAL)
+    (GDI::UpdateWindow win)
+    (GDI::MessageLoop)))
+
+#|
+(trace GDI::make-wndclass)
+(trace GDI::make-createstruct)
+(trace GDI::add-callbacks)
+(trace onDraw)
+(trace GDI::onCreate)
+|#
+
+(main)
diff -burN origsrc/clisp-2.48/modules/gdi/struct1.awk src/clisp-2.48/modules/gdi/struct1.awk
--- origsrc/clisp-2.48/modules/gdi/struct1.awk	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/struct1.awk	2006-08-13 14:24:15.000000000 +0000
@@ -0,0 +1 @@
+{ printf("  p->%s = I_to_uint8(TheRecord(arg)->recdata[i++]);\n",$2) }
diff -burN origsrc/clisp-2.48/modules/gdi/struct2.awk src/clisp-2.48/modules/gdi/struct2.awk
--- origsrc/clisp-2.48/modules/gdi/struct2.awk	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/struct2.awk	2006-08-13 14:24:15.000000000 +0000
@@ -0,0 +1 @@
+{ printf("(%s 0 :type fixnum)\n",tolower($2))}
diff -burN origsrc/clisp-2.48/modules/gdi/struct3.awk src/clisp-2.48/modules/gdi/struct3.awk
--- origsrc/clisp-2.48/modules/gdi/struct3.awk	1970-01-01 00:00:00.000000000 +0000
+++ src/clisp-2.48/modules/gdi/struct3.awk	2006-08-13 14:24:15.000000000 +0000
@@ -0,0 +1 @@
+{ printf("  TheRecord(STACK_0)->recdata[i++] = fixnum(p->%s);\n",$1) }
